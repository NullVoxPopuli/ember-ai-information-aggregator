---
stage: released
start-date: 2014-08-14T00:00:00.000Z
release-date: 2016-05-03T00:00:00.000Z
release-versions:
  ember-data: v2.5.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1
project-link:
meta:
  ember-issue: https://github.com/emberjs/data/pull/4086
---

# Summary

For Ember Data. Pass through attribute meta data, which includes `parentType`, `options`, `name`, etc.,
to the transform associated with that attribute. This will allow provide the following function signiture updates to `DS.Transform`:

* `transform.serialize(deserialized, attributeMeta)`
* `transform.deserialize(serialized, attributeMeta)`

# Motivation

The main use case is to be able to configure the transform
on a per-model basis making more DRY code. So the transform can be aware of type and options on `DS.attr` can
be useful to configure the transform for DRY use.

# Detailed design

## Implementing

The change will most likely start in [`eachTransformedAttribute`][1], which gets the attributes for that instance via `get(this, 'attributes')`. In the `forEach` the `name` will be used to get the specific attribute, e.g.

```js
var attributeMeta = attributes.get(name);
callback.call(binding, name, type, attributeMeta);
```

The next change will be in [`applyTransforms`][2], where the `attributeMeta` parameter is added and passed to `transform.deserialize` as the second argument.

You also have to handle the serialization part in [`serializeAttribute`][3], where you pass through the `attribute` parameter to `transform.serialize`.

## Using

A convoluted example:

```js
// Example based on https://github.com/chjj/marked library
App.PostModel = DS.Model.extend({
  title: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: false,
      sanitize: true
    }
  })
});

App.TechnicalPostModel = DS.Model.extend({
  title: DS.attr('string'),
  gistUrl: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: true,
      tables: true,
      sanitize: false
    }
  })
});

App.MarkdownTransform = DS.Transform.extend({
  serialize: function (deserialized, attributeMeta) {
    return deserialized.raw;
  },

  deserialize: function (serialized, attributeMeta) {
    var options = attributeMeta.options.markdown || {};

    return marked(serialized, options);
  }
});
```

# Drawbacks

Extra API surface area, although not much. This could also potentially introduce tight coupling between models and transforms if used improperly, e.g. not returning a default value if using type checking.

# Alternatives

1. Passing the information from the server, which is a poor solution.
2. Writing a new transform for each model/attribute that needs a variation. Although this might be a good solution sometimes if you extend a base transform.

# Unresolved questions

Does the whole meta object need to be passed, or do we selectively pass in only the useful properties? Like
`options` and `parentType` and `name`..



[1]: https://github.com/emberjs/data/blob/master/packages/ember-data/lib/system/model/attributes.js#L193
[2]: https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L117
[3]: https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L528


---

---
stage: recommended
start-date: 2014-08-18T00:00:00.000Z
release-date: 2015-02-07T00:00:00.000Z
release-versions:
  ember-source: v1.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/3
project-link:
meta:
  issues:
    Ember Stream support: emberjs/ember.js#5522
    Handlebars parser support: wycats/handlebars.js#906
    HTMLBars compiler support: tildeio/htmlbars#147
---

# Summary

Introduce block parameters to the Handlebars language to standardize context-preserving helpers, for example:

```handlebars
{{#each people as |person|}}
  {{person.name}}
{{/each}}
```

# Motivation

### The Problem

There is no idiomatic way to write a helper that preserves context and yields values to its template. This is particularly painful for components which have strict context-preserving semantics.

### Current workarounds

- Don't write components that need to yield a value.
  - *Problem:* This may not be an option.
- Invent a non-standard per-helper syntax (like `{{#with foo as bar}}` or `{{#each item in items}}`) that hook into the undocumented `keywords` to inject variables.
  - *Problems:* Custom syntaxes are not in the spirit of the Handlebars language and require the consumer to know the special incantation. Component authors must an non-trivial understanding of how `keywords` work.

### New possibilities

```handlebars
{{#for-each obj as |key val|}}
  {{key}}: {{val}}
{{/for-each}}
```

```handlebars
{{#form-for post as |f|}}
  {{f.input "title"}}
  {{f.textarea "body"}}
  {{f.submit}}
{{/form-for}}
```


# Detailed design

- Phase 1: Add block params to the Handlebars language
- Phase 2: Rewrite Ember's helpers to accept streams
- Phase 3: Add block param support to `{{each}}` and `{{with}}`

### Phase 1: Add block params to the Handlebars language

The proposed syntax is `{{#x-foo a b w=x y=z as |param1 param2 ... paramN|}}` and is only available for block helpers.

The names of the block parameters are compiled into the inner template, but are not known to the helper (`x-foo` in the example above). To call a template and populate its block params we use the arguments option:


```javascript
var template = compile('{{person.name}}', {
  blockParams: [ 'person' ]
});

template({}, ..., [ personModel ]);
```

More commonly, block params will be defined inside of the template.

```
{{#with currentPost.author as |a|}}
  {{a.name}} <em>{{a.email}}</em>
{{/with}}
```

```javascript
registerHelper('with', function(object, options) {
  return options.fn(this, ..., [ object ]);
});
```

For compatibility reasons, the *number of block params* are passed to the helper so that the pre-block-params behaviour of the helper can be preserved. Example:

```javascript
function eachHelper(..., options) {
  if (options.blockParamsLength > 0) { /* do new behaviour */ }
  else { /* do old behaviour */ }
}
```

### Phase 2: Rewrite Ember's helpers to accept streams

In the `with` example above, if the `currentPost` changes the `a` block param should update. This means it's not sufficient to pass only the initial value of the author in the arguments. Instead, we pass a stream which emits values whenever the observed property changes.

In Handlebars, a block param can appear anywhere that an identifier can, for example `{{log a.name}}`. This means that all helpers would need to be modified to understand streams.

### Phase 3: Add block param support to `{{each}}` and `{{with}}`

Deprecate context-changing and ad-hoc keyword flavors of `{{each}}` and `{{with}}` in favor of block params.

# Drawbacks

- Handlebars already has a similar notion of with `data` which can lead to confusion.

# Alternatives

To my knowledge, no other designs have been considered. Not implementing this feature would mean that components would continue to be difficult to compose.

# Unresolved questions

The associated HTML syntax for HTMLBars needs to be finalized.


---

---
stage: accepted
start-date: 2015-01-10T00:00:00.000Z
release-date:
release-versions:
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/3
project-link:
---

# Summary

We need a way to run diagnostics on Ember CLI based projects to let developers know about potential system level incompatibilities. Developers should also be able to get a bill of health for their project for things like outdated dependencies.  This bill of health should also be extensible.  Output from running this command should be as consise and only ever log things that don't seem healthy.

# Motivation

The motivation behind this is 2 pronged:

1. Allows developers to submit system level information in pull requests, so that bugs can be filed and potentially replicated.
2. Gives developers the ability to know about the health of their project and to potentially help with stagnation.

# Detailed design

The design for this is rather simple. We would first introduce a command called `ember doctor` that would run some default checks. The default checks would do the following:

- Run `ember v --verbose` and complain loudly for incompatible versions
- Run `npm outdated --depth 0` to check on outdated modules
- Run `bower list` and display out of date bower components
- Run check to grab OS information

These are what is considered default `checks`.

In your project developers can setup their own Doctor `checks` that get merged in with the default checks. To allow for this Ember CLI will have `ember generate doctor check:service-health`.

This command will generate the following directory structure in the root of the project:

```
doctor/
  checks/
    service-health.js
  index.js
```

When `ember doctor` is ran we simply will do a merge of the default checks and the ones provided by the application.

There should also be a way of excluding checks to be ran. Developers should be able to simply pass flags for things they do not care to run e.g. `ember doctor --skip=npm,os`.

# Addon Design
Much like the project addons can add their own diagnostics as projects.
In the addons main entry point there will be a hook much like
`includedCommands` that allows Ember CLI to look up the diagnostics and
role them into the consuming project.

```
var checks = require('./checks');
...
includedChecks: function() {
  return checks;
}
...
```

# Expected Output
Output of running the doctor command should be as concise as possible.
Unless there are any issues with the project that is being analyzed, the
output should be something like the following:

```
Success: All diagnostics checked out fine.
```

In the event that there is an issue with the project that is being
analyzed the output will look something like the following:

```
Warning: NPM modules out of date. Below are the out of date modules.
╔══════╤═══════╤═════════╗
║ Name │ Yours │ Current ║
╟──────┼───────┼─────────╢
║ glob │ 1.1.2 │ 1.2.3   ║
╚══════╧═══════╧═════════╝
```

# Drawbacks

This adds "yet another thing" to the Ember CLI API surface. Doctor will be bound to a network connection such as checking outdated dependencies.

# Alternatives

There have been other other attempts to put checking for system level checking in various places. The BDFL's would like to consolidate this into an `ember doctor` command.

# Unresolved questions


---

---
stage: released # FIXME: Is this Recommended?
start-date: 2014-10-24T00:00:00.000Z
release-date: 2016-09-08T00:00:00.000Z
release-versions:
  ember-source: v2.8.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/10
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/12685
---

# Summary

Engines allow multiple logical applications to be composed together into a
single application from the user's perspective.

# Motivation

Large companies are increasingly adopting Ember.js to power their entire
product lines. Often this means separate teams (sometimes distributed
around the world) working on the same app. Typically, responsibility is
shared by dividing the application into one or more "sections". How this
division is actually implemented varies from team to team.

Sometimes, each "section" will be a completely separate Ember app, with
a shared navigation bar allowing users to switch between each app. This
allows teams to work quickly without stepping on each others' toes, but
switching apps feels slow (especially compared to the normally speedy
route transitions in Ember) because the entire page must be thrown out,
then an entirely new set of the same assets downloaded and parsed.
Additionally, code sharing is largely accomplished via copy-and-paste.

Other times, the separation is enforced socially, with each team
claiming a section of the same app in the same repository.
Unfortunately, this approach leads to frequent conflicts around shared
resources, and feedback from tests gets slower and slower as test suites
grow in size.

A more modular approach is to break off elements of a single application into
separate [addons](http://www.ember-cli.com/user-guide/#addons). Addons are
essentially mixins for [ember-cli](http://www.ember-cli.com/) applications. In
other words, the elements of an addon are merged with those of the application
that includes them. While addons allow for distributed development, testing, and
packaging, they do not provide the logical run-time separation required for
developing completely independent "sections" of an application. Addons must
function within the namespace, registry, and router of the application in which
they are included.

Engines provide an alternative to these approaches that allows for distributed
development, testing, and packaging, _as well as_ logical run-time separation.
Because engines are derived from applications, they can be just as
full-featured. Each has its own namespace and registry. Even though engines are
isolated from the applications that contain them, the boundaries between them
allow for controlled sharing of resources.

Engines can be either "routable" or "route-less":

* Routable engines provide a routing map which can be integrated with the
  routing maps of parent applications or engines. Routing maps are always eager
  loaded, which allows for deep linking into an engine's routes regardless of
  whether the engine itself has been instantiated.

* Route-less engines can isolate complex functionality that is not related to
  routing (e.g. a chat engine in a sidebar). Route-less engines can be rendered
  into outlets ad hoc as routes are loaded.

The potential scope of engines is large enough that this feature merits
development and delivery in multiple phases. A minimum viable version could be
released sooner, which could be augmented with more advanced features later.

An initial release of engines could provide the following benefits:

* Distributed development - Engines can be developed and tested in isolation
  within their own Ember CLI projects and included by applications or other
  engines. Engines can be packaged and released as addons themselves.

* Integrated routing - Support for mounting routable engines in the routing maps
  of applications or other engines.

* Ad hoc embedding - Support for embedding route-less engines in outlets as
  needed.

* Clean boundaries - An engine can cooperate with its parents through a few
  explicit interfaces. Beyond these interfaces, engines and applications are
  isolated.

Subsequent releases of engines could allow for the following:

* Lazy loading - An engine could allow its parent to boot with only its routing
  map loaded. The rest of the engine could be loaded only as required (i.e.
  when a route in an engine is visited). This would allow applications to boot
  faster and limit their memory consumption.

* Namespaced access to engine resources from applications - This could open up
  the potential for applications to use, and extend, an engine's resources much
  like resources in other addons, but without the possibility of namespace
  collisions.

## Detailed design

Engines are very similar to regular applications: they can be developed in
isolation in Ember CLI, include addons, and contain all the same elements,
including routes, components, initializers, etc. The primary differences are
that an engine does not boot itself and an engine does not control the router.

### Engine internals

New `Engine` and `EngineInstance` classes will be introduced.

Applications and engines will share ancestry. It remains TBD whether
applications will subclass engines, or whether a common ancestor will be
introduced.

Engines and applications will share the same pattern for registry / container
ownership and encapsulation. Both will also have initializers and instance
initializers.

Engine instances will have access to their parent instances. An engine's parent
could be either an application or engine.

#### Routable vs. route-less engines

Routable engines will define their routes in a new `Ember.Routes` class. This
class will encapsulate the functionality provided by `Router#map`, and will be
used internally by `Ember.Router` as well (with no public interface changes of
course).

Route-less engines do not define routing maps nor can they contain routes.

### Developing engines

Engines can be developed in isolation as Ember CLI addon projects or as part of
a parent application.

#### Engines as addons

Engines can be created as separate addon projects with:

```
ember engine <engine-name>
```

This will create a special form of an ember addon. The file structure will match
that of a standard addon, but will have an `engine` directory instead of an
`addon` directory.

Engines can be unit tested and can also be integration tested within a dummy
app, just like standard addons.

#### In-repo engines

An engine can be created within an existing application's project using a
special `in-repo-engine` generator (similar to the `in-repo-addon` generator):

```
ember g in-repo-engine <engine-name>
```

In-repo engines can be unit tested in isolation or integration testing with the
main application (instead of a dummy application).

> Note: In-repo addons currently are created in the `/lib` directory (e.g.
`/lib/my-addon`). Unit tests and integration tests are currently co-mingled with
tests for the main application. It's recommended that in-repo engines provide
better test separation than is provided for regular addons, and perhaps the
whole in-repo addon directory structure should be re-examined at the same time
in-repo engines are introduced.

#### Engine directory structure

An engine's directory will contain a file structure identical to the `app`
directory in a standard ember-cli application, with the following exceptions:

* `engine.js` instead of `app.js` - defines the `Engine` class and
  loads its initializers.

* `routes.js` instead of `router.js` - defines an engine's routing map in a
  `Routes` class. This file should be deleted entirely for route-less engines.

### Installing engines

Engines developed as addons can be installed in an application just like any
other addon:

```
ember install <engine-name>
```

During development, you can use `npm link` to make your engine available in
another parent engine or application.

### Mounting routable engines

The new `mount()` router DSL method is used to mount an engine at a particular
"mount-point" in a route map.

For example, the following route map mounts the `discourse` engine at the
`/forum` path:

```
Router.map(function() {
  this.mount('discourse', {path: '/forum'});
});
```

> Note: If unspecified, `path` will match the name of the engine.

Calls to `mount` can be nested within routes. An engine can be mounted at
multiple routes, and each will represent a new instance of the engine to be
created.

### Mounting route-less engines

A `mount()` DSL will also be added to routes, which will enable embedding of
route-less engines in outlets. This can be called from `renderTemplate` (or
`renderComponents` once routable components are introduced).

`mount` has a similar signature to `render`, although it is obviously
engine-specific instead of template-specific. `mount` can be used to specify
a target template and outlet as follows:

```
renderTemplate: function() {
  // Mount the chat engine in the sidebar
  this.mount('chat', {
    into: 'main',
    outlet: 'sidebar'
  });
}
```

As a result, the engine's `application` template will be rendered into the
`sidebar` outlet in the application's `main` template.

### Loading phases

Engines can exist in several phases:

* Booted - an engine that's been installed in a parent application will have
  its dependencies loaded and its (non-instance) initializers invoked when the
  parent application boots.

* Mounted - Routable and route-less engines have slightly different concepts of
  "mounting". A routable engine is considered mounted when it has been included
  by a router at one or more mount-points. A route-less engine is considered
  mounted as soon as a route's `mount` call resolves.

* Instantiated - When an engine is instantiated, an `EngineInstance` is created
  and an engine's instance initializers are invoked. A routable engine is
  instantiated when a route is visited at or beyond its mount-point. A
  route-less engine is instantiated as soon as it is mounted.

Special `before` and `after` hooks could be added to application instance
initializers that allow them to be ordered relative to engine instance
initializers.

### Engine boundaries

Besides its routing map, an engine does not share any other resources with its
parent by default. Engines maintain their own registries and containers, which
ensure that they stay isolated. However, some explicit sharing of resources
between engines and parents is allowed.

#### Engine / parent dependencies

Dependencies between engines and parents can be defined imperatively or
declaratively.

Imperative dependencies can be defined in an engine's instance initializers.
When an engine is instantiated, the `parent` property on its `EngineInstance` is
set to its parent instance (either an `ApplicationInstance` or
`EngineInstance`). Since the engine instance is available in the instance
initializer, this `parent` property can also be accessed. This allows an engine
instance to interrogate its parent, specifically through its `RegistryProxy` and
`ContainerProxy` interfaces.

Alternatively, declarative dependencies can be defined on a limited basis. The
initial API will be limited: an engine can define an array of `services` that it
requires from its parent.

For example, the following engine expects its parent to provide `store` and
`session` services:

```
import Ember from 'ember';

var Engine = Ember.Engine.extend({
  dependencies: {
    services: [
      'store',
      'session'
    ]
  }
});

export default Engine;
```

The parent application can provide a re-mapping of services from its namespace
to that of the engine via an `engines` declaration.

In the following example, the application shares its `store` service directly
with the `checkout` engine. It also shares its `current-user` service as the
`session` service requested by the engine.

```
import Ember from 'ember';

var App = Ember.Application.extend({
  engines: {
    checkout: {
      dependencies: {
        services: [
          'store',
          {session: 'current-user'}
        ]
      }
    }
  }
});

export default App;
```

When engines are instantiated, the listed dependencies will be looked up on
the parent and made accessible within the engine.

Note that the `engines` declaration provides further space to define
characteristics about an engine, such as whether it should be eager or
lazy-loaded, URLs for manifest files, etc.

# Drawbacks

This RFC introduces the new concept of engines, which increases the
learning curve of the framework. However, I believe this issue is
mitigated by the fact that engines are an opt-in packaging around
existing concepts.

In the end, I believe that "engines" are just a small API for composing
existing concepts. And they can be introduced at the top of the
conceptual ladder, once users are comfortable with the basics of Ember,
and only for those working on large teams or distributing addons.

# Alternatives

Several incomplete alternatives are discussed in the Motivations section above.

I know of no alternatives being discussed in the Ember community that meet the
same needs as engines; namely, for development _and_ run-time isolation.

# Unresolved questions

## Non-CLI Users

This RFC assumes Ember CLI. I would prefer to prove this out in Ember
CLI before locking down the public APIs/hooks the router exposes for
locating and mounting engines. Once this is done, however, we should
expose and document those hooks so users who cannot use Ember CLI for
whatever reason can still take advantage of composability.

## Declarative dependencies

The initial scope of declarative dependency sharing is limited in scope to
services. Should other types of dependencies be declaratively shareable?
Should addons be the recommended path to share all other dependencies?

## Async mounting of route-less engines

`Route#renderTemplate` is called synchronously, although `Route#mount` should
surely be async. How async mounting is represented in the route lifecycle is
TBD. A solution isn't proposed here because the problem is shared by routable
and async components, and a common solution should be reached.

## Lazy loading manifests

In order to facilitate lazy loading of engines, we will need to determine a
structure for manifest files that contain an engine's assets. Furthermore, an
application will need to be configurable with URLs for these manifests.

It's likely that an engine's routing map will always be needed at the time of
application deployment. Allowing lazy loading of routing maps would prevent the
formation of any links from a parent application into an engine's routes.

When developed in isolation as addons, engines will have their own sets of
dependencies. These dependencies will be treated like any other addons when
engines are deployed together with an application. However, in order to support
lazy loading, it would be ideal to dedupe dependencies in order to create a lean
and conflict-free asset manifest.

Reference: deduping strategy discussed by @wycats in
[this Google doc](https://docs.google.com/a/tomdale.net/document/d/12CsR-zli5oP2TDWOef_-D28zjmbVD83hU4q9_VTk-9s/edit).

## Namespaced access to engine resources

The concept of namespaced access to engine resources is mentioned above as a
potential goal of a future release of engines. This will require further
discussion to decide how it should work both technically and semantically, and
how it applies to lazy-loaded engines.

If these problems can be resolved, this feature would allow for more flexibility
in parent / engine interactions. Instead of just allowing engines to look up
resources in a parent, the inverse could also be allowed.

For example, if the `authentication` engine contains
`engines/authentication/models/user.js`, a parent application could look up this
same model through a namespace. Perhaps as follows:

```js
container.lookup('authentication@model:user');
```

Other APIs in Ember would need to be extended to support namespaces to
take full advantage of this feature. For example, components that ship
with an engine might be accessed from the primary application like this:

```handlebars
{{authentication@login-form obscure-password=true}}
```


---

---
stage: discontinued
start-date: 2014-09-30T00:00:00.000Z
release-date: 2014-10-28T00:00:00.000Z
release-versions:
  ember-source: v1.8.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/11
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/9527
---

# Summary

Improve computed property syntax

# Motivation

Today, the setter variant of CP's is both confusing, and looks scary as sin.
(Too many concepts must be taught and it is too easy to screw it up.)

# Detailed design

today:
------

```js
fullName: Ember.computed('firstName', 'lastName', function(key, value) {
  if (arguments.length > 1) {
    var names = value.split(' ');
    this.setProperties({
      firstName: names[0],
      lastName: names[1]
    });
    return value;
  }

  return this.get('firstName') + ' ' + this.get('lastName');
});
```

Tomorrow:
---------

```js
fullName: Ember.computed('firstName', 'lastName', {
  get: function(keyName) {
    return this.get('firstName') + ' ' + this.get('lastName');
  },

  set: function(keyName, fullName, oldValue) {
   var names = fullName.split(' ');

   this.setProperties({
     firstName: names[0],
     lastName: names[1]
   });

   return fullName;
  }
});
```


Notes:
------

* we should keep `Ember.computed(fn);`  as shorthand for getter only
* `get` xor `set` variants would also be possible.
* `{ get() { } }` is es6 syntax for `{ get: function() { } )`

Migration
---------

* 1.x support both, detect new behaviour by testing if the last arg is not null and typeof object
* 1.x+1 deprecate if last arg is a function and its arity is greater than 1


# Drawbacks

N/A

# Alternatives

N/A

# Unresolved questions

None


---

---
stage: released
start-date: 2015-05-16T00:00:00.000Z
release-date:
release-versions: # FIMXE: Prior to 3.0
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/12
project-link:
---

# Summary

This has come up in [#3699](https://github.com/ember-cli/ember-cli/issues/3699) and [EmberTown/ember-hearth/#66](https://github.com/EmberTown/ember-hearth/issues/66).

In short, it would be nice for tools that depend on Ember-CLI to be able to read the help output as JSON (for example `ember g --help --json`).

# Motivation

In our specific use case in [Ember Hearth](https://github.com/EmberTown/ember-hearth/) we would like to be able to render a dynamic GUI for some tasks, like generating blueprints. This way we could also include any blueprints added by addons. This will also apply to any other tools interfacing with Ember-CLI.

# Detailed design
We should probably make the internal help-functions (like `printBasicHelp` and `printDetailedHelp`) use JSON internally, and parse to human readable before printing (unless `--json` is specified).

I'm imagining the json output would be something like this:

```json
{
  "name":"generate",
  "description":"Generates new code from blueprints.",
  "aliases":["g"],
  "flags":[
    {
      "flag":"--verbose",
      "aliases":["-v"],
      "description":"Verbose output"
    }, {…}],
  "commands":[
    {
      "command":"template",
      "description":"Generates a template.",
      "arguments":["name"]
    },
    {
      "command":"model",
      "description":"Generate an ember-data model.",
      "arguments":[
        "name",
        {
          "argument":"attr:type",
          "description":"Add attributes to the model, e.g. 'name:String age:Number'",
          "multiple":true
        }]
    }, {…}]
}
```

Note that this output contains a bit more info than the current --help, specifically in the attr:type argument for the model command. This is something I feel is currently missing (I did not understand the model generator command without consulting a colleague, for example), and would be nice to add while we're at it.

It should be pretty straight forward to generate a human readable output from this JSON. There are a few things missing: However: The generate help command specifically groups commands by addon. I'm not sure how this should be accomplished, and if this matches the other help outputs. Ideally, any tools reading the JSON should be able to rely on the format being the same for all commands. This would keep the internals cleaner as well, including the human readable parser.

# Drawbacks

* Requires rewrite of help methods, possibly also for some addons (unless we can provide backwards compatability)
* Increases codebase size

# Alternatives

* We could standardize help output enough that it can be safely regexed by other tools
* We could not do this, and require any tools to update whenever Ember-CLI changes any commands

# Unresolved questions

* Internal architecture specifics (rewrite printBasicHelp or create a new setup, etc)
* Specifying JSON format details
* List any dependencies, like docs, that will need to be updated with this change


---

---
stage: discontinued # FIXME: Is this correct?
start-date: 2014-12-03T00:00:00.000Z
release-date: 2015-08-13T00:00:00.000Z
release-versions:
  ember-source: v2.0.0
  ember-data: v2.0.0
  ember-cli: v2.0.0

teams:
  - framework
  - data
  - cli
  - learning
  - typescript
  - steering
prs:
  accepted: https://github.com/emberjs/rfcs/pull/15
project-link:
meta:
  ember-issue: This RFC is implemented over many Ember PRs
---

# The Road to Ember 2.0

## Intro

Today, we're announcing our plan for Ember 2.0. While the major version
bump gives us the opportunity to simplify the framework in ways that
require breaking changes, we are designing Ember 2.0 with migration in mind.

This is **not** a big-bang rewrite; we will continue development
on the `master` branch, and roll out changes incrementally on the 1.x
release train. The 2.0.0 release will simply remove features that have
been deprecated between now and then. Our goal is that you can move
your Ember app to 2.0 incrementally, one sprint at a time.

This RFC captures the results of the last two core team face-to-face
meetings, where we discussed community feedback about the future of the
project. While it explains the high-level goals and tries to paint a
picture of how all the pieces fit together, this document will be
updated over time with links to individual RFCs that contain additional
implementation detail.

We plan to flesh out these more-detailed RFCs in the next few weeks,
as the discussion here progresses, before finalizing this plan.

We are announcing Ember 2.0 through our community RFC process in advance
of a release, both so our proposals can be vetted by the community and
so the community can understand the goals and contribute their own ideas
back.

## Motivation

### Stability without Stagnation

Ember is all about identifying common patterns that emerge from the web
development community and rolling them into a complete front-end stack.
This makes it easy to get started on new projects and jump into existing
ones, knowing that you will get a best-of-breed set of tools that the
community will continue to support and improve for years to come.

In the greater JavaScript community, getting the latest and greatest
often means rewriting parts of your apps once a year, as the community
abandons existing solutions in search of improvements. Progress is
important, but so is ending the constant cycle of writing and rewriting
that plagues so many applications.

The Ember community works hard to introduce new ideas with an eye
towards migration. We call this "stability without stagnation", and it's
one of the cornerstones of the Ember philosophy.

Below, we introduce some of the major new features coming in Ember
2.0. Each section includes a transition plan, with details on how
we expect existing apps to migrate to the new API.

When breaking changes are absolutely necessary, we try to make those
changes ones you can apply without too much thought. We call these
"mechanical" refactors. Typically, they'll involve a change to
syntax without changing semantics. These are significantly easier to
adopt than those that require fundamental changes to your application
architecture.

**To further aid in these transitions, we are planning to add a new tab to the
Ember Inspector that will list all deprecations in your application**,
as well as a list of the locations in the source code where the
deprecated code was triggered. This should serve as a convenient
"punch list" for your transitional work.

Every member of the core team works on up-to-date Ember applications,
and we feel the tension between stability and progress acutely. We want
to deliver cutting-edge products, but need to keep shipping, and many
companies that have adopted Ember for their products tell us the
same thing.

### Big Bets

In 2014, we made big bets in two areas, and they've paid off.

The first bet was on open standards: JavaScript modules, promises and
Web Components. We started the year off with globals-based apps,
callbacks and "views", and incrementally (and compatibly) built towards
standards-based solutions as those standards solidified.

The second bet was that the community was as tired as we were of
hand-rolling their own build scripts for each project. We've invested
heavily in Ember CLI, giving us a single tool that unifies the community
and provides a venue for disseminating great ideas.

**In Ember 2.0, Ember CLI and ES6 modules will become first-class parts
of the Ember experience.** We will update the website, guides, documentation,
etc. to teach new users how to build Ember apps with the CLI tools and
using JavaScript's new module syntax.

While globals-based apps will continue to work in 2.0, we may introduce
new features that rely on either Ember CLI or ES6 modules. **You should
begin moving your app to Ember CLI as soon as possible.**

All of the apps maintained by the Ember core team have been migrated to
Ember CLI, and we believe that most teams should be able to make the
transition incrementally.

### Learning from the Community

We're well aware that we don't have a monopoly on good ideas, and we're
always analyzing competing frameworks and libraries to discover great
ideas that we can incorporate.

For example, AngularJS taught us the importance of making early on-ramp
easy, how cool directives/components could be, and how dependency
injection improves testing.

We've been analyzing and discussing React's approach to data flow and
rendering for some time now, and in particular how they make use of a
"virtual DOM" to improve performance.

Ember's view layer is one of the oldest parts of Ember, and was designed
for a world where IE7 and IE8 were dominant. We've spent the better part
of 2014 rethinking the view layer to be more DOM-aware, and the new
codebase (codenamed "HTMLBars") borrows what we think are the
best ideas from React. We cover the specifics below.

React's "virtual DOM" abstraction also allowed them to simplify the
programming model of component-based applications. We really like these
ideas, and the new HTMLBars engine, landing in the next Ember release, lays
the groundwork for adopting the simplified data-flow model.

**In Ember 2.0, we will be adopting a "virtual DOM" and data flow model
that embraces the best ideas from React and simplifies communication
between components.**

Interestingly, we found that well-written Ember applications are already
written with this clear and direct data flow. This change will mostly
make the best patterns more explicit and easier for developers to find
when starting out.

### A Steady Flow of Improvement

Ember 1.0 shipped over a year ago and we have continued to improve the
framework while maintaining backwards-compatibility. We are proud of the
fact that Ember apps tend to track released versions.

You might expect us to do Ember 2.0 work on a separate "2.0" branch,
accumulating features until we ship. We aren't going to do that.

Instead, **we plan to do the vast majority of new work on `master` (behind
feature flags), and land new features in 1.x as they become stable.**

The `2.0.0` release **will simply remove the cruft** that naturally
builds up when maintaining compatibility with old releases.

If we add features that change Ember idioms, we will add clear
deprecation warnings with steps to refactor to new patterns.

Our goal is that, as much as possible, people will be able to boot up
their app on the last `1.x` version, update to the latest set of idioms
by following the deprecation prompts, and have things working on `2.0`.

Because going from the last version of Ember 1.x to Ember 2.0 will be
just another six-week release, there simply won't be much time for us to
make it an incredibly painful upgrade. ;)

## Simplifying Ember Concepts

Ember evolved organically from a view-layer-only framework in 2011 into
the route-driven, complete front-end stack it is today. Along the way,
we've accumulated several concepts that are no longer widely used in idiomatic
Ember apps.

These vestigial concepts make file sizes larger, code more complex, and
make Ember harder to learn.

**Ember 2.0 is about simplification**. This lets us reduce file sizes,
reduce code complexity, and generally make Ember apps easier to pick up
and maintain.

The high-level set of improvements that we have planned are:

* More intuitive attribute bindings
* New HTML syntax for components
* Block parameters for components
* More consistent template scope
* One-way data binding by default, with opt-in to mutable, two-way bindings
* More explicit communication between components, which means less
  implicit communication via two-way bindings
* Routes drive components, instead of controller + template
* Improved actions that are invoked inside components as simple callbacks

In some sections, we provide estimates for when a feature will land.
These are our best-guesses, but because of the rapid-release train model
of Ember, we may be off by a version or two.

However, all features that are slated for "before 2.0" will land before
we cut over to a major new version.

## More Intuitive Attribute Bindings

Today's templating engine is the oldest part of Ember.js. Under the
hood, it generates a string of HTML and then inserts it into the page.

One unfortunate consequence of this architecture is that it is not
possible to intuitively bind values to HTML attributes.

You would expect to be able type something like:

```handlebars
<a href="{{url}}">Click here</a>
```

But instead, in today's Ember, you have to learn about and use the
`bind-attr` helper:

```handlebars
<a {{bind-attr href=url}}>Click here</a>
```

The new HTMLBars template engine makes `bind-attr` a thing of the past,
allowing you to type what you mean. It also makes it possible to express
many attribute-related concepts simply:

```handlebars
<a class="{{active}} app-link" href="{{url}}.html">Click here</a>
```

### Transition Plan

The HTMLBars templating engine is being developed on master, and parts
of it have already landed in Ember 1.8. Doing the work this way means
that the new engine continues to support the old syntax: your existing
templates will continue to work.

The improved attribute syntax has not yet landed, but we expect it to
land before Ember 1.10.

**We do not plan to remove support for existing templating syntax (or
no-longer-necessary helpers like `bind-attr`) in Ember 2.0.**

## More Intuitive Components

In today's Ember, components are represented in your templates as
Handlebars "block helpers".

The most important problem with this approach is that Handlebars-style
components do not work well with attribute bindings or the `action`
helper. In short, a helper that is meant to be used inside an HTML tag
cannot be used inside a call to a component.

Beginning in Ember 1.11, we will support an HTML-based syntax for
components. **The new syntax can be used to invoke existing components,
and new components can be called using the old syntax.**

```handlebars
<my-video src={{movie.url}}></my-video>

<!-- equivalent to -->

{{my-video src=movie.url}}
```

### Transition Plan

The improved component syntax will (we hope) land in Ember 1.11. You can
transition existing uses of `{{component-name}}` to the new syntax
at that time. You will likely benefit by eliminating uses of computed
properties that can now be more tersely expressed using the
interpolation syntax.

**We have no plans to remove support for the old component syntax in
Ember 2.0.**

## Block Parameters

In today's templates, there are two special forms of built-in Handlebars
helpers: `#each post in posts` and `#with post as p`. These allow the
template inside the helper to retain the parent context, but get a piece
of helper-provided information as a named value (such as `post` in the previous examples).

```
{{#with contact.person as p}}
  {{!-- this block of code is still in the parent's scope, but
        the #with helper provided a `p` name with a
        helper-provided value --}}
  <p>{{p.firstName}} {{p.lastName}}</p>

  {{!-- `title` here refers to the outer scope's title --}}
  <p>{{title}}</p>
{{/with}}
```

Today, this capability is hardcoded into the two special forms,
but it can be useful for other kinds of components. For example,
you may have a calendar component (`ui-calendar`) that displays a
specified month.

The `ui-calendar` component may want to allow users to supply a custom
template for each day in the month, but each repetition of the template
will need information about the day it represents (its day of the week,
date number, etc.) in order to render it.

With the new "block parameters" feature, any component will have
access to the same capability as `#each` or `#with`:

```handlebars
<ui-calendar month={{currentMonth}} as |day|>
  <p class="title">{{day.title}}</p>
  <p class="date">{{day.date}}</p>
</ui-calendar>
```

In this case, the `ui-calendar` component iterates over all of days
in `currentMonth`, rendering each instance of the template with
information about which date it should represent.

We also think that this feature will be useful to allow container
components (like tabs or forms) to supply special-case component
definitions as block params. We are still working on the details,
but believe that an approach along these lines could make these
kinds of components simpler and more flexible.

### Transition Plan

Block parameters will hopefully land in 1.12, and at that point the
two special forms for `{{each}}` and `{{with}}` will be deprecated.
You should refactor your templates to use the new block parameters
syntax once it lands, as it is a purely mechanical refactor.

**We have no plans to remove support for the `{{each}}` and `{{with}}`
special forms in Ember 2.0.**

## More Consistent Handlebars Scope

In today's Ember, the `each` and `with` helpers come in two flavors: a
"context-switching" flavor and a "named-parameter" flavor.

```handlebars
{{#each post in posts}}
  {{!-- the context in here is the same as the outside context,
        and `post` references the current iteration --}}
{{/each}}

{{#each posts}}
  {{!-- the context in here has shifted to the individual post.
        the outer context is no longer accessible --}}
{{/each}}
```

This has proven to be one of the more confusing parts of the Ember
templating system. It is also not clear to beginners which to use,
and when they choose the context-shifting form, they lose access to
values in the outer context that may be important.

Because the helper itself offers no clue about the context-shifting
behavior, it is easy (even for more experienced Ember developers)
to get confused when skimming a template about which object a value
refers to.

In Ember 1.10, we will deprecate the context-shifting forms of
`#each` and `#with` in favor of the named-parameter forms.

### Transition Plan

To transition your code to the new syntax, you can change templates
that look like this:

```hbs
{{#each people}}
  <p>{{firstName}} {{lastName}}</p>
  <p>{{address}}</p>
{{/each}}
```

with:

```hbs
{{#each people as |person|}}
  <p>{{person.firstName}} {{person.lastName}}</p>
  <p>{{person.address}}</p>
{{/each}}
```

**We plan to deprecate support for the context-shifting helpers in Ember
1.10 and remove support in Ember 2.0.** This change should be entirely
mechanical.

## One-Way Bindings by Default

After a few years of having written Ember applications, we have observed
that most of the data bindings in the templating engine do not actually
require two-way bindings.

When we designed the original templating layer, we figured that making
all data bindings two-way wasn't very harmful: if you don't set a
two-way binding, it's a de facto one-way binding!

We have since realized (with some help from our friends at React), that
components want to be able to hand out data to their children without
having to be on guard for wayward mutations.

Additionally, communication between components is often most naturally
expressed as events or callbacks. This is possible in Ember, but the
dominance of two-way data bindings often leads people down a path of
using two-way bindings as a communication channel. Experienced Ember
developers don't (usually) make this mistake, but it's an easy one to
make.

When you use the new component syntax, the `{{}}` interpolation syntax
defaults to creating one-way bindings in the components.

```handlebars
<my-video src={{url}}></my-video>
```

In this example, the component's `src` property will be updated whenever
`url` changes, but it will not be allowed to mutate it.

If a template wishes to allow the component to mutate a property, it can
explicitly create a two-way binding using the `mut` helper:

```handlebars
<my-video paused={{mut isPaused}}></my-video>
```

This can help ease the transition to a more event-based style of
programming.

It also eliminates the boilerplate associated with an event-based style
when working with form controls. Instead of copying state out of a
model, listening for callbacks, and updating the model, the `input`
helper can be given an explicit mutable binding.

```handlebars
<input value={{mut firstName}}>
<input value={{mut lastName}}>
```

This is similar to the approach taken by [React.Link][1], but we think
that the use-case of form helpers is sufficiently common to make it
ergonomic.

[1]: http://facebook.github.io/react/docs/two-way-binding-helpers.html

### Transition Plan

The new one-way default is triggered by the use of new component syntax.
This means that component invocations in existing templates will
continue to work without changes.

When transitioning to the new HTML-based syntax, you will likely want to
evaluate whether bindings are actually being mutated, and avoid using
`mut` for values that the component never changes. This will make it
easier for future readers of your template to get an understanding of
what properties might be changed downstream.

To preserve the same semantics during a refactor to the new HTML-based
syntax, you can simply mark all bindings as `mut`.

```handlebars
{{!-- these are semantically equivalent --}}

{{my-video src=movie.url paused=controller.isPaused}}

<my-video src={{mut movie.url}} paused={{mut controller.isPaused}}>
</my-video>
```

While the above example preserves the same mutability semantics, it
should be clear that the video player component should never change the
`url` of the `movie` model.

To make sure you get an exception should this ever happen, simply remove
the `mut`:

```handlebars
<my-video src={{movie.url}} paused={{mut controller.isPaused}}>
</my-video>
```

**We have no plans to remove the old-style component syntax in Ember
2.0, so the semantics of existing component invocations will not
change.**

## Separated Component Parameters

In today's Ember, parameters passed to components as attributes become
properties of the component itself, putting them in the same place as
other internal state.

This can be somewhat confusing, because it may not be obvious to the
reader of a component's JavaScript or template which values are
internal, and which are passed in as part of the public API.

To remind themselves, many Ember users write their components like this:

```js
export default Component.extend({
  /* Public API */

  src: null,
  paused: null,
  title: null,

  /* Internal */
  scrubber: null
})
```

It can also be unclear how to react to a change in the external
properties. It is possible to use observers for this purpose in Ember,
but observers feel low-level and do not coordinate very well with the
rendering process.

To reduce confusion, we plan to move external attributes into a new
`attrs` hash.

If you invoke a component like this:

```handlebars
<my-video src={{movie.url}}></my-video>
```

then the `my-video` component accesses the passed-in `src` attribute as
`this.attrs.src`.

We also plan to provide lifecycle callbacks (modelled after [React's
lifecycle callbacks][react-lifecycle]) for changes to `attrs` that will
integrate with the rendering lifecycle. We plan to supplement the API
with callbacks for changes in individual properties as well.

[react-lifecycle]: http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods

### Transition Plan

In Ember 1.10, we will begin installing provided attributes in the
component's `attrs` hash. If a provided attribute is accessed directly
on the component, a deprecation warning will be issued.

In applications, you should update your component JavaScript and
templates to access provided attributes via the component's `attrs`
property.

**In Ember 2.0, we will stop setting attributes as properties on the
component itself.**

We will also provide a transitional mixin that Ember addons can use that
will make provided attributes available as `attrs.*`. This will allow
add-ons to move to the new location, while maintaining support for older
versions of Ember. We expect people to upgrade to Ember 1.10 relatively
quickly, and do not expect addons to need to maintain support for Ember
1.9 indefinitely.

## Routeable Components

Many people have noticed that controllers in Ember look a lot like
components, but with an arbitrary division of responsibilities. We
agree!

In current versions of Ember, when a route is entered, it builds a
controller, associates a model with it, and hands it off to an
(old-style) view for rendering. The view itself is invisible; you just
write a template with the correct name.

We plan to transition to: when a route is entered, it renders a
**component**, passing along the model as an `attr`. This eliminates a
vestigial use of old-style views, and associates the top-level template
with a regular component.

### Transition Plan

Initially, we will continue to support routing to a controller+template,
so nothing will break. Going forward, routes will route to a component
instead.

In order to do that refactoring, several things will change:

* Instead of referring to model properties directly (or on `this`), you
  will refer to them as `model.propName`.
* Similarly, computed properties that move to your component will need
  to depend on `model.propName` if they are migrated from an
  `ObjectController`.
* In both cases, the short version is that you can no longer rely on the
  proxying behavior of `ObjectController` or `ArrayController`, but you
  can remedy the situation by prefixing `model.` to the property name.
* Unlike controllers, top-level components do not persist across
  navigation. Persistent state should be stored in route objects and
  passed as initial properties to routable components.
* In addition to the asynchronous `model` hook in routes, routes will
  also be able to define a `attrs` hook, which can return additional
  asynchronous data that should be provided to the component.
* Routeable Components should be placed in a "pod" naming convention. For
  example, the component for the `blog-post` route would be
  `app/blog-post/component.js`.

**We plan to land support for routeable components in Ember 1.12, and
deprecate routeable controllers at the same time. We plan to remove
support for routeable controllers in Ember 2.0.** This will allow
you to move your codebases over to routeable components piecemeal before
making the jump to 2.0.

**We will also provide an optional plugin for Ember 2.0 apps that restores
existing behavior.** This plugin will be included in the Ember automated
test suite to ensure that we do not introduce accidental regressions in
future releases on the 2.x series.

We realize that this is the change has the largest transitional cost of
all the planned features, and we plan to dedicate time to the precise
details in the full RFC on this topic.

## Improving Actions

Today's components can communicate with their parent component through
actions. In particular, the `sendAction` method allows a child component
to invoke a named action on the parent (inside of the `actions` hash).

Part of the reason for this API was a limitation in the original
Handlebars syntax:

```handlebars
{{!-- we can't get too fancy with the value of key-press --}}
{{input key-press="valueChanged"}}
```

In this example, when the `input` component calls
`this.sendAction('key-press')`, it invokes the `valueChanged` action on
its parent component.

With the new HTML syntax for components, we have more flexibility:

```handlebars
<input key-press={{action "valueChanged"}}>
```

This will package up the parent's `valueChanged` action (in the
`actions` hash) as a callback function that is available to the child
component as `this.attrs['key-press']`.

```js
export default Ember.Component.extend({
  keypress: function(event) {
    this.attrs['key-press'](event.target.value);
  }
});
```

The benefit of this approach is twofold:

* Actions are no longer treated specially in the component API. They are
  simply properties packaged up to be called by the child component.
* It is possible to pass an alternative function as the `key-press`,
  reducing the child component's knowledge of what the callback is
  doing. This has testing and abstraction benefits.

### Transition Plan

We will continue to support the `sendAction` API for the forseeable
future in today's Handlebars syntax.

When calling an existing component with new HTMLBars syntax, you do not
need to change your existing `actions` hash. You should change syntax
that looks like this:

```handlebars
{{video-player playing="playingBegins"}}
```

To this:

```handlebars
<video-player playing={{action "playingBegins"}}>
```

The `video-player` component's internal use of `sendAction` will work
with both calling styles.

New components should use `this.attrs.playing()`, but existing components
that want to continue supporting legacy callers should continue to use
`sendAction` for now. The `sendAction` API will seamlessly support both
calling styles, and will be supported for the forseeable future.

```js
// instead of
this.sendAction('progress', value);

// new code can use
this.attrs.progress(value);
```

## Onward

Version 2.0 marks the transformation of Ember from simply an MVC framework
to a complete front-end stack. Between Ember's best-in-class router,
revamped components with virtual DOM, easy-to-use build tools, and a growing
ecosystem that makes taking advantage of additional libraries a breeze, there's
no better way to get started and stay productive developing web apps today.

Hopefully, this plan demonstrates that staying on the cutting-edge can be done
without rewriting your app. There are a huge number of Ember apps in production
today, and we're looking forward to a time in the very near future where they
can start to take advantage these new features.

Expect to see many more RFCs covering these features in depth soon (including
a roadmap for Ember Data 1.0). We look forward to hearing your feedback!



---

---
stage: recommended
start-date: 2015-07-10T00:00:00.000Z
release-date: 2015-07-29T00:00:00.000Z
release-versions:
  ember-cli: v1.13.5

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/20
project-link:
---

# Summary

Enable [Subresource Integrity [SRI]](http://www.w3.org/TR/SRI/) checks by default.

# Motivation

To promote the use of SRI in Ember apps as a safe default. Applications should be built with integrity attributes when it is safe to do so. (Unfortunately the main advantage won't be met by default, however confirming one attribute will)

This solves having poisoned CDN content: [An introduction to JavaScript-based DDoS](https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/)


# Detailed design

Install [ember-cli-sri](https://www.npmjs.com/package/ember-cli-sri) by default.

- Applications with relative paths will get SRI.
- Applications with `SRI.crossorigin` will get SRI on `fingerprint.prepend` assets
- Applications with `fingerprint.prepend` and `origin` specified and matching get a `SRI.crossorigin` of anonymous on `fingerprint.prepend` assets

By default development environments wont run SRI for performance reasons.

Further explanation available in: [ember-cli-sri](https://www.npmjs.com/package/ember-cli-sri)

# Drawbacks

- SRI won't always be on for sites with prepend due to SRI requiring CORS.
- CORS requirement adds a barrier to entry to some users.
- Broken SRI attrs would break the application.

# Alternatives

No other alternatives appear suitable.

# Unresolved questions

- Adding origin attribute to add a safe same-origin check that doesn't need CORS.
- Could users be warned until they explicitly set `SRI.enabled = false` or `SRI.crossorigin = `?


---

---
stage: accepted
start-date: 2015-08-18T00:00:00.000Z
release-date:
release-versions:
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/23
project-link:
---

# Summary

Adds command line completion *(tab completion)* to ember-cli that fills in partially typed commands by the user and suggests available sub commands or options. *(from now on i will refer to "strings in the command line" as "cli-commands" and "generate" and "new" as unprefixed "commands")*

# Motivation

With all the already existing commands and especially all blueprints, plus the fact that any addon can add even more blueprints to your tool kit, users can get overwhelmed. Currently, when you want to execute a specific task and you don't quite know the correct cli-command you have to invoke `ember help` which is noisy and slow *( especially when you just want to know the spelling of a specific thing)*. This feature will enable the user to choose from all existing cli-commands by pressing __[tab]__ or just to let ember-cli fill partially typed cli-commands for speed.

# Detailed design

The two main components of that feature are a __completion function__ that is responsible for the actual tab-completion, and a __generation function__ that will write the cli-command hierarchy together with metadata into a JSON file for fast processing.

## completion function

To enable this feature, a __completion function__ will run at the main entry point of the process *(making use of  [omelette](https://github.com/f/omelettev) for shell completion)*. On every __[tab]__ it will parse the command line and either completes a partially typed, unambiguous cli-command, or suggests possible cli-commands for the current context.

The user interface will work as you would expect it from a shell completion:

- it suggests all commands if none are typed yet

  ```
    $ ember <tab>
    > addon     destroy   help      install   serve     version
      build     generate  init      new       test
  ```
- it completes partially typed commands

  ```
    $ ember gen<tab>
    $ ember generate
  ```
- it completes to suggests commands based on user input (note how it __should__ understand aliases)

  ```
    $ ember g ad<tab>
    > adapter       adapter-test  addon
  ```
- it, by default, will not suggest options

  ```
    $ ember g resource <tab>
  ```
- it will suggest options on demand (note how it __should__ know when an option needs a value)

  ```
    $ ember g resource post --<tab>
    --dry-run         --in-repo-addon=  --verbose
    --dummy           --pod
  ```

## generation function

For a good user experience we don't want to figure out those suggestions on runtime or the completion feature would not be substantially faster then the `ember help` command. So there will be a __generation function__ that generates a JSON file once after ember-cli is installed and then during every `ember install some-addon` command to ensure that blueprints added by new addons are recognized aswell.

Here an example snippet of a cli-command with one cli-subcommand:
```
  ...
  {
    "name": "command-name",
    "aliases": [
      "cn",
      "c"
    ],
    "options": [
    ],
    "commands": [
      {
        "name": "some-subcommand",
        "aliases": [
        ],
        "options": [
          {
            "name": "pods",
            "type": "boolean"
          }
        ],
        "commands": [
        ]
      }
    ]
  }
  ...
```
The __generation function__ will, as a first step, iterate over all commands and reads the following properties:
- __name:__ a string, the autocompletion function will suggest
- __aliases:__ this is what the autocompletion function will accept in the cli-command chain
- __availableOptions:__ an array of options that need to have a `name` and a `type` property those will be accumulated for every cli-command in the cli-command chain and suggested on `some-command --<tab>`
- __cliCommands:__ can either be an array or a function that returns an array of objects that themselfs will be parsed for the properties in this list those cli-commands will be accepted as subcommands of the current cli-command.
- __skipHelp:__ whenever this property is set to true, the cli-command will also not be suggested by the autocompletion

Whenever an object does not have one of the above properties, a reasonable default is chosen (except for `name`. If it has no name, it will not be shown at all). This way it is easy to extend that feature in the future to handle arbitrary nested cli-commands.

# Alternatives

- Currently the __completion function__ will just expect certain properties to be on a cli-command, this way most commands and blueprints work out of the box but maybe some architectual pattern, like a cli-command mixin or the like would be more robust and obvious.
- Someone with more experience with ember-cli could have an idea of how to generate all cli-commands fast enough at runtime. So that we would not need to store the data in a JSON file.

# Unresolved questions

Currently the autocompletion will figure out your default shell and configures it to allow tab-completion for ember. However on __first-time usage__ you would need to resource your config file (or close and open your terminal) and I haven't figured out how to do this programmatically.


---

---
stage: recommended
start-date: 2014-11-26T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/24
project-link:
---

# Summary

Unlike Handlebars, HTMLBars parses HTML as it parses a template.
Bound attributes are one syntax now possible.

For example, this variable `color` is bound to set a class:

```hbs
<div class="{{color}}"></div>
```

Though traditional HTML attribute syntax should be preserved (using
`class` and not `className` for example), the default path will be
to set attributes as properties on the DOM node.

However this happy path has several important exceptions, and results
in a few strange edge cases. This rfc will go into detail about the
expected behavior without talking about the implementation of attribute
on the Ember rendering pipeline.

# Motivation

`{{bind-attr` is a verbose syntax and difficult for new developers to
understand.

# Detailed design

Given a use of bound attributes:

```hbs
<input type="checkbox" checked={{isChecked}}>
```

There are three important inputs:

* The element (`tagName`, `namespaceURI`)
* The attribute name
* The value (literal or stream)

The following described the algorithm for updating the attribute/property
value on an element.

1. If the element has an SVG namespace, use `setAttribute`. Setting SVG attributes
   as properties is not supported.
2. If the attribute name is `style`, use `setAttribute`.
3. Normalize the property name as described in `propertyNameFor` below. If a normalized
   name is returned, set that property on the element (`element[normalizedPropName]`).
   If it is not returned, set with `setAttribute`.

`propertyNameFor` is a normalization setup for attribute names that takes the element
and attribute name as input.

1. Build a list of normalized properties for the passed element `normalizedAttrs[element.tagName][elementAttrName.toLowerCase()] = elementAttrName`
2. Fetch the normalized property name from this list `normalizedAttr = normalizedAttrs[element.tagName][passedAttrName.toLowerCase()]`
3. Return this normalized attr. If an `attrName` is did not normalize to a property (for example `class`), null is returned

### Acknowledged edge cases

* Boolean attrs with blank string won't work like they would in HTML: `<input disabled="{{blankString}}">` would be false
* Some selectors may not work as expected. `<input value="{{color}}">` will not result in a working `[value=red]` selector

# Drawbacks

None.

# Alternatives

Two obvious alternatives considered in detail are Angular and React.

In **Angular 2.0**, [a new prop/attr/event syntax](http://www.beyondjava.net/blog/angularjs-2-0-sneak-preview-data-binding/)
is being introduced.

Setting an attribute just like setting an HTML attribute:

```html
<pui-tab title="What a nice tab!">
```

Properties are flagged with the `[]` syntax:

```html
<input [disabled]="controller.isInputDisabled">
```

Angular is limited by it's HTML templating here. The value must be quoted
to have complex content, where as in HTMLBars it is easier to bend the
rules to introduce literal values: `disabled={{controller.isInputDisabled}}`.

Events are out of our immediate purview in this RFC, but for completeness
note Angular's syntax:

```html
<button (click)="hide()">hide image</button>
```

**React's JSX** has its own [property syntax](http://facebook.github.io/react/docs/jsx-in-depth.html),
one that diverges from traditional HTML by focusing entirely on properties
instead of attributes. This means the templates are well prepared for
use with components, but also that JSX must maintain a large whitelist of
special cases such as [supported tags](http://facebook.github.io/react/docs/tags-and-attributes.html)
and [some HTML attributes](http://facebook.github.io/react/docs/jsx-gotchas.html).

In general we would prefer to have Ember templates be as close to HTML
as possible, without requiring developers to learn a new set of property
names replacing the attribute names they already know.

# Unresolved questions

* How do we deal with `on*` attributes?
* Should we do anything special about generic element properties like `<div outerhtml={{lol}}></div>`?
* Should HTMLBars unbound attributes use the same alorithm?

There is a spike of significant depth [in PR #9721](https://github.com/emberjs/ember.js/pull/9721)
and a followup [in PR #9977](https://github.com/emberjs/ember.js/pull/9977).


---

---
stage: recommended
start-date: 2015-11-02T00:00:00.000Z
release-date: 2017-01-23T00:00:00.000Z
release-versions:
  ember-cli: v2.11.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/28
project-link:
---

# Summary

Allow `app.import` to specify outputFIle of a given import.
The default `app.import` would be considered to have an outputFile of
`assets/vendor.js`

# Motivation

It is common for individuals to want control over the outputFile for a given
dependency. For example, one may want to load some asm.js code independently
rather then via the single vendor.js blob.

It is also common for developers to want to group various dependencies
together, and then lazy-load them in the routes they are required.

Although not as automatic as we would like, it does provide a rather elegant
escape valve. Further work will likely continue to explore automation.

# Detailed design

`outputFile:` option, specifies the target file for the given import. If
multiple imports share an outputFile, they will be concatenated (regardless of
type, css/images/videos/js/txt) in the order they where imported.

`outputFile:` will default to `assets/vendor.js`

## Examples


#### variation 0: the default

```js
app.import('vendor/vim.js', { outputFile: 'assets/vendor.js'});
```

#### variation 1: 1 file -> 1 outputFile

```js
app.import('vendor/vim.js', { outputFile: 'assets/vim.js'});
```

* `vendor/vim.js` becomes `assets/vim.js`
* in prod it is:
  * uglified (unless using the uglify options it is excluded)
  * fingerprinted (unless it is excluded via the asset-rev options)

#### variation 2, multiple files to same outputFile

```js
app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
```

* in-order of the corresponding `app.import` invocation, using sourceMap
  concat, the files are combined into `assets/alternate-vendor.js`
  * `vendor/dependency-1.js` + `vendor/dependency-2.js` >> `assets/alternative-vendor.js`

#### variation n, multiple files to same outputFile

```js
app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-n.js', { outputFile: 'assets/alternate-vendor.js'});
```

* resulting concat is:
  * `vendor/dependency-1.js` + `vendor/dependency-2.js` ... `vendor/dependency-n.js`>> `assets/alternative-vendor.js`

# Drawbacks

* potential overlap with @chadhietala's packager/linker work
* does not offer additional build-pipeline hooks for these files

# Alternatives

Alternatives exist, such as adding support to the linker/packager
effort, or instructing developers to drop down and use
broccoli-funnel/source-map-concat.

The linker/packager effort is still a ways off, and could be thought of as
complementary.

Dropping down to broccoli is a solution available today, but for this problem,
it feels like a slightly too low level of abstraction.

# Unresolved questions

* how does this relate to `type` in `app.import(..., { type: ... })` ?
* should additional build-steps be allowed for specific output files? (I
  suspect maybe, but a future RFC can likely explore)


---

---
stage: accepted # FIXME: This may be a further stage or Discontinued since we now have allowlist and blocklist.
start-date: 2015-11-11T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/29
project-link:
---

# Summary

It should be possible to white- and/or blacklist addons in `EmberApp`.

# Motivation

If there are two (or more) `EmberApp`s, it's very likely that not all applications need all addons.
E.g. if there is a main page application and one application for embeddable widgets, the main page might need all sorts of addons like `ember-modal-dialog` which adds completely useless bytes to widgets javascript and css files for the widgets. Other addons may add useless initializers or other things that have runtime performance penalties for no benefit.

# Detailed design

When EmberApp ctor gets passed a blacklist like this

```javascript
  EmberApp({
    addonBlacklist: ['ember-modal-dialog']
  });
```

it won't add addons whose `name` matches `ember-modal-dialog` to the list of addons for this app, just as if the addon's `isEnabled()` hook returned `false`.

C.f. https://github.com/ember-cli/ember-cli/blob/master/lib/broccoli/ember-app.js#L344, this is also were I would add this check.

Whitelist could work analogously.

# Drawbacks

- It adds a bit of API surface while you (possibly) don't care for the multiple app use case of ember-cli.

- It kinda makes the `name` of an addon public api, so people might change it, not noticing they are breaking people's build (and people might not notice it either). Some addons have names like `Ember CLI ic-ajax` which seems awkward to use as an identifier.

# Alternatives

- Add a unified way to enable/disable an addon via normal config
    - if that is added one day, the white/blacklist could still be an abstraction for that

# Unresolved questions

None.


---

---
stage: discontinued # FIXME: Is this correct?
start-date: 2015-06-07T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework # FIXME - added automatically as it was missing during migration
prs:
  accepted: https://github.com/emberjs/rfcs/pull/45
project-link:
---

# Summary

Solicit feedback about the support timeframe for Internet Explorer 8 and Internet Explorer 9.

# Motivation

As Ember heads towards version 2.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 2.0 until Ember 3.0.

Ember 1.x did not have an official browser support matrix, but we would like to correct this for Ember 2.0.

We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.

Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, no one was still supporting IE8.

Because of this, the core team's impression is that the costs of IE8 support now far exceed the benefits, and we are considering dropping support
for IE8 in Ember 2.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE8 incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.

Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. All of these are shackled to the limitations of IE8, and by dropping support for IE8, people can begin to rely on the improved baseline of ES5.

Below, we outline the costs of continuing to support IE8, so that you can help us make a considered decision.

# Detailed design

## IE8

### Eliminate `get()`

Currently, accessing properties on an Ember object requires using the `.get()` method. By using this abstraction, we have been able to implement several powerful features, such as proxies and computed properties, even on older browsers like IE8 that lack getters and setters.

However, ECMAScript 5, which shipped in **2009**, added support for getters to JavaScript itself, and we would like to use this feature in Ember to eliminate the explicit calls to `get`. Developers new to the framework tell us that having to remember to use `.get()` is a big source of confusion. More seasoned developers get used to it, but moving the Ember object model closer to the pure JavaScript object model is a major goal for Ember 2.x. While many of the features of ES6 classes can be transpiled, getters and setters require engine support, and could not be used if we needed to support IE8.

### More ES6 Features, Today

While much of ES6 can be transpiled correctly to ES3 (the version of JavaScript included with IE8), transpiling ES6 modules and classes requires `defineProperty`.

Continued support for IE8 limits our ability to adopt new ES6 features in the internals of Ember, and to talk about them in our documentation.

One example: In ES6, classes define their methods as non-enumerable properties. Transpiling this to existing browsers is only possible with `defineProperty`, which is not included in IE8. Trying to transpile ES6 classes to work on IE8 would lead to apps exhibiting subtly different behavior that would be painful to debug. IE8 users would discover that the larger Ember ecosystem was incompatible with their apps in hard-to-predict ways, and we think the ecosystem is one of the biggest advantages Ember offers.

In other words, we don't think we can make the full transition to JavaScript classes a first-class part of the Ember experience if we still support IE8. As we did with modules, we would like to move more of our core to JavaScript features in the future, which would be significantly stymied by the lack of `defineProperty` in IE8.

### Remove the jQuery Dependency

For its entire lifetime, Ember has relied on jQuery to smooth the rough edges of browser compatibility when interacting with the DOM. When people think about that dependency, they often assume that we could just replace calls to things like `.attr` with their more verbose DOM counterpart and call it a day.

jQuery does more than just patch over IE8 rough spots; it also serves as the central place for normalizing behavior that can differ significantly across browsers. If we tried to pick-and-choose pieces of jQuery to pull into Ember, we would also be responsible for backporting any changes made to jQuery. We'd rather just rely on jQuery directly; that's what dependencies are for.

The jQuery dependency has helped us with a few cross-browser areas:

* Portable `DOMContentLoaded` (via `jQuery.ready`)
* Support for event delegation across a wide variety of events.
* Attribute and property normalization, which has already been implemented by HTMLBars
* HTML parsing, which has also been implemented by HTMLBars

Of these, proper support for event delegation is the largest remaining reason to rely on jQuery. IE9's support for the capture phase of events makes it simpler to support event delegation properly across all event types without a normalization layer.

### Support More Event Types

Many newly specified events in the web platform (such as the media events) do not bubble, which is a problem for frameworks like Ember that rely on event delegation. However, the capture API, which was added in IE9, is invoked properly for all events, and does not require a normalization layer. Not only would supporting the capture API allow us to drop the jQuery dependency, but it would allow us to properly handle these non-bubbling events. This would allow you to use events like `playing` in your components without having to manually set up event listeners.

### CSS Improvements in Ember 2.x

Today, the main Ember framework does very little to directly help with CSS. We expect that to change in the 2.x series, as we explore ways to help tame the CSS beast.

However, a number of important CSS features landed in IE9: CSS3 selectors, full support for `querySelectorAll`, `getComputedStyle`, `calc()` to name a few. Productively tackling the CSS problem without these features would be like fighting with both hands tied behind our backs, and it may be impossible for us to robustly tackle the problem until Ember 3.0 if we needed to continue to support IE8.

While it may be theoretically possible to implement some form of this feature in IE8, it is likely that the cost of doing so in a backwards-compatible way would significantly add to development time; perhaps so significantly it would be better to wait until we drop support for IE8 than attempt to bolt it on to a browser released half a decade ago.

### Maintenance Costs

While it's very easy to weigh the costs of features that we could not implement at all due to IE8, there is a much more pernicious cost that is harder to see.

Support for IE8 adds costs, sometimes significant, to every new feature we work on. For example, broken support for text nodes in IE8 significantly impeded early work on Glimmer. Every new area of work requires budgeting a significant amount of time for IE8 support.

This is not surprising. When asked many years ago what jQuery could do when IE6 was gone, John Resig replied that we would gain little from dropping IE6, and that the benefits would not come until jQuery could drop IE8, the last version of IE featuring the bugs that made IE6 so difficult to develop for.

Quite often, we will assume that a feature is ready to ship, and only discover subtle issues in IE8 very close to the release once it has been tested. We estimate that support for legacy Internet Explorer slowed down the development of HTMLBars by 2x.

In short, we would be able to implement more features more quickly without the burden of bugs that were first introduced 15 years ago.

## What About IE9?

In the first decade of 2000, browsers were updated very slowly, and every new release took a long time to be supplanted by the next release. As the last version of Internet Explorer supported by Windows XP, IE8 is a relic of this bygone era. In contrast, IE9 usage was quickly supplanted by IE10, and that pattern continues with IE11.

The public trackers have IE9 at a lower share of total usage than IE8, so it might be worth considering dropping them together. Our decision for Ember 2.0 will likely hold until late 2016, so it's worth considering more than just the current moment when making the decision.

While IE9 added support for the ES5 features we need to move into the future for JavaScript, IE10 added support for the last great wave of web features. Here is a sampling:

* Flexbox and Grid Layout
* Offline storage (IndexedDB, File, Blob)
* Web Workers
* Typed Arrays
* Web Sockets
* App Cache
* History API

Several of these features are required for asm.js, and in total, they make the web platform a capable application runtime. While we don't have any immediate plans to take advantage of these web features right now, the best experiments that people are doing today rely on them. By assuming IE10 as the baseline across the entire ecosystem, we would be able to do much more aggressive experimentation on the web platform.

# Drawbacks

Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. When we announced in early 2014 that we would continue to support IE8 for at least another year, other libraries and frameworks had already dropped support. That being said, there will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.

However, in many cases, the requirement of IE8 support is driven by non-technical management who do not have a strong sense of the experience of using apps in IE8. In practice, many applications are not rigorously tested in older browsers, and the performance of IE8 is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with a DOM and JavaScript engine written in the 90s.

Still, some people make it work, and dropping IE8 support may prevent those teams from staying with the community as it migrates to Ember 2.0.

# Alternatives

## Drop IE8 Support During 2.x

One alternative we have considered is deprecating IE8 support prior to releasing 2.0, but still maintaining it for a few point releases to give IE8 more time to lose market share.

After discussing with the core team, we believe that this would be a violation of our Semantic Versioning commitment to users. Specifically, we want to avoid a large group of apps getting stuck midway through the 2.x cycle. Version numbers are an important tool for developers, maintainers and ecosystems to communicate compatibility. Tools such as package managers rely on version numbers correctly indicating breaking changes.

We consider browser compatibility to be a feature of Ember, and dropping IE8 support in a minor release would be akin to stripping out any other major feature. While the ecosystem would muddle along in either case, such a move would cause exactly the kind of ecosystem fragmentation that Semantic Versioning is designed to prevent.

If we want to communicate the idea that changing versions comes with a reduction in functionality, we should do that the same way we always do, by incrementing the major version.

## Early 3.0

Another option is to release 3.0 in six months, rather than the nearly two years between Ember 1.0 and Ember 2.0.

Correctly tuning the cadence of major releases is a delicate tradeoff. Semantic Versioning allows us to easily communicate about breaking changes, and some take this as a license to make them frequently. However, a robust ecosystem relies on a certain measure of stability.

We believe that the frustration of breaking changes every six months (or even a year) would outweigh whatever benefits it would provide. Ember's biggest goal is building a shared foundation for our ecosystem to build on, and this requires a careful commitment to stability.

While we could make a "small" breaking release soon after 2.0, breaking changes inherently fragment the ecosystem, and we hope that the years to come bring more stability for add-on authors and tool-makers, not less.

## Bring Your Own Compatibility

Some libraries attempt to thread the needle of IE8 compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if IE8 did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers. For example, React asks users to bring libraries such as `es5-shim`, `es5-sham`, `console-polyfill` and `html5shiv` if they want IE8 support.

Facebook.com supports IE8, and uses React, so there is a path to using React with IE8. This path is partially documented on the React website. This gives us a perfect opportunity to evaluate the impact of this strategy in the real world. We admire the React team's work in this area: support for IE8 is difficult and triaging and fixing IE8 bugs requires diligent effort.

After reviewing the [IE8-compatibility issues filed on React.js tracker](https://github.com/facebook/react/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+ie8), we believe there are significant user experience costs to this strategy.

We have spent considerable effort on first-class IE8 support in Ember 1.x, and we feel that users who require IE8 support will have a better experience using Ember 1.14 (with the subset of the ecosystem that supports 1.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.

# Unresolved questions

We are relying on the community to help us weigh the above tradeoffs. The more data you can provide about the browser makeup of your customers (especially as it affects revenue), the better we can reason whether now is the time to remove IE8 (and possibly IE9) support.

If you cannot share the information publicly, please email whatever information you consider useful to browserusage@emberjs.com. We will keep it in the strictest of confidence.


---

---
stage: recommended
start-date: 2016-03-26T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/46
project-link:
---

# Improved Release Process

## Summary & Motivation

ember-cli has followed an ad hoc release process throughout its existence which has made it difficult to know exactly when releases would come out, what features would and would not be supported, and the degree to which it would support existing Ember applications. With the proposal for lockstep SemVer there were ideals of guaranteeing compatibility, which we have mostly met, but that resulted in making decisions of delaying an official 2.X release of ember-cli to avoid additional major version bumps.

We propose that we adopt a pattern similar to Ember itself in order to align with the expectations of the Ember community, more-clearly communicate around our release lifecycle, and provide rigor around our support structure. Anything which is not specifically called out as a difference in this document is inferred to be following the patterns specified by Ember itself.

## Channel Design

To begin there will be three separate channels: canary, beta, and release. We intend to investigate an LTS channel after this process has matured.

- **Canary**: represents the latest work in ember-cli, and is synonymous with the `HEAD` of the `master` branch and is the least stable of all channels.
- **Beta**: branched off of master every six weeks, exact commit decided upon manually. Updated and released weekly with commits that are prefixed `[BUGFIX beta]`. Less stable than `release` as it is a proving ground. No new features will be added once the branch has been created to allow for existing features to mature. Tags will match Ember's patterns, for example `v2.6.0-beta.1`. Branch name: `beta`.
- **Release**: branched off of Beta every six weeks. Only rarely will this be updated, but possible for security issues and uncaught regressions. Branch name: `release`.

ember-cli will not support daily releases as time-based packaging doesn't make a lot of sense.

## New Features

New features to ember-cli must be protected by feature flags. Incomplete and WIP features will be available in the Canary channel, but will not be available in the Beta or release channels.

## Tooling Design

We must create additional tooling and patterns in order to make this efficient. Since ember-cli successfully installs and works from npm without modification we don't need to bundle and publish an asset for each Canary build. We'll publish tags to npm for `beta` and `release` channel releases so that they're not tied to a git remote URL. The `latest` tag for npm (the default when installing via `npm install -g ember-cli`) will track our `release` channel at all times. We will publish tagged releases (i.e. v2.6.0-beta.1) to the npm `beta` tag which is used via `npm install --save-dev ember-cli@beta`.

## Timeline

Since the ember-cli project is presently designed to track Ember development, we'll run our release schedule on a one week delay from Ember itself. This ensures that we're able to incorporate the latest changes from Ember into ember-cli and gives us a week to check for Ember-introduced regressions. As Ember itself becomes an npm module this will become less of a concern and we can diverge on our release schedule as best suits the ember-cli project. We will ship the last beta coincidentally with the newest Ember release.

## Drawbacks

The largest drawback is also a feature: we require more rigor in our release processes. This process presently requires a weekly manual review of new commits to master and their prefixes which then get cherry-picked to the appropriate `release` and `beta` branches.

We've also encountered issues with `npm` in the past which may require investigation into other tools.

## Effort

In order to undertake this task, there are multiple workflows which must occur:

- [ ] Updates to the website and documentation communicating this plan.
- [ ] Teaching new patterns to ember-cli contributors, most specifically commit tagging and feature flagging.
- [ ] Increased automation of the release process.
- [ ] Tooling to support feature flags.

## References

- [Ember's Post-1.0 Release Cycle](http://emberjs.com/blog/2013/09/06/new-ember-release-process.html)
- [Ember RFC #56 - Improved Release Cycle](https://github.com/emberjs/rfcs/blob/master/text/0056-improved-release-cycle.md)
- [Announcing Ember's First LTS Release](http://emberjs.com/blog/2016/02/25/announcing-embers-first-lts.html)
- [ember-cli Release Instructions](https://github.com/ember-cli/ember-cli/blob/master/RELEASE.md)


---

---
stage: recommended
start-date: 2015-04-09T00:00:00.000Z
release-date: 2015-10-05T00:00:00.000Z
release-versions:
  ember-source: v2.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/46
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/11440
---

# Summary

Fully encapsulate and privatize the `Container` and `Registry` classes by
exposing a select subset of public methods on `Application` and
`ApplicationInstance`.

# Motivation

The `Container` and `Registry` classes currently lead a confusing life of
semi-private exclusion within Ember applications. They are undocumented
publicly but not fully private either, as knowledge of their particulars is
required for developing both initializers and unit tests. This situation has
become untenable as the new `Registry` class has been extracted from
`Container`, and the complexity of their usage has grown across
`Application` and `ApplicationInstance` classes.

We can bring sanity to this situation by continuing the work started at the
`Application` level to expose methods such as `register` and `inject` from the
internally maintained `Registry`.

Furthermore, once `Container` and `Registry` are fully private, their
architecture and documentation can be cleaned up. For instance, a
`Container` can freely reference its associated `Registry` as `registry`
rather than `_registry`, as it can be assumed that only framework developers
will reference this property.

# Detailed design

`Application` will expose the following methods from its internally maintained
registry:

* `register`
* `inject`
* `registerOptions` - mapped to `Registry#options`
* `registerOptionsForType` - mapped to `Registry#optionsForType`

`ApplicationInstance` will also expose the the same methods. However, these
methods will be exposed from its own internally maintained registry, which
has the associated `Application`'s registry configured as a "fall back". No
direct path will be provided from the `ApplicationInstance` to the
`Application`'s registry.

`ApplicationInstance` will also expose the following methods from its
internally maintained container:

* `lookup`
* `lookupFactory`

`ApplicationInstance` will cease exposing `container`, `registry`, and
`applicationRegistry` publicly.

`Application` initializers will receive a single argument to `initialize`:
`application`.

Likewise, `ApplicationInstance` initializers will receive a single argument
to `initialize`: `applicationInstance`.

`Container` and `Registry` will be made fully private and documented as
such. Each `Container` will freely reference its associated `Registry` as
`registry` rather than `_registry`.

[ember-test-helpers](https://github.com/switchfly/ember-test-helpers)
will provide an `isolatedApplicationInstance` method instead of an
`isolatedContainer` for unit testing. A mechanism will be developed to specify
which initializers should be engaged in the initialization of this instance.
In this way, we can avoid duplication of registration logic, as is currently
done in a most un-DRY manner in the [isolatedContainer](https://github.com/switchfly/ember-test-helpers/blob/master/lib/ember-test-helpers/isolated-container.js#L56-L79).

# Drawbacks

This refactor will require maintaining backwards compatibility and
deprecation warnings until Ember 2.0. This will temporarily increase
internal code complexity and file sizes.

# Alternatives

The obvious alternative is to make `Container` and `Registry` fully public
and documented. An application's registry would be available as a `registry`
property. An application instance's container would remain available as
`container`.

We could still pass an `Application` into application initializers
and an `ApplicationInstance` into application instance initializers.

If this alternative is taken, I would suggest that `Application` should
deprecate `register` and `inject` in favor of calling the equivalents on its
public `registry`.

Regardless of which alternative is chosen, we should ensure that the public
aspects of container and registry usage are well documented.

# Unresolved questions

* Are the public methods listed above sufficient or should any others be
exposed?

* What mechanism should be used to engage initializers in unit and
integration tests? Should test modules simply have an `initializers` array,
similar to the current `needs` array?

* Given the semi-private nature of containers and registries, we may not need
to worry about semver for deprecations. However, we should be good citizens
and properly deprecate as much as possible. Some real world use cases in
initializers will no doubt be a surprise, so we need to tread carefully.


---

---
stage: recommended
start-date: 2016-04-06T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/50
project-link:
---

# Summary

A number of Ember framework function calls are no-ops in production. Ember CLI should strip these no-op function invocations from production builds by default.

# Motivation

Removing code that isn't required in production results in smaller and faster applications.

# Detailed design

The following framework function calls will be removed from ember-cli production builds by default:

 * [`Ember.assert`](http://emberjs.com/api/#method_assert)
 * [`Ember.debug`](http://emberjs.com/api/#method_debug)
 * [`Ember.deprecate`](http://emberjs.com/api/#method_deprecate)
 * [`Ember.info`](http://emberjs.com/api/#method_info)
 * [`Ember.runInDebug`](http://emberjs.com/api/#method_runInDebug)
 * [`Ember.warn`](http://emberjs.com/api/#method_warn)

The API documentation will be updated where necessary to indicate that these function calls will be stripped from production builds.

A babel plugin will execute the removal of these function calls based on provided configuration. The plugin will affect the code of the current app or addon only and won't affect code in child or grandchild addons. As this change becomes part of the default ember-cli configuration, addons will adopt the code stripping as they upgrade to newer ember-cli versions.

The plugin configuration will define an array of modules or global functions to remove. Here's an example of what this configuration might look like:

```js
{
  removals: [
    {
      module: 'ember', //eg. import Em from 'ember';
      paths: [
        'assert', //Em.assert will be removed
        'debug',  //Em.debug will be removed
        'a.b.c'   //Em.a.b.c will be removed
      ]
    }, {
      global: 'Ember',
      paths: [
        'deprecate' //Ember.deprecate will be removed
      ]
    }, {
      paths: [
        'console.log' //console.log will be removed
      ]
    }
  ]
}
```

The plugin will support removal of destructured and reassigned invocations of these functions and will support both Babel 5 and 6.

An app or addon can disable the code removal by removing the babel plugin.

# How We Teach This

This change doesn't bring any new functionality. Other than updating the Ember API docs, we don't need to make guide or other documentation changes. At the time of releasing, we may want to point out the possible side effects in a release blog post (see the _Drawbacks_ section below).

If we want to expose the configuration options so that application authors can customize the settings, we can include a new section in the Ember CLI docs.

# Drawbacks

This may introduce an unexpected change in production builds as arguments that have side effects will no longer be executed. For example:

```js
Ember.assert('Some assertion', someSideEffect());
```

Currently, the `someSideEffect` function will be executed in production. When this RFC lands, it won't.

# Alternatives

An Ember addon could provide opt-in function stripping for applications that want it. If this RFC isn't deemed a good default for Ember CLI, that option should be explored.


---

---
stage: discontinued
start-date: 2014-05-06T00:00:00.000Z
release-date: 2015-06-12T00:00:00.000Z
release-versions:
  ember-source: v1.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/50
project-link:
---

# Summary

The `{{action` helper should be improved to allow for the creation of
closed over functions that can be passed between components and passed
the action handlers.

See [this example JSBin from @rwjblue](http://emberjs.jsbin.com/rwjblue/466/edit?html,js,output)
for a demonstration of some of these ideas.

# Motivation

Block params allow data to be passed from one component to a downstream
component, however there is currently no way to pass a callback to a downstream
component.

# Detailed design

First, the existing uses of `{{action` will be maintained. An action can be attached to an
element by using the helper in element space:

```hbs
{{! app/index/template.hbs }}
{{! submit action will hit immediate parent }}
<button {{action "submit"}}>Save</button>
```

An action can be passed to a component as a string:

```hbs
{{! app/index/template.hbs }}
{{my-button on-click="submit"}}
```

```js
// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction('on-click');
  }
});
```

Or a default action can be passed:

```hbs
{{! app/index/template.hbs }}
{{my-button action="submit"}}
```

```js
// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction();
  }
});
```

In all these cases, `submit` is called on the parent context relative to the scope `action` is
attached in. The value `"submit"` is attached to the component in the last two as
`this.attrs.on-click` or `this.attrs.action`, although it is not directly used.

### Creating closure actions

Closure actions are created in a template and may be used in all places a string
action name can be used. For example, this current functionality:

```hbs
<button {{action "submit" on="click"}}>Save</button>
```

Would be written using a closure action as:

```hbs
<button {{action (action "submit") on="click"}}>Save</button>
```

The functionality is exactly the same as the string-based action example.
How does that happen?

* `(action "submit")` reads the `submit` function off the current scope's
  `actions.submit` property.
* It then creates a closure to call that function.
* `{{action` receives that function as a param. It registers a listener (in
  this case on click) and when fired calls the closure function.

Consider usage on the calling side. With the current string-based actions:

```hbs
{{my-component action="submit"}}
```

```js
export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a string
    this.attrs.action; // => "submit"
  }
});
```

With closure actions, the action is available to call directly. The `(action` helper
wraps the action in the current context and returns a function:

```hbs
{{my-component action=(action "submit")}}
```

```js
export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a function
    this.attrs.action(); // submit action, new style
  }
});
```

A more complete example follows, with a controller for context:

```js
// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      // some submission task
    }
  }
});
```

```hbs
{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
```

```js
// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs.save();
    // for backwards compat, you may also this.sendAction('save');
  }
});
```

### Hole punching with a closure-based action

The current system of action bubbling falls down quickly when you want to pass a message through multiple
levels of components. A closure based action system helps address this.

Instead of relying on bubbling, a closure action wraps an action from the current context's
`actions` hash in a function that will call it on that context. For example:

```hbs
{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
```

```hbs
{{! app/components/my-form/template.hbs }}
{{my-button on-click=attrs.submit}}
```

```hbs
{{! app/components/my-button/template.hbs }}
<button></button>
```

```js
// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs['on-click']();
    // for backwards compat, you may also this.sendAction();
  }
});
```

A closure action can also be called by an action handler:

```hbs
{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
```

```hbs
{{! app/components/my-form/template.hbs }}
{{my-button on-click=submit}}
```

```hbs
{{! app/components/my-button/template.hbs }}
<button {{action on-click}}></button>
```

Lastly, closure actions allow for yielding an action to a block. For example:

```hbs
{{! app/index/template.hbs }}
{{my-form save=(action 'submit') as |submit reset|}}
  <button {{action submit}}>Save</button>
  {{! ^ goes to my-form's save attr property, which
        is the submit action on the outer scope }}
  <button {{action reset}}>Reset</button>
  {{! ^ goes to my-form }}
  <button {{action "cancel"}}>Cancel</button>
  {{! ^ goes to outer scope }}
{{/my-form}}
```

```hbs
{{! app/components/my-form/template.hbs }}
{{yield attrs.save (action 'reset')}}
```

```js
// app/components/my-form/component.js
export default Ember.Component.extend({
  actions: {
    reset: function(){
      // rollback
    }
  }
});
```

### Currying arguments with a closure-based action

With string-based actions, an argument can be passed to the called function. For
example:

```hbs
<button {{action "save" model}}></button>
```

```js
export default Ember.Component.extend({
  actions: {
    save: function(model) {
      model.save();
    }
  }
});
```

Closure actions allow for another opportunity to curry arguments. Arguments
set by an element action helper simply add to the end of the arguments list:

```hbs
{{! app/index/template.hbs }}
{{my-component save=(action "save" model)}}
```

```hbs
{{! app/components/my-component/template.hbs }}
<button {{action attrs.save prefs}}></button>
```

```js
// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    save: function(model, prefs) {
      model.set('prefs', prefs);
      model.save();
    }
  }
});
```

Multiple arguments can be curried or set at any level. If an action is called ala
`this.attrs.save(additionalPrefs)`, that final argument is added
to the end of the arguments list.

### Re-targeting the scope of a closure action

The `target` option may be provided to specify what scope the closure is called
with. For example:

```hbs
{{! app/index/template.hbs }}
<my-component on-click={{action "save" model target=someComponentInstance}}></my-component>
```

Much like with the `{{action` helper, passing both a
target and a bound argument will throw.

The default target for a closure is always the current scope.

* When routable components land, the current component will be the default target.
* If a controller is the current scope, that controller will also be a default target.
* A route will *never* be a closure action target. String actions will continue
  to have their current behavior of bubbling to the route.

A later proposal will determine how actions on a route are passed to a routable
component.

### Return values of a closure action

Closure actions return the returned value of their called function. For example:

```js
// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      return 'great success';
    }
  }
});
```

```hbs
{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
```

```js
// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    var result = this.attrs.save();
    // for backwards compat, you may also this.sendAction('save') but
    // in that case you do not have access to the return value.
    result; // => 'great success'
  }
});
```

### Actionable object with INVOKE

`{{mut` is a new helper in Ember.js. It is not yet widely used in Ember apps, but its
interaction with the action helper is important to align early on.

Mut objects represent a modifiable value. For example with tag-based components:

```hbs
{{! app/index/template.hbs }}
<my-form name={{mut model.name}}></my-component>
```

This will cause a mutable property to be added to `attrs`. To update the name,
`this.attrs.name.update(newName)` can be called. The value can be read (in
JavaScript) as `this.attrs.name.value`.

Often, a mutable value will be set as the result of an action. Mutable values
can be called actionable. For example:

```hbs
{{! app/index/template.hbs }}
<my-form submit={{action (mut model.name)}}></my-component>
```

```js
// app/components/my-form/component.js
export default Ember.Component.extend({
  click() {
    const value = this.get('newValue');
    this.attrs.submit(value);
  }
});
```

What is happening here?

* `(mut model.name)` creates a mutable object for the `model.name` value.
* `{{action (mut model.name)}}` tests the passed object for a property with the
  key `INVOKE` (an internal symbol). This value is a function that updates the mutable value.
* Action wraps the calling of the `INVOKE` property in a function like any
  other action, and passes it to the `attrs`.

Thus, when the action is called the argument is passed to `INVOKE` which uses
it to update the mutable value. This is a simple way to enable the "actions up"
part of component-driven app architecture without ceremony around changing state.

### Plucking a property from the first argument with value

A component (or when Ember supports this better, an element) may emit an event
object and pass it to an action. In this case the value will need to be read off
the event before it can be passed to the action function. For example:

```hbs
{{input input=(action 'setName')}}
```

```js
export default Ember.Component.extend({
  actions: {
    setName(event) {
      this.get('model').set('name', event.target.value);
    }
  }
});
```

The action serves only to read the value off of the event. Here the `value`
option can be used as sugar to accomplish the same task:

```hbs
{{input input=(action (mut model.name) value="target.value")}}
```

The `value` path is read off of whatever the first argument to the actions is.

* `(mut model.name)` becomes a function, our action
* When the `input` event fires, the function is called with the event as the
  first argument.
* The first argument is re-written to the value of `event.target.value`
* The function wrapping the `mut` is set
* The `mut` is updated.

This option is designed to align with future plans for `on-some-event` handlers
for html elements.

# Drawbacks

Currently `{{action` is only used in an element space:

```hbs
<button {{action "booyah"}}>Fire</button>
```

The closure usage is a new, perhaps `action` is not the right word. However the two
behaviors are pretty similar in their conceptual behavior.

* `{{action` in element space attaches an event listener that fires a bubbling
  action.
* `(action` closes over an action from the current scope so it can be attached
  via `{{action` or passed around and called later.

This confusion should go away as we move to an `on-click` event listener pattern,
ala `<button on-click={{someClosureAction}}>`.

Additionally, there may be developers who still have `{{action someActionName}}` instead
of the quoted version. This is long deprecated, but these apps may see some
unexpected behavior.

Also additionally, some emergent behaviors exist that may not be desired as real APIs. For example,
an action being a function means it can be passed directly to event handlers:

```hbs
{{my-component mouseEnter=(action 'didEnter')}}
```

The actual API we plan for 2.0 (ideally) is:

```hbs
{{my-component on-mouse-enter=(action 'didEnter')}}
```

These behaviors should not be documented, and we should make clear that they rely on behavior that
will be deprecated. A mitigating move is to *not* proxy actions through to
`get` on a component, and only allow them to be accessed on `attrs`.

Lastly, default actions may look a bit confusing:

```hbs
{{my-button action=(action 'action')}}
{{! ^ this is valid }}
```

But the quoted string syntax is not being removed.

# Alternatives

There is maybe a thing called `ref` that solves this same problem. There has also
been discussion of accessing properties on `outlet` across all child components
and their layouts, which would allow easy targetting of the top level component.

# Unresolved questions

Interaction with `ref` or `outlet.` if any..


---

---
stage: recommended
start-date: 2015-05-17T00:00:00.000Z
release-date: 2015-06-12T00:00:00.000Z
release-versions:
  ember-source: v1.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/53
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/11278
---

# Summary

Ember.js 1.13 will introduce a new API for helpers. Helpers will come in two
flavors:

**Helpers** are a class-based way to define HTMLBars subexpressions. Helpers:

  * Have a single return value.
  * Must have a dash in their name.
  * Cannot be used as a block (`{{#some-helper}}{{/some-helper}}`).
  * Can store and read state.
  * Have lifecycle hooks analogous to components where appropriate. For
    example, a helper may call `recompute` at any time to generate a new
    value (this is akin to `rerender`).
  * Are a superset of shorthand helpers, the function-based syntax described
    below. They can do more, but in many cases a shorthand helper is appropriate.

**Shorthand helpers** are a function-based way to define HTMLBars
subexpressions. Helpers written this way:

  * Have all the limitations of regular helpers.
  * Have no instance associated with them, cannot store or read state.
  * Have no lifecycle hooks. The function is simply re-computed when any input
    changes.

These improved helpers fill a gap in Ember's current template APIs:

|                   | has positional params | has layout (shadow DOM) | can yield template | has lifecycle, instance | can control rerender |
|-------------------|-----------------------|-------------------------|--------------------|-------------------------|----------------------|
| components        | Yes                   | Yes                     | Yes                | Yes                     | Yes                  |
| helpers           | Yes                   | No                      | No                 | Yes                     | Yes                  |
| shorthand helpers | Yes                   | No                      | No                 | No                      | No                   |

An example helper:

```js
// app/helpers/full-name.js
import Ember from "ember";

export default Ember.Helper.extend({
  nameBuilder: Ember.inject.service(),
  compute(params) {
    const builder = this.get('nameBuilder');
    return builder.fullName(params[0], params[1]);
  }
});
```

An example shorthand helper:

```js
// app/helpers/full-name.js
import Ember from "ember";

export default Ember.Helper.helper(function(params, hash) {
  let fullName = params.join(' ');
  if (hash.honorific) {
    fullName = `${hash.honorific} ${fullName}`
  }
  return fullName;
});
```

Helpers can be used anywhere an HTMLBars subexpression is valid:

```hbs
{{full-name 'Bigtime' 'Beagle'}}
{{input value=(full-name 'Gyro' 'Gearloose') readonly=true}}
{{#if (eq (full-name 'Webbigail' 'Vanderquack') selectedFullName))}}
  You have chosen wisely.
{{/if}}
```

# Motivation

Ember.js 1.13 make a private API change that removed the ability to access
application containers. `Ember.HTMLBars._registerHelper` was previously passed
the `env` object, and this was removed as it is an internal implementation
detail.

Ember's helper API has not kept pace with improvements possible
after the introduction of HTMLBars. This has resulted in the community using
a variety of private APIs, many of which leak information about the outer
context of a helpers invocation as well as the render layer implementation.

The current public API is:

* [Ember.Handlebars.makeBoundHelper](http://emberjs.com/api/classes/Ember.Handlebars.html#method_makeBoundHelper)

This API is sorely lacking in functionality required by addon authors.

* Has no access to other parts of the app, like services
* Leaks a private API for dealing with blocks
* Results in less efficient helpers due to the Handlebars compatibility layer
* Has poor support for hash arguments

Additionally it remains difficult to write a helper that recomputes due to
something besides the change of its input.

Specifically, this RFC addresses many of the concerns in
[emberjs/ember.js#11080](https://github.com/emberjs/ember.js/issues/11080).
Libraries such as [yahoo/ember-intl](https://github.com/yahoo/ember-intl),
[dockyard/ember-cli-i18n](https://github.com/dockyard/ember-cli-i18n), and
[minutebase/ember-can](https://github.com/minutebase/ember-can) will be
provided a viable public API to couple to.

# Detailed design

Helpers must have a dash in their name. In an Ember-CLI app, they can be named
according to the `app/helpers/full-name.js` convention (`app/full-name/helper.js`
in pods mode). For a globals app, naming a helper `App.FullNameHelper` is
sufficient.

### Definition and lifecycle

A helper is defined as a class inheriting from `Ember.Helper`. For
example:

```js
// app/helpers/hello-world.js
import Ember from "ember";

// Usage: {{hello-world}}
export default Ember.Helper.extend({
  compute() {
    return "Hello Helper World";
  }
});
```

Upon initial render:

* The helper instance is created.
* The `compute` method is called. The return value is outputted where the
  helper is used. For example in `<div class={{some-helper}}></div>` the return
  value is set to the class.

The `compute` function is always called with `params` (the bare, ordered
arguments) and `hash` (the named arguments). For example:

```js
// app/helpers/greet-someone.js
import Ember from "ember";

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.extend({
  compute(params, hash) {
    return `Hello ${params[0]}, nice to ${hash.greeting}`;
  }
});
```

Which functions the same as this shorthand:

```js
// app/helpers/greet-someone.js
import Ember from "ember";

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.helper(function(params, hash) {
  return `Hello ${params[0]}, nice to ${hash.greeting}`;
});
```

When the `params` or `hash` contents change, the `compute` method is called
again. The instance of the helper is preserved across rerenders of the parent.
A shorthand helper, having no instance, is called every time a bound
argument changes.

The `init` and `destroy` methods can be subclassed for setup and teardown.

### Consuming a helper

Helpers can be used anywhere an HTMLBars subexpression can be
used. For example:

```hbs
{{#if (can-access 'admin')}}
  {{link-to 'login'}}
{{/if}}
{{#if (eq (can-access 'admin') false)}}
  No login for you
{{/if}}
<my-login-button isAdmin={{can-access 'admin'}} />
Can access? {{can-access 'admin'}}
```

Passing a helper to a `{{`- invoked component skips the auto-`mut` behavior:

```hbs
{{my-login-button isAdmin=(can-access 'admin')}}
```

Let's step through exactly what happens when using an helper like this:

```hbs
<my-login-button isAdmin={{can-access 'admin'}} />
```

Upon initial render:

* The helper `can-access` is looked up on the container
* The helper is identified as a full helper, not a shorthand helper function
* The helper is initialized (`init` is called)
* The `compute` function is called on the helper.
* The return value from `compute` is passed as an `attr` to `my-login-button`.
* The helper instance remains in memory.

If the parent scope is rerendered:

* The `compute` function is called again.
* The return value from `compute` is passed as an `attr` to `my-login-button`.

Upon teardown:

* The helper is destroyed, calling the `destroy` method.

### Returning a value

The return value of helper is passed through to where their subexpression
is called. For example, given a helper (this one a shorthand helper):

```js
// app/helpers/full-name.js
import Ember from "ember";

export default Ember.Helper.helper(function fullName(params, hash) {
  return params.join(' ');
}
```

The following are effectively the same:

```hbs
<div data-name={{full-name "Fenton" "Crackshell"}}></div>
<div data-name={{"Fenton Crackshell"}}></div>
```

```hbs
{{my-component name=(full-name "Magica" "De Spell")}}
{{my-component name="Magica De Spell"}}
```

```hbs
<p>{{full-name "Bentina" "Beakley"}}</p>
<p>{{"Bentina Beakley"}}</p>
```

An exclusion to this pattern is the following form:

```hbs
<div {{full-name "Webbigail" "Vanderquack"}}></div>
```

This is a legacy form of mustache usage. Helpers will throw an exception when
used in this manner.

### Consuming services and recompute

Helpers are a valid target for service injection. For example:

```js
// app/helpers/current-user-name.js
import Ember from "ember";

export default Ember.Helper.extend({
  // Same API as components:
  session: Ember.inject.service(),
  compute() {
    return this.get('session.currentUser.name');
  }
});
```

However consuming a property from a service does not bind the data being
displayed to that property. After `{{current-user-name}}` has been computed
and rendered, it will never be invalidated.

For this reason, helpers are granted some control over their
computation lifecycle. A helper will recompute when:

* A value passed via the template changes (`params` or `hash`)
* The `recompute` method is called

For example, this helper checks if the current use has access to a
resource type:

```js
// app/helpers/can-access.js
import Ember from "ember";

// Usage {{if (can-access 'admin') 'Welcome, boss' 'Heck no!'}}
export default Ember.Helper.extend({
  session: Ember.inject.service(),
  onCurrentUserChange: Ember.observes('session.currentUser', function() {
    this.recompute();
  }),
  compute(params) {
    const currentUser = this.get('session.currentUser');
    return currentUser.can(params[0]);
  }
});
```

# Drawbacks

Helpers may superficially appear similar to components, but in
practice they have none of the special behavior of components such as managing
DOM. The intent of this RFC is that full class-based helpers remain very close
to the spirit of a pure function (as in the shorthand). However, despite this
intent they are a new concept for the framework.

# Alternatives

A [previous RFC](https://github.com/emberjs/rfcs/pull/52) explored creating a new class called Expressions, which would have
more closely modeled the API of components (using positional params, attrs).
After discussion and consideration it was clear that a third kind of template
API would be very challenging to document and teach well.

# Unresolved questions

Perhaps there should be hooks in place for the lifecycle, instead of relying on
`init` and `destroy`.


---

---
stage: recommended
start-date: 2016-06-14T00:00:00.000Z
release-date: 2016-10-20T00:00:00.000Z
release-versions:
  ember-cli: v2.9.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/55
project-link:
---

# Summary

This RFC proposes extending the `app.import` API to consume anonymous AMD modules. It accompanies [ember-cli PR 5976](https://github.com/ember-cli/ember-cli/pull/5976).

# Motivation

AMD modules come in two flavors: named and anonymous. _Anonymous AMD_ is the more portable distribution format, but it typically requires preprocessing into _named AMD_ before it can be included into an application.

    /* Anonymous AMD Examples */

    // direct value
    define({ color: 'black' });

    // function returning value
    define(function() { return { color: 'black' }; });

    // function returning value, with declared dependencies
    define(["jquery", "moment"], function(jQuery, moment) {
      return {
        injectTime: function() {
          jQuery('#time-box').html(moment().format('HH:MM'));
        }
      }
    });

    /* Named AMD Examples */

    // direct value
    define('my-config', { color: 'black' });

    // function returning value
    define('my-config', function() { return { color: 'black' }; });

    // function returning value, with declared dependencies
    define('time-utils', ["jquery", "moment"], function(jQuery, moment) {
      return {
        injectTime: function() {
          jQuery('#time-box').html(moment().format('HH:MM'));
        }
      }
    });


Today, ember-cli users can add arbitrary third-party _named AMD_ modules into their application via:

    app.import('/path/to/module.js');

But this does not support _anonymous AMD_ modules, which is annoying because _anonymous AMD_ is the better format for library distribution and is widely used.

# Detailed design

In order to de-anonymize AMD, it's necessary to choose a name for the module for use within a given application. So I propose extending the:

    app.import('/path/to/module.js');

API with an additional argument:

    app.import('/path/to/module.js', {
      using: [
        { transformation: 'amd', as: 'some-dep' }
      ]
    });

`using` provides a list of transformations. Each transformation is identified by its `transformation` property. Any other properties are treated as arguments to the transformation implementation -- they are opaque to ember-cli. Transformations will run in the given order.

In this particular case, the `amd` transformation will run and receive the argument `{as: 'some-dep'}`.

The exactly meaning of the `amd` transformation is: within this Javascript file, any call(s) to the global `define()` function will be intercepted and the given module name (`some-dep` in the above example) will be prepended to the argument list.

[A complete implementation is available here](https://github.com/ember-cli/ember-cli/pull/5976). (As of this edit it lags behind updates to this RFC.)

# Learning

An appropriate place to document this feature is [here](https://ember-cli.com/user-guide/#standard-amd-asset). That existing documentation is silent on the distinction between named and anonymous AMD, which probably trips people up.

# Drawbacks

I am not attempting to specify static error detection, mostly because doing that well would require fully parsing and understanding the imported module, which is likely to be more expensive and fragile.

Examples of static errors that would theoretically be nice to detect would be the presence of a _named AMD_ module in the file, the lack of any AMD module in the file, or the present of multiple _anonymous AMD_ modules in the file.

The current implementation causes any sourcemap information inside the imported file to be discarded (you don't get an invalid sourcemap, but you lose detail).

I have not specified a pluggable way to add additional transformations. My intent is to reserve space in our public API so that future extraction and pluggability is fully backward compatible.

# Alternatives

Many libraries fall back to global variables if they cannot detect a valid AMD loader. I suspect this is the most common alternate pattern that's in use in the community.

Some applications include their own manually written shims in `vendor` or elsewhere.

# Unresolved questions

We should confirm that my implementation performs well in apps with very large dependency directories.


---

---
stage: recommended
start-date: 2015-10-02T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework # FIXME - added automatically as it was missing during migration
prs:
  accepted: https://github.com/emberjs/rfcs/pull/56
project-link:
---

# Refining the Release Process

Ember balances a desire for overall stability with a desire for continued improvements using a two-pronged approach:

* General adherence to Semantic Versioning, which means that we don't
  make breaking changes to public, documented APIs except when the
  major version changes.
* A rapid release cycle that allows us to ship additive changes to the
  framework on a regular, digestible basis.

Since Ember 1.0, we have refined this approach:

* All new public APIs are added using feature flags onto the master
  branch. Feature flagged features are not included in beta or release
  builds until they are "Go"ed by the core team.
* We avoid breaking heavily used but private APIs in minor versions.
* When we feel we must break a private API that is heavily used, we
  use a two-step deprecation approach: deprecate the private API in
  one release and remove it in a subsequent release, once apps and
  add-ons have had an opportunity to upgrade.
* When we plan to make breaking changes in a future major release,
  we first deprecate the changes in a previous minor release.
* We never deprecate features until there is an already-landed
  transition path to a new approach whose feature flag has already
  been "Go"ed.

And finally:

* A major release does not introduce any new breaking changes that
  were not previously deprecated. Major versions simply remove
  deprecated features that already landed.

Ember 2.0 is the first major release cycle where we have followed these refinements; this document is an attempt to outline some additional refinements that we might adopt going forward.

## Benefits of the 1.x Model

* New features are added predictably, and it's relatively easy to
  follow the list of new APIs that are under development, and where
  they are in the process.
* There is little pressure for contributors to land a feature
  prematurely, because missing a release deadline isn't
  catastrophic–there will be another train six weeks hence.
* We have a lot of very good automation tools that keep the trains
  running–commits can be (mostly) automatically backported to the
  current beta or release version.
* Upgrading Ember itself from version to version is typically a quick
  process, except when private APIs are in use. We aim for upgrades to
  be possible to slot into existing product sprints, and the nature of
  the process means that we tend to hit this goal for most users.
* Upgrading Ember across a number of versions is typically pretty
  straightforward, at least in theory.

In total, this process provides a way for us to clearly message medium-term changes in a way that helps you make the changes predictably and as mechanically as possible.

The process of getting from *here* to *there* is a series of incremental releases with deprecations, which gives you a trail of breadcrumbs to follow as things change.

## Problems with the 1.x Model

While the approach we're using has provided a lot of benefits, there are a number of areas that could still use improvement:

* While it is in theory possible to upgrade only once every few
  releases, there is no guidance about exactly how to do that, and
  little clarity about how many releases we plan to support with
  security fixes. (Because of the two-step deprecations of heavily
  used  private APIs, it is in practice important to go through each
  intermediate release to clear deprecation warnings before
  proceeding.)
* While SemVer guarantees apply to public APIs, many addons are forced
  to use private APIs as part of experiments. These experiments are a
  crucial part of the evolution of the Ember ecosystem, and the Ember
  1.x series has had a fair bit of churn in these APIs.
* While the SemVer guarantees apply to Ember proper, they do not apply
  to parts of the blessed experience that have not yet reached 1.0.
* While the SemVer guarantees promise that your code will continue
  working, they do not address changes to idiomatic Ember usage, which
  can change over time. In practice, this means that there can be
  churn in the experience of using Ember without actual breakages.
* While deprecations technically don't force you to change anything,
  in practice clearing deprecations is a part of the upgrade process.
  A constant stream of deprecations, like in the lead-up to Ember 2.0,
  can feel almost as bad as breaking changes.
* In the lead-up to Ember 2.0, a desire to remove as much cruft as
  quickly as possible led to a need to land new features with much
  more urgency than usual.

In total, these problems introduce churn in the experience of using Ember. In practice, things like moving to ES6 modules, moving to Ember CLI, and the changes in Ember Data have made the experience of "keeping up" more frenetic than we would have liked.

Because Ember releases a new version every six-weeks, it's easy to associate the overall churn with the rapid pace of releases.

## Non-Goals of the Improvements

The release process does not attempt to change the overall pace of change, but rather to make changes more predictable, easy to track, and easy to upgrade to.

The six-week cycle can incidentally affect the pace of change, because it means that large changes usually need to be broken up into pieces that can land a bit at a time. However, in practice this speeds up ecosystem-wide adoption of the entire feature, because people do not find themselves stuck behind a big-bang change that they can't schedule the time to upgrade to.

A recent survey of the Ember ecosystem, which had close to 1,000 respondents, showed that the vast majority of Ember users are using one of the past three versions of Ember.

## Proposal: LTS Releases

In theory, it's possible to upgrade every few releases, instead of every release. This has a few drawbacks:

* Because of the two-step deprecation process for heavily-used
  private APIs that we want to remove, it is in practice necessary
  to go through all intermediate releases in order to catch possible
  deprecations.
* We currently don't have any official policy about which exact
  releases we backport security patches to, other than a promise
  that we will always backport to the previous released version.
* Since different people upgrade at different rates, it's hard for
  add-ons and other parts of the Ember ecosystem that are not
  bound by the same SemVer guarantees to know which versions to
  continue to support.

**I propose that every 4 releases is considered a "Long-Term-Support (LTS) release" . With the six-week cycle, that means every 24 weeks, or roughly twice per year.**

This means:

* We will only remove heavily used private APIs if they were
  deprecated in a previous LTS release. This means that
  if a feature is deprecated in 2.3, the first LTS release that
  the deprecation will appear in is 2.4, and it can therefore be
  removed in 2.5.
* We will provide release notes for each LTS release that
  roll up the changes for the releases it includes, including new
  deprecations and new features.
* We will use the LTS releases to provide better big-picture
  messaging on the goals of any deprecations and changes to
  idiomatic Ember.
* Security fixes will always be backported to the most recent
  LTS release.
* We will encourage the Ember ecosystem to maintain support for
  the LTS releases, and lead by example with our own
  projects that have not yet reached SemVer stability. Ideally, this
  will give more of a voice to people who are upgrading less
  frequently.

This means that people who want to stay on the latest and greatest can continue to upgrade every six weeks (with the same SemVer guarantees we've come to expect), and people who want to upgrade less frequently can do so.

In practice, since these releases still abide by SemVer, upgrading from LTS release to LTS release should not be significantly more work than upgrading along the six-week release cycle.

Upgrading less frequently will mean, of course, that you would need to wait to take advantage of new features, and experience less gradual changes to idioms. It will also mean that every upgrade will come with a bigger bundle of deprecations to clear.

> It is important for us to keep an eye on the situation to see whether less frequent updates result in people getting left behind.

## Proposal: Svelte Releases and Major Releases

Another problem worth addressing is that, as Ember gradually deprecates old idioms to make way for new ones, SemVer guarantees require that we continue shipping deprecated features until the next major release.

This has two related problems:

1. Ember users who are not using deprecated features need to continue
   shipping deprecated code, which increases both code bloat and
   an opportunity to accidentally slip back into older idioms.
2. Ember itself needs to continue maintaining support for
   deprecated features in its internals, which, over time, results
   in cruft that impacts our ability to improve Ember.

However, we also need to be cognizant of the fact that changes to Ember idioms take time to be reflected in online materials, so it's important for snippets copy-and-pasted from tutorials to continue to produce deprecation notices for some time.

In general, this is the question of how to "garbage collect" cruft in the framework gradually and with minimal impact.

Leading up to the 2.0 release, we thought we would address this issue with periodic "cruft removal" major releases. Every so often, we would issue a major release with the primary purpose of clearing out accumulated cruft. Minor releases could create deprecations, but not purge their associated code.

Unfortunately, because of the fact that **Ember does not generally deprecate features without a clear transition to something else**, this meant that the 2.0 release became a critical release for adding new features as well. In the run-up to 2.0, we felt a higher degree of urgency to add new features in the programming model to replace ones we expected to want to remove early in the 2.x series.

The goal of the train release model is to eliminate big-bang releases and the attendant stress on releasing particular features by a given date, and the 2.0 release has been far too disruptive to that goal.

In the 2.x cycle, I propose a few enhancements:

1. Ember itself will more clearly mark deprecated features in a
   similar way that it marks new features, including with the
   release it was deprecated in.
2. Ember CLI will support "svelte builds", which strip out
   deprecated features.
3. In development mode, Ember CLI will convert deprecated features
   into errors, to ensure that people running svelte builds can still
   get clear messages when using code that was designed for earlier
   builds, including addons.
4. We will still use major releases to remove built up cruft,
   especially deeply intertwined cruft, but the svelte releases
   should take the pressure off of the major release timeline.

**The 1.x release cycle helped us establish an orderly process for adding features; this proposal establishes a more orderly process for removing them.**

## Proposal: Plugin APIs

Since the release of Ember 1.0, we have worked on refining the public APIs while maintaining stability. However, those public APIs do not cover all possible use-cases, and add-ons have cropped up to fill the gaps.

Unfortunately, this has placed a heavy compatibility burden on add-on authors who want to maintain stability in their public APIs even as versions of Ember have changed the private APIs they rely on.

In practice, the costs of the six-week release cycle weigh most heavily on add-on authors, who are often forced into using private APIs, but still want to keep their add-ons working with every release.

The canary and beta cycles help to ensure that popular add-ons work by the time the release version comes out, but only because add-on authors keep a close eye on the beta releases and absorb the churn on behalf of their users.

**I propose that as of Ember 2.0, any use of a private API in a plugin is considered a bug in Ember to be fixed.**

That doesn't mean that add-on authors should never use private APIs: to the contrary, use of private APIs when no other choice is available helps us discover what APIs are missing.

But a major goal of the 2.x series of Ember should be to identify ways to extend the stability promises that Ember offers to application authors to add-on authors.


---

---
stage: released # FIXME: This may be Recommended
start-date: 2015-05-20T00:00:00.000Z
release-date: 2016-02-29T00:00:00.000Z
release-versions:
  ember-data: v2.4.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/57
project-link:
meta:
  ember-issue: https://github.com/emberjs/data/pull/3303
---

# Summary

This RFC adds a unified way to perform meta-operations on records, has-many relationships and belongs-to relationships:

* get the current local data synchronously without triggering a fetch or producing a promise
* notify the store that a fetch for a given record has begun, and provide a promise for its result
* similarly, notify a record that a fetch for a given relationship has begun, and provide a promise for its result
* retrieve server-provided metadata about a record or relationship

# Motivation

When we initially designed the Ember Data API for relationships, we focused on consumption and mutation of the relationship data. For example, you can retrieve the value of a `belongsTo` relationship via `get('post')`, or adding new records to a has-many relationship via `get('comments').pushObject(newComment)`.

The top-level reading operations are designed to be [zalgo][zalgo]-proof: regardless of whether or not the record or relationship has been loaded already, you get back a promise for the result. Behind the scenes, this will trigger a fetch if needed, or simply return the current value if it has already been fetched. From a programming model perspective, this simplifies your code because you can handle locally-available data and remotely-available data in a single code path.

[zalgo]: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony

However, in sophisticated applications, there is often a need to refer to a record without triggering side effects.

For example, you may want to initiate the fetch for a record or relationship yourself, and provide Ember Data with a promise representing the result of that fetch. That use-case is supported by the `store.push` API, but it has a few problems:

* The `store.push` API supports pushing data once the fetch has completed, but no way of telling
  Ember Data that a fetch has begun. As a result, any calls to `store.find` in the interim will
  trigger unnecessary fetches.
* The `store.push` API works only for top-level records with already-known types and IDs. It does
  not support any way of "feeding" the data for a relationship to Ember Data.

In sum, this makes it difficult to front-load work (especially asynchronous work). Instead, Ember Data is currently optimized for reacting to requests from the application layer, which is sometimes a very awkward way of structuring your code.

Second, Ember Data was originally designed with APIs that refer to data and operations on data. Over time, we have come to realize that people quite often need to look at metadata about records or relationships, as well as perform meta-operations on them.

Some examples:

* getting the expected count of a has-many relationship before it has been fetched
* learning whether a relationship is already loaded or not
* examining server-sent metadata
* working with pages of records in a has-many relationship, especially when pages are loaded asynchronously ("pagination")

Third, because has-many relationships are represented as a `RecordArray`, we have been able to kludge around some of these issues by adding meta-operations to the has-many relationship itself. In contrast, belongs-to relationships have remained anemic. For example, there is no way to trigger a reload of a belongs-to relationship, whereas has-many relationships can be reloaded by calling `.reload()` on the `RecordArray`.

# Detailed design

This RFC proposes the addition of three new **public** APIs:

* `RecordReference`
* `HasManyReference`
* `BelongsToReference`

## Getting References

* `store.getReference(type, id)`
* `record.getReference(name)`

## References

### `push`

```js
/**
  This API allows you to provide a reference with new data. The simplest usage
  of this API is similar to `store.push`: you provide a normalized hash of data
  and the object represented by the reference will update.

  If you pass a promise to `push`, Ember Data will not ask the adapter for the
  data if another attempt to fetch it is made in the interim. When the promise
  resolves, the underlying object is updated with the new data, and the promise
  returned by *this function* is resolved with that object.

  For example, `recordReference.push(promise)` will be resolved with a record.

  @method
  @param {Promise|Object}
  @returns Promise<T> a promise for the value (record or relationship)
*/
```

### `pushPayload`

```js
/**
  This API is similar to `push`, but it invokes the serializer with the
  resolved data. This makes it possible to share normalization logic
  across multiple calls to `pushPayload` or between proactive pushes
  and reactive responses from the adapter.

  @method
  @param {Promise|Object}
  @returns Promise<T> a promise for the value (record or relationship)
*/
```

### `state`

```js
/**
  The current state of the entity, based on the semantics of the
  entity in question. For records, this should expose a subset of
  the named states in the internal state machine.

  @property
  @type String
*/
```

### `value`

```js
/**
  If the entity referred to by the reference is already loaded, it
  is present as `reference.value`. Otherwise, the value of this
  property is `null`.

  @property
*/
```

### `data`

```js
/**
  The value of the (normalized) representation of this entity. For
  example, `recordReference.data` will return a normalized dictionary
  of attributes and links.

  @property
*/
```

### `metadata`

```js
/**
  The most recent value of the metadata returned by the server for
  the value represented by this reference.

  @property
*/
```

### `load`

```js
/**
  Triggers a fetch for the backing entity based on its `remoteType`
  (see `remoteType` definitions per reference type).

  @method
  @param {Object} an options hash, similar to the one currently
    passed to `store.find`.
*/
```

### `unload`

```js
/**
  Unload the entity referred to by this relationship. After this
  operation, its `value`, `data` and `metadata` members will return
  to `null`, and the record itself will be purged from the identity
  map.

  @method
*/
```

## RecordReference

### `remoteType`

```js
/**
  How the reference will be looked up with it is loaded:

  * `link`, a URL
  * `identity`, by the `type` and `id`
*/
```

### `type`

```js
/**
  The type of the record that this reference refers to.

  @property
*/
```

### `id`

```js
/**
  The `id` of the record that this reference refers to.

  Together, the `type` and `id` properties form a composite key
  for the identity map.

  @property
*/
```

## HasManyReference

### `remoteType`

```js
/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `ids`, a list of IDs provided by the server
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
```

### `link`

```js
/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
```

### `ids`

```js
/**
  If the `remoteType` is `ids`, a list of IDs that is used to formulate
  the query to the server (together with `type`).

  @property
*/
```

### `type`

```
/**
  The model type represented by this relationship.

  @property
*/
```

### `parent`

```js
/**
  A reference to the record that has this `hasMany` on it.

  @property
*/
```

### `inverse`

```js
/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
```

## BelongsToReference

### `remoteType`

```js
/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `id`, an ID to use to form the URL
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
```

### `link`

```js
/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
```

### `ids`

```js
/**
  If the `remoteType` is `id`, an ID that is used to formulate
  the query to the server (together with `type`).

  @property
*/
```

### `type`

```
/**
  The model type represented by this relationship.

  @property
*/
```

### `parent`

```js
/**
  A reference to the record that has this `belongsTo` on it.

  @property
*/
```

### `inverse`

```js
/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
```


# Drawbacks

The main drawback to this proposal is that it adds significant surface area to Ember Data, which could easily be perceived as significant additional complexity. However, we believe that the unification of the various entities in Ember Data, as well as exposing internal tools that were previously only available to the store, will actually reduce the complexity of many common patterns.

# Alternatives

The main alternative is to address each use case with a new API:

* `store.peek(record, id)`, `record.peek(relationship)` to retrieve the current value of the relationship only if it was loaded
* extend `store.push` and `store.pushPayload` to take promises
* APIs like `record.inverseFor(relationship)`, `record.typeFor(relationship)`, etc.
* APIs like `record.idsFor(relationship)`, `record.metadataFor(relationship)`, and `store.metadataFor(type, id)`

We believe that the cumulative overhead of all of these APIs is far more than the overhead of the reference APIs.

# Unresolved questions

Is there a need to represent "prefetch metadata" separately? This is metadata that the app knows about before fetch, and which it would want to persist through an `unload()` operation (along with identity information like type, id and link).


---

---
stage: discontinued
start-date: 2015-05-24T00:00:00.000Z
release-date: 2016-06-12T00:00:00.000Z
release-versions:
  ember-source: v1.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/58
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/11393
---

# Summary

This RFC outlines a new strategy for the registration of helpers in Ember 1.13.
In previous versions of Ember, helper lookup was a two-phase process of:

* Look in a whitelist of registered helpers. If in the whitelist, resolve that
  path in the container.
* If the path has a dash, try to resolve it in the container
* If the container does not have a factory for this path, treat the path as a
  bound value.

This logic runs for every `{{somePath}}` in an Ember application.

This proposal attempts to simplify and unify that logic in a a single pass
against a whitelist, thus removing the special behavior of dashed paths.
Additionally, it attempts to design a solution that removes the current
`registerHelper` ceremony for undashed helpers.

# Motivation

In [RFC #53](https://github.com/emberjs/rfcs/pull/53) a new API for helpers is
outlined. This RFC presumes helpers will continue to have the naming
requirement of including a dash character.

The dash requirement for helpers exists for two reasons:

* For every `{{path}}` in an Ember application, it must be decided if that path
  is a bound value, component, or helper. Component and helper lookup (the
  discovery of a class or template) is lazy in Ember, thus for every `{{path}}`
  a lookup for that string in the container is required. Container lookups
  (the first time) are fairly slow, and performing this lookup for every
  path may significantly impact initial render time. Thus, helpers are either
  added to a whitelist (with `registerHelper`) or require a way to differentiate
  themselves from the majority of data-binding cases (the dash).
* In Ember 1.x, components were treated as helpers for certain code paths. This
  made the dash requirement for components a natural extension to helpers.

The Glimmer engine has removed some of these concerns and limitations.

Addon authors and app authors have both felt a need for non-dashed helper
names, for example `{{t 'some-string-to-translate'}}`. New developers to Ember
often find the dash requirement arbitrary and the `registerHelper` work around
difficult to understand and use.

For the new helper API to provide feature parity with APIs available to addon
authors in 1.12, a path to dashless helpers must be present in 1.13.

Given that a solution exists that addresses the performance concern, dropping
the dash requirement would resolve a significant amount of developer pain and
confusion.

# Detailed design

At application boot, all known helper items (according to the resolver) are
iterated and added to a `helper-listing` service. This service is merely a
Set object with the names of all helpers.

When handling a `{{path}}`, the `helper-listing` service is consulted for the
presence of that `path`. If it is present, the path is looked up
on the container as a helper and the helper is used. Dashed paths are treated
no differently than any other path (for helpers).

### Boot time discovery

To discover what paths may be helpers in Ember-CLI, the module names are
iterated. For example:

```
not helper: app/components/foo-bar/component
not helper: app/controllers/foo-bar
not helper: app/foo-bar/route
helper "t": app/t/helper
helper "t": app/helpers/t
helper "foo-bar": app/helpers/foo-bar
helper "foo/bar": app/helpers/foo/bar
```

In a globals-mode application, The app namespace is iterated:

```
not helper: App.FooBarComponent
not helper: App.FooBarController
not helper: App.FooBarRoute
helper "t": App.THelper
helper "foo-bar": App.FooBarHelper <- should dasherize
```

In both cases **the resolver is responsible for providing a list of modules
by type**. The proposed API is `eachOfType`, here with Ember-CLI as an example:

```js
// Given helperListing as a Set:
resolver.eachOfType(‘helper’, function(parsedName, item) {
  helperListing.add(parsedName.fullName);
})
```

In Ember-CLI, the `app/` tree of an addon is merged with the app tree of an
application. This means for a helper like `t` to be discovered, nothing besides
adding it to `app/helpers/t.js` must be done.

In 1.13, this will impact existing apps by discovering all helpers regardless
of if `registerHelper` has been called. This is a small behavior change that
should match intent, and will not impact sanely written apps.

Note that only the path of the helper is added to the listing. During discovery,
the helper is not looked up from the container, instead lookup still occurs
at render time.

The helper listing is intended to be a private service in Ember, and will be
registered at `services:-helper-listing`. If the discovery semantics described
here are not sufficient for some edge-cases, wrapping this service in a
public API on application instances may be required.

### Render-time lookup and use

Let us consider how a path is rendered. For example:

```hbs
{{date}}
```

* The `service:-helper-listing` service is fetched
* The path `date` is checked for on the listing: `helperListing.has(path)`
* If the path is not in the listing, `date` is treated like a bound value
* If the path is in the listing, the helper is looked up from Ember's
  container as `helper:date`
* depending on the instance returned from the factory (a helper, shorthand
  helper, or legacy `Ember.Handlebars` or `Ember.HTMLBars._registerHelper`
  helper) the proper invocation for that helper is executed

Every rendered path will hit the `helper-listing` service, but the check
against a well-implemented Set should be inexpensive.

# Drawbacks

Removing the dash requirement will likely result in a larger number of naming
conflicts between addons and apps than has existed before now. In general,
encouraging verbose helper names may mitigate this concern. Long term, there
have been several discussions to date about how to implement namespaces in
Ember templates and for Ember engines.

That the helper listing is eagerly discovered at application boot time may
impact the design of Ember engines and lazy-loading parts of an app. The
discovery cache may need to be flushed and re-generated, however this limitation
already exists for the container lookup itself (which caches failures).

That the helper listing is not based on the container means helpers registered,
but not added to the listing because of non-standard naming, may need to
manually register against the private helper listing API.

# Alternatives

Instead of a new across-the-board solution, Ember could continue to use a
`registerHelper` pattern very similar to what exists today. This would
perpetuate the existing pain, but would perhaps be more similar to what devs
already know.

# Unresolved questions

The exact timing of helper discovery in Ember-CLI and globals mode has not been
decided.


---

---
stage: recommended
start-date: 2015-06-03T00:00:00.000Z
release-date: 2015-06-16T00:00:00.000Z
release-versions:
  ember-data: v1.13.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/61
project-link:
meta:
  ember-issue: This RFC is implemented over many Ember Data PRs
---

# Summary

This RFC proposes new methods on the adapter to signal to the Ember Data store when it should re-request a record that is already cached in the store. It also proposes a new adapter options object that can be used by to provide instructions to the adapter from the place where the store's find method is called.

# Motivation

## Use Cases

When it comes to fetching records, there are several different behaviors
that users may expect. The behavior that users expect is influenced by
unique quirks in their data model, pre-existing expectations based on
traditional development models, and implementation details of their
adapter.

Fundamentally, users may expect or want one of the following sets of
behavior when fetching a model for the `model()` hook:

* Fetching data from the server the first time a record is requested,
  but using only cached data subsequent times the route is entered.
  (This is the current behavior of `find()`.)
* Fetching new data every time the route is entered. The route will
  "block" (show a loading spinner) until fresh data is received.
* Using local data if available, but otherwise not triggering any
  fetches if the data is not available. This is useful if records will
  be pushed into the store ahead of time, e.g. by a socket, and
  non-existence in the store means non-existence on the server.
* Immediately returning a model with local data if available, rendering
  the route's template immediately, and updating the record in the
  background. If the record changes after conferring with the server,
  the template is re-rendered.

## Discussion

### Fetch Only On Initial Render

In this model, the record data is fetched from the server the first time
a record with a given ID is requested. Subsequent requests (e.g. leaving
and re-entering the same route) use locally cached data. This is the
strategy used by the current `find()` method.

The advantage of this model is that it keeps conferring with the server
to a minimum. Once data is loaded, the client can render new routes with
the model data that it has cached, without a network roundtrip.

Additionally, in some data models, records are immutable. For example, on
Twitter, tweets never change. In an email app, emails cannot change once
they are sent. Asking the server for the most up-to-date version of an
immutable record is a waste of resources.

The downsides of this model are two-fold.

First, this model is surprising to new developers. When navigating
between pages, they expect the most up-to-date representation to be
fetched and displayed every time.

Second, even for developers who understand what is happening, it is very
easy for long-lived applications to accumulate stale information,
particularly if the model they are displaying updates frequently.
Developers must somehow disambiguate between the first time a model is
looked up, and allowing it to proceed, and detecting when a cached model
is being used and updating it manually.

### New Fetch Every Render

The advantages of this model are that it most closely matches the mental
model for developers coming from server-rendered and jQuery backgrounds.
In that model, every time a new page is loaded, the most up-to-date
information is guaranteed to be displayed. Because each page navigation
triggers a fetch from the database, the only way for information to
become stale is for the user to stop navigating.

The downside of this model is that it eliminates many of the advantages
of client-side routing. In traditional client apps, data is stored
locally, and navigations use that local data. In this model, every page
transition is blocked awaiting a network response from the server. It's
a slight improvement in that the data should be much smaller than a full
HTML page, but it is often latency and not bandwidth that causes
slowdowns.

### Never Fetch

While an edge case, many Ember Data users have requested the ability to
fetch a record out of the store only if it exists locally.

One use case is for stores that are optimistically populated via pushed
data from a socket. In that case, if the record doesn't exist in the
store, it means that it doesn't exist on the server.

For obvious reasons, this is an uncommon case for the majority of apps.
While we should support it, it should not be part of the happy path for
new developers.

### Immediate Render, Background Refresh

In this model, the first time a record is requested, it blocks the
render and shows a loading spinner. On subsequent requests, the locally
cached data is displayed and the render happens immediately without
making the user wait.

However, in the background, the store also kicks off a request to the
adapter to update the record. When the new data comes in, the record is
updated, and if there have been changes to the record since the initial
render, the template is re-rendered with the new information.

This is the model that I believe strikes the best tradeoff among the
options available.

First, it preserves the speed of client-side navigation. Once data for a
record is cached, transitioning to any route that relies on it is nearly
instantaneous and has no network bottleneck.

Second, because it triggers a background update, even users who expect a
new fetch every time will not be surprised as, ideally after a few
milliseconds, the new data will arrive and be persisted into the DOM.

Third, in most applications, models are not changing frequently.  Most
of the time, the cached version in the Ember Data store will be
identical to the latest server revision. In those cases, there is no
point in making users stare at a loading spinner

Of course, there are several downsides to this model that we should keep
in mind. For immutable records, fetching a new version in the background
is wasteful of bandwidth and server capacity and we should allow
developers to opt out of this behavior.

A second related case is apps using a socket to subscribe to record
changes once a record is fetched. In those cases, fetching up-to-date
information on subsequent requests for the model is wasteful because
they have guaranteed that they will keep the model up-to-date via change
events from the server. In this case, we need a way for adapter authors
to signal that subsequent update requests for a record are a no-op.

Third, it may be an unpleasant user experience for new information to
pop in suddenly after the initial render, particularly for records that
frequently change in dramatic ways. In those instances, we should make
sure we give developers the tools to build UIs that can indicate to the
user that the information is being updated, perhaps by greying it out or
displaying a loading spinner.

# Detailed design

## Proposal

### New Adapter Methods.

`shouldRefetchRecord` is a new method on the adapter that will be called by the store to make initial decision whether to refetch the record form the adapter or return the cached record from the store. This could method could be used to implement caching logic (e.g. only refetch this record after the time specified in its cache expires token) or for improved offline support (e.g. always refetch unless there is no internet connection then use cached record).

This record would only be called if the record was already found in the store and is in the loaded state.

This method is only checked by `store.findById` and `store.findAll`. Methods with `fetch` in their name always refetch the record(s) from the adapter.

```js
{
  /**
   `shouldRefetchRecord` returns true if the adapter determines the record is
   stale and should be refetch. It should return false if the record
   is not stale or some other condition indicates that a fetch should
   not happen at this time (e.g. loss of internet connection).

   This method is synchronous.

   @method shouldRefetchRecord
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
   */
  shouldRefetchRecord: function(store, record, adapterOptions),
}
```

The method `shouldBackgroundUpdate` would be used by the store to make the decision to re-fetch the record after it has already been returned to the user. This would allow realtime adapter to opt out of the background fetch if the adapter is already subscribing to changes on the record.

```js
{
  /**
   `shouldBackgroundUpdate` returns true if the store should re fetch a
   record in the store after returning it to the user to ensure the
   record has the most up to date data.

   This method is synchronous.

   @method shouldBackgroundUpdate
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
  */
  shouldBackgroundUpdate: function(store, record, adapterOptions),
}
```


In the next major version of Ember Data the recommend way of finding a record
will be:

```js
this.store.findById('person', 1);
```

This will return a promise that:

1. Waits to resolve until the data is fetched from the server, on the
   initial request.
2. Resolves immediately with the locally cached request for subsequent
   requests, but triggers a request to the server for the updated
   version and updates the record in-place if there are changes.


In terms of the above methods `shouldRefetchRecord` will always return `false` and `shouldBackgroundUpdate` will always return `true` in the default `RESTAdapter`.

The fundamental guarantee of `findById()/findAll()` when using the default `RESTAdapter` is:

> Give me the information you have available locally, then give me the
> most up-to-date information as soon as possible.

Currently, the `find()` method takes an optional third parameters that
is passed to the adapter. In this API, that data structure is moved to
a field in the new options hash:

```js
this.store.findById('person', 1, {
  preload: { comment_id: 1 }
});
```

### `isUpdating` Flag

To assist developers in building UIs that communicate the state of
models to their users, we should provide a helper that allows developers
to show UI elements when a model is in the process of being updated via
`fetch()`.

I propose adding an `isUpdating` flag to models, which can be used to
conditionally show a spinner:

```handlebars
<h1>{{post.title}}</h1>
{{#if isUpdating post}}
  <small>Updating...</small>
{{/if}}

<p>{{post.body}}</p>
```

(Currently, only `RecordArray`s have an `isUpdating` flag.)

Models have an `isReloading` flag. This will be deprecated in favor of the new `isUpdating` flag.



# Drawbacks

Why should we *not* do this?

After the record has been updated in the background Ember's Data binding will cause any views to automatically update with the latest changes. This can result an a surprising "popping" effect which is especially pronounced when the background fetch resolves quickly (The user sees an initial render with the stale data then a quick re-render with the fresh data).




# Alternatives

What other designs have been considered? What is the impact of not doing this?

One alternate option could be for Ember Data to track an expires token on a model. This would allow Ember
Data to behave like a caching proxy when fetching. If the record is expired, fetch should block.
If the record is not expired it would return a resolve the record right away however still issue a
second request.

When used with backends that do not return an expires token. Ember Data would assume that the
record is stale (this could be configured on the adapter).


# Unresolved questions






---

---
stage: recommended
start-date: 2015-06-12T00:00:00.000Z
release-date: 2015-03-28T00:00:00.000Z
release-versions:
  ember-source: v1.11.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/64
project-link:
---

# Summary

The goal of this RFC is to allow for better component composition and the
usage of components for domain specific languages.

Ember components can be invoked three ways:

* `{{a-component`
* `{{component someBoundComponentName`
* `<a-component` (coming soon!)

In all these cases, attrs passed to the component must be set at the place of
invocation. Only the `{{component someBoundComponentName` syntax allows for the name
of the component invoked to be decided elsewhere.

All component names are resolved to components through one global resolution
path.

To improve composition, four changes are proposed:

* The `(component` helper will be introduced to close over component attrs in
  a yielding context.
* The `{{component` helper will accept an argument of the object created by
  `(component` for invocation (as it invokes strings today).
* Property lookups with a value containing a dot will be considered for
  rendering as components. `{{form.input}}` would be considered, for instance.
  Helper invocations with a dot will also be treated like a component if the
  key has a value of a component, for instance `{{form.input value=baz}}`.
* A `(hash` helper will be introduced.

# Motivation

When building a complex UI from several components, it can be difficult to
share data without breaking encapsulation. For example this template:

```hbs
{{#great-toolbar role=user.role}}
  {{great-button role=user.role}}
{{/great-toolbar}}
```

Causes the user to pass the `role` data twice for what are obviously related
components. A component can yield itself down:

```hbs
{{! app/components/great-toolbar/template.hbs }}
{{yield this}}
```

```hbs
{{#great-toolbar role=user.role as |toolbar|}}
  {{great-button toolbar=toolbar}}
{{/great-toolbar}}
```

And `great-button` can have knowledge about properties on `great-toolbar`, but
this break the isolation of components. Additionally the calling syntax is not
much better, `toolbar` must still be passed to each downstream component.

Often `nearestOfType` is used as a workaround for these limitations. This API
is poorly performing, and still results in the downstream child accessing the
parent component properties directly.

Consequently there is a demand by several addons for improvement. Our goal
is a syntax similar to DSLs in Ruby:

```hbs
{{#great-toolbar role=user.role as |toolbar|}}
  {{toolbar.button}}
  {{toolbar.button orWith=additionalProperties}}
{{/great-toolbar}}
```

As laid out in this proposal, the `great-toolbar` implementation would look
like:

```hbs
{{! app/components/great-toolbar/template.hbs }}
{{yield (hash
  button=(component 'great-button' role=user.role)
)}}
```

# Detailed design

### The `(component` helper and `{{component` helper

Much like `(action` creates a closure, it is proposed that the `(component`
helper create something similar. For example with actions:

```hbs
{{#with (action "save" model) as |save|}}
  <button {{action save}}>Save</button>
{{/with}}
```

The returned value of the `(action` nested helper (a function) closes over the
action being called (`actions.save` on the context and the `model` property).
The `{{action` helper can accept this resulting value and invoke the action
when the user clicks.

The `(component` helper will close over a component name. The
`{{component` helper will be modified to accept this resulting value and invoke
the component:

```hbs
{{#with (component "user-profile") as |uiPane|}}
  {{component uiPane}}
{{/with}}
```

Additionally, a bound value may be passed to the `(component` helper. For
example `(component someComponentName)`.

Attrs for the final component can also be closed over. Used with yield, this
allows for the creation of components that have attrs from other scopes. For
example:

```hbs
{{! app/components/user-profile.hbs }}
{{yield (component "user-profile" user=user.name age=user.age)}}
```

```hbs
{{#user-profile user=model as |profile|}}
  {{component profile}}
{{/user-profile}}
```

Of course attrs can also be passed at invocation. They smash any conflicting
attrs that were closed over. For example `{{component profile age=lyingUser.age}}`

Passing the resulting value from `(component` into JavaScript is permitted,
however that object has no public properties or methods. Its only use would
be to set it on state and reference it in template somewhere.

### Hash helper

Unlike values, components are likely to have specific names that are semantically
relevent. When yielded to a new scope, allowing the user to change the name
of the component's variable would quickly lead to confusing addon documentation.
For example:

```hbs
{{#with (component "user-profile") as |dropDatabaseUI|}}
  {{component dropDatabaseUI}}
{{/with}}
```

The simplest way to enforce specific names is to make building hashes
of components (or anything) easy. For example:

```hbs
{{#with (hash profile=(component "user-profile")) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
```

The `(hash` helper is a generic builder of objects, given hash arguments. It
would also be useful in the same manner for actions:

```hbs
{{#with (hash save=(action "save" model)) as |userActions|}}
  <button {{action userActions.save}}>Save</button>
{{/with}}
```

### Component helper shorthand

To complete building a viable DSL, `.` invocation for `{{` components will be
introduced. For example this `{{component` invocation:

```hbs
{{#with (hash profile=(component "user-profile")) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
```

Could be converted to drop the explicit `component` helper call.

```hbs
{{#with (hash profile=(component "user-profile")) as |userComponents|}}
  {{userComponents.profile}}
{{/with}}
```

A component can be invoked like this only when it was created by the
`(component` nested helper form. For example unlike with the `{{component`
helper, a string is not acceptable.

To be a valid invocation, one of two criteria must be met:

* The component can be called as a path. For example `{{form.input}}` or `{{this.input}}`
* The component can be called as a helper. For example `{{form.input value=baz}}` or `{{this.input value=baz}}`

And of course a `.` must be present in the path.

# Drawbacks

This proposal encourages aggressive use of the `(` nested helper syntax.
Encouraging this has been slightly controversial.

No solution for angle components is presented here. The syntax for `.`
notation in angle components is coupled to a decision on the syntax for
bound, dynamic angle component invocation (a `{{component` helper for angle
components basically).

`(component 'some-component'` may be too verbose. It may make sense to simply
allow `(some-component`.

Other proposals have leaned more heavy on extending factories in JavaScript
then passing an object created in that space. Some arguments against this:

* Getting the container correct is tricky. Who sets it when?
* Properties on the classes would not be naturally bound, as they are in this proposal.
* As soon as you start setting properties, you likely want a `mut` helper,
  `action` helper, etc, in JavaScript space.
* Keeping the component lookup in the template layer allows us to take advantage
  of changes to lookup semantics later, such as local lookup in the pods
  proposal.

# Alternatives

All pain, no gain. Addons really want this.

# Unresolved questions

There has been discussion of if a similar mechanism should be available for
helpers.


---

---
stage: recommended
start-date: 2015-06-30T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/65
project-link:
---

# Summary

Deprecations and warnings in Ember.js should have configurable runtime handlers.
This allows default behavior (logging, raise when `RAISE_ON_DEPRECATION` is true)
to be overridden by an enviornment (Ember's tests), addon, or other tool
(like the Ember Inspector).

Ember-Data and the Ember Inspector have both requested a public
API for changing how deprecation and warning messages are handled. The requirements
for these and other requests are complex enough that deferring the message
behavior into a runtime hook is the suggested path.

# Motivation

`Ember.deprecate` and `Ember.warn` usually log messages. With `ENV.RAISE_ON_DEPRECATION`
all deprecations will throw an exception. In some scenarios, this
is less than ideal:

* Ember itself needs a way to silence some deprecations before their usage
  is completely removed from tests. For example, many view APIs in Ember 1.13.
* The Ember inspector desires to raise on specific deprecations, or silence
  specific deprecations.
* Ember-Data also desires to silence some deprecations in tests

In [PR #1141](https://github.com/emberjs/ember.js/pull/11419)
a private log level API has been introduced, which allows finer grained control
if specific deprecations should be logged, throwing an error or be silenced
completely. For example:

```js
Ember.Debug._addDeprecationLevel('my-feature', Ember.Debug._deprecationLevels.LOG);
// ...
Ember.deprecate("x is deprecated, use Y instead", false, { id: 'my-feature' });
```

Initially a public version of this API was discussed, but it quickly became
clear that a runtime hook provided more flexibility without incurring the
cost of a complex log-level API.

Note that "runtime" refers to Ember itself. A custom handler could be injected
into Ember-CLI's template compilation code. "runtime" in this context still
refers to handling deprecations raised during compilation.

# Detailed design

A handler for deprecations can be registered. This handler will be called
with relevent information about a deprecation, including guarantees about
the presence of these items:

* The deprecation message
* The version number where this deprecation (and feature) will be removed
* The "id" of this deprecation, a stable identifier independent of the message

Additionally, an application instance may be passed with the options. An example
handler would look like:

```js
import { registerHandler } from "ember-debug/deprecations";

registerHandler(function deprecationHandler(message, options) {
  // * message is the deprecation message
  // * options.until is the version this deprecation will be removed at
  // * options.id is the canonical id for this deprecation
  if (options.until === "2.4.0") {
    throw new Error(message);
  } else {
    console.log(message);
  }
});
```

Warnings are similar, but will not recieve an `until` value:

```js
import { registerHandler } from "ember-debug/warnings";

registerHandler(function warningHandler(message, options) {
  // * message is the warning message
  // * options.id is the canonical id for this warning
  if (options.id !== 'view.rerender-on-set') {
    console.log(message);
  }
});
```

##### chained handlers

Since several handlers may be registered, a method of deferring to a previously
registered handler must be allowed. A third option is passed to handlers, the
function `next` which represents the previously registered handler.

For example:

```js
import { registerHandler } from "ember-debug/deprecations";

registerHandler(function firstDeprecationHandler(message, options, next) {
  console.warn(message);
});

registerHandler(function secondDeprecationHandler(message, options, next) {
  if (options.until === "2.4.0") {
    throw new Error(message);
  }
  next(...arguments);
});
```

The first registed handler will receive Ember's default behavior as `next`.

##### new assertions for deprecate and warn

Ember's APIs for deprecation and warning do not currently require any information
beyond a message. It is proposed that deprecations be **required** to pass
the following information:

* Message
* Test
* Canonical id (with a format of `package-name.some-id`)
* Release when this deprecation will be stripped

For example:

```
import Ember from "ember";

Ember.deprecate("Some message", false, {
  id: 'ember-routing.query-params',
  until: '3.0.0'
});
```

If this information is not present and assertion will be made.

Warnings likewise will be required to pass a canonical id:

```
import Ember from "ember";

Ember.warn("Some warning", {id: 'ember-debug.something'});
```

##### default handlers

The default handler for deprecation should be quite simple, and mirrors current
behavior:

```js
function defaultDeprecationHandler(message, options) {
  if (Ember.ENV.RAISE_ON_DEPRECATION) {
   throw new Error(format(message, options));
  } else {
   console.log(format(message, options));
  }
}
```

The default handler for warnings would be simple `console.log`.

# Drawbacks

By not providing a robust log-level API, we are punting complexity to the
consumer of this API. For a low-level tooling API such as this one, it seems
and appropriate tradeoff.

# Alternatives

Each app can stub out `deprecate` and `warn`.

# Unresolved questions

`RAISE_ON_DEPRECATION` could be considered deprecated with this new API.


---

---
stage: recommended
start-date: 2016-11-21T00:00:00.000Z
release-date: 2017-03-16T00:00:00.000Z
release-versions:
  ember-cli: v2.12.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/80
project-link:
---

# Summary

This RFC attempts to expose a public API in `ember-cli` to allow other platforms/infrastructure to serve the base page (index.html) and other assets from the `tmp` directory in their own custom way. This is only for development as this will only be used with `ember serve`. Currently `ember serve` serves files from the tmp directory (which is built as part of the build process) using the `broccoli-middleware`. This middleware in addition to serving the files also sets the correct headers for the assets it is serving. This RFC aims to split the work of setting the header and serving the files into two different addons such that any other infrastructure can easily create a middleware to serve assets using its own logic.

# Motivation

FastBoot and other infrastructure (for example the infrastructure at LinkedIn to serve the base page) does not require the index.html to be served from the disk directly. FastBoot requires to serve the index.html after it has appended the serialized template for the current request. It therefore requires to do some runtime replacements in the index.html before it can be served to the client. At LinkedIn, we stream the index.html in chunks for performance reasons and require to do some string replacements in index.html on per request basis.

During development, this requires us to create our own  express middleware via `serverMiddleware` which should run before the `serve-files` middleware. It also requires us to almost copy paste the headers that are set by `broccoli-middleware`. In addition to the above, the ability to be able to serve from `tmp` directory allows FastBoot and other infrastructure to correctly serve the assets from the directory pointing to the current build. Currently (with using their own middleware) FastBoot serves assets from the `dist` directory which is not the correct behavior.

In order to mitigate the need to diverge into another middleware which behaves almost same as `broccoli-middleware`, this RFC proposes to split the work of setting the headers and serving the files via `broccoli-middleware` and expose a public API that will allow an addon to define how it wants to serve the assets. It will be a low level public API that will be invoked by certain addons.

# Detailed design

Currently the [`serve-files`](https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18) addon defines how it will serve the incoming asset requests. It invokes the `broccoli-middleware` which is responsible for three sets of things:

1. Setting the response headers

2. serving the files and ending the response

3. Shows an error template if it is a build error

## Public API
This RFC proposes expose two new in-repo addons in `ember-cli` which will now split the above work and remove the `serve-files` addon:

1. `ember-cli:broccoli:watcher`: This addon will contain the middleware which will be responsible for making sure the build is done and will set the response headers that `broccoli-middleware` is doing today. After setting the response headers, it will call the next middleware in the chain. In addition, if the build results in an error, it will show the error template and not terminate the response.

2. `ember-cli:broccoli:serve-files`: This addon will always run *after* `ember-cli:broccoli:watcher` addon. It will contain a middleware that will be responsible for serving the files from the filesystem and ending the response.

For any infrastructure that needs to serve the assets in its own way will be create an addon that will be injected between the above two addons. It will use the `serverMiddleware` public hook to provide its own middleware. Specifically the custom addon should run *before* `ember-cli:broccoli:serve-files` so that it can either override any response headers or can serve the files using its own logic and end the response. This will ensure that when the build is successful `ember-cli:broccoli:watcher` can call the correct next middleware in the chain.

## Implementation Details
In order for the above API to be exposed, we need to drop the `serve-files` addon in `ember-cli`, refactor `broccoli-middleware` and create the two new addons.

### Refactor `broccoli-middleware` to expose additional middlewares
*Note*: This refactor section is only for making the reader understand how the integration is meant to work in `ember-cli`. This is not going to be `ember-cli` public API.

`broccoli-middleware` is currently responsible for setting the response headers and serving the files. It is a middleware that does these two tasks. It doesn't expose a proper middleware API to do the two tasks differently. We would like to refactor `broccoli-middleware` such that it exposes two additional middlewares:
- `forWatcher(watcher)`:
```javascript
  /**
   * Function responsible for setting the response headers or creating the build error template
   *
   * @param {Object} watcher ember-cli watcher
   * @return {Function} middleware function
   */
   forWatcher: function(watcher) {
     var outputPath = watcher.builder.outputPath;
     ...
     return function middleware(request, response, next) {
       watcher.then(function() {
         // mostly all of this https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L96
         request.headers['x-broccoli'] = {
           outputPath: outputPath
         };
         next();
       }, function(buildError) {
         // mostly this: https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L121
       })
     }

   }
```

- `serveFiles()`:
```javascript
 /**
  * This function will be responsible for serving the files from the filesystem
  *
  * @param {HTTP.Request} request
  * @param {HTTP.Response} response
  * @param {Function} next
  */
  serveFiles: function() {
    return function(req, resp, next) {
      // get the output path from from the request headers
      // most of `broccoli-middleware` https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L115
    }
  }
```

### Create `ember-cli:broccoli:watcher` addon
The current `serve-files` addon invokes the `broccoli-middleware` and delegates the task to this middleware to serve the files and set the headers. We would like to change that and instead this new in-repo addon `ember-cli:broccoli:watcher` should only call `setResponseHeaders` function from `broccoli-middleware`. The `serverMiddleware` function of this [addon](https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18) will now look as follows:
```javascript
  ServeFilesAddon.prototype.serverMiddleware = function(options) {
    var app = options.app;
    var watcher = options.options.watcher;
    var broccoliMiddleware = require('broccoli-middleware');

    app.use(function(req, resp, next) {
      // copy over this: https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L33
      if (options.options.middleware) {
        // call the middleware that is provided for testemMiddleware
      } else {
        var watcherMiddleware = broccoliMiddleware.forWatcher(watcher);

        watcherMiddleware(req, resp, function(err) {
          if (err) {
            // log error
          }
          next(err);
        });
      }
    });
  }
```

As seen above `ember-cli:broccoli:watcher` will only be responsible for setting the headers and calling the the next middleware which will serve the files.

### Create `ember-cli:broccoli:serve-files` addon
We will create a new in-repo addon called as `ember-cli:broccoli:serve-files` which will be responsible for serving the the files. This addon will run *after* `ember-cli:broccoli:watcher` addon.

This function will be responsible for serving the incoming asset request from the filesystem. It will use the `serverMiddleware` API to serve the files using `broccoli-middleware`.
```javascript
  BroccoliServeFilesAddon.prototype.serverMiddleware = function(options) {
    var broccoliMiddleware = require('broccoli-middleware');
    var outputPath = options.watcher.builder.outputPath;
    var autoIndex = false;

    var options = { outputPath, autoIndex };
    app.use(function(req, resp, next) {
      var serveFileMiddlware = broccoliMiddleware.serveFiles();
      serveFileMiddlware(req, resp, function(err) {
        next(err);
      })
    });
  }
```

In order for FastBoot to be able to serve the assets using its own logic, it will specific that it run *before* `ember-cli:broccoli:serve-files` addon so that it can serve the assets. In this way, FastBoot will be able to inject itself into the correct order and be able to serve assets from the `tmp` directory.

### Drop `serve-files` addon in ember-cli
Since the work that `serve-files` does today is now split into two new in-repo addons, `serve-files` addon doesn't need to be present any longer. It is not exposing any public API or functionality that users may be using today and therefore can be dropped.

# How We Teach This

We will need to update the `ember-cli` website with this new in-repo addon and specify the above usecase with an example.

# Drawbacks

The only drawback is addon authors wanting to serve assets using their own logic, will need to know the correct order of middleware execution. Moreover, if someone has forked `ember-cli` to hack `serve-files` addon logic, it will be a breaking change for them.

# Alternatives

N/A

# Unresolved questions
- [ ] Should this addons be better named?


---

---
stage: discontinued
start-date: 2016-12-04T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/86
project-link:
---

# Summary

Replace PhantomJS with Firefox as the default browser for continuous integration testing.

# Motivation

We want to provide the best possible out-of-the-box continuous integration testing experience for Ember apps. Today that means shipping with configurations for testem and TravisCI. Those configurations use PhantomJS.

But PhantomJS is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And "how to debug in Phantom" is an entire extra skill people are forced to learn.

A user-targeted, standards-compliant, modern browser makes a better default choice. Firefox is a good candidate because it's 100% open source, well-supported by Testem on all major operating system, and built-in to TravisCI. Debugging in Firefox has a dramatically nicer learner curve than PhantomJS.

# Detailed design

This is a proposed change to the blueprints for new apps and addons. Existing apps and addons would only be affected when they re-run `ember init` as part of an upgrade and choose to take the updated configuration.

## Changes in testem.js

Replace `PhantomJS` with `Firefox`.

## Changes in travis.yml

Add the following new section to start up a virtual display:

```
before_script:
  - export DISPLAY=:99; sh -e /etc/init.d/xvfb start; sleep 3
```

# How We Teach This

In the guides, replace instructions for installing PhantomJS with instructions for installing Firefox. Since Firefox is a consumer-facing browser with widely-understood installers and behavior, this is one less intimidating thing for newbies to learn.

# Drawbacks

PhantomJS has two primary benefits over other browsers: being headless and being scriptable.

## Headlessness

Firefox is not headless, so it needs to render to a display. That is why the Travis configuration needs xvfb.

## Scriptability

PhantomJS is scriptable, but we don't rely on that functionality anyway. We want cross-browser test suites, so Phantom's scriptability is not particularly useful.

# Alternatives

The default alternative is to do nothing and keep PhantomJS.

Another alternative would be to pick Chrome, since it is a very popular browser. However, Chrome is not 100% open source, which complicates distribution. It's not built into Travis, and the popular methods of installing it there require users to opt into non-container-based images, which are heavier and slower to boot.

Chromium is the fully-open-source parts of Chrome, but like PhantomJS it is an odd duck that's not really well-packaged for end users. It's also not installed by default in Travis.





---

---
stage: recommended
start-date: 2016-12-11T00:00:00.000Z
release-date: # FIXME
release-versions:
  # ember-cli: FIXME - Probably 2.12 or earlier

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/90
project-link:
---

# Summary

In Ember CLI today, all addons at each level are built through the standard `treeFor` / `treeFor*` hooks. These hooks are responsible for preprocessing the JavaScript included by the tree returned from that specific hook (e.g., `treeForAddon` preprocesses the JS for the addon tree). This RFC proposes a mechanism that would allow these returned trees to be cached by default (when no build time customization is done) and expose proper hooks for addon authors to control the degree to which we dedupe these trees.

# Motivation

Today, given the dependency graph:

```
ember-basic-dropdown:
  ember-wormhole@0.4.1

ember-modal-dialog:
  ember-wormhole@0.4.1

ember-paper:
  ember-wormhole@0.4.1
```
We would actually build `ember-wormhole`'s `addon` tree 3 different times, even though [as you can see](https://github.com/yapplabs/ember-wormhole/blob/0.4.1/index.js) there is absolutely no build time customization being done. After all of these `ember-wormhole` tree instances are built, we merge them such that the last tree wins (thus making all of the work to preprocess these trees completely moot). If you extrapolate this out to larger applications or ones using multiple engines (lazy or not) it is fairly common to see these sorts of dependencies shared upwards of 4 to 5 times. This can lead to significant build performance degradation.

# Detailed design

- Add a `Addon.prototype.cacheKeyForTree` method to [lib/models/addon.js](https://github.com/ember-cli/ember-cli/commits/master/lib/models/addon.js) that is invoked prior to calling `treeFor` for the same tree name. The `Addon.prototype.cacheKeyForTree` method is expected to return a cache key allowing multiple builds of the same tree to simply return the original tree (preventing duplicate work). If `Addon.prototype.cacheKeyForTree` returns `null` / `undefined` the tree in question will opt out of this caching system.
- ember-cli's custom [`mergeTrees` implementation](https://github.com/ember-cli/ember-cli/blob/4ec7b5951e8a9dd292029faf20d1858abf7bdfa0/lib/broccoli/merge-trees.js) (which is already aware of other tree reduction techniques) will be updated so that calling `mergeTrees([treeA, treeA]);` simply returns `treeA`, and `mergeTrees([treeA, treeB, treeA])` removes the duplicated `treeA` in the input nodes.

The proposed declaration for `Addon.prototype.cacheKeyForTree` in Typescript syntax is:

``` ts
function cacheKeyForTree(treeType: string): string;
```
The default implementation for `Addon.prototype.cacheKeyForTree` will:

- Utilize a shared NPM package (e.g. `calculate-cache-key-for-tree`) that will generate a cache key that incorporates at least the following pieces of information:
    - `this.name` - The addon's name (generally from `package.json`).
    - `this.pkg` - This builds a checksum accounting for the addon's `package.json`.
    - `treeType` - The specific tree in question (e.g. `addon`, `vendor`, `addonTestSupport`, `templates`, etc).

- Resort to disabling all addon tree caching in the following scenarios
    - The addon implements a custom `treeFor`
    - The addon implements a custom `treeFor*` method (where `*` represents the tree type)


Addons that implement custom `treeFor` or `treeFor*` methods can still opt-in to caching in scenarios that they can confirm are safe. To do this, they would implement a custom `cacheKeyForTree` method and return a cache key as appropriate for their caching needs.

# How We Teach This

This is something that we do not expect 99% of ember-cli users to have to learn and understand, however it is still important for it to be possible to determine what is going on and how to work within the system when building addons.

The following should help us teach this to the correct audience (roughly "addon power users"):

- Document the shared NPM package (referred to above as `calculate-cache-key-for-tree`). This will help authors of addons that need to implement `treeFor*` hooks understand how they can properly implement `Addon.prototype.cacheKeyForTree`.
- Write API docs for the newly added `Addon.prototype.cacheKeyForTree` method.

# Drawbacks

- Cache invalidation is difficult to get right, and it is possible to accidentally troll our users. This can be mitigated by thorough review of the implementation and this RFC.

# Alternatives

# Unresolved questions

- Confirm if including the same tree multiple times will only trigger a single build of that tree (this should be a Broccoli feature). We have confirmed that code exists in broccoli-builder ([see here](https://github.com/ember-cli/broccoli-builder/blob/0-18-x/lib/builder.js#L89-L97)), but still need to actually confirm `.build` / `.read` / `.rebuild` are not called twice within the same build.



---

---
stage: recommended
start-date: 2016-12-14T00:00:00.000Z
release-date: 2017-03-16T00:00:00.000Z
release-versions:
  ember-cli: v2.12.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/91
project-link:
---

# Summary

Add an instrumentation hook that is available to addons.  This enables users to
write addons that do things like summarize and report build performance
information.

- see https://github.com/ember-cli/ember-cli/issues/6349 for additional context.
- see https://github.com/ember-cli/ember-cli/pull/6606 for an experimental
  implementation.

# Motivation

Build performance is important to users.  We want to enable users to:

1. Easily discover which portions of their build are costly;
2. Be able to summarize and report build information in an addon;
3. Be able to write addons that analyze build performance instrumentation so
   that they can more easily help diagnose build performance issues in projects
   to which they do not have direct access.  This is of particular interest to
   @ember-cli/core &c.

In order to provide these hooks to enable iteration and experimentation prior to
making firm commitments to format, this rfc propose to initially expose them as
experiments (see the experiments section below).

# Detailed design

## Experiments

Experiments live in `lib/experiments/index.js`.  Unlike feature flags, there is
no need to strip them from production.  Experiments allow us to provide power
user features that are not fully stable without their resorting to private API
usage.

Experiments are available only in canary builds.  This is achieved by only
including `lib/experiements/index.js` in canary, and making it the entry point
for all experiments.

## Instrumentation Hook

We have already a build instrumentation hook as an
experiment in https://github.com/ember-cli/ember-cli/pull/6546

A more encompassing instrumentation hook is implemented in
https://github.com/ember-cli/ember-cli/pull/6606


The goal of this RFC is:

  1. To make the concept of experiments supported and explicit
  2. To promote this particular experiment to public API

### Enabling Instrumentation

Instrumentation is enabled if either the environment variable `BROCCOLI_VIZ` is
set to `1` or if `EMBER_CLI_INSTRUMENTATION` is set to `1`.

If `BROCCOLI_VIZ=1` then in addition to instrumentation hooks being invoked, a
serialized form of the instrumentation information is written to disk, that is
appropriate for consumption by [broccoli-viz](https://github.com/ember-cli/broccoli-viz) which is the current behaviour.

### Instrumentation

#### Hook

An addon that implements `instrumentation` will have this hook invoked when
instrumentation is enabled.

```js
module.exports = {
  name: 'my-great-addon',

  instrumentation(name, payload) {
    // format of instrumentation payload outlined below
  }
};
```

##### name

The `name` argument indicates what phase the instrumentation payload describes.
In beta and released versions this will always be a string.

On canary it could be a symbol from `lib/experiments` if we add more phases (eg
more fine-grained phases) for instrumentation information.

The initial set of phases this RFC advocates are:
  - `init`
  - `command`
  - `build`
  - `shutdown`

##### payload

`payload` is an object with two properties, `summary` and `graph`.

##### payload.summary

The exact format of `payload.summary` depends on the specific phase for which
the instrumentation hook was called.  In each case, the keys listed are the
minimum keys that are guaranteed to be present, but there is no guarantee that
additional information might not also be present.

###### init

`init` covers the period up to, but not including, command execution.  This
means it's mostly dealing with `require` time.

For `init`, the summary object has the following shape.

```js
{
  totalTime,
  platform: {
    name,
  },
}
```

- `summary.totalTime` The total time spent during `init`
- `summary.platform.name` The value of `process.platform`

###### build

`build` covers the time spent in an individual build or rebuild.

For `build`, the summary object has the following shape.

```js
{
  build: {
    type,
    count,
    outputChangedFiles

    // additional fields for rebuilds
    primaryFile,
    primaryFileCount,
    changedFiles
  },
  platform: {
    name,
  },
  output,
  totalTime,
  buildSteps,
}
```

- `summary.build.type` one of `'initial'` or `'rebuild'`
- `summary.build.count` the number of the build (0 for initial build, > 0 for
  rebuilds).
- `summary.build.outputChangedFiles` an array of paths to output files that
  changed during this build.  These paths are relative to the `dist` directory.
- `summary.build.primaryFile` only present for rebuilds.  Indicates the first
  file the watcher noticed had changed.
- `summary.build.changedFileCount` only present for rebuilds.  The number of
  files the watcher had noticed changed before the build started.
- `summary.build.changedFiles` only present for rebuilds. The first 10 files
  the watcher had noticed changed before the build started.
- `summary.platform.name` The value of `process.platform`
- `summary.output` The temp directory containing the results of the build.
- `summary.totalTime` The total time (in nanoseconds) of the build.
- `summary.buildSteps` The number of broccoli nodes built in this tree

###### command

`command` covers the time spent during a command.  When the command includes a
build, there will be overlap between `command` and `build`.  When the command is
`serve`, this overlap will include only the last build, to avoid memory leaks.

For `command`, the summary object has the following shape.

```js
{
  totalTime,
  platform: {
    name,
  },
  name,
  args
}
```

- `summary.totalTime` The total time spent during `init`
- `summary.platform.name` The value of `process.platform`
- `summary.name` The name of the command that was run
- `summary.args` The args of the command that was run

###### shutdown

`shutdown` covers the period from the command completing to process exit, ie
cleanup time.

For `shutdown`, the summary object has the following shape.

```js
{
  totalTime,
  platform: {
    name,
  },
}
```

- `summary.totalTime` The total time spent during `init`
- `summary.platform.name` The value of `process.platform`

##### payload.graph

`graph` is an object that represents the instrumentation information we have
gathered for the build.  It is a DAG, whose flow is inverted from the broccoli
graph. It has a single source node (currently `TreeMerger (all trees)`).
`payload.graph` is this single source node.

Each node in the graph provides an API for iterating its subgraph as well as
iterating its own stats. The specific nodes in the graph will change over time as
the instrumentation within ember-cli changes.  There is no particular guarantee
about what the nodes will be, although we will continue to ensure that its
`toJSON` format is consumable by
[broccoli-viz](https://github.com/ember-cli/broccoli-viz)

The API that each node supports is:

- `label`
- `toJSON`
- `adjacentIterator`
- `dfsIterator`
- `bfsIterator`

###### label

A POJO property that describes the node.  It will always include a `name`
property and for broccoli nodes will include a `broccoliNode` property.

Example:
```js
node.label === {
  name: 'TreeMerger (allTrees)',
  broccoliNode: true,
}
```

###### toJSON()

Returns a POJO that represents the serialized subgraph rooted at this node (the
entire tree if called on the root node).

There is no particular guarantee about the format, except that whatever it is
will be supported by [broccoli-viz](https://github.com/ember-cli/broccoli-viz).

Example:
```js
// for a graph
//  TreeMerger
//    |- Babel_1
//    |- Babel_2
//    |--|- Funnel
console.log(JSON.stringify(node.toJSON(), null, 2));
// might print
//
{
  nodes: [{
    id: 1,
    children: [2,3],
    stats: {
      time: {
        self: 5000000,
      },
      fs: {
        lstat: {
          count: 2,
          time: 2000000
        }
      },
      own: {
      }
    }
  }, {
    // ...
  }]
}
```

###### adjacentIterator

Returns an iterator that yields each adjacent outbound node.  There is no
guarantee about the order in which they are yielded.

```js
// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
node.label.name === "TreeMerger";
for (n of node.adjacentIterator()) {
  console.log(n.label.name);
}
// prints
//
// Babel_1
// Babel_2


for (n of node.preOrderIterator(x => x.label.name === 'Babel_2')) {
  console.log(n.label.name);
}
// prints
//
//  TreeMerger
//  |- Babel_1
```

###### dfsIterator(until)

Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in depth-first order.  If the optional parameter `until` is
passed, nodes for which `until` returns `true` will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.

Example:
```js
// for a graph
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.dfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Funnel
// Babel_2
```

###### bfsIterator()

Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in breadth-first order.  If the optional parameter `until` is
passed, nodes for which `until` returns `true` will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.


Example:
```js
// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.bfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Babel_2
// Funnel
```

###### statsIterator()

Returns an iterator that yields `[name, value]` pairs of stat names and values.

Example:
```js
  //  for a typical broccoli node
  for ([statName, statValue] of node.statsIterator()) {
    console.log(statName, statValue);
  }
  // prints
  //
  // "time.self" 64232794
  // "fs.statSync.count" 40
  // "fs.statSync.time" 401232123
  // ...
  ```

# How We Teach This

This has no effect on day-to-day usage of ember-CLI.  It is a tool to help users
monitor and analyze their build performance, so documentation and teaching
belong primarily in `PERF_GUIDE.md`.  Having said that, we should also add a
section to `https://ember-cli.com/extending/` and the API docs to make using
this feature easier for addon authors and CLI power users.

# Drawbacks

* No drawbacks come to mind, besides the ever present issue of maintenance

# Alternatives

One alternative is the status quo: with `BROCCOLI_VIZ=1` users can output a file
with a similar format that they can post-process offline.  Although this works
for manual analysis, it is considerably more cumbersome for any automated system
(such as ongoing monitoring of build performance).  It also does not include
instrumentation outside of the build, most notably startup.

# Unresolved questions

- [heimdalljs-tree](https://github.com/heimdalljs/heimdalljs-tree) supports
  `Symbol.Iterator`; should we commit to this as part of our API?



---

---
stage: discontinued
start-date: 2015-09-11T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/91
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/12224 / https://github.com/emberjs/ember.js/pull/12990 / https://github.com/emberjs/ember.js/pull/13688
---

# Summary

Introduce `Ember.WeakMap` (`@ember/weakmap`), an ES6 enspired WeakMap. A
WeakMap provides a mechanism for storing and retriving private state. The
WeakMap itself does not retain a reference to the state, allowing the state to
be reclaimed when the key is reclaimed.

A traditional WeakMap (and the one that will be part of the language) allows
for weakness from key -> map, and also from map -> key. This allows either the
Map, or the key being reclaimed to also release the state.

Unforunately, this bi-directional weakness is problemative to polyfil. Luckily,
uni-directional weakness, in either direction, "just works". A polyfil must
just choose a direction.

*Note: Just like ES2015 WeakMap, only non null Objects can be used as keys*
*Note: `Ember.WeakMap` can be used interchangibly with the ES2015 WeakMap. This
will allow us to eventually cut over entirely to the Native WeakMap.*

# Motivation

It is a common pattern to want to store private state about a specific object.
When one stores this private state off-object, it can be tricky to understand
when to release the state. When one stores this state on-object, it will be
released when the object is released. Unfortunately, storing the state
on-object without poluting the object itself is non-obvious.

As it turns out, Ember's Meta already solves this problem for
listeners/caches/chains/descriptors etc. Unfortunately today, there is no
public API for apps or addons to utilize this. `Ember.WeakMap` aims to be
exactly that API.

Some examples:

* https://github.com/offirgolan/ember-cp-validations/blob/master/addon/utils/cycle-breaker.js
* https://github.com/stefanpenner/ember-state-services/ (will soon utilize the user-land polyfil of this) to prevent common leaks.

# Detailed design

## Public API

```js
import WeakMap from '@ember/weak-map'

var private = new WeakMap();
var object = {};
var otherObject = {};

private.set(object, {
  id: 1,
  name: 'My File',
  progress: 0
}) === private;

private.get(object) === {
  id: 1,
  name: 'My File',
  progress: 0
});


private.has(object) === true;
private.has(otherObject) === false;

private.delete(object) === private;
private.has(object) === false;
```

## Implementation Details

The backing store for `Ember.WeakMap` will reside in a lazy `ownMap` named
`weak` on the key objects `__meta__` object.

Each `WeakMap` has its own internal GUID, which will be the name of its slot,
in the key objects meta weak bucket. This will allow one object to belong in
multiple weakMaps without chance of collision.

Concrete Implementation: https://github.com/emberjs/ember.js/pull/12224
Polyfill: https://www.npmjs.com/package/ember-weakmap

# Drawbacks

* implementing bi-direction Weakness in userland is problematic.
* Using WeakMap will insert a non-enumerable `meta` onto the key Object.

# Alternatives

* Weakness could be implemented in the other direction, but this has questionable utility.

# Unresolved questions

N/A


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2016-12-17T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/92
project-link:
---

# Summary

Give blueprint generators the ability to clean up old files.

# Motivation

We want to eliminate the noise of having old files laying after updating
ember-cli using `ember init`.

# Detailed design

We'd like an API for blueprints to delete files instead of only
create. It would be essentially syntactic sugar for removing the file yourself
in an `afterInstall` hook. It would be a returned array on the blueprint's `index.js`.

```js
// ember-cli/bluprints/blah/index.js
module.exports = {
  // ...

  get oldFilesToRemove() {
    return [
      'brocfile.js',
      'LICENSE.MD',
      'testem.json'
    ];
  }
};
```

# How We Teach This

The guides could use this addition in the blueprints section, but I envision it
being used by mostly power users.

A changelog entry should be sufficient to teach this.

# Drawbacks

The only reason to not do this is to hold out for a large blueprint reworking.
We would be locked into this API.

# Alternatives

The key name can be bikeshed. I chose `oldFilesToRemove` to be verbose and
explicit, but it can be changed.


---

---
stage: recommended
start-date: 2017-01-03T00:00:00.000Z
release-date: 2017-04-29T00:00:00.000Z
release-versions:
  ember-cli: v2.13.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/95
project-link:
---

# Summary

This RFC proposes the introduction of a official convention to specify the target browsers
and node versions of an application.

# Motivation

Javascript and the platforms it runs on are moving targets. NodeJS and browsers release new
versions every few weeks. Browsers auto update and each update brings new language features
and APIs.

Developers need an easy way to express intention that abstracts them from the ever-changing
landscape of versions and feature matrices, so this RFC proposes the introduction of a unique
place and syntax to let developers express their intended targets that all addons can use,
instead of having each addon define it in a different way.

This configuration should be easily available to addons, but this RFC doesn't impose
any mandatory behavior on those addons. All addons that want to customize their behavior
depending on the target browsers will have a single source of truth to get that
information but it's up to them how to use it.

The advantage of having a single source of truth for the targets compared to configure this
on a per-addon basis like we do today is mostly for better ergonomics and across-the-board
consistency.

Examples of addons that would benefit from this conventions are `babel-preset-env`, `autoprefixer`,
`stylelint` and `eslint` (vía `eslint-plugin-compat`) and more. Even Ember itself could,
once converted into an addon, take advantage of that to avoid polyfilling or even taking
advantage of some DOM API (`node.classList`?) deep in Glimmer's internals, helping the goal
of Svelte Builds.

# Detailed design

What seems to be the most popular tool and the state of the art on building suport matrices
for browser targets is the [browserlist](https://github.com/ai/browserslist) npm package.

That package is the one behind `babel-preset-env`, `autoprefixer` and others, and uses the data from
[Can I Use](http://caniuse.com/) for knowing the JS, CSS and other APIs available on every browser.

The syntax of this package is natural but also pretty flexible, allowing complex
queries like `Firefox >= 20`, `>2.5% in CA` (browsers with a market share over 2.5% in Canada)
and logical combinations of the previous.

The way this library work is by calculating the minimum common denominator support on a per-feature basis.

Per example, if the support matrix for an app is `['IE11', 'Firefox latest']` and we have a linter
that warns us when we use an unsupported browser API, it would warn us if we try to use
pointer events (supported in IE11 but not in Firefox), would warn us also when using `fetch` (supported
in firefox but not in IE) and would not warn us when using `MutationObserver` because it is supported by both.

This library is very powerful and popular, making relatively easy to integrate with a good amount of
tools that already use it with low effort.

This configuration must be made available to addons but it's up to the addon authors to take advantage
of it.

### Browser support

The configution of target browsers must be placed in a file that allows javascript execution and exports an object
with the configuration. The reason to prefer a javascript file over a JSON one is to allow users to
dinamically generate different config depending on things like the environment they are building the app in or
any other environment variable.

One possible location for this configuration is the `.ember-cli` file.
A new dedicated named `/config/targets.js` also seems a good option, similar way how addons use `config/ember-try.js`
to configure the test version matrix.

Ember CLI will require this file when building the app and make the configuration available to addons
in a `this.project.targets` property.

This `targets` object contains a getter named `browsers` that returns the provided configuration or the default
one if the user didn't provide any.

Example usage:

```js
module.exports = {
  name: 'ember-data',

  included(app) {
    this._super.included.apply(this, arguments);

    console.log(this.project.targets.browsers); // ['>2%', 'last 3 iOS versions', 'not ie <= 8']
  }
};
```

This `targets` object can, and probably will, be expanded in the future with new properties
for different kind of targets, like cordoba apps or fastboot, but that will be
done in a different RFC.

# How We Teach This

This is a new concept in Ember CLI, so guides will have to be updated to explain this
concept. The good part is that this new concept can help enforcing with tools a task were
traditionally enforced only with peer reviews.

To ease the transition Ember CLI can also, in the absence of a specific value provided by the user,
default to a predefined matrix of browsers that matches the browsers officially supported by the framework.

As of today, the supported browser list for Ember.js, according to the platforms we test in saucelabs, is:

`['IE9', 'Chrome current', 'Safari current', 'Firefox current']`

There is no mention to IOS/Android, so this must be validated still.

# Drawbacks

While this RFC standardizes a concept that will open the door to better and more comprehensive tooling,
it makes us choose one syntax (the one used by [browserlist](https://github.com/ai/browserslist)) over
any other perhaps superior choice that may exist or appear in the future.

# Alternatives

Let every addon that wants to deal with targets to have a `targets`-like option in its configuration
instead of standardizing a single configuration option, which effectively leaves things as they are
right now.

Example:

```
var app = new EmberApp(defaults, {
  'ember-cli-autoprefixer': {
    browsers: ...
  },
  'ember-cli-babel': {
    targets: ...
  },
  'ember-cli-eslint': {
    engines: ...
  },
  ...
});
```

# Unresolved questions

The proposed syntax for node only supports a single version of node. Is it reasonable to
make this property an array of versions? P.e. `["4.4", "6", "7"]`


---

---
stage: recommended
start-date: 2015-09-24T00:00:00.000Z
release-date: 2018-12-18T00:00:00.000Z
release-versions:
  ember-source: v3.6.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/95
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/14805
---

# Summary

This RFC proposes:

 - creating a public `router` service that is a superset of today's `Ember.Router`.

 - codifying and expanding the supported public API for the `transition` object that is currently passed to `Route` hooks.

 - introducing the `get-route-info` template helper
 - introducing the `#with-route-info` template keyword
 - introducing the `readsRouteInfo` static property on `Component` and `Helper`.

These topics are closely related because they share a unified `RouteInfo` type, which will be described in detail.

# Motivation

Given the modern Ember concepts of Components and Services, it is clear that routing capability should be exposed as a Service. I hope this is uncontroversial, given that we already implement it as a service internally, and given that usage of these nominally-private APIs is already becoming widespread.

The immediate benefit of having a `RouterService` is that you can inject it into components, giving them a friendly way to initiate transitions and ask questions about the current global router state.

A second benefit is that we have the opportunity to add new capabilities to the `RouterService` to replace several common patterns in the wild that dive into private internals in order to get things done. There are several places where we leak internals from router.js, and we can plug those leaks.

A `RouterService` is great for asking global questions, but some questions are not global and today we incur complexity by treating them as if they are. For example:

 - `{{link-to}}` can use implicit models from its context, but that breaks when you're trying to animate to or from a state where those models are not present.

 - `{{link-to}}` has a lot of complexity and performance cost that deals with changing its active state, and the precise timing of when that should happen.

 - there is no way to ask the router what it would do to handle a given URL without actually visiting that URL.

All of the above can be addressed by embracing what is already internally true: "the current route" is not a single global, it's a dynamically-scoped variable that can have different values in different parts of the application simultaneously.

# Detailed design

## RouterService

By way of a simple example, the router service behaves like this:

```js
import Component from 'ember-component';
import service from 'ember-service/inject';

export default Component.extend({
  router: service(),
  actions: {
    goToMars() {
      this.get('router').transitionTo('planet.mars');
    }
  }
});
```

Like any Service, it can also be injected into Helpers, Routes, etc.

### Relationship between EmberRouter and RouterService

Q: "Why are you calling this thing 'router' when we already have a router? Shouldn't the new thing be called 'routing' or something else?".

A: We shouldn't have two things. From the user's perspective, there is just "the router", and it happens to be available as a service. While we're free to continue implementing it as multiple classes under the hood, the public API should present as a single, coherent concept.

Terminology:

 - `EmberRouter` is the class that we already have today, defined in `ember-routing/system/router` and available publicly as `Ember.Router`
 - `RouterService` is the new class I am proposing.

`EmberRouter` has the following public API today:

 - `map`
 - `location`
 - `rootURL`
 - `willTransition`
 - `didTransition`

That API will be carried over verbatim to `RouterService`, and the publicly accessible `Ember.Router` class will *become* `RouterService`. In terms of implementation, I expect the existing `EmberRouter` class will continue to exist mostly unchanged. But public access to it will be moderated through `RouterService`.

### New Methods: Initiating Transitions

```js
transitionTo(routeName, ...models, queryParams)
replaceWith(routeName, ...models, queryParams)
```

These two have the same semantics as the existing methods on `Ember.Route`:

### New Method: Checking For Active Route

 - `isActive(routeName, ...models, queryParams)`

The arguments have the same semantics as `transitionTo`, the return value is a boolean. This should provide the same logic that determines whether to put an active class on a `link-to`. Here's an example of how we can implement `is-active` as a helper, using this method:

```js
import Helper from 'ember-helper';
import service from 'ember-service/inject';
import observer from 'ember-metal/observer';

export default Helper.extend({
  router: service(),
  compute([routeName, ...models], hash) {
    let allModels;
    if (hash.models) {
      allModels = models.concat(hash.models);
    } else {
      allModels = models;
    }
    return this.get('router').isActive(routeName, ...allModels, hash.queryParams);
  },
  didTransition: observer('router.currentRoute', function() {
    this.recompute();
  })
});
```

```hbs
{{!- Example usage -}}
<li class={{if (is-active "person.detail" model) 'chosen'}} >

{{!- Example usage with generic routeName and list of models (avoids splat) -}}
<a class={{if (is-active routeName models=models) 'chosen'}} >

{{!- Note that the complexities of currentWhen can be avoided by composing instead. }}
<a class={{if (or (is-active 'one') (is-active 'two')) 'active'}} href={{url-for 'two'}} >

```

### New Method: URL generation

`urlFor(routeName, ...models, queryParams)`

This takes the same arguments as `transitionTo`, but instead of initiating the transition it returns the resulting root-relative URL as a string (which will include the application's `rootUrl`).

A `url-for` helper can be implemented almost identically to the `is-active` example above.

### New Method: URL recognition

`recognize(url)`

Takes a string URL and returns a `RouteInfo` for the leafmost route represented by the URL. Returns `null` if the URL is not recognized. This method expects to receive the actual URL as seen by the browser _including_ the app's `rootURL`.


Example: this feature can replace [this use of private API in ember-href-to](https://github.com/intercom/ember-href-to/blob/b8cf0699eec6a65570b05e4fc22b27d8cea49c42/app/instance-initializers/browser/ember-href-to.js#L34).


### New Method: Recognize and load models

`recognizeAndLoad(url)`

Takes a string URL and returns a promise that resolves to a `RouteInfoWithAttributes` for the leafmost route represented by the URL. The promise rejects if the URL is not recognized or an unhandled exception is encountered. This method expects to receive the actual URL as seen by the browser _including_ the app's `rootURL`.

### Deprecating willTransition and didTransition

Application-wide transition monitoring events belong on the Router service, not spread throughout the Route classes. That is the reason for the existing `willTransition` and `didTransition` hooks/events on the Router. But they are not sufficient to capture all the detail people need. See for example, https://github.com/nickiaconis/rfcs/blob/1bd98ec534441a38f62a48599ffa8a63551b785f/text/0000-transition-hooks-events.md

In addition, they receive handlerInfos in their arguments, which are an undocumented internal implementation detail of router.js that doesn't belong in Ember's public API. Everything you can do with handlerInfos can be done with the RouteInfo type that is proposed in this RFC, with the benefit of sticking to supported public API.

So we should deprecate willTransition and didTransition in favor of the following new events.

### New Events: routeWillChange & routeDidChange

The `routeWillChange` event fires whenever a new route is chosen as the desired target of a transition. This includes `transitionTo`, `replaceWith`, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, `routeDidChange` fires.

Both events receive a single `transition` argument as described in the "Transition Object" section below, which explains the meaning of `from` and `to` in more detail.

Redirection example:

 1. current route is A
 2. user initiates a transition to B
 3. routeWillChange fires `from` A `to` B.
 4. B redirects to C
 5. routeWillChange fires `from` A `to` C.
 6. routeDidChange fires `from` A `to` C.

Abort example:

 1. current route is A
 2. user initiates a transition to B
 3. routeWillChange fires `from` A `to` B.
 4. in response to the previous routeWillChange event, the transition is aborted.
 5. routeWillChange fires `from` A `to` A.
 8. routeDidChange fires `from` A `to` A.

Error example:

 1. current route is A
 2. user initiates a transition to B.index
 3. routeWillChange fires `from` A `to` B.
 4. B throws an exception, and the router discovers a "B-error" template.
 5. routeWillChange fires `from` A `to` B-error
 6. routeDidChange fires `from` A `to` B-error

These are events, not extension hooks -- now that we are exposing a Service, it makes more sense to subscribe to its events than extend it.

### New Properties

`currentRoute`: an observable property. It is guaranteed to change whenever a route transition happens (even when that transition only changes parameters and doesn't change the active route). You should consider its value deeply immutable -- we will replace the whole structure whenever it changes. The value of `currentRoute` is a `RouteInfo` representing the current leaf route. `RouteInfo` is described below.

`currentRouteName`:  a convenient alias for `currentRoute.name`.

`currentURL`: provides the serialized string representing `currentRoute`.

### Query Parameter Semantics

Today, `queryParams` impose unnecessarily high cost because we cannot generate URLs or determine if a link is active without taking into account the default values of query parameters. Determining their default values is expensive, because it involves instantiating the corresponding controller, even in cases where we will never visit its route.

Therefore, the `queryParams` argument to the new `urlFor`, `transitionTo`, `replaceWith`, and `isActive` methods defined in this document will behave differently.

 - default values will not be stripped from generated URLs. For example, `urlFor('my-route', { sortBy: 'title' })` will always include `?sortBy=title`, whether or not `title` is the default value of `sortBy`.

 - to explicitly unset a query parameter, you can pass the symbol `Ember.DEFAULT_VALUE` as its value. For example, `transitionTo('my-route', { sortBy: Ember.DEFAULT_VALUE })` will result in a URL that does not contain any `?sortBy=`.

(Sticky parameters are still allowed, because they only apply when the destination controller has already been instantiated anyway.)



## RouteInfo Type

A RouteInfo object has the following properties. They are all read-only.

 - name: the dot-separated, fully-qualified name of this route, like `"people.index"`.
 - localName: the final part of the `name`, like `"index"`.
 - params: the values of this route's parameters. Same as the argument to `Route`'s `model` hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).
 - paramNames: ordered list of the names of the params required for this route. It will contain the same strings as `Object.keys(params)`, but here the order is significant. This allows users to correctly pass params into routes programmatically.
 - queryParams: the values of any queryParams on this route.
 - parent: another RouteInfo instance, describing this route's parent route, if any.
 - child: another RouteInfo instance, describing this route's active child route, if any.

Notice that the `parent` and `child` properties cause `RouteInfos` to form a linked list. So even though the `currentRoute` property on `RouterService` points at the leafmost route, it can be traversed to discover everything about all active routes. As a convenience, `RouteInfo` also implements `Enumerable` over all the reachable `RouteInfos` from topmost to leafmost. This makes it possible to say things like:

```js
router.currentRoute.find(info => info.name === 'people').params
```

## RouteInfoWithAttributes

This type is almost identical to `RouteInfo`, except it has one additional property named `attributes`. The attributes contain the data that was loaded for this route, which is typically just `{ model }`.

## Transition Object

A `transition` argument is passed to `Route#beforeModel`, `Route#model`, `Route#afterModel`, `Route#willTransition`, and `Router#willTransition`. Today `transition`'s public API is only really `abort()` and `retry()`.

### New Properties: `from` and `to`

I'm proposing we add `from` and `to` properties on `transition` whose values are `RouteInfo` instances representing the initial and final leafmost routes for this transition. Like all RouteInfos, these are read-only and internally immutable. They are not observable, because a  `transition` instance is never changed after creation.

On an initial full-page load, the `from` property will be `null`. This creates a public API for distinguishing in-app transitions from full-page reloads.

### Example: testing whether route will remain active

Here's an example showing how `willTransition` can figure out if the current route will remain active after the transition:

```js
willTransition(transition) {
  if (!this.transition.to.find(route => route.name === this.routeName)) {
    alert("Please save or cancel your changes.");
    transition.abort();
  }
}
```

### Example: parent redirecting to a fallback model

Here's an example of a parent route that can redirect to a fallback model, without losing its child route:

```js
this.route('person', { path: '/person/:person_id' }, function() {
  this.route('index');
  this.route('detail');
});

//PersonRoute
const fallbackPersonId = 0;
model({ personId }, transition) {
  return this.get('store').find('person', personId).catch(err => {
    this.replaceWith(transition.to.name, fallbackPersonId);
  });
}

// If personId 5 is invalid, and the user visits /person/5/detail, they will get
// redirected to /person/0/detail. And /person/5 will get redirected to /person/0.
```


### Actively discourage use of private API

This RFC provides public API for doing the things people have become accustomed to doing via private API. To eliminate confusion over the correct way, we should hide all the private API away behind symbols, and provide deprecation warnings per our usual release policy around breaking "widely-used private APIs".

Some of the private APIs we should mark and warn include:

 - transition.state
 - transition.params
 - `lookup('router:main')` (should use `service:router` instead)


## Dynamically-Scoped Route Info

"The current route" is not a global value -- it varies from place to place within an application. Internally, Ember already models route info as a dynamically-scoped variable (currently named `outletState`). This RFC proposes publicly exposing that value in order to make things like `link-to` easier to implement directly on public primitives, and in order to enable stable public API for addons usage like `{{liquid-outlet}}`.

We propose `get-route-info` for reading the current route info in handlebars:

 ```hbs
 {{!- retrieve the value of a dynamically scoped variable }}
 {{some-component currentRoute=(get-route-info)}}
 ```

We propose `readsRouteInfo` for defining a component that reads route info:

```js
let MyComponent = Ember.Component.extend({
  didInsertElement() {
    // Accessing routInfo here is intended to be indistinguishable
    // from a normal, explicitly-passed input argument.
    doSomethingWith(this.get('routeInfo'));
  }
});
MyComponent.reopenClass({
  // This is where we declare that we need access to routeInfo
  readsRouteInfo: true
});
```

And `readsRouteInfo` also works on `Helper`:

```js
let MyHelper = Ember.Helper.extend({
  compute(params, hash) {
    // routeInfo is indistinguishable from a normally-passed hash argument
    return doSomethingWith(hash.routeInfo);
  }
});
MyHelper.reopenClass({
  readsRouteInfo: true
});
```

We propose the `#with-route-info` keyword for setting a new route info:

```hbs
{{#with-route-info someValue}}
  {{!-
    within this block AND ALL ITS DESCENDANTS until
    otherwise overridden by another set-route-info statement,
    `get-route-info` returns someValue.
  -}}
{{/with-route-info}}
```

Note that there is no `set-route-info`. You can only introduce new scopes, not mutate your containing scope. There is also no way to set routeInfo directly from Javascript -- your component must use a `with-route-info` block within its handlebars template.

### routeInfo's type, and examples

The value returned from `get-route-info` and acceptd by `with-route-info` is always a `RouteInfoWithAttributes` object. This enables several nice things, which I will illustrate with examples:

1. Here is a simplified `is-active` helper that will always update at the appropriate time to match exactly what is rendered in the current outlet. It will maintain the correct state even during animations. Instead of injecting the router service, it consumes the `routeInfo` from its containing environment:

```js
Ember.Helper.extend({
  compute([routeName], { routeInfo }) {
    return !!routeInfo.find(info => info.name === routeName);
  }
}).reopenClass({
  readsRouteInfo: true
});
```

A more complete version that also matches models and queryParams can be written in the same way.

2. We can improve `link-to` so that it always finds implicit model arguments from the local context, rather than trying to locate them on the global router service. This will fix longstanding bugs like https://github.com/ember-animation/liquid-fire/issues/347 and it will make it easier to test components that contain `{{link-to}}`. This would also open the door to relative link-tos.

3. `liquid-outlet` can be implemented entirely via public API. It would become:

```hbs
{{#liquid-bind (get-route-info) as |currentRouteInfo|}}
  {{#with-route-info currentRouteInfo}}
    {{outlet}}
  {{/with-route-info}}
{{/liquid-bind}}
```

4. Prerendering of non-current routes becomes possible. You can use `recognizeAndLoad` to obtain a `RouteInfoWithAttributes` and then use `{{#with-route-info myRouteInfo}} {{outlet}} {{/with-route-info}}` to render it.


# Drawbacks

This RFC deprecates only two public extension hooks API, so the API-churn burden may appear low. However, we know that use of the private APIs we're deliberately disabling is widespread, so users will experience churn. We can provide our usual deprecation cycle to give them early warning, but it still imposes some cost.

This RFC doesn't attempt to change the existing and fairly rich semantics for initiating transitions. For example, you can pass either models or IDs, and those have subtle semantic differences. I think an ideal rewrite would also change the semantics of the route hooks and transitionTo to simplify that area.

# Alternatives

## Less Churn

We could adopt some of the existing broadly used APIs as de-facto public. This avoids churn, but imposes a complexity burden on every new learner, who needs to be told "this is a weird API, but it's what we're stuck with".

## Semver Lawyering

I'm interpreting router.js's public/private documentation as out-of-scope for Ember's semver. The fact that we pass an instance of router.js's Transition as our `transition` argument is not documented. An alternative interpretation is that we need to continue supporting those methods marked as public in router.js's docs.

## Optional Helpers

I didn't propose shipping `is-active` and `url-for` template helpers -- I merely showed that they're easy to build using the router service. But we should arguably just ship them as part of the framework too.

## Branching Route Hierarchies

I am implicitly assuming we will only ever have linear route hierarchies, where a given route has at most one child. I can imagine eventually wanting a way to support branching route hierarchies, where each branch can transition independently. I'm not trying to account for that future.

## Route.parentRoute

This RFC makes it possible for a route to determine its parent's name dynamically via public API, and thus access its parent's model/params/controller:

```js
beforeModel(transition) {
  const parentInfo = transition.to.find(info => info.name === this.routeName).parent;
  const parentModel = this.modelFor(parentInfo.name);
}
```

However, this pattern feels awkward, and I think it justifies just adding a public `parentRouteName()` method to `Route` that would simplify to:

```js
beforeModel(transition) {
  const parentModel = this.modelFor(this.parentRouteName());
}
```
Possibly we *want* this to feel awkward because it's a weird thing to do.

## Naming of Ember.DEFAULT_VALUE Symbol

Should we introduce new API via the `Ember` global and switch to a module export once all the rest of Ember does, or should we just start with a module export right now? If so, what module?

    import { DEFAULT_VALUE } from 'ember-routing';



---

---
stage: recommended
start-date: 2017-02-02T00:00:00.000Z
release-date: 2017-04-29T00:00:00.000Z
release-versions:
  ember-cli: v2.13.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/96
project-link:
---

# Summary

Enable Ember CLI users to opt into using yarn for packagement management.

# Motivation

Ember CLI currently uses the npm command line tool to install dependencies when you run `ember install` or `ember new`/`ember addon`. However, several problems usually arise from npm's semantics.
Dependency resolution and install times can be significant enough to disrupt workflows, as well as offline support, non-deterministic, non-flat dependency graphs.

Yarn was introduced to the JavaScript community with the intent to provide a better developer experience in these areas:
- Faster installs
- Offline support
- Deterministic dependency graphs
- Lockfile semantics

While Ember CLI users can currently use Yarn to manage their dependencies, Ember CLI will use the npm client internally when running the above mentioned commands. By allowing users to specify that Ember CLI should use Yarn for everything, we're hoping to provide a more consistent experience.

# Detailed design

Enabling Yarn is designed as opt-in to prevent disruptions to the developer's current workflow.
We will address the two moments where this can happen.

## `ember install`

There are two mechanisms through which to opt-in.
The first one is the presence of a `yarn.lock` file in the project root.

The `yarn.lock` file is generated by Yarn when you run `yarn install` (or the shorter `yarn`),
so we assume that its presence means the developer intends to use Yarn to manage their dependencies.

Alternatively you, you can force Ember CLI to use Yarn with the `--yarn` flag, and symmetrically,
you can force Ember CLI to not use Yarn with the `--no-yarn` flag.

To recap:

- `ember install ember-cli-mirage` with `yarn.lock` present will use Yarn
- `ember install ember-cli-mirage` without `yarn.lock` present will use npm
- `ember install ember-cli-mirage --yarn` will use Yarn
- `ember install ember-cli-mirage --no-yarn` will use npm

## `ember init`, `ember new`, `ember addon`

Since this triad of commands is generally ran before a project is set up, there is no `yarn.lock` file presence to check.
This means we are left with the `--yarn`/`--no-yarn` pair of flags, that will also be added to these commands:

- `ember new my-app` will use npm
- `ember new my-app --yarn` will use Yarn

The above also applies to `ember addon` and `ember init`, noting that `ember init` doesn't receive any arguments.

# How We Teach This

Both the Ember.js Guides as well as the Ember CLI Guides will be updated to reflect the new flags,
as well as the new semantics of `ember install` in the presence of `yarn.lock`.

In addition, the built-in instructions for `ember help` will be updated to reflect this.

# Drawbacks

To be determined.

# Alternatives

Do nothing.

# Unresolved questions

To be determined.


---

---
stage: recommended
start-date: 2015-10-23T00:00:00.000Z
release-date: 2016-02-29T00:00:00.000Z
release-versions:
  ember-data: v2.4.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/101
project-link:
meta:
  ember-issue: https://github.com/emberjs/data/pull/3930
---

# Summary

Add more illustrative detail to the default Ember Data Adapter Errors.

# Motivation

With a production Ember project, it's common to have many errors of the form "Adapter Error",
originating from deep in the Ember Data stack and carrying little context about what the
original error cause was.

The intent is to add the original request URL, the response code, and some payload information
to the default Error message for `DS.AdapterError`s. From there Errors can be handled or
tracked as normal.

# Detailed design

I've been using something similar to the following Adapter (`friendly-error-adapter.js`):

```js
import ActiveModelAdapter from 'active-model-adapter';

import DS from 'ember-data';

export default ActiveModelAdapter.extend({

  ajax(url, method)  {
    this.lastRequest = {
      url:    url,
      method: method
    };
    return this._super(...arguments);
  },

  handleResponse: function (status, headers, payload) {
    let payloadContentType = headers["Content-Type"].split(";").get("firstObject");
    let shortenedPayload;

    if (payloadContentType === "text/html" && payload.length > 250) {
      shortenedPayload = "[omitted long blob of HTML]";
    } else {
      shortenedPayload = payload;
    }

    let errorMessage = `Ember Data Error (${this.lastRequest.method} ${this.lastRequest.url} returned a ${status}). \n Payload (${payloadContentType}): \n\n ${shortenedPayload}`;

    if (this.isSuccess(status, headers, payload)) {
      return payload;
    } else if (this.isInvalid(status, headers, payload)) {
      return new DS.InvalidError(payload.errors, errorMessage);
    }

    let errors = this.normalizeErrorResponse(status, headers, payload);

    return new DS.AdapterError(errors, errorMessage);
  }
});
```

(Note that the code inside the adapter could be MUCH simpler and cleaner, the above
is a very quick hacked up example! :bomb:)

The intent is to get an error message out of the form:

 1. "Ember Data Error"
 2. Request Method & URI
 3. Response Status
 4. Response Content Type
 5. A sane representation of the Response payload

# Drawbacks

Adding complexity to an Error handler always runs the risk of generating errors inside
the handler itself, which would not be overly friendly.

# Alternatives

There's probably quite a few different pieces of information that could be included
in the message.

We could also potentially look at attaching the extra information to other fields on
the `AdapterError` (and its subclasses). The only drawback there would be that most
error reporters would then not include that information by default.

# Unresolved questions

 * Exact Error Message Format


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2017-04-23T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/105
project-link:
---

# Summary

It should be possible to specify packages/addons in `optionalDependencies` of the `package.json` of an `ember-cli project`, and ember-cli should scan for packages/addons mentioned in optionalDependencies while processing the build so that such packages/addons could also be included into the consuming application.

The build need not fail asserting "missing dependency" if any of the dependencies specified in optionalDependencies is missing/absent.

# Motivation

In general, the current ember-cli build process will scan for the packages specified in the `dependencies` hash and `devDependencies hash` from the downloaded packages in the node_modules folder, discovers and then includes them into the consuming application. The build is designed to fail if any of the packages specified in these two dependencies hash is missing in the `node_modules` folder. But this procedure may not be sufficient for a variety of cases.

So there could be an option for the developer to specify packages in optionalDependencies and ember-cli can lookup optionalDependencies while processing the build. The Build need not fail if there is any package specified in optionalDependencies is missing, since it is only optional and moreover may only be required for developmental purposes. This way the developer can have more control over the choice of packages he wishes to use for development and skip for production by giving appropriate commands like `npm install --no-optional`, thereby preventing the installation of packages itself rather than blacklisting in `ember-cli-build.js` which suggests preventing the installed addons sepcifed in the `blacklist` array from being included into the consuming application.

# Detailed design
We can tweak ember-cli addon/package discovery process to lookup for optionalDependencies as well and if the package is missing, we can make ember-cli proceed the build without terminating.

# How We Teach This

This functionality can simply be documented in ember-cli guides to teach.

# Alternatives

None.


---

---
stage: released # FIXME: This may be a further stage
start-date: 2017-06-18T00:00:00.000Z
release-date: 2017-10-09T00:00:00.000Z
release-versions:
  ember-cli: v2.16.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/108
project-link:
---

# Summary

This RFC proposes to add a new API to allow addons to register a custom transformation. This transformation can then be used by other addons when calling `app.import` with `using` API.

# Motivation

Addons or apps may want import browser only compatible libraries using `app.import` via bower or npm. These libraries should not be running in Node.

When FastBoot was doing two builds (to generate different assets for browser and Node environment), addon or apps often conditionally imported these libraries relying on the value of `process.env.EMBER_CLI_FASTBOOT`. With the new scheme of the build where only additional Node assets are built, this enviornment is no longer exposed.

In order to expose better semantics to allow apps and addon authors to easily import these libraries without much overhead (see issue [here](https://github.com/ember-fastboot/ember-cli-fastboot/issues/413)), we need to have these libraries wrapped with an FastBoot check. This can be achieved by extending the `using` API of `app.import`. FastBoot addon would like to register a custom transformation that other FastBoot compatible addons may chose to use in a declarative API.

# Detailed design

Today, Ember CLI supports transforming anonymous AMD modules imported via `app.import` into named AMD modules:

```js
app.import('/path/to/module.js', {
  using: [
    { transformation: 'amd', as: 'some-dep' }
  ]
});
```

The `amd` transform is hardcoded in Ember CLI. However, it is not possible for addon authors to provide any additional transformation that other addons can use when importing third-party modules. Addons like, FastBoot would like to provide custom transformation for other addons to use so that they can wrap their third party libraries in Node environments.

In order to do this, we would like to expose an API that allows addons to register a custom transformation. This API will be an advanced API and will only be used by addons that want to provide custom transformation. Other addons can chose to use that custom transformation using its name.

The API to register a custom transformation in Ember CLI will be defined in `index.js` of the addon and will be an advanced API:

```js
importTransforms() {
  return {
    'fastboot-shim': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        return `if (typeof FastBoot === 'undefined) { ${content} }`;
      });
    }
  }
}
```

`importTransforms` returns a map of the name of the transform and a callback function that will be run on every module that uses the transform. The callback function takes the `tree` as broccoli tree contain all the files that want to run this transform and `options` map (optional) that contains the additional key value pairs that a consumer transformer provides. The later argument would be used by transformations like `amd` (explained below).

With this, we also should move the hard coded `amd` transform into an in-repo addon in Ember CLI. This would allow other addons that define their own transformation to also control the order of their transformation (using `before` or `after` hooks of addon initialization). The registeration of `amd` transform would be:

```js
importTransforms() {
  return {
    'amd': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        const name = options[relativePath].using;
        if (name) {
          return [
            '(function(define){\n',
            content,
            '\n})((function(){ function newDefine(){ var args = Array.prototype.slice.call(arguments); args.unshift("',
            name,
            '"); return define.apply(null, args); }; newDefine.amd = true; return newDefine; })());',
          ].join('');
        } else {
          return content;
        }
      });
    }
  }
}
```

As seen above, `options` contains the optional AMD module ID that the consumer of `amd` transform can provide. If registered transforms want to depend on any other user provided values, those can easily be available during the transforms.

When the addons are initialized, we will check if `importTransforms` is defined and store these callbacks and transform names in an array.

Now, if addon authors would like to use these transforms when importing libraries, they would simply do the following:

```js
app.import('/path/to/module.js', {
  using: [
    {  transformation: 'fastboot-shim' },
    { transformation: 'amd', as: 'some-dep' }
  ]
});
```

As seen above, an addon author could provide the list of transformations to run and Ember CLI would run them in the order of when the transformations were registered.
Internally, for every transform we will maintain an array of file paths that need to run this transform. When the transformations need to run, we will read the registration order, run the transformation on those files. The output of the transformation will then be merged back and then the next transformation would run. This will ensure that more than one transformation can be correctly applied to a module.

## Same name conflict

Allowing addons to define custom transform could lead to naming conflicts where more than two addons may provide transform functions with the same name but slightly or totally different functionality. Therefore, if more than one addon provides a same name for a transform by default the last addon in the order that registered its transform will win. In addition, we will also warn the users of the name conflicts and which addon's registered transformation is going to run.

# How We Teach This

The registeration of transform is an advanced API of Ember CLI that very few addons would use. We will be updating the guides [here](https://ember-cli.com/user-guide/#standard-anonymous-amd-asset).

# Drawbacks

The drawback of this approach is that the order of running the transformation is controlled by the addon that provides the transform rather than the addon that uses the transform. The reasoning for this is mainly for performance reasons (in order to not create a funnel per asset path) and to make sure the more than one transform can be applied correctly on an asset path.

# Alternatives

Currently the alternative is for addons to import their bower or npm dependency in `vendor` via `treeForVendor` and manually use broccoli plugins to do transformations. The alternative for apps is to create an in-repo addon to do this.

# Unresolved questions

 N/A


---

---
# FIXME: This may be a further stage or Discontinued.
# The v3.20.0 changelog mentions deprecating the packager experiment. Does that refer to this?
stage: accepted
start-date: 2017-09-07T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/110
project-link:
---

# Summary

The goal of this RFC is to solidify the next version of the mechanism that
`ember-cli` uses to build final assets. It will allow for a more flexible build
pipeline for Ember applications. It also unlocks building experimental features
on top. It is a backward compatible change.

# Motivation

The [Packager
RFC](https://github.com/chadhietala/rfcs/blob/packager/active/0002-packager.md)
submitted by [Chad Hietala](https://github.com/chadhietala) is a little over 2
years old. A lot of things have changed since then and it requires a revision.

The current application build process merges and concatenates input broccoli
trees. This behaviour is not well documented and is a tribal knowledge. While
the simplicity of this approach is nice, it doesn't allow for extension. We can
refactor our build process and provide more flexibility when desired.

Most importantly, the approach described below helps us achieve:

+ defining and developing a common language around the subject
+ removing highly coupled code and streamline technical implementation (Ember
  Engines and Fastboot)
+ unlock a whole different set of plugins we couldn't have before:
  + ability to create custom bundles (i.e per-engine and per-route bundles)
  + take advantage of [HTTP2
    multiplexing](https://http2.github.io/faq/#why-is-http2-multiplexed) and
    [cache
    pushing](https://www.mnot.net/blog/2014/01/30/http2_expectations#4-cache-pushing)
  + optimising plugins (JavaScript and CSS tree-shaking)

# Scope

+ New public API for customising build process and giving more granular control over
the final build output

# Terminology

+ **Packaging** - The process of designing, evaluating, and producing final build assets.

# Detailed design

The detailed design is separated in various sections so that it is easier for a
reader to understand.

## Packaging

It gives you granular control over the final build output. It could be used in many
different ways (we are going to go over use cases below). Note, it isn't meant to be
used for "postprocess" transformations; "postprocess" is called after packaging is
finished.

Currently, Ember.js application and all of its depedencies get assembled under one
directory with the following structure:

```ruby
bundler:js:input/
├── addon-tree-output/
├── the-app-name-folder/
├── node_modules/
└── vendor/
```

where:

+ `addon-tree-output` is a folder that contains dependencies from Ember add-ons.
+ `the-app-name-folder` is a folder that contains Ember application code.
+ `node_modules` is a folder that contains node dependencies.
+ `tests` is a folder that contains test code.
+ `vendor` is a folder that contains other dependencies.

Note, for clarity purposes we should rename `addon-tree-output` to `addon-modules` as
both `tree` and `output` don't communicate well about the contents of the folder.

During packaging process the final output will be generated (everything that currently
resides under `dist/` folder when a developer runs `ember build`).

### `package` API

A new public `package` method will be introduced to open up a way to customise packaging process:

```javascript
// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`
      // and return customised `inputTree`
    }
  });

  return app.toTree();
}
```

`package` function has the following signature:

```typescript
interface EmberApp {
  package(inputTree: BroccoliTree): BroccoliTree;
}
```

where `inputTree` will have the following structure:

```ruby
bundler:js:input/
├── addon-modules/
├── the-app-name-folder/
├── node_modules/
├── tests/
└── vendor/
```

Note, that `package` method must return a broccoli tree.

This change should be behind an experiment flag, `PACKAGING`.
This will allow us to start experimenting right away and not being
tied to a particular release cycle.

Note, that `package` is optional. If you don't define it, you're
effectively "opting out" of the feature and using the default
behaviour.

### `defaultPackager` API

It's important to make it easy for users to still use default Ember CLI
packaging.

`defaultPackager` is a way for the users to access out-of-the-box packaging while
still be able to customise the final build output.

```javascript
// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`

      return defaultPackager(app, inputTree);
    }
  });

  return app.toTree();
}
```

`defaultPackager` has the following signature:

```typescript
function defaultPackager(app: EmberApp, inputTree: BroccoliTreel): BroccoliTree;
```

`defaultPackager` must return a `BroccoliTree`.

### Possible usages

#### Debug/Analyse

One of the applications of `package` API would be to run different analysis on the
Ember applications. Take
[broccoli-concat-analyser](https://github.com/stefanpenner/broccoli-concat-analyser),
for example. This could be easily incorporated into the build.

```javascript
// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, { });

  app.package = function(inputTree) {
    const analysedTree = new BroccoliConcatAnalyser(inputTree);

    return defaultPackager(app, analysedTree);
  }

  return app.toTree();
}
```

#### Static Assets Split

One of the techniques for improving site speed is isolating changes throughout
application deployments. Assuming  the application assets are uploaded to CDN,
the reasoning is very simple: if `ember.js` or `jQuery` (possibly along with
other third party libraries) don't change with every deployment, why bust CDN
cache for them?

#### ES6 Modules

ES6 modules are [starting](https://caniuse.com/#feat=es6-module) to land in browsers.
This means that you can use `<script type="module" src="/my/app.js"></script>`.

This [article](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/) [explains](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/#is-this-really-worth-the-extra-effort) the benefits of using ES6 modules over ES2015 (smaller total file sizes, faster to parse and evaluate).

`package` API will make it possible to package your application for both ES2015 only browsers as well
the ones with ES6 modules support.

# Topics for Future RFCs

While working on this RFC, some ideas were brought into focus regarding existing
and new features in Ember CLI. They all likely require separate discussions in
future RFCs, but the discussion points have been included below.

## Tree-shaking

Firstly, what's _tree-shaking_? AFAIK, the term
[originated](https://groups.google.com/forum/#!msg/comp.lang.lisp/6zpZsWFFW18/-z_8hHRAIf4J)
in Lisp. The gist of the idea is "how about we start using _only_ the code that
we actually need?"

Secondly, how is it different from [Dead Code
Elimination](https://en.wikipedia.org/wiki/Dead_code_elimination)? [Rich
Harris](https://twitter.com/Rich_Harris)
[offers](https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80)
a pretty good explanation in the context of [Rollup](https://rollupjs.org/). The
gist is dead code elimination happens on a final product by removing bits that
are unused. Tree-shaking is quite different - given an object we want to construct, what is the exact set of dependencies we need?.

With this RFC, we lay out the foundation and create a framework by which both
dead code elimination and tree-shaking code be implemented.

However, there are still several things that are missing:

+ **Linker** - Responsible for resolving and reducing the graph to a tree
  containing only reachable modules.
+ **File System Resolver** - Responsible for connecting a module name with a
  file path.

`Linker` would be responsible for:

+ building a minimal dependency graph as well as check for redundant edges in
  the graph (more on the topic, [Transitive reduction of a directed
  graph](https://en.wikipedia.org/wiki/Transitive_reduction#Graph_algorithms_for_transitive_reduction));
+ producing an application tree with only used modules

Dependency graph represents dependencies using module names, there is a need to
be able to convert module name to file path. This is where `File System
Resolver` comes in. Here's couple of examples:

```javascript
fileSystemResolver.resolve('lodash') => `some-path/node_modules/lodash/lodash.js`
fileSystemResolver.resolve('ember-ajax') => `some-path/addon-modules/ember-ajax/index.js`
fileSystemResolver.resolve('ember-data') => `some-path/addon-modules/modules/ember-data/index.js`
fileSystemResolver.resolve('ember-data/-private') => `some-path/addon-modules/modules/-private.js`
```

This effort could be broken down into several phases:

+ dead modules elimination inside of the `addons/` (application would be the
  main entry point and unused modules are removed only from `addons/`)
+ dead modules elimination inside of the `app/`
  + removing unused components and helpers (requires analysing templates)
  + removing unused initializers/services (this likely entails work on
    dependency injection layer as we would need access to a resolver resolution
    map)
+ tree-shaking (Rollup-like tree-shaking where we include *only* the code that is
  used)

`Linker` would be able to take an `exclude` list of modules as a parameter.
Although, valuable in some situations, it should be clearly marked as advanced
API. It should be used as a last resort and serve as an "escape hatch".

It would make sense to implement `Linker` as a strategy. Developers would be
able to "opt in"/"opt out" of optimising behaviour.

## Deprecating `app.import` API

Ember applications which choose to use `Linker` strategy should be able to
remove usages of `app.import`.

## Tools

With growing complexity of Ember applications, it is crucial to provide more
insights into final assets.

Main goals are:

- report raw/uglified/compressed asset sizes;
  [broccoli-concat-analyser](https://github.com/stefanpenner/broccoli-concat-analyser)
- find source code duplication across your javascript assets (enables you to
  fine tune code splitting parameters to reduce bundle invalidation rates as
  well as improve repeat page load performance)

# How We Teach This

This is a backward compatible change to the existing Ember CLI ecosystem. In
order to teach users how to use `package` API, we need to update the API docs
with a section for this and the best practices of when to use this. A more
general purpose blog post could be beneficial as well.

# Drawbacks

There are several potential drawbacks that are worth noting.

_Build performance_. There is minimal overhead in instantiating strategies and
calling methods on them and I believe this approach shouldn't degrade build
performance.

_A note on add-ons_. Add-ons don't rely on the way Ember CLI does bundling. That
means existing build system continues to work as expected and add-ons won't have
to change their implementation.

# Alternatives

This RFC allows us to customise packaging when needed.
[Webpack](https://webpack.js.org) has become very popular in solving this
similar problem. One could implement a `package` function that would use Webpack
for packaging. Ultimately, we need something that is aware of how Ember apps are
assembled and how Ember apps utilise dependency injection that takes advantage
of existing tools. The long term plan is to have a dependency graph that is
aware of application structure so can avoid the "wall of configuration" that
other asset packaging systems are susceptible to.

# Unresolved questions

+ Will it increase build time?
+ Should we introduce the same API on add-on level?

# Thanks

Many thanks for [@stefanpenner](https://github.com/stefanpenner/),
[@rwjblue](https://github.com/rwjblue/) and
[@chadhietala](https://github.com/chadhietala/) for helping me to drive this
forward.


---

---
stage: discontinued # FIXME: Is this correct? We don't quite do what is specified here
start-date: 2018-01-04T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/114
project-link:
---

# Summary

Add https://github.com/rwjblue/ember-cli-template-lint as a default addon for the app and addon blueprints using the recommended rules.

# Motivation

Linting and security in templates would help not only individual developers write better apps with better accessibility and security, but would also help teams to be on the same page and stick to a handful of standards.

# Detailed design

1. Move ember-cli-template-lint to the ember-cli org (better for contributing and getting work off one person, @rwjblue)
2. Add the dependency to the app blueprint here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/package.json#L19
3. Also add it to the addon blueprint, like the eslint addon here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/addon/index.js#L66

# How We Teach This

The same way that we teach ESLint being on by default.

# Drawbacks

- More chatter in the terminal.
- An additional dependency.
- Recommended rules might not be good for everyone.. but that same issue probably exists with ESLint.

# Alternatives

Do nothing and have people write sub par template code.

# Unresolved questions

None


---

---
stage: recommended
start-date: 2018-02-12T00:00:00.000Z
release-date: 2018-07-02T00:00:00.000Z
release-versions:
  ember-cli: v3.2.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/116
project-link:
---

# Summary

Introduce [`qunit-dom`] as a dependency by default in the `app` and `addon` blueprints.

[`qunit-dom`]: https://github.com/simplabs/qunit-dom

# Motivation

> Why are we doing this?

In a modern Ember application making assertions around the state of the DOM is
fundamental to confirming your applications functionality. These assertions are
often quite verbose:

```js
assert.equal(this.element.querySelector('.title').textContent.trim(), 'Hello World!');
```

Using the `find()` helper of `@ember/test-helpers` we can simplify the DOM
element lookup, but the signal-to-noise ratio of the code is still not great:

```js
assert.equal(find('.title').textContent.trim(), 'Hello World!');
```

With `qunit-dom` we can write much more readable assertions for DOM elements:

```js
assert.dom('.title').hasText('Hello World!');
```

> What use cases does it support?

It supports the most common assertions on DOM elements, like:

- what text does the element have?
- what value does the `<input>` element have?
- is a certain CSS class applied to the element

The full API is documented at <https://github.com/simplabs/qunit-dom/blob/master/API.md>.

> What is the expected outcome?

Using `qunit-dom` will lead to more simple and readable test code.


# Detailed design

The necessary changes to `ember-cli` are relatively small since we only need
to add the dependency to the `app` blueprint, and the `addon` blueprint will
inherit it automatically.

This has the advantage (over including it as an implicit dependency), that
apps and addons that don't want to use it for some reason can opt-out by
removing the dependency from their `package.json` file.

A WIP pull request has been created already at <https://github.com/ember-cli/ember-cli/pull/7605>.


# How We Teach This

> Would the acceptance of this proposal mean the Ember guides must be
> re-organized or altered? Does it change how Ember is taught to new users
> at any level?

Once we decide that this is the right way to go, we should update the official
Ember.js testing guides to use `qunit-dom` assertions by default. This has the
nice side effect of making the testing code in the guides easier to read too.

At the same time (same minor release) we should update the relevant blueprints
in the `ember-source` package to use `qunit-dom` by default. This should be a
relatively small change as only the `component` and `helper` tests use
DOM assertions.

> How should this feature be introduced and taught to existing Ember
> users?

We should also explicitly mention this change in the release blog post and
recommend that people use this from now on. For those users that want to
migrate their existing tests to `qunit-dom` a basic codemod exists at
<https://github.com/simplabs/qunit-dom-codemod>.


# Drawbacks

> Why should we *not* do this? Please consider the impact on teaching Ember,
> on the integration of this feature with other existing and planned features,
> on the impact of the API churn on existing apps, etc.
>
> There are tradeoffs to choosing any path, please attempt to identify them here.

- `qunit-dom` is "owned" by a third-party consulting company (simplabs) and
  the Ember CLI team is not directly in control.

- `qunit-dom` has not reached v1.0.0 yet so there might be small breaking
  changes in the future.

- `qunit-dom` is another abstraction layer on top of the raw QUnit assertions
  which adds to the existing learning curve.

- Adding `qunit-dom` to the default blueprint could make it look even more like
  `ember-mocha` is only a second-class citizen. Since we add it to the default
  `package.json` file it is easy to opt-out though and can be replaced with
  `chai-jquery` or `chai-dom` for a roughly similar API.


# Alternatives

> What other designs have been considered?

- Using the `find()` helper functions can be considered an alternative, but
  as mentioned above they still result in more verbose code than using
  `qunit-dom`. Another advantage is that `qunit-dom` generates a useful
  assertion description by default, while `assert.equal()` will just show
  something like "A does not match B".

> What is the impact of not doing this?

We will keep using hard-to-read assertions by default and leave it up to our
users to discover `qunit-dom` by themselves.


# Unresolved questions

- Should the `ember-source` blueprints detect `qunit-dom` usage and fallback
  to raw QUnit assertions if the dependency can't be found?


---

---
stage: recommended
start-date: 2018-07-30T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/120
project-link:
---

# Ember CLI Docs

## Summary

This RFC proposes converting the existing [Ember CLI website](https://ember-cli.com/) into an
Ember app, restructuring the table of contents, replacing a significant
portion of the learning material, and inviting community members to participate in writing new content.

## Motivation

The purpose of these changes are to empower new contributors, create a consistent
narrative structure, correct outdated information, and lead new readers through an easier learning progression.

Ember's public sites are being migrated from Ruby apps to Ember apps
in order to improve maintainability and empower new contributors. The CLI docs
are currently a Jekyll app. Similar migrations have been very successful.

The rewrite and/or reorganization of content is driven by an audit of the existing
content's relevance and balance. While trying to plan a refactor in place, it became clear that a greenfield approach is more time efficient and will lead to a
better learning experience. A significant portion of the content from the current guides site can be ported over once a new structure is in place.

## Detailed design

This app will have a new table of contents. The architecture will follow the
same patterns successfully used in other apps that have been converted from
Middleman apps to Ember.

### Writing process

Writing new content and porting over existing information is a job that will require the help of many contributors! After this RFC is accepted, a call for contributors will be made.

Here are some strategies to help contributor work to be successful:
- A quest issue will outline sections that need work so that people can volunteer
- Collaboration will be encouraged so that no one person blocks writing on a particular topic
- Contributing can take multiple forms. For example, developers with some CLI expertise who don't have time/interest for formal writing can share some brief notes or suggestions to help out the writers. Writers don't need to be experts. In some cases, it's better when someone isn't very familiar with the content because they can help identify gaps.
- Each unwritten section will have comments in the markdown indicating which topics to cover. In cases where content has been ported over, comments will indicate which sections to fact-check, clarify, or revise.
- A strike team channel will be created on a chat
- A writing styleguide will be provided for contributors
- Following a verson one release, writing work will be organized via normal GitHub issues.

Since maintaining consistent voice and structure across a blank slate is a challenge, beta content for the core learning experience has already been drafted, including Basic Use guides and a tutorial for creating an addon from start to finish.

The beta version of the CLI Guides content can be found at [ember-learn/cli-guides-source](https://github.com/ember-learn/cli-guides-source). The Markdown files there are rendered by [ember-learn/cli-guides-app](https://github.com/ember-learn/cli-guides-source). The app is currently deployed to a temporary endpoint for testing and UX validation. The link is available on the repositories.

### User Personas

The content layout should follow the progression of an Ember developer's
learning experience. There are four main user personas for the
CLI documentation:

1. A new or "typical" Ember CLI user - someone whose primary work is
running common commands like `ember serve` and who has a "zero
config" type of experience with Ember
2. Power users - developers who make their own configurations to the
build pipeline
3. Beginner addon authors - those who are looking to build simple
shared UI components, methods, or wrappers for existing npm libraries
4. Advanced addon authors - those who dig into internals to make their
addon work, or who are planning for broad extensibility

### Table of Contents

Applying these User Personas to the CLI content, the following topics layout emerges. "Beginner" topics will include links to later "Advanced"
topics, similar to how the Guides link to the API docs.

- Introduction
    - how to install ember cli
    - a very simple, short definition of what it is (the official way to create, build, and test an Ember app)
    - Why is the CLI needed
    - Guidance on learning path
    - How to contribute
- Basic use (explain options of each)
    - CLI Commands: Explain how to use the `help` command and common commands like `ember new`, `ember server`, `ember generate`, etc. Each is explained briefly, together with an example usage and a link to the Main Ember Guides with more information about how to use those files.
    - How to find and use addons
    - How to use npm packages
    - Installation and Upgrading the CLI (including a note about upgrading your app, with a link to more resources)
    - feature flags & configurations
- Advanced use
    - shims
    - broccoli
    - custom blueprints
    - CSS compilation
    - Using another testing library
    - more on dependencies
    - more configurations
- Writing Addons
    - Overview
    - Tutorial: Creating a standalone addon and an in-repo addon,
    - Using the dummy app
    - Including assets
    - Configuration
    - Nested addons
    - Testing your addon
    - Sharing your addon (deploying)
- API Documentation
    - brief description of the target audience and a link

### Versioning

Only one version of the documentation will be deployed and maintained.
The documentation app itself will have clear releases
as major changes are made, so that users working on
older apps can still go back in time if they need to.

The url will contain `/release/` so that if versioning is needed in the future,
the option is available.

### Transition and legacy links

While the project is in development, it will be worked on as a separate site, and the main site, [https://ember-cli.com](https://ember-cli.com) will remain in place.

Legacy links should be maintained because deprecating the links would cause SEO problems. Consensus seems to be that the best option is to create individualized redirects from pages within [https://ember-cli.com](https://ember-cli.com) to the new site.

Upon reaching feature parity, [https://ember-cli.com](https://ember-cli.com) will redirect to the new site. Ultimately, content will be hosted at [https://cli.emberjs.com/](https://cli.emberjs.com/). This improves the SEO of our emberjs domain.

### Application architecture

The application architecture will follow similar patterns as other Middleman
apps that have been successfully turned into Ember apps. Some examples of past conversions are:

- [Deprecations](https://github.com/ember-learn/deprecation-app)
- [The Guides](https://github.com/ember-learn/guides-app)
- [The API docs](https://github.com/ember-learn/ember-api-docs)

[Chris Manson](https://github.com/mansona?tab=overview&from=2018-06-01&to=2018-06-30) has a project in development that automates the creation of documentation apps, integrating the lessons learned from these past conversions. Early results are looking great!

The resulting app will make use of typography and UI assets from
[ember-styleguide](https://github.com/ember-learn/ember-styleguide)

Although only one version will be deployed/maintained for the forseeable future, the URL structure will allow for future growth, i.e. `https://cli.emberjs.com/release/some-topic`

### Maintaining content

With module unification and tree shaking refactors underway, there may be some big changes to Ember's
file structure. There are a few ways to mitigate this, while still maintaining only one version of these guides:

1. Whenever possible, the CLI guides should link to the Ember Guides. The details of file layout and syntax are best handled in a resource that is versioned.
2. The CLI guides can also frequently give a nod to past configurations/features. A url checker will make sure that these "legacy" resource links still exist. The pace of major version releases is slow enough that this should be sustainable.
3. As mentioned earlier, the urls for the cli guides will include `/release/` in case future versioning is needed

Members of both the Learning Core Team and Ember CLI Core team will have merge access.

## How we teach this

Overall, bringing the CLI docs content up to speed and making it
more maintainable should result in better integration of the
CLI documentation into the Guides. The current content is out
of date, and so it is not frequently linked.

The impact to new users will be a better experience. Existing
Ember users may have an adjustment period to learn the new layout,
but the current layout is confusing, so we believe there will be
net improvement from day one. The addition of search tools will help
with the transition.

Links in the Guides will need to be updated to point
to the new documentation app. There are 41 links to the
current ember-cli website, but only a handful are unique.

The Ember CLI website is not referenced in the API docs.

## Drawbacks

Some potential drawbacks include:

- Old bookmarks will still point to old content, and it is significant engineering effort to maintain those legacy links
- Users may be used to finding content in a particular place
- Some existing content will be deemphasized or removed
- It's another app to keep in step with the main website

## Alternatives

An alternative is to refactor the content in place. This will be more
time consuming, and will not achieve a consistent narrative voice or cumulative learning experience.


---

---
stage: discontinued # FIXME: Is this correct? Doesn't appear to be the recommended way of doing it.
start-date: 2016-02-11T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/120
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/13016
---

# Summary

This RFC proposes replacing the existing [`Route#serialize`](http://emberjs.com/api/classes/Ember.Route.html#method_serialize) method with an equivalent method on the options hash passed into [`this.route` within `Router#map`](http://emberjs.com/api/classes/Ember.Router.html#method_map). The primary goal here is to enable asynchronous Engines by decoupling information about how to link to a route from the actual route object.

# Motivation

As we move towards an increasingly asynchronous world with Engines, we need to separate knowledge about how to _**link** to a route_ and how to _**enter** a route_. Linking to a route should be able to happen _before_ a route object is instantiated, which is the behavior needed to asynchronously load Engines. However, in our current reality, these concerns are coupled and a route object must be instantiated before being able to link to _or_ enter a route.

By separating these concerns, we can preemptively load the information on how to link to a route without also requiring all the knowledge of how to enter that route. This would be beneficial in both the asynchronous and synchronous worlds by allowing us to defer work.

Since the `serialize` method is the only method currently used by the `Route` class to define how to link to a route, the proposal is to extract this method into the space which currently contains the other linking information (e.g., the Router's map).

_**Note:** this separation of concerns will also need to be implemented in router.js for the preemptive loading proposed here to actually work, but we can prepare for that future world by creating a separation of concerns within application code now._

# Detailed Design

Since the current API is a simple function, the new hash option will also be a simple function that mirrors the signature of the original. Here's an example:

```js
// app/router.js
function serializePostRoute(model, params) {
  // serialize the model into the dynamic paths
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
```

Preserving the current function signature means that refactoring existing code should be simple in most cases. Here's the example currently given in the Ember docs (updated to reflect Ember-CLI):

```js
// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  },

  serialize(model) {
    // this will make the URL `/posts/12`
    return { post_id: model.id };
  }
});

// app/router.js
export default Router.map(function() {
  this.route('post', {
    path: '/post/:id'
  });
});
```

Here is that same code refactored for the proposal:

```js
// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  }
});

// app/router.js
function serializePostRoute(model) {
  // this will make the URL `/posts/12`
  return { post_id: model.id };
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
```

# Migration Plan

Even though the refactoring needed here is easy, we still need a clear (though simple) migration plan.

The first step will be to introduce the new option into the Router's callback `route` function. Once that is done, we can deprecate `Route#serialize` over the remainder of the 2.x series to give developers the time to update their code base. We can then remove support in 3.x.

As noted in the "Motivation" section, there is still work to be done in router.js in order to support this separation of concerns. Due to this, the initial implementation of this new option will essentially be a polyfill that proxies to the corresponding `Route#serialize` property internally. This will set us up for an internal migration at a later point to actually separate the two; this, however, should not affect developers as it will be internal.

# Pedagogy (How We Teach This)

Once the new option is introduced, the Ember guides will need to be updated to reflect this. Those changes should be relatively straightforward as shown in the example above. This will help introduce the feature to new users and those users that haven't used `Route#serialize` before. Since inline serializers in the router map can be distracting to understanding the general layout of a codebase, we should teach them as defined outside the map itself (as in the code example in this RFC).

For existing users, we can introduce this feature through deprecation warnings (as mentioned above). The deprecations should briefly introduce the new option and point to an appropriate deprecation guide that explains how to migrate.

# Drawbacks

- Adds another option to the Router map. Though this is largely mitigated due to the fact that this feature is not in wide use currently.
- Can be sort of ugly to format.

# Alternatives

- Introduce a standalone module to represent the `Route#serialize`. This was the first proposal of this RFC and there is much opposition to introducing yet another construct for Ember-CLI and developers to manage. The approach proposed above avoids this major drawback.
- Introduce a holistic construct to represent route linking information. Instead of introducing a new option as a function, we could introduce a class that would represent all the information needed to link to a route. Since there is not currently much other information needed, this seems overkill and would suffer similar opposition as the first alternative.
- Don't do this and continue loading and instantiating all route information upfront. This prevents us from improving performance by keeping concerns coupled with prevents introducing async engines. It also requires all Route classes be instantiaed upfront.

# Unresolved Questions

- Do we wish to apply a similar approach for default query params? And if so, do we wish to incorporate that approach into this new construct?


---

---
stage: recommended
start-date: 2018-08-13T00:00:00.000Z
release-date: # FIXME
release-versions:
  ember-cli: v3.17.0

teams:
  - cli
prs:
  accepted: https://github.com/ember-cli/rfcs/pull/121
project-link:
---

# Summary

Remove https://github.com/ember-cli/ember-cli-eslint from projects generated by
`ember-cli`.

[ember-cli-eslint](https://github.com/ember-cli/ember-cli-eslint) is an addon
designed to show lint errors during test runs. Tooling around `eslint` has
improved enough where this feature may no longer be necessary.

To be clear, the proposal is _not_ to remove linting in tests. It is to follow
the rest of JavaScript community and follow the standard tooling process.

There are multiple ways to run `eslint`:

1. Integration with editors
2. Utilize precommit hooks with `eslint`
3. Support a standard way to run `eslint` (such as `yarn lint:js`)

We can also discuss configuring `testem` to automatically run `eslint` as part
of `yarn test`

# Motivation

1. Improve our build speed
2. Simplicity. `eslint` is common among JS stack, and integrations with editors
   / precommit-hooks are ubiquitous. Removing this layer of abstraction will
   simplify how `eslint` is used throughout `ember-cli`. Most editors have
   plugins available for `eslint`, and as long as the `.eslint.rc` is not
   removed, we should still see the benefits of `eslint` in our Ember projects.
3. Hacks required to support features such as [PR #122
   broccoli-lint-eslint](https://github.com/ember-cli/broccoli-lint-eslint/pull/122#discussion-diff-153937455R28)

# Detailed design

1. Change blueprint to pull in `eslint` as opposed to `ember-cli-eslint` under
   `devDependencies`.
2. Provide documentation on `eslint` and editor integration as well as precommit hooks

Redefine `npm test` or `yarn test` (depending on whether the `--yarn` option was
used to create project) to

```
ember test && npm run lint:js && npm run lint:hbs
```

and

```
ember test && yarn lint:js && yarn lint:hbs
```


# How We Teach This

Providing documentation regarding how to run linting should suffice as well as
documentation to editor integration.

Deleting abstractions and going towards a explicit path, `eslint` within the
`ember-cli` ecosystem becomes _easier_ to teach.

# Drawbacks

1. No console warnings during builds
2. lint failures are no longer included in browser tests

# Alternatives

1. Leave `ember-cli-eslint` alone

# Unresolved questions

N/A


---

---
stage: recommended # FIXME: Should this be discontinued?
start-date: 2016-04-16T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/136
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/13553
---

# Summary

[`contains`](http://emberjs.com/api/classes/Ember.Array.html#method_contains) is
implemented on `Ember.Array`, but [contains was renamed to includes in 2014]
(https://github.com/tc39/Array.prototype.includes/commit/4b6b9534582cb7991daea3980c26a34af0e76c6c)
- this proposal is for `contains` to be deprecated in favour of an `includes`
method on `Ember.Array`

# Motivation

Motivation is to stay in line with web standards

# Detailed design

First, implement `includes` polyfill in compliance with `includes` spec. Polyfill
sample from MDN is:

```js
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
    'use strict';
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {k = 0;}
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
         (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}
```

Then, alias `contains` to `includes` with deprecation warning, deprecate in line with standard
deprecation process. I don't believe that adding the additional parameter will
have any affect on existing usage of `contains`.

# How We Teach This

* Update any references in docs and guides to `includes`
* Write a deprecation guide, mentioning any edge cases where the new `includes` behaves differently to `contains`, and giving migration examples
* Indicate in api docs that this is a polyfill

# Drawbacks

* May break existing apps
* [Was considered before but was too early](https://github.com/emberjs/ember.js/issues/5670#issuecomment-64084814)

# Alternatives

Keep current methods

# Unresolved questions

None


---

---
stage: recommended
start-date: 2016-04-18T00:00:00.000Z
release-date: 2016-09-08T00:00:00.000Z
release-versions:
  ember-source: v2.8.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/139
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/13666
---

# Summary

Introduce `Ember.String.isHtmlSafe()` to provide a reliable way to determine if an object is an "html safe string", i.e. was it created with `Ember.String.htmlSafe()`.


# Motivation

Using `new Ember.Handlebars.SafeString()` is slated for deprecation. Many people are currently using the following snippet as
a mechanism of type checking: `value instanceof Ember.Handlebars.SafeString`. Providing `isHtmlSafe` offers a
cleaner method of detection. Beyond that, the aforementioned test is a bit leaky. It requires the developer to understand
`htmlSafe` returns a `Ember.Handlerbars.SafeString` instance and thus limits Ember's ability to change
`htmlSafe` without further breaking it's API.

Based on our app at Batterii and some research on Github, I see two valid use cases for introducing this API.

First, and most commonly, is to make it possible to test addon helpers that are expected to return a safe string. I believe this test on ember-i18n says it all: ["returns HTML-safe string"](https://github.com/jamesarosen/ember-i18n/blob/master/tests/unit/utils/i18n/default-compiler-test.js#L56-L59).

The second use case is to do type checking. In our app, we have an `isString` utility that is effectively:

```javascript
import Ember from 'ember';

export default function(value) {
  return typeof value === 'string' || value instanceof Ember.Handlebars.SafeString;
}
```

Newer versions of ember-i18n, doing `this.get('i18n').t('someTranslatedValue')` will return a safe string. Thus our `isString` utility has to consider that.


# Detailed design

`isHtmlSafe` will be added to the `Ember.String` module. The implementation will basically be:

```javascript
function isHtmlSafe(str) {
  return str && typeof str.toHTML === 'function';
}
```

It will be used as follows:

```javascript
if (Ember.String.isHtmlSafe(str)) {
  str = str.toString();
}
```


# Transition Path

As part of landing `isHtmlSafe` we will simultaneously re-deprecate `Ember.Handlebars.SafeString`. This deprecation will
take care to ensure that `str instanceof Ember.Handlebars.SafeString` still passes so that we can continue to
maintain backwards compatibility.

Additionally, a polyfill will be implemented to help provide forward compatibility for addon maintainers and others
looking to get a head while still on older versions of Ember. Similar to [ember-getowner-polyfill](https://github.com/rwjblue/ember-getowner-polyfill).


# How We Teach This

I think we'll continue to refer to these strings as "html safe strings". This RFC does not
introduce any new concepts, rather it builds on an existing concept.

I don't believe this feature will require guide discussion. I think API Docs will suffice.

The concept of type checking is a pretty common programming idiom. It should be relatively self
explanatory.


# Drawbacks

The only drawback I see is that it expands the surface of the API and it takes a step
towards prompting "html safe string" as a thing.


# Alternatives

An alternative would be to expose `Ember.Handlerbars.SafeString` publicly once again. Users
could revert back to using `instanceof` as their type checking mechanism.


# Unresolved questions

There are no unresolved questions at this time.


---

---
stage: released # FIXME: Is this correct? Or is it Discontinued?
start-date: 2016-05-09T00:00:00.000Z
release-date: # FIXME
release-versions:
  # ember-cli: FIXME - v2.16 or earlier

teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/143
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/27 / https://github.com/emberjs/ember.js/issues/14882
---

> Note: This RFC replaces the closely related RFC for [Module
Normalization](https://github.com/emberjs/rfcs/pull/124). As discussed in the
[Alternatives](#alternatives) section below, many concepts are shared between
the two proposals, but there is also a fundamental difference.

# Summary

Create a unified pattern for organizing and naming modules in Ember projects
that is deterministic, extensible, and ergonomic.

# Motivation

Ember CLI's conventions for project layouts and file naming are central to every
Ember developer's experience. It's crucial to get both the technical and
ergonomic details right.

The existing conventions used by Ember CLI have evolved gradually and
organically over the years. Ember CLI and its predecessor Ember App Kit were
early adopters of ES modules and have always leveraged strong conventions to
deduce an understanding of modules based on their locations. Ember CLI's
resolver encodes those conventions to enable run-time module resolutions.

The current system works fairly well, but has some complexities and
inconsistencies that both steepen its learning curve and limit its technical
potential.

Drawbacks include:

* Confusion over which of two orthogonal approaches to use for organizing
  modules:

  * classic - modules are organized at the top-level by "type"
    (`components`, `templates`, etc.) and then by namespace and name.

  * pods - modules are organized by namespace, then name, then type.

* Addons define modules to be merged into an application through a special `app`
  directory. These public modules are typically private modules that are
  imported and re-exported, which introduces an extra module per export and an
  extra level of abstraction to learn.

* Because addons' modules are mixed into an application, there's the possibility
  of naming collisions between two addons or an addon and its consuming
  application.

* Modules don't have a clear sense of "locality", which prevents the ability to
  declare modules that are available only in a "local" namespace (this as-yet
  unsupported feature has been called "local lookup").

* Resolution rules that are declared only in JavaScript are difficult to
  analyze and optimize.

* Module resolution is inefficient due to the number of potential places to
  lookup a particular module by name.

Recognizing these drawbacks, the Core Team compiled a set of
[design constraints](https://github.com/emberjs/core-notes/blob/master/ember.js/2016-01/january-22.md#summary-of-pods-design-constraints)
for a rethink of Ember's approach to modules:

1. Reasonable branching factor. Users should see a reasonable number of items at any given level in their hierarchy. Flattening out too much results in an unreasonably large number of items.
2. No slashes in component names. The existing system allows this, but we don't want to support invocation of nested components in Glimmer Components.
3. Addons need to participate in the naming scheme, most likely with namespace prefix and double-colon separator.
4. Subtrees should be relocatable. If you move a directory to a new place in the tree, its internal structure should all still work.
5. There should be no cognitive overhead when adding a new thing. The right way should be obvious and not impose unnecessary decisions.
6. We need clean separation between the namespace of the user's own components, helpers, routes, etc and the framework's own type names ("component", "helper", etc) so that we can disambiguate them and add future ones.
7. Ideally we will have a place to put tests and styles alongside corresponding components.
8. Local relative lookup for components and helpers needs to work.
9. Avoid the "titlebar problem", in which many files are all named "component.js" and you can't tell them apart in your editor.
10. The resolver should be configured via declarative rules, not imperative
    JavaScript. In addition to enforcing consistency, this allows addons to
    augment the system with their own types in a predictable way.
11. Module structures must be statically analyzable at build time to enable
    efficiency optimizations.
12. Module classifications must be extensible and allow for customizations by
    apps, engines, and addons.

> Note: Constraints > 9 were added based on discussions subsequent to the
initial meeting.

This proposal attempts to address these constraints with a single consistent
approach to modules that will make Ember easier to use and learn _and_ improve
the efficiency of Ember's resolver at run-time.

# Detailed Design

This proposal introduces a new top-level directory, `src`, and establishes
conventions for organizing modules within it. Also proposed is a refactor of the
Ember resolver to enable efficient and flexible resolutions based upon the new
module conventions.

The `src` directory will be used to contain the core ES modules within an Ember
CLI project, whether that project contains an application, addon, or engine. To
maintain backward compatibility, the `src` directory will be allowed to
co-exist alongside existing `app` and/or `addon` directories, although these
directories should eventually be deprecated.

## Examples

Let's start by taking a look at some examples of Ember projects organized
according to the proposed conventions.

### Example Application

A simple blogging application could be structured as follows:
```
src
├── data
│   ├── models
│   │   ├── comment
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   ├── post
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   └── author.js
│   └── transforms
│       └── date.js
├── init
│   ├── initializers
│   │   └── i18n.js
│   └── instance-initializers
│       └── auth.js
├── services
│   └── auth.js
├── ui
│   ├── components
│   │   ├── date-picker
│   │   │   ├── component.js
│   │   │   └── template.hbs
│   │   └── list-paginator
│   │       ├── paginator-control
│   │       │   ├── component.js
│   │       │   └── template.hbs
│   │       ├── component.js
│   │       └── template.js
│   ├── partials
│   │   └── footer.hbs
│   ├── routes
│   │   ├── application
│   │   │   └── template.hbs
│   │   ├── index
│   │   │   ├── controller.js
│   │   │   ├── route.js
│   │   │   └── template.hbs
│   │   └── posts
│   │       ├── -components
│   │       │   ├── -utils
│   │       │   │   └── strings.js
│   │       │   ├── capitalize.js
│   │       │   └── titleize.js
│   │       ├── post
│   │       │   ├── -components
│   │       │   │   └── post-viewer
│   │       │   │       ├── component.js
│   │       │   │       └── template.hbs
│   │       │   ├── edit
│   │       │   │   ├── -components
│   │       │   │   │   ├── post-editor
│   │       │   │   │   │   ├── post-editor-button
│   │       │   │   │   │   │   ├── component.js
│   │       │   │   │   │   │   └── template.hbs
│   │       │   │   │   │   ├── calculate-post-title.js
│   │       │   │   │   │   ├── component.js
│   │       │   │   │   │   └── template.hbs
│   │       │   │   │   ├── route.js
│   │       │   │   │   └── template.hbs
│   │       │   │   ├── route.js
│   │       │   │   └── template.hbs
│   │       │   ├── route.js
│   │       │   └── template.hbs
│   │       ├── route.js
│   │       └── template.hbs
│   ├── styles
│   │   └── app.scss
│   └── index.html
├── utils
│   └── md5.js
├── main.js
└── router.js
```

### Example Engine

An engine could provide the same blogging functionality with almost entirely the
same module structure as the example blog application. Only the following
notable changes would be needed:

* An engine should declare its routes in `src/routes.js` instead of `src/router.js`
* An engine would require a `dummy` app within `tests`
* An engine should export an `Engine` instead of an `Application` from `src/main.js`

### Example Addon

Here's how the
[ember-power-select](https://github.com/cibernox/ember-power-select) addon could
be restructured:

```
src
├── styles
│   └── ember-power-select.scss
├── ui
│   └── components
│       ├── main
│       │   ├── before-options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       ├── multiple
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       └── is-selected.js
└── main.js
```

### Migration Tool

As a proof of concept for the module layout described in this RFC, Robert
Jackson has created a [migration
tool](https://github.com/rwjblue/ember-module-migrator) and used it to migrate
the following repos:

* [Ghost admin client](https://github.com/rwjblue/--ghost-modules-sample/tree/grouped-collections/src)
* [Travis client](https://github.com/rwjblue/--travis-modules-sample/tree/modules/src)
* [`ember new my-app`](https://github.com/rwjblue/--new-app-blueprint/tree/modules/src)

You can also use Robert's migration tool on your own projects to gain a feel for
how this RFC will affect your work.

## ES Modules

It's important to understand how ES module paths are mapped from the file
system so that you can import modules from elsewhere in your project and its
associated dependencies.

ES module paths will be formed from a project's package name followed by a
direct mapping of file paths from the project root. The file's final extension
(e.g. `js` or `hbs`) will be excluded because all ES modules will of course be
compiled into JavaScript from their original format.

For example, the file `src/ui/components/date-picker.js` in the
`my-calendar` app will be exported with the module path
`my-calendar/src/ui/components/date-picker`.

An application and its associated addons and engines will all be merged into the
same ES module space, as is done today. Any module can import from any other
module within this space, although cross-package imports should be done with
care.

## Module Naming and Organization

This section describes the conventions proposed for naming and organizing a
project's modules within `src`. These conventions will allow Ember CLI's
resolver to determine the purpose of each module at run-time. They will also
enable static analysis of modules to lint against errors and to prepare a
normalized map for efficient resolutions.

Every resolvable module must have both a `name` and a `type`. The `type`
typically corresponds to the base class of the module's default export (e.g.
`route`, `template`, etc.).

Modules can be grouped together with other modules of related types in
"collections". Collections are directories with type-aware resolution rules
which allow related modules to share a namespace. For example, the `models`
collection contains models, adapters, and serializers.

Collections that are related to each other can be further organized in "group"
directories. For example, the `ui` group contains the `components`, `partials`,
and `routes` collections.

Ember CLI will have a build step that normalizes modules to a common form and
builds a mapping between that form and the ES module path described above.
While building this normalized map, the build must error and provide useful
messages if any module naming errors are detected. Unregistered collections and
types should not be allowed. Also, the same normalized module path must not be
repeated through alternative naming forms.

### Module Type

The type of a module can be determined through the following file naming and
module export rules:

1. `src/${type}` - typed modules named `main` (explained further below), in
    which default exports match the type specified by the file name.
2. `src/${collection}/${namespace}/${name}/${type}` - expanded collection
    modules, in which default exports match the type specified by the file name.
3. `src/${collection}/${namespace}/${name}` - in which type can be inferred
    based on the module's exports. Default exports must match the default
    type for the collection. If there is no default export, named exports will
    be scanned for a matching type allowed in the collection.

Note that template precompilers will need to use default vs. named exports
appropriately in order to satisfy the expectations of Rules 2 and 3.

Here are a few example applications of the module type determination rules:

```
// Rule 1

src/router (with `export default Ember.Router.extend()`)
=> name: 'main',
   type: 'router'

// Rule 2

src/ui/routes/posts/post/route.js (with `export default Ember.Route.extend()`)
=> collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'route'

src/ui/routes/posts/post/template (with `export default Ember.HTMLBars.template(COMPILED)`)
=> collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'template'

// Rule 3

src/data/models/author (with `export default DS.Model.extend()`)
=> collection: 'data/models',
   name: 'author',
   type: 'model' (the default type for the models collection)

src/ui/components/titleize (with `export let helper = Ember.Helper.helper(function() { })`)
=> collection: 'ui/components',
   name: 'titleize',
   type: 'helper'

src/ui/components/show-title (with `export let template = Ember.HTMLBars.template(COMPILED)`)
=> collection: 'ui/components',
   name: 'show-title',
   type: 'template'
```

### Main Modules

Every project must have a "main" module, named `src/main.js`, that
serves as an entry point into the project.

The main module must export an `Application`, `Engine`, or (new) `Addon` class.
This class must define a `modulePrefix`, which must match the node package name
for the project.

The main module also declares other properties that help the Ember resolver
understand relationships between projects. For instance, the main module can
declare which modules in an addon are available to a consuming app's resolver.

The main module of an addon can also declare a `rootName`, which is used by the
resolver to lookup main modules. Initially, the `rootName` will be a read-only
property that equals the `modulePrefix` with any `ember-` and  `ember-cli-`
prefixes stripped (e.g. `ember-power-select` becomes `power-select`). It's
possible that we may allow overrides / aliases in the future.

Modules that appear alongside `main.js` in `src` are also considered `main`
modules for their respective `type`. For instance, `src/router.js` is registered
with a `name` of `main` and a `type` of `router`.

### Module Collections

Top-level namespaces within `src` serve to group modules into
type-aware "collections".

The following rules apply to module collections and types:

1. Each collection can contain one or more types. The types allowed
   in a particular collection MUST be explicitly declared.
2. Each type MAY exist in any number of collections.
3. Each type MUST have only one "definitive collection", which is the
   collection the resolver will use for resolutions if a module can't be found
   in the local (i.e. originating) collection.
4. Each collection MAY have a single "default type". If a module does not
   indicate its type through its file name, then its default export should
   align with the default type for its collection.
5. Each collection can allow "private collections" to be defined at a namespace.
   Private collections are localized additions to a top-level collection,
   available only from the namespace at which they're defined.
6. Top-level collections may be grouped for organization purposes. No
   resolvable modules must be placed in a group directory.
7. A collection can appear only once in a project (i.e. it can not be
   contained in multiple group directories, or in a group as well as at the
   top-level).

The following collections and allowed types (rules 1 & 2) are proposed:

* `components` - COMPONENT, HELPER, template
* `initializers` - INITIALIZER
* `instance-initializers` - INSTANCE-INITIALIZER
* `models` - MODEL, ADAPTER, SERIALIZER
* `partials` - PARTIAL
* `routes` - ROUTE, CONTROLLER, template
* `services` - SERVICE
* `transforms` - TRANSFORM
* `utils` - UTIL

> Note: ALL CAPS indicates which collections are definitive (rule 3) for a type.

The following default types are proposed for collections (rule 4):

* `components` - component
* `initializer` - initializer
* `instance-initializers` - instance-initializer
* `models` - model
* `partials` - partial
* `routes` - route
* `services` - service
* `transforms` - transform
* `utils` - util

The following private collections are allowed within collections (rule 5):

* `components` - utils
* `models` - utils
* `initializers` - utils
* `instance-initializers` - utils
* `routes` - components, utils
* `services` - utils
* `transforms` - utils

The following groups are proposed for collections (rule 6):

* `data` - models, transforms
* `init` - initializers, instance-initializers
* `ui` - components, partials, routes

The collection and type system is designed to be extensible, so that addons can
contribute their own collections and types. The `data` collection and its
corresponding types should be defined in ember-data. Liquid-fire might want to
define an `animations` collection and a `transition` type, and expand `routes`
to allow `animations` as a private collection.

The specific format of collection and type declarations for addons is TBD.

#### "Components" Collection

This proposal broadens the scope of the term "component" to include all
template-invocable parts of Ember. This includes today's components and helpers,
and the future implementation of "glimmer components" (with angle brackets) and
element modifiers.

Grouping template-invocable elements together in a single collection recognizes
that they already coexist in the same namespace. After all, only one helper OR
component can be invoked as `{{foo-bar}}`. Using a common collection will not
only simplify file management and searching, it will also provide implicit
linting against creating a helper and class-based component of the same name.

#### Private Collections

You may wish to make a component available in a particular template without
polluting the top-level `components` collection with a more local concern.
Private collections allow you to augment a top-level collection's contents for
use at a particular namespace.

Private collections are declared as a directory sharing the name of the
top-level collection, prefixed with a `-`. So the top-level `routes`
collection could be augmented via a private `-components` collection.

Say that you want to define a `post-viewer` component to be available only from
within `src/ui/routes/posts/post/template.hbs`. You could achieve this by
creating your component module in
`src/ui/routes/posts/post/-components/post-viewer.js`.

#### Non-resolved Files

The rules above apply to modules that are resolved, namely `*.js` and `*.hbs`
files. Other files that are used for documenting code, such as `*.md` and
`*.html` files, can be freely co-located in any directories.

Conventions will still be used for non-resolved files that have significance
within an Ember project, including:

* `src/ui/styles` - A project's stylesheets.
* `src/ui/index.html` - A project's html container.

### Packages

In-repo addons (including engines) will be placed in a new top-level `packages`
directory (a sibling of `src`). We can begin to use the term "packages" instead
of the rather clumsy "in-repo addons". This differentiation will emphasize that
packages are internal and addons are external to a project. Packages should be
seen as a lightweight way to add new namespacing within a project without the
overhead of a full addon.

The `packages` directory will provide a separate space away from other library
modules that might be kept in `lib`, the current directory used for in-repo
addons. Introducing a new top-level directory will allow a clear migration path
for in-repo addons, in the same way that there's a clear migration path from
`app` to `src`.

Inside `packages`, packages should be grouped by name. Each package can have
its own `index.js`, `package.json`, and `src` directory.

## Ember Resolver Refactor

The Ember resolver must be refactored significantly to be made aware of the
new `src` and `packages` directories and associated conventions.

### Module Normalization

As discussed above, Ember CLI will perform a normalization process for all the
modules in a project and its associated projects. The normalization step will
involve the construction of a map from each module's normalized form to its
corresponding ES module path. If any conflicts are detected, the process should
error and notify the developer.

The Ember resolver will only look up modules in their normalized form, utilizing
the pre-built normalization map to resolve the actual module path.

### Addon modules

A resolver will only implicitly consider an addon's top-level modules named
`main` (e.g. a `main` component) to be public and available for resolution. More
explicit control over an addon's public modules can be declared in the addon's
`main` module (details TBD). An addon's public modules will all be resolvable at
the `rootName` of the addon (see above).

Public components and helpers can be invoked in templates using the `rootName`
as a namespace. For modules named `main`, the bare root name will suffice.

Let's say that the `ember-power-select` addon has a `rootName` of `power-select`
and a top-level `main` component declared in `src/ui/components/main.js`. An
app could invoke this component in a template as `{{power-select::main}}` or
more simply as `{{power-select}}`.

Addons should use the same namespacing that will be used by consuming apps when
invoking their own components and helpers from templates. For instance, if the
`ember-power-select` addon has a `date-picker` component that invokes multiple
`main` components, it should also invoke them in a template as
`{{power-select::main}}` or more simply as `{{power-select}}`.

### Module Resolutions

Module resolution rules must account for the following:

* The requested module's `type`, `name`, and (potentially) `namespace`.
* (Optional) A "source" `rootName`, collection, and namespace from which the
  lookup originates.
* (Optional) An "associated type" for lookups that should start in a collection
  that is not definitive for the requested `type`.

Module resolutions occur in the following order:

1. Local - If a source module is specified and the requested type is allowed in
   the source module's collection, look in a namespace based on the source
   module's namespace + name.
2. Private - If a source module is specified, look in a private collection at
   the source module's namespace, if one exists that is definitive for the
   requested type.
3. Associated - If an associated type is specified, look in the definitive
   collection for that associated type. Only resolve if the collection can
   contain the requested type.
4. Top-level - In the definitive collection for the requested type, defined at
   its top-level.

The resolver must maintain mappings of modules at multiple levels to make these
resolutions efficient. A lookup tree can be pre-built for production builds.

#### Example Resolutions

Let's walk through some example resolutions from the above blogging app paired
with the `ember-power-select` addon. We'll assume that the package name for
the app is `blogmeister`, and the package name for the addon is
`ember-power-select`. The addon has a `rootName` of `power-select` for cleaner
references.

----

From `blogmeister/src/ui/components/list-paginator/template`:

`{{paginator-control}}` resolves to `blogmeister/src/ui/components/list-paginator/paginator-control/component`

`{{date-picker}}` resolves to `blogmeister/src/ui/components/date-picker/component`

`{{power-select}}` resolves to `ember-power-select/src/ui/components/main/component`

`{{power-select::multiple}}` resolves to `ember-power-select/src/ui/components/multiple/component`

----

From `blogmeister/src/routes/posts/post/template`:

`{{post-viewer}}` resolves to `blogmeister/src/ui/routes/posts/post/-components/post-viewer/component`

`{{date-picker}}` resolves to `blogmeister/src/ui/components/date-picker/component`

`{{power-select}}` resolves to `ember-power-select/src/ui/components/main/component`

## Other Refactorings

### Generators and Blueprints

Generators and blueprints will need to be made aware of the new module
conventions.

Let's take a look at the files that some generators will create (note: tests
have been left out of these examples for now):

`ember g component date-picker`:

* `src/ui/components/date-picker/component.js`
* `src/ui/components/date-picker/template.hbs`

`ember g component ui/routes/posts/post-editor`:

* `src/ui/routes/posts/-components/post-editor/component.js`
* `src/ui/routes/posts/-components/post-editor/template.hbs`

`ember g helper titleize`:

* `src/ui/components/titleize.js`

# How We Teach This

The Ember guides will need to be updated significantly to reflect the new
conventions.

## Teaching Conventions through Tooling

As discussed above, generators and blueprints will be made aware of the new
module conventions. This will help new projects start on track and stay on
track as modules are added.

Developers with existing projects will be able to use Robert Jackson's
[migration tool](https://github.com/rwjblue/ember-module-migrator) to move their
projects over to use the new conventions. This tool is a WIP and will continue
to be refined to work well with both the classic and pods structures. It's
possible these migration capabilities will eventually be rolled into Ember
Watson.

Furthermore, the Ember Inspector should be enhanced to understand the new
conventions and become more type and collection aware.

## New Concepts

It will be important for both new and experienced Ember developers to
understand some core concepts that are proposed in this RFC.

### Collections and Types

This proposal's concept of collections and types should feel familiar enough to
users of both the classic and pods layouts to enable a smooth transition. In
many ways, this proposal merges the classic and pods layouts into a single
uniform layout.

The core driver to collections is to store "like with like". However, instead of
the classic layout's narrow definition of "like" to be of a _single_ type, this
proposal takes the pods approach that _multiple_ types can be related. A good
test of whether multiple module types should be stored together is whether they
should be considered to share a common namespace. Routes, controllers, and
templates are a good example, as are models, adapters, and serializers.

A related concept to understand about collections is the notion of a default
type. Every top-level module within a collection can be considered to match its
default type (unless named exports are used in those modules to represent types
other than the default). Within a collection's namespaces, every module must be
either that default type or related to it. It's helpful to consider that every
namespace within a collection represents a set of named module exports, and that
the default type represents the default export for that collection.

Here's an illustration of exports from a collection:

```
src
  data
    models
      author.js <- exports an Author `model`, the default type in the `models` collection
      comment
        adapter.js     <- exports a Comment `adapter`
        model.js       <- exports a Comment `model`
        serializer.js  <- exports a Comment `serializer`
```

#### Components

The term "component" has been widely adopted across most front-end frameworks
to describe a broad swath of UI concerns. Using the same term for the collection
of template-invocable UI elements will lower the learning curve for developers
who are new to Ember, while allowing for a useful set of specialized terms to
flourish to describe particular _types_ of components.

We've already started down the road of component specialization by introducing
the concept of "routable components". Once we start actually using "routable
components" in practice, it will become necessary to refer to plain old
components as something more specific, like "template components". And this
distinction will probably lead to plain old helpers being referred to as
"template helpers". Other concepts, such as "Glimmer components" and "template
component modifiers" will soon be mixed in. We will end up with a multi-faceted
toolbox available at the template layer which deserves a simple name that
matches developer expectations. The general term "components" seems a good fit.

### Scope

Developers should understand the available levels of module scope, as well as
when each is appropriate to use. Scope should be considered when modules are
generated, and developers should feel free to move modules if they expand or
contract in scope.

The following levels of scope should be understood:

* Private - private collections should be used when a component or utility
  function is needed from a single namespace.

* Project - top-level, project-wide collections should be used for modules that
  are needed throughout a project.

* Local package - namespaced collections can be useful to group a common set of
  cross-cutting concerns within a project.

* Local engine - a type of local package that encapsulates a set of
  functionality that benefits from run-time isolation and strict dependency
  sharing.

### Testing

Unit, integration, and some acceptance tests can now be co-located with their
associated modules. Co-location should be encouraged because it makes test
modules easier to locate in the file system, and easier to move if a module's
scope changes.

Robert Jackson plans to adapt the
[Grand Testing Unification RFC](https://github.com/emberjs/rfcs/pull/119)
to illustrate test co-location and to introduce module types for tests.

# Drawbacks

Any change to a pattern as fundamental as file naming will incur some mental
friction for developers who are accustomed to the current conventions. It is
hoped that tooling like Robert's migrator and Ember Watson can lessen this
friction by automating transitions, and that updated guides, generators, and
blueprints can make these conventions easy to follow.

Of course, we won't prevent usage of the currently used patterns for some time,
but they will eventually be deprecated. Some efficiencies, especially in the
resolver, may not be fully realized until the new patterns are used throughout
a project.

# Alternatives

## The Module Normalization RFC

Perhaps the most prominent alternative that has been explored is the
[Module Normalization RFC](https://github.com/emberjs/rfcs/pull/124). Module
Unification shares many aspects with Module Normalization, but with one
fundamental difference: buckets in Module Normalization are normalized away
for the resolver, while collections in Module Unification play an important
role in module resolution.

The Ember Core Team decided that the sleight of hand required to allow buckets
to be used for organization only, and not for resolution, could create
confusion. Essentially, modules could conflict across buckets, because they
could have matching namespaces, names, and types. This kind of conflict could
not be allowed, so developers would need to understand too much about the
resolution strategy to make it ergonomic.

## Other Alternatives

[A large number of other alternatives have been explored](https://gist.github.com/dgeb/396fed953184acb04f4f)
before settling on this recommendation. Feel free to explore the history of any
of the linked gists to understand some of the subtle alternatives.

Of course, one alternative is to simply not change anything and accept the
drawbacks discussed in the Motivation section above. However, even if we accept
inefficiencies in our resolver and confusion over divergent file structuring
strategies, we still need to solve the "local lookup" problem, which does not
have a clean solution in today's module system.

# Unresolved questions

## How should tests be co-located in `src`?

Should tests be allowed within `src` via `*-test` types (e.g.
`component-integration-test`, `component-unit-test`, etc.) within respective
collections?

If this RFC is approved, then Robert Jackson plans to adapt the
[Grand Testing Unification RFC](https://github.com/emberjs/rfcs/pull/119) to
propose answers to these questions.

## What about routable components?

Should routable components have a type that's unique from other components?

Should they exist alongside `route` and `template` types in the `routes`
collection?

It seems plausible that routable components could simply use the `component`
type, and that we could lint against allowing template-invocable components
alongside routes.

## How should configuration declarations be made in the `main` module?

For example:

* How should resolvable exports be declared from addons?
* Can apps override the root names of addons? For example, if
  `ember-power-select` has a root name of `power-select`, could a consuming app
  override this?
* How do addons and apps declare their collection and type exports? For example,
  how could liquid-fire allow for a `transition` type and an `animations`
  collection?

## Should we allow collection groups?

Do the organizational benefits of collection groups outweigh the potential
confusion over where lines are drawn between a group/collection/namespace
when viewing a project structure.


---

---
stage: recommended
start-date: 2016-06-11T00:00:00.000Z
release-date: 2017-04-07T00:00:00.000Z
release-versions:
  ember-source: v2.12.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/150
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/14360
---

# Summary

With the goal of making significant performance improvements and of adding
public API to support use cases long-served by a private API, a new API of
`factoryFor` will be added to `ApplicationInstance` instances.

# Motivation

Ember's dependency injection container has long supported fetching a factory
that will be created with any injections present. Using the private API that
provided this support allows an instance of the factory to be created
with initial values passed via `create`. For example:

```js
// app/logger/main.js
import Ember from 'ember';

export default Ember.Logger.extend({
  someService: Ember.inject.service()
});
```

```js
import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let Factory = getOwner(this)._lookupFactory('logger:main');
    this.logger = Factory.create({ level: 'low' });
  }
});
```

In this API, the `Factory` is actually a subclass the original main logger
class. When `_lookupFactory` is called, an additional `extend` takes place
to add any injections (such as `someService` above). The class/object setup
looks like this:

* In the module: `MyClass = Ember.Object.extend(`
* In `_lookupFactory`: `MyFactoryWithInjections = MyClass.extend(`
* And when used: `MyFactoryWithInjections.create(`

The second call to `extend` implements Ember's owner/DI
framework and permits `someService` to be resolved later. The "owner" object
is merged into the new `MyFactoryWithInjections` class along with any
registered injections.

This "double extend" (once at define time, once at `_lookupFactory` time)
takes a toll on performance booting an app. This design flaw has motivated
a desire to keep `_lookupFactory` private.

The `MyFactoryWithInjections` class also features as a cache. Because it is
attached to the owner/container, it is cleared between test runs or
application instances. To illustrate, this flow-chart shows how
`MyFactoryWithInjections` diverges between tests:

```
               +-------------------------------+
               |                               |
               |      /app/models/foo.js       |
               |                               |
               +-------------------------------+
                               |
              first test run   |    nth test run
              +----------------+---------------+
              |                                |
              v                                v
   +---------------------+          +--------------------+
   |resolve('model:foo') |   ===    |resolve('model:foo')|
   +---------------------+          +--------------------+
              |                                |
              |                                |
              v                                v

     extend(injections)               extend(injections)

              |                                |
              |                                |
              |                                |
              v                                v
+--------------------------+     +---------------------------+
|lookupFactory('model:foo')| !== |lookupFactory('model:foo') |
+--------------------------+     +---------------------------+
```

Despite the design flaws in this API, it does fill a meaningful role in
Ember's DI solution. Use of the private API is common. Some examples:

* [ember-cart](https://github.com/DockYard/ember-cart) uses the functionality to create model objects without
  tying them to the store [example a](https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/controllers/application.js#L16),
  [example b](https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/models/dog.js#L11)
* Ember-Data's [`modelFactoryFor`](https://github.com/emberjs/data/blob/54ea432b1cbb0d1231d9a0454b09d3b3a0bc2533/addon/-private/system/store.js#L1868)

The goal of this RFC is to create a public API for fetching factories with
better performance characteristics than `_lookupFactory`.

# Detailed design

Throughout this document I reference Ember 2.12 as it is the next LTS at writing. This
proposal may ship for 2.12-LTS or be bumped to the next LTS.

This feature will be added in these steps.

1. In Ember introduce a `ApplicationInstance#factoryFor` based on
   `_lookupFactory`. It should be documented that certain behaviors
   inherent to "double extend" are not supported. In development builds
   and supporting browsers, wrap return values in a Proxy. The proxy should
   throw an error when any property besides `create` or `class` is accessed.
   `class` must return the registered factory, not the double extended factory.
2. In the same release add a deprecation message to usage of `_lookupFactory`.
   As this API is intimate it must be maintained through at least one LTS
   release (2.12 at this writing).
3. In 2.13 drop `_lookupFactory` and migrate the `factoryFor` implementation to avoid
   "double-extend" entirely.

Additionally, a polyfill will be released for this feature supporting prior
versions of Ember.

#### Design of `ApplicationInstance#factoryFor`

A new API will be introduced. This API will return both the original base
class registered into or resolved by the container, and will also return a function
to generate a dependency-injected instance. For example:

```js
import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let factory = getOwner(this).factoryFor('logger:main');
    this.logger = factory.create({ level: 'low' });
  }
});
```

Unlike `_lookupFactory`, `factoryFor` will not return an extended class with
DI applied. Instead it will return a factory object with two properties:

```js
// factoryFor returns:
let {

  // a function taking an argument of initial properties passed to the object
  // and returning an instance
  create,

  // The class registered into (or resolved by) the container
  class

} = owner.factoryFor('type:name');
```

This API should meet two requirements of the use-cases described in
"Motivation":

* Because `factoryFor` only returns a `create` method and reference to the
  original class, its internal implementation can diverge away from the
  "double extend". A side-effect of this is that the
  class of an object instantiated via `_lookupFactory(name).create()`
  and `factoryFor(name).create()` may not be the same, given the
  same original factory.
* The presence of `class` will make it easy to identify the base class of the
  factory at runtime.

For example today's `_lookupFactory` creates an inheritance structure like
the following:

```
                    Current:
       +-------------------------------+
       |                               |
       |      /app/models/foo.js       |
       |                               |
       +-------------------------------+
                       |
                       |
                       |
                       v
            +--------------------+
            |  Class[model/Foo]  |
            +--------------------+
                       |
                       |
                       |
       first test run  |   nth test run
           +-----------+----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     subclass of    | |     subclass of    |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
```

Between test runs 2 instances of `model:foo` will have a common
shared ancestor the grandparent `Class[model/Foo]`.

This implementation of `factoryFor` proposes to remove the intermediate
subclass and instead have a generic
factory object which holds the injections and allows for injected instances
to be created. The resulting object graph would look something like this:

```
                  Proposed:
      +-------------------------------+
      |                               |
      |      /app/models/foo.js       |
      |                               |
      +-------------------------------+
                      |
                      |
                      |
                      v
           +--------------------+
           |  Class[model/Foo]  |
           +--------------------+
                      |
                      |
                      |
      first test run  |   nth test run
           +----------+-----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     Factory of     | |     Factory of     |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
```

With `factoryFor` instances of `model:foo` will share a common constructor.
Any state stored on the constructor would of course leak between the tests.

An example implementation of `factoryFor` can be reviewed [on this GitHub
comment](https://github.com/emberjs/rfcs/issues/125#issuecomment-193827658).

##### Implications for `owner.register`

Currently, factories registered into Ember's DI system are required to
provide an `extend` method. Removing support for extend-based DI in `_lookupFactory`
will permit factories without `extend` to be registered. Instead factories
must only provide a `create` method. For example:

```js
let factory = {
  create(options={}) {
    /* Some implementation of `create` */
    return Object.create({});
  }
};
owner.register('my-type:a-factory', factory);
let factoryWithDI = owner.factoryFor('my-type:a-factory');

factoryWithDI.class === factory;
```

##### Development-mode Proxy

Because many developers will simply re-write `_lookupFactory` to `factoryFor`,
it is important to provide some aid and ensure they actually complete the
migration completely (they they avoid setting state on the factory). A proxy
wrapping the return value of `factoryFor` and raising assertions when any
property besides `create` or `class` is accessed will be added in development.

Additionally, using `instanceof` on the result of `factoryFor` should be
disallowed, causing an exception to be raised.

A good rule of thumb is that, in development, using anything besides `class` or
`create` on the return value of `factoryFor` should fail with a helpful message.

##### Releasing a polyfill

A polyfill addon, similar to [ember-getowner-polyfill](https://github.com/rwjblue/ember-getowner-polyfill)
will be released for this feature. This polyfill will provide the `factoryFor`
API going back to at least 2.8, provide the API and silence the deprecation
in versions before `factoryFor` is available, and be a no-op in versions where
`factoryFor` is available.

# How We Teach This

This feature should be introduced along side `lookup` in the
[relevant guide](https://guides.emberjs.com/v2.6.0/applications/dependency-injection/).
The return value of `factoryFor` should be taught as a POJO and not as
an extended class.

#### Example deprecation guide: Migrating from `_lookupFactory` to `factoryFor`

Ember owner objects have long provided an intimate API used to
fetch a factory with dependency injections. This API, `_lookupFactory`, is deprecated
in Ember 2.12 and will be removed in Ember 2.13. To ease the transition to this
new public API, a polyfill is provided with support back to at least Ember 2.8.

`_lookupFactory` returned the class of resolved factory extended with
a mixin containing its injections. For example:

```js
let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner._lookupFactory('my-type:a-name');
klass.constructor.superclass === factory; // true
let instance = klass.create();
```

`factoryFor` instead returns an object with two properties: `create` and `class`.
For example:

```js
let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner.factoryFor('my-type:a-name');
klass.class === factory; // true
let instance = klass.create();
```

A common use-case for `_lookupFactory` was to fetch an factory with
specific needs in mind:

* The factory needs to be created with initial values (which cannot be
  provided at create-time via `lookup`.
* The instances of that factory need access to Ember's DI framework (injections,
  registered dependencies).

For example:

```js
// app/widgets/slow.js
import Ember from 'ember';

export default Ember.Object.extend({
  // this instance requires access to Ember's DI framework
  store: Ember.inject.service(),

  convertToModel() {
    this.get('store').createRecord('widget', {
      widgetType: 'slow',
      name, canWobble
    });
  }

});
```

```js
// app/services/widget-manager.js
import Ember from 'ember';

export default Ember.Service.extend({

  init() {
    this.set('widgets', []);
  },

  /*
   * Create a widget of a type, and add it to the widgets array.
   */
  addWidget(type, name, canWobble) {
    let owner = Ember.getOwner(this);
    // Use `_lookupFactory` so the `store` is accessible on instances.
    let WidgetFactory = owner._lookupFactory(`widget:${type}`);
    let widget = WidgetFactory.create({name, canWobble});
    this.get('widgets').pushObject(widget);
    return widget;
  }

});
```

For these common cases where only `create` is called on the factory, migration
to `factoryFor` is mechanical. Change `_lookupFactory` to `factoryFor` in the
above examples, and the migration would be complete.

##### Migration of static method calls

Factories may have had static methods or properties that were being accessed
after resolving a factory with `_lookupFactory`. For example:

```js
// app/widgets/slow.js
import Ember from 'ember';

const SlowWidget = Ember.Object.extend();
SlowWidget.reopenClass({
  SPEEDS: [
    'slow',
    'verySlow'
  ],
  hasSpeed(speed) {
    return this.SPEEDS.contains(speed);
  }
});

export default SlowWidget;
```

```js
let factory = owner._lookupFactory('widget:slow');
factory.SPEEDS.length; // 2
factory.hasSpeed('slow'); // true
```

With `factoryFor`, access to these methods or properties should be done via
the `class` property:

```js
let factory = owner.factoryFor('widget:slow');
let klass = factory.class;
klass.SPEEDS.length; // 2
klass.hasSpeed('slow'); // true
```

# Drawbacks

The main drawback to this solution is the removal of double extend. Double
extend is a performance troll, however it also means if a single class is registered
multiple times each `_lookupFactory` returns a unique factory. It is plausible
that some use-case relying on this behavior would get trolled in the migration
to `factoryFor`, however it is unlikely.

For example these cases where state is stored on the factory would no
longer be scope to one instance of the owner (like one test). Instead, setting
a value on the class would set it on the registered class.

Some real-world examples of setting state on the factory class:

- ember-model
  - https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L404 and https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L457
    with `factoryFor` will increment a shared counter across application and
    container instances.
  - https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L723-L725
    would also set properties on the base `Ember.Model` factory instead of
    an extension of that class.
- ember-data
  - If attrs change between test runs (seems very unlikely) then https://github.com/emberjs/data/blob/387630db5e7daec6aac7ef8c6172358a3bd6394c/addon/-private/system/model/attr.js#L57
    would be affected. The CP of `attributes` will have a value cached on the
    factory, and where with `_lookupFactory`'s double-extend the cache would be
    on the extended class, in `factoryFor` that CP cache will be on the
    class registered as a factory.
- Any other of the following:
  - `lookupFactory(x).reopen` / `reopenClass` at runtime (or test time to monkey patch code)
  - `lookupFactory(x).something = value`

# Alternatives

More aggressive timelines have been considered for this change.

However we have considered the possibility that removing `_lookupFactory` in 2.13
(something LTS technically permits) would be too aggressive for the
community of addons. Providing a polyfill is part of the strategy to handle
this change.

# Unresolved questions

Are there any use-cases for the double extend not considered?


---

---
stage: recommended
start-date: 2016-11-05T00:00:00.000Z
release-date: 2017-10-09T00:00:00.000Z
release-versions:
  ember-source: v2.16.0

teams:
  - framework
  - data
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/176
project-link:
---

# Summary

Make Ember feel less overwhelming to new users, and make Ember applications
start faster, by replacing the `Ember` global with a first-class system for
importing just the parts of the framework you need.

# Motivation

ECMAScript 2015 (also known as ES2015 or ES6) introduced a syntax for importing
and exporting values from modules. Ember aggressively adopted modules, and if
you've used Ember before, you're probably familiar with this syntax:

```js
import Ember from "ember";
import Analytics from "../mixins/analytics";

export default Ember.Component.extend(Analytics, {
  // ...
});
```

One thing to notice is that the entire Ember framework is imported as a single
package. Rather than importing `Component` directly, for example, you import
`Ember` and subclass `Ember.Component`. (And this example still works even if
you forget the import, because we also create a global variable called
`Ember`.)

Using Ember via a monolithic package or global object is not ideal for several
reasons:

* It's overwhelming for learners. There's a giant list of classes and functions
  with no hints about how they're related. The API documentation reflects this.
* Experienced developers who don't want all of Ember's features feel like
  they're adding unnecessary and inescapable bloat to their application.
* The `Ember` object must be built at boot time, requiring that we ship the
  entire framework to the browser. This has two major costs:
  1. Increased download time, particularly noticeable on slower connections.
  2. Increased parsing/evaluation cost, which still must be paid even when
     assets are cached. On some browsers/devices, this can far exceed the cost of the
     download itself.

Defining a public API for importing parts of Ember via JavaScript modules helps
us lay the groundwork for solving all of these problems.

#### Reducing Load Time

Modules help us eliminate unneeded code. The module syntax is _statically
analyzable_, meaning that a tool like Ember CLI can analyze an application's
source code and reliably determine which files, in both the framework and the
application, are actually needed. Anything that's not needed is omitted from the
final build.

This allows us to provide the file size benefits of a "small modules" approach
to building web applications while retaining the productivity benefits of a
complete, opinionated framework.

For example, if your application never used the `Ember.computed.union` computed
property helper, Ember could detect this and remove its code when you build your
application. This technique for slimming down the payload automatically is often
referred to as _tree shaking_ or _dead code elimination_.

Building the module graph doesn't just mean we get a list of files used by the application—
we also know which files are used _route-by-route_.

We can use this knowledge to optimize boot time even more, by prioritizing
sending only the JavaScript needed for the requested route, rather than the
entire application.

For example, if the user requests the URL
`https://app.example.com/articles/123`, the server could first send the code for
`ArticlesRoute`, the `Article` model, the `articles` template, and any
components and framework code used in the route. Only after the route is
rendered would we start to send the remainder of the application and framework
code in the background.

#### Guiding Learners

We can group framework classes and utilities by functionality, making it clear
what things are related and how they should work together. People can feel
confident they are getting only what they need at that moment, not an entire
framework that they're not sure they're benefiting from.

#### Modernizing Ember

Lastly, developers are growing increasingly accustomed to using JavaScript
modules to import libaries. If we don't adapt to modules, Ember will feel clunky
and antiquated compared to modern alternatives.

### Prior Art

Initial efforts to define a module API for Ember began with the
[`ember-cli-shims`][shims] addon. This addon provides a set of "shim" modules
that re-export a value off the global `Ember`. While this setup doesn't offer
the benefits of true modules, it did allow us to rapidly experiment with a
module API without making changes to Ember core.

[shims]: https://github.com/ember-cli/ember-cli-shims

Common feedback from shim users was that, while they were a net improvement,
they introduced too much verbosity and were hard for beginners to remember.

An oft-cited example of this verbosity is that implementing an object and using
`Ember.get` and `Ember.set` requires three different imports:

```js
import EmberObject from "ember-object";
import get from "ember-metal/get";
import set from "ember-metal/set";
```

In fact, one of the principles outlined in this RFC is designed to correct this
verbosity; namely, that [utility functions and the class they are related to
should share a module](#utility-functions-are-named-exports).

For those who have already adopted modules via the `ember-cli-shims` package, we
will provide a migration tool to rewrite shim modules into the final module API.
The static nature of the import syntax makes this even easier and more reliable
than migrating globals-based apps. The upgrade process should take no more than
a few minutes (see [Migration](#migration)).

This RFC also builds significantly on [@zeppelin's](https://github.com/zeppelin)
previous [ES6 modules RFC](https://github.com/emberjs/rfcs/pull/68), which drove
initial discussion, including the idea to use scoped packages.

# Detailed Design

## Terminology

* **Package** - a bundle of JavaScript addressable by npm and other package
  managers, it may contain many modules (but has a default module, usually
  called `index.js`).
* **Scoped Package** - a namespaced package whose name starts with an `@`, like
  `import Thing from "@scope/thing"`.
* **Module** - a JavaScript file with at least one default export or named
  export.
* **Top-Level Module** - the module provided by importing a package directly,
  like `import Component from "@ember/component"`.
* **Nested Module** - a module provided at a path _inside_ a package, like
  `import { addObserver } from "@ember/object/observers"`.

## Module Naming & Organization

Because our goal is to eliminate the `Ember` global object, any public classes,
functions or properties that currently exist on the global need an equivalent
module that can be imported.

Given how fundamental modules are to the development process, how we organize
and name them impacts new learners and seasoned veterans alike. Thus we must try
to find a balance between predictability for new and intermediate users, and
terseness for experienced developers with large apps.

There is another goal at play: we would like to help dispel the misconception
that Ember is a monolithic framework. Ideally, module names help us tell a story
about Ember's layered features. Rather than inheriting the entire framework at
once, you can pull in just the pieces you need.

For that reason, package names should assist the developer in understanding what
capabilities are added by bringing in that new package. We should pick
meaningful names, not let our public API be a by-product of how Ember's
internals are organized.

A full table of proposed mappings from global to module is available in
[Addendum 1 - Table of Module Names and Exports by
Global](#addendum-1---table-of-module-names-and-exports-by-global) and [Addendum
2 - Table of Module Names and Exports by
Package](#addendum-2---table-of-module-names-and-exports-by-package). Because
there is some implicit functionality that you get when loading Ember that is not
encapsulated in a global property (for example, automatically adding prototype
extensions), there is also [Addendum 3 - Table of Modules with Side
Effects](#addendum-3---table-of-modules-with-side-effects).

Before diving in to these tables, however, it may be helpful to understand some
of the thinking that guided this proposal. And keep in mind, this RFC specifies
a _baseline_ module API. Nothing here precludes adding additional models in the
future, as we discover missing pieces.

### Use Scoped Packages

Last year, [npm introduced support for scoped packages][scoped-packages]. Scopes
are similar to organizations on GitHub. They allow us to use any package name,
even if it's already in use on npm, by namespacing it inside a scope.

[scoped-packages]: http://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages

For example, the [`component`][component] package is already reserved by an
unmaintained tool; we couldn't use `component` as a package name even if we
wanted to.

[component]: https://www.npmjs.com/package/component

However, scopes allow us to create a package named `component` that lives under
the `@ember` scope: `import Component from "@ember/component"`.

The advantages of using scoped packages, as this proposal does, are two-fold:

1. "Official" packages are clearly differentiated from community packages.
2. There is no risk of naming conflicts with existing community packages.

Note that actually publishing packages to npm may not be immediately necessary
to implement this RFC. We should still design around this constraint so that we
have the option available to us in the future. For more discussion, see the
[Distribution unresolved question](#distribution).

### Prefer Common Terminology

Module names should use terms people are more likely to be familiar with. For
example, instead of the ambiguous `platform`, polyfills should be in a module
called `polyfill`.

Similarly, the vast majority of advanced Ember developers couldn't crisply
articulate the difference between `ember-metal` and `ember-runtime`. Instead, we
should prefer `ember-object`, to match how people actually talk about these
features: the Ember object model.

### Organize by Mental Model

One of the biggest barriers to learning is the fact that short-term memory is
limited. To understand a complex system like a modern web application, the
learner must hold in their head many different concepts—more concepts than most
people can reason about at once.

[Chunking][chunking] is a strategy for dealing with this. It means that you
present concepts that are conceptually related together. When the learner needs
to reason about the overall system, in their mind they can replace a group of
related concepts with a single, overarching concept.

[chunking]: https://en.wikipedia.org/wiki/Chunking_(psychology)

For example, if you tell someone that in order to build an Ember app, they will
need to understand computed properties, actions (bubbling and closure),
components, containers, registries, routes, helpers (stateful and stateless),
dependent keys, controllers, route maps, observers, transitions, mixins,
computed property macros, injected properties, the run loop, and array
proxies—they will rightfully feel like Ember is an overwhelming, overcomplicated
framework. Most people (your RFC author included) simply cannot keep this many
discrete concepts in their head at once.

The day-to-day reality of building an Ember app, of course, is not nearly so
complex. For those developers who stick through the learning curve, they end up
with a greatly simplified mental model.

This proposal attempts to re-align module naming with that simplified mental
model, placing everything into packages based on the chunk of functionality they
provide:

* `@ember/application` - Application-level concerns, like bootstrapping,
  initializers, and dependency injection.
* `@ember/component` - Classes and utilities related to UI components.
* `@ember/routing` - Classes used for multi-page routing.
* `@ember/service` - Classes and utilities for cross-cutting services.
* `@ember/controller` - Classes and utilities related to controllers.
* `@ember/object` - Classes and utilities related to Ember's object model,
  including `Ember.Object`, computed properties and observers.
* `@ember/runloop` - Methods for scheduling behavior on to the run loop.

It includes a few other packages that, over time, your author hopes become
either unneeded or can be moved outside of core into standalone packages:

* `@ember/array` - Array utilities and observation. Ideally these can be replaced
  with a combination of ES2015+ features and array diffing in Glimmer.
* `@ember/enumerable` - Replaced by iterables in ES2015.
* `@ember/string` - String formatting utilities (dasherize, camelize, etc.).
* `@ember/map` - Replaced by `Map` and `WeakMap` in ES2015.
* `@ember/polyfills` - Polyfills for `Object.keys`, `Object.assign` and `Object.create`.
* `@ember/utils` - Grab bag of utilities that could likely be replaced with
  something like lodash.

And finally, some packages that may be used by internals, extensions, or addons
but are not used day-to-day by app developers:

* `@ember/instrumentation` - Instrumentation hooks for measuring performance.
* `@ember/debug` - Utility functions for debugging, and hooks used by debugger tools like Ember Inspector.

### Classes are Default Exports

Classes that the user is supposed to import and subclass are always the default
export, never a named export. In the case where a package has more than one primary class,
those classes live in a nested module.

This rule ensures there is no ambiguity about whether something is a named
export or a default export: classes are always default exports. In tandem with
the following rule ([Utility Functions are Named
Exports](#utility-functions-are-named-exports)), this also means that classes
and the functions that act on them are grouped into the same `import` line.

#### Examples

Primary class only:

```js
import EmberObject from "@ember/object";
```

Primary class plus secondary classes:

```js
import Component from "@ember/component";
import Checkbox from "@ember/component/checkbox";

import Map from "@ember/map";
import MapWithDefault from "@ember/map/with-default";
```

Multiple primary classes:

```js
import Router from "@ember/routing/router";
import Route from "@ember/routing/route";
```

### Utility Functions are Named Exports

Functions that are only useful with a particular class, or are used most frequently with
that class, are named exports from the package that exports the class.

#### Examples

```js
import Service, { inject } from "@ember/service";
import EmberObject, { get, set } from "@ember/object";
```

In cases where there are many utility functions associated with a class, they can be further subdivided into
nested packages but remain named exports:

```js
import EmberObject, { get, set } from "@ember/object";
import { addObserver } from "@ember/object/observers";
import { addListener } from "@ember/object/events";
```

In the future, [decorators][decorators] would be included under this rule as
well. In fact, designing with an eye towards decorators was a large driver
behind this principle. For more discussion, see the [Everything is a Named
Export alternative](#everything-is-a-named-export).

[decorators]: http://tc39.github.io/proposal-decorators/

### One Level Deep

To avoid deep directory hierarchies with mostly-empty directories, this proposal
limits nesting inside a top-level package to a single level. Deep nesting like
this can add additional time to navigating the hierarchy without adding much
benefit.

Java packages often have this problem due to their URL-based namespacing; see
e.g. [this Java
library](https://github.com/elvishew/xLog/tree/fbfb60f9472e32723436b3d6bdd6c1878a5afb37/library/src)
where you end up with deeply nested directories, like
`xLog/library/src/test/java/com/elvishew/xlog/printer/AndroidPrinterTest.java`.

This rule leads to including the type in the name of the module in some cases
where it might otherwise be grouped instead. For example, instead of
`@ember/routing/locations/none`, we prefer `@ember/routing/none-location` to
avoid the second level of nesting.

### No Non-Module Namespaces

The global version of Ember includes several functions that also act as a
namespace to group related functionality.

For example, `Ember.run` can be used to run some code inside a run loop, while
`Ember.run.scheduleOnce` is used to schedule a function onto the run loop once.

Similarly, `Ember.computed` can be used to indicate a method should be treated as
a computed property, but computed property macros also live on `Ember.computed`, like
`Ember.computed.alias`.

When consumed via modules, these functions no longer act as a namespace. That's
because tacking these secondary functions on to the main function requires us to
eagerly evaluate them (not to mention the potential deoptimizations in
JavaScript VMs by adding properties to a function object).

In practice, that means that this won't work:

```js
// Won't work!
import { run } from "@ember/runloop";
run.scheduleOnce(function() {
  // ...
});
```

Instead, you'd have to do this:

```js
import { scheduleOnce } from "@ember/runloop";
scheduleOnce(function() {
  // ...
});
```

The [migration tool](#migration), described below, is designed to detect these
cases and migrate them correctly.

### Prototype Extensions and Other Code with Side Effects

Some parts of Ember change global objects rather than exporting classes or
functions. For example, Ember (by default) installs additional methods on
`String.prototype`, like the `camelize()` method.

Any code that has side effects lives in a module without any exports; importing
the module is enough to produce the desired side effects. For example, if I
wanted to make the string extensions available to the application, I could
write:

```js
import "@ember/extensions/string"
```

Generally speaking, modules that have side effects are harder to debug and can
cause compatibility issues, and should be avoided if possible.

## Migration

To assist in assessing this RFC in real-world applications, and to help upgrade
apps should this RFC be accepted and implemented, your author has provided an
automatic migration utility, or "codemod":

[ember-modules-codemod][ember-modules-codemod]

To run the codemod, `cd` into an existing Ember app and run the following commands.

```sh
npm install ember-modules-codemod -g
ember-modules-codemod
```

**Note**: The codemod currently requires Node 6 or later to run.

This codemod uses [`jscodeshift`](https://github.com/facebook/jscodeshift) to
update an Ember application in-place to the module syntax proposed in this RFC.
It can update apps that use the global `Ember`, and will eventually also support
apps using [ember-cli-shims][shims].

[shims]: https://github.com/ember-cli/ember-cli-shims

**Make sure you save any changes in your app before running the codemod, because
it modifies files in place. Obviously, because this RFC is speculative, your app
will not function after applying this codemod. For now, the codemod is only
useful for assessing how this proposal looks in real-world applications.**

For example, it will rewrite code that looks like this:

```js
import Ember from 'ember';

export default Ember.Component.extend({
  isAnimal: Ember.computed.or('isDog', 'isCat')
});
```

Into this:

```js
import Component from '@ember/component';
import { or } from '@ember/object/computed';

export default Component.extend({
  isAnimal: or('isDog', 'isCat')
});
```

For more information, see the [README][ember-modules-codemod].

[ember-modules-codemod]: https://github.com/tomdale/ember-modules-codemod

# How We Teach This

This RFC makes changes to one of the most foundational (and historically stable)
concepts in Ember: how you access framework code. Because of that, it is hard to
overstate the impact these changes will have. We need to proceed carefully to
avoid confusion and churn.

It is possible that the work required to update the documentation and other
learning materials will be significantly more than the work required to do the
actual implementation. That means we need to start getting ready _now_, so that
when the code changes are ready, it is not blocked by a big documentation
effort.

That said, we do have the advantage of the new modules being "just JavaScript."
We can lean heavily on the greater JavaScript community's learning materials,
and any teaching we do has the benefit of being transferable and not an
"Ember-only" skill.

## Documentation Examples

Examples in the Getting Started tutorial, guides and API docs will need to be
updated to the new module syntax.

Probably the most efficient and least painful way to do this would be to write a
tool that can extract code snippets from Markdown files and run the
[migrator](#migration) on them, then replace the extracted code with the updated
version. For the API docs, this tool would need to be able to handle Markdown embedded
in JSDoc-style documentation.

The benefit of this approach is that, once we have verified the script works
reliably, we can wait until the last possible moment to make the switch. If we
attempt to update everything by hand, the duration and tediousness of that
process will likely take out an effective "lock" on the documentation code base,
where people will put off making big changes because of the potential for merge
conflicts.

## Generators

Generators are used by new users to help them get a handle on the framework, and
by experienced users to avoid typing repetitive boilerplate. We need to ensure
that the generators that ship with Ember are updated to use modules as soon as
they are ready. The recent work by the Ember CLI team to ship generators with
the Ember package itself, rather than Ember CLI, should make this relatively
painless.

## API Documentation

Our API documentation has long been a source of frustration, because the laundry
list of (often rarely used or internal) classes makes Ember feel far more
overwhelming than it really is.

The shift to modules gives us a good opportunity to rethink the presentation of
our API documentation. Instead of the imposing mono-list, we should group the
API documentation by package–which, conveniently in this proposal, means they
will also be grouped by area of functionality.

We should investigate the broader ecosystem to see if there is a good tool that
generates package-oriented documentation for JavaScript projects. If not, we may
wish to adapt an existing tool to do so.

## Explaining the Migration

Once the guides and API documentation are updated, modules should be
straightforward for new learners—indeed, more and more new learners are starting
with JavaScript modules as the baseline.

The most challenging aspect of teaching the new modules API, counterintuitively,
will likely be _existing_ users. In particular, for changes that touch nearly
every file, most teams working on large apps cannot pause work for a week to
implement the change.

Our focus needs to be:

* Communicating clearly that the existing global build will work for the
  foreseeable future.
* Making clear the file size benefits of moving to modules.
* Building robust tooling that allows even large apps to migrate in a day or
  two, not a week.

It is important to frame the module transition as a carrot, not a stick. We
should avoid dire warnings or deprecation notices. Instead, we should provide
good reporting when doing Ember CLI builds. If an app is compiled in globals
mode, we can offer suggestions for how to reduce the file size, providing a
helpful pointer to the modules migration guide. This will make the transition
feel less like churn and more like an optimization opportunity that developers
can take advantage of when they have the time or resources.

### Addons

One pitfall is that a _single_ use of the `Ember` global means we have to
include the entire framework. That means that a developer could migrate their
entire app to modules, but a single old addon that uses the Ember globals will
negate the benefits.

This requires a two-pronged strategy:

* Tight integration into Ember CLI
  * Good reporting to make it obvious when a fallback to globals mode
  occurs, and which addons/files are causing it.
  * An opt-in mode to prohibit globals mode. Installing an incompatible addon
    would produce an error.
* Community outreach and pull requests to help authors update addons.

# Drawbacks

## Complexity

There is something elegantly simple about a single `Ember` global that contains
everything. Introducing multiple packages means you don't just have to know what
you need—you also need to know where to import it from.

JavaScript module syntax is also something not everyone will be familiar with,
given its newness. However, this is something we must deal with anyway because
module syntax is already in use within apps.

## Module Churn

The `ember-cli-shims` package is already included by default in new Ember apps,
and is in fairly common usage. Many developers are already familiar with its
API. This drawback can be at least partially mitigated by [the automated
migration process](#migration), which will be easily applied to existing shimmed
apps.

## Scoped Packages Are an Unknown Quantity

This proposal relies on scoped packages. Despite being released over a year ago,
scoped packages are not always well supported.

For example, [scoped packages currently wreak havoc on Yarn][yarn]. Until very
recently, the [npmjs.com](https://npmjs.com) search did not include scoped
packages. Generally speaking, there will be a long-tail of tools in the
ecosystem that will choke on scoped packages.

That said, Angular 2 is distributed under the `@angular` scope, and TypeScript
recently adopted the `@types` scope for publishing TypeScript typings to npm.
The popularity of both of these should drive compatibility. Despite this, we can
expect [similar compatibility issues][scoped-proxy-issue] for some time.

[yarn]: https://github.com/yarnpkg/yarn/issues?utf8=✓&q=is%3Aissue%20is%3Aopen%20scoped%20packages
[scoped-proxy-issue]: https://github.com/angular/angular/issues/8422

## Nested Modules

To satisfy the [Classes are Default Exports](#classes-are-default-exports) rule,
this RFC proposes the use of nested modules. That is, a module name may contain
an additional path segment beyond the package name. For example,
`@ember/object/observers` is a nested module, while `@ember/object` is not.

In the Node/CommonJS world, nested modules are unusual but not unheard of. For
example, Lodash offers a [functional programming
style](https://github.com/lodash/lodash/wiki/FP-Guide) accessed by calling
`require('lodash/fp')`.

There are two drawbacks associated with nested modules:

1. Because they are uncommon, developers may be confused by the syntax.
2. Because they allow you to "reach in" to the package for an
   arbitrary file, encouraging the end user to use nested modules may
   inadvertently _also_ encourage them to access private modules, thinking they are
   public.

The first issue is surmountable with education, good reference documentation,
and good tools to help guide developers in the right direction. That this style
is uncommon in the Node ecosystem seems to be more a [function of
dogma](http://blog.izs.me/post/44149270867/why-no-directorieslib-in-node-the-less-snarky)
than any technical shortcoming of nested modules.

To ensure that developers don't inadvertently access private modules, we have
two good options:

1. Package modules in such a way that private modules _cannot_ be accessed.
2. Take a page from Ember Data and put all private modules in a `-private`
   directory, hopefully making it clear accessing this module is not playing by
   the rules.

We could avoid using this uncommon style by hoisting nested modules up to their
own package. For example, `@ember/object/observers` could become
`@ember/observers` or `@ember/object-observers`. However, because I could not
find a strong technical reason against it, and because having more packages is
in tension with the explicit goal to [make Ember feel less
overwhelming](#organize-by-mental-model), I decided it was worth the small cost.

# Alternatives

### `ember-` prefix

One alternative to the `@ember` scope is to use the `ember-` prefix. This avoids
the drawbacks around scoped packages described above. However, they would be
indistinguishable from the large number of community packages that begin with
`ember-`.

### Everything is a Named Export

This proposal argues that classes should be a module's default export, and any
utility functions should be a named export. That means you can never have more
than one class per module, and _that_ means, inherently, more `import`
statements than a system where multiple classes can live in one module.

Additionally, in cases where there is not a clear "primary" class, this can feel
a little awkward:

```js
import Route from "@ember/routing/route";
import Router from "@ember/routing/router";
```

One commonly proposed alternative is to say that classes become named exports,
and default exports are not used at all. The above example would become:

```js
import { Route, Router } from "@ember/routing";
```

In this case, classes are distinguished by being capitalized, rather than by
being a default export.

There is one major change coming to JavaScript and Ember that, your author
believes, deals a fatal blow to this approach: decorators.

If you're unfamiliar with decorators, see [Addy Osmani's great
overview][decorators]. Decorators provide a mechanism for adding declarative
annotations to classes, methods, properties and functions.

[decorators]: https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.y9umddvsl

For example, Robert Jackson has an [experimental library for using decorators to
annotate computed properties in a class][ember-computed-decorators]. Something
like this will probably make its way into Ember in the future:

```js
import EmberObject, { computed } from "@ember/object";

export default class Cat extends EmberObject {
  @computed("hairLength")
  isDomesticShortHair(hairLength) {
    return hairLength < 3;
  }
}
```

[ember-computed-decorators]: https://github.com/rwjblue/ember-computed-decorators

Most decorators are tightly coupled to a particular class because they configure
some aspect of behavior that is only relevant to that class. If every decorator
and every class share a namespace, it is hard to identify which go with each
other.

```js
import { Router, Route, resource, model, location, inject, queryParam } from "@ember/routing";
```

Can you tell me which of these decorators goes with which class?

And this import is getting so long, you'd probably be tempted to break it up
into multiple lines _anyway_, so it's not clear that it's actually a win over
separate imports.

Contrast this with the same thing expressed using the rules in
this RFC:

```js
import Router, { resource, location } from "@ember/routing/router";
import Route, { model, inject, queryParam } from "@ember/routing/route";
```

Here, the decorators are clearly tied to their class. And it's far nicer from a
refactoring perspective: if you delete a class from a file, you then delete a
single line from your imports.

Contrast that with making fiddly edits to a long list of named exports unrelated
to each other.

# Unresolved Questions

### Intimate APIs

How much do we want to provide module API for so-called "intimate
APIs"—technically private, but in widespread use?

### Backwards Compatibility for Addons

How do we provide an API for addons to use modules but fall back to globals mode
in older versions of Ember? We should ensure that, at minimum, addons can
continue to support LTS releases. At the same time, it's critical that adding an
addon doesn't opt your entire application back in to the entire framework.

Because there is a lot of implementation-specific detail to get right here, and
because it doesn't otherwise block landing this module naming RFC, the final
design of API for addon authors should be broken out into a separate RFC.

### Distribution

In practice, how do we ship this code to end users of Ember CLI?

When building client-side apps, it's very important to avoid duplicate
dependencies, which can quickly cause file size to balloon out of control.

Unfortunately, npm@3's de-duping is so naïve that it's likely that users would
end up in dependency hell if we shipped the framework as separate npm packages.
There's no good way to ship dependencies in version lockstep and feel confident
that they will reliably be de-duped.

Until Yarn usage is more widespread, and to eliminate significant complexity in
the first iteration, it probably makes sense for the first phase of
implementation to continue shipping a single npm package that Ember CLI apps can
depend on. This gives us atomic updates and makes sure you never have one piece
of the framework interacting with a different piece that is inadvertently three
versions old.

What this means is that, rather than shipping `@ember/object` on npm, we'd ship
a single `ember-source` (or something) package that includes the entire
framework. At build time, the Ember build process would virtually map the
`@ember/object` package to the right file inside `ember-source`. In essence, all
of the benefits of smaller bundles without the boiling hellbroth of managing
dependencies.

That said, because this RFC is designed with an eye towards eventually
publishing each package to npm individually, we will have that option available
to us in the future once we determine that we can do so without causing lots of
pain.

# Addenda

_(Ed. note: These tables are automatically generated from the scripts in the [codemod][codemod] repository.)_

[codemod]: https://github.com/tomdale/ember-modules-codemod

## Addendum 1 - Table of Module Names and Exports by Global

| Before                                | After                                                                      |
| ---                                   | ---                                                                        |
| `Ember.$`                             | `import $ from "jquery"`                                                   |
| `Ember.A`                             | `import { A } from "@ember/array"`                                         |
| `Ember.Application`                   | `import Application from "@ember/application"`                             |
| `Ember.Array`                         | `import EmberArray from "@ember/array"`                                    |
| `Ember.ArrayProxy`                    | `import ArrayProxy from "@ember/array/proxy"`                              |
| `Ember.AutoLocation`                  | `import AutoLocation from "@ember/routing/auto-location"`                  |
| `Ember.Checkbox`                      | `import Checkbox from "@ember/component/checkbox"`                         |
| `Ember.Component`                     | `import Component from "@ember/component"`                                 |
| `Ember.ContainerDebugAdapter`         | `import ContainerDebugAdapter from "@ember/debug/container-debug-adapter"` |
| `Ember.Controller`                    | `import Controller from "@ember/controller"`                               |
| `Ember.DataAdapter`                   | `import DataAdapter from "@ember/debug/data-adapter"`                      |
| `Ember.DefaultResolver`               | `import GlobalsResolver from "@ember/application/globals-resolver"`        |
| `Ember.Enumerable`                    | `import Enumerable from "@ember/enumerable"`                               |
| `Ember.Evented`                       | `import Evented from "@ember/object/evented"`                              |
| `Ember.HashLocation`                  | `import HashLocation from "@ember/routing/hash-location"`                  |
| `Ember.Helper`                        | `import Helper from "@ember/component/helper"`                             |
| `Ember.Helper.helper`                 | `import { helper } from "@ember/component/helper"`                         |
| `Ember.HistoryLocation`               | `import HistoryLocation from "@ember/routing/history-location"`            |
| `Ember.LinkComponent`                 | `import LinkComponent from "@ember/routing/link-component"`                |
| `Ember.Location`                      | `import Location from "@ember/routing/location"`                           |
| `Ember.Map`                           | `import EmberMap from "@ember/map"`                                        |
| `Ember.MapWithDefault`                | `import MapWithDefault from "@ember/map/with-default"`                     |
| `Ember.Mixin`                         | `import Mixin from "@ember/object/mixin"`                                  |
| `Ember.MutableArray`                  | `import MutableArray from "@ember/array/mutable"`                          |
| `Ember.NoneLocation`                  | `import NoneLocation from "@ember/routing/none-location"`                  |
| `Ember.Object`                        | `import EmberObject from "@ember/object"`                                  |
| `Ember.RSVP`                          | `import RSVP from "rsvp"`                                                  |
| `Ember.Resolver`                      | `import Resolver from "@ember/application/resolver"`                       |
| `Ember.Route`                         | `import Route from "@ember/routing/route"`                                 |
| `Ember.Router`                        | `import Router from "@ember/routing/router"`                               |
| `Ember.Service`                       | `import Service from "@ember/service"`                                     |
| `Ember.String.camelize`               | `import { camelize } from "@ember/string"`                                 |
| `Ember.String.capitalize`             | `import { capitalize } from "@ember/string"`                               |
| `Ember.String.classify`               | `import { classify } from "@ember/string"`                                 |
| `Ember.String.dasherize`              | `import { dasherize } from "@ember/string"`                                |
| `Ember.String.decamelize`             | `import { decamelize } from "@ember/string"`                               |
| `Ember.String.fmt`                    | `import { fmt } from "@ember/string"`                                      |
| `Ember.String.htmlSafe`               | `import { htmlSafe } from "@ember/string"`                                 |
| `Ember.String.loc`                    | `import { loc } from "@ember/string"`                                      |
| `Ember.String.underscore`             | `import { underscore } from "@ember/string"`                               |
| `Ember.String.w`                      | `import { w } from "@ember/string"`                                        |
| `Ember.TextArea`                      | `import TextArea from "@ember/component/text-area"`                        |
| `Ember.TextField`                     | `import TextField from "@ember/component/text-field"`                      |
| `Ember.addListener`                   | `import { addListener } from "@ember/object/events"`                       |
| `Ember.addObserver`                   | `import { addObserver } from "@ember/object/observers"`                    |
| `Ember.aliasMethod`                   | `import { aliasMethod } from "@ember/object"`                              |
| `Ember.assert`                        | `import { assert } from "@ember/debug"`                                    |
| `Ember.assign`                        | `import { assign } from "@ember/polyfills"`                                |
| `Ember.cacheFor`                      | `import { cacheFor } from "@ember/object/internals"`                       |
| `Ember.compare`                       | `import { compare } from "@ember/utils"`                                   |
| `Ember.computed`                      | `import { computed } from "@ember/object"`                                 |
| `Ember.computed.alias`                | `import { alias } from "@ember/object/computed"`                           |
| `Ember.computed.and`                  | `import { and } from "@ember/object/computed"`                             |
| `Ember.computed.bool`                 | `import { bool } from "@ember/object/computed"`                            |
| `Ember.computed.collect`              | `import { collect } from "@ember/object/computed"`                         |
| `Ember.computed.deprecatingAlias`     | `import { deprecatingAlias } from "@ember/object/computed"`                |
| `Ember.computed.empty`                | `import { empty } from "@ember/object/computed"`                           |
| `Ember.computed.equal`                | `import { equal } from "@ember/object/computed"`                           |
| `Ember.computed.filter`               | `import { filter } from "@ember/object/computed"`                          |
| `Ember.computed.filterBy`             | `import { filterBy } from "@ember/object/computed"`                        |
| `Ember.computed.filterProperty`       | `import { filterProperty } from "@ember/object/computed"`                  |
| `Ember.computed.gt`                   | `import { gt } from "@ember/object/computed"`                              |
| `Ember.computed.gte`                  | `import { gte } from "@ember/object/computed"`                             |
| `Ember.computed.intersect`            | `import { intersect } from "@ember/object/computed"`                       |
| `Ember.computed.lt`                   | `import { lt } from "@ember/object/computed"`                              |
| `Ember.computed.lte`                  | `import { lte } from "@ember/object/computed"`                             |
| `Ember.computed.map`                  | `import { map } from "@ember/object/computed"`                             |
| `Ember.computed.mapBy`                | `import { mapBy } from "@ember/object/computed"`                           |
| `Ember.computed.mapProperty`          | `import { mapProperty } from "@ember/object/computed"`                     |
| `Ember.computed.match`                | `import { match } from "@ember/object/computed"`                           |
| `Ember.computed.max`                  | `import { max } from "@ember/object/computed"`                             |
| `Ember.computed.min`                  | `import { min } from "@ember/object/computed"`                             |
| `Ember.computed.none`                 | `import { none } from "@ember/object/computed"`                            |
| `Ember.computed.not`                  | `import { not } from "@ember/object/computed"`                             |
| `Ember.computed.notEmpty`             | `import { notEmpty } from "@ember/object/computed"`                        |
| `Ember.computed.oneWay`               | `import { oneWay } from "@ember/object/computed"`                          |
| `Ember.computed.or`                   | `import { or } from "@ember/object/computed"`                              |
| `Ember.computed.readOnly`             | `import { readOnly } from "@ember/object/computed"`                        |
| `Ember.computed.reads`                | `import { reads } from "@ember/object/computed"`                           |
| `Ember.computed.setDiff`              | `import { setDiff } from "@ember/object/computed"`                         |
| `Ember.computed.sort`                 | `import { sort } from "@ember/object/computed"`                            |
| `Ember.computed.sum`                  | `import { sum } from "@ember/object/computed"`                             |
| `Ember.computed.union`                | `import { union } from "@ember/object/computed"`                           |
| `Ember.computed.uniq`                 | `import { uniq } from "@ember/object/computed"`                            |
| `Ember.copy`                          | `import { copy } from "@ember/object/internals"`                           |
| `Ember.create`                        | `import { create } from "@ember/polyfills"`                                |
| `Ember.debug`                         | `import { debug } from "@ember/debug"`                                     |
| `Ember.deprecate`                     | `import { deprecate } from "@ember/application/deprecations"`              |
| `Ember.deprecateFunc`                 | `import { deprecateFunc } from "@ember/application/deprecations"`          |
| `Ember.get`                           | `import { get } from "@ember/object"`                                      |
| `Ember.getOwner`                      | `import { getOwner } from "@ember/application"`                            |
| `Ember.getProperties`                 | `import { getProperties } from "@ember/object"`                            |
| `Ember.guidFor`                       | `import { guidFor } from "@ember/object/internals"`                        |
| `Ember.inject.controller`             | `import { inject } from "@ember/controller"`                               |
| `Ember.inject.service`                | `import { inject } from "@ember/service"`                                  |
| `Ember.inspect`                       | `import { inspect } from "@ember/debug"`                                   |
| `Ember.instrument`                    | `import { instrument } from "@ember/instrumentation"`                      |
| `Ember.isArray`                       | `import { isArray } from "@ember/array"`                                   |
| `Ember.isBlank`                       | `import { isBlank } from "@ember/utils"`                                   |
| `Ember.isEmpty`                       | `import { isEmpty } from "@ember/utils"`                                   |
| `Ember.isEqual`                       | `import { isEqual } from "@ember/utils"`                                   |
| `Ember.isNone`                        | `import { isNone } from "@ember/utils"`                                    |
| `Ember.isPresent`                     | `import { isPresent } from "@ember/utils"`                                 |
| `Ember.keys`                          | `import { keys } from "@ember/polyfills"`                                  |
| `Ember.makeArray`                     | `import { makeArray } from "@ember/array"`                                 |
| `Ember.observer`                      | `import { observer } from "@ember/object"`                                 |
| `Ember.on`                            | `import { on } from "@ember/object/evented"`                               |
| `Ember.onLoad`                        | `import { onLoad } from "@ember/application"`                              |
| `Ember.platform.defineProperty`       | `import { defineProperty } from "@ember/polyfills"`                        |
| `Ember.platform.hasPropertyAccessors` | `import { hasPropertyAccessors } from "@ember/polyfills"`                  |
| `Ember.removeListener`                | `import { removeListener } from "@ember/object/events"`                    |
| `Ember.removeObserver`                | `import { removeObserver } from "@ember/object/observers"`                 |
| `Ember.reset`                         | `import { reset } from "@ember/instrumentation"`                           |
| `Ember.run`                           | `import { run } from "@ember/runloop"`                                     |
| `Ember.run.begin`                     | `import { begin } from "@ember/runloop"`                                   |
| `Ember.run.bind`                      | `import { bind } from "@ember/runloop"`                                    |
| `Ember.run.cancel`                    | `import { cancel } from "@ember/runloop"`                                  |
| `Ember.run.debounce`                  | `import { debounce } from "@ember/runloop"`                                |
| `Ember.run.end`                       | `import { end } from "@ember/runloop"`                                     |
| `Ember.run.join`                      | `import { join } from "@ember/runloop"`                                    |
| `Ember.run.later`                     | `import { later } from "@ember/runloop"`                                   |
| `Ember.run.next`                      | `import { next } from "@ember/runloop"`                                    |
| `Ember.run.once`                      | `import { once } from "@ember/runloop"`                                    |
| `Ember.run.schedule`                  | `import { schedule } from "@ember/runloop"`                                |
| `Ember.run.scheduleOnce`              | `import { scheduleOnce } from "@ember/runloop"`                            |
| `Ember.run.throttle`                  | `import { throttle } from "@ember/runloop"`                                |
| `Ember.runInDebug`                    | `import { runInDebug } from "@ember/debug"`                                |
| `Ember.runLoadHooks`                  | `import { runLoadHooks } from "@ember/application"`                        |
| `Ember.sendEvent`                     | `import { sendEvent } from "@ember/object/events"`                         |
| `Ember.set`                           | `import { set } from "@ember/object"`                                      |
| `Ember.setOwner`                      | `import { setOwner } from "@ember/application"`                            |
| `Ember.setProperties`                 | `import { setProperties } from "@ember/object"`                            |
| `Ember.subscribe`                     | `import { subscribe } from "@ember/instrumentation"`                       |
| `Ember.tryInvoke`                     | `import { tryInvoke } from "@ember/utils"`                                 |
| `Ember.trySet`                        | `import { trySet } from "@ember/object"`                                   |
| `Ember.typeOf`                        | `import { typeOf } from "@ember/utils"`                                    |
| `Ember.unsubscribe`                   | `import { unsubscribe } from "@ember/instrumentation"`                     |
| `Ember.warn`                          | `import { warn } from "@ember/debug"`                                      |

## Addendum 2 - Table of Module Names and Exports by Package

Each package is sorted by module name, then export name.

### `@ember/application`
| Module                                                              | Global                  |
| ---                                                                 | ---                     |
| `import Application from "@ember/application"`                      | `Ember.Application`     |
| `import { getOwner } from "@ember/application"`                     | `Ember.getOwner`        |
| `import { onLoad } from "@ember/application"`                       | `Ember.onLoad`          |
| `import { runLoadHooks } from "@ember/application"`                 | `Ember.runLoadHooks`    |
| `import { setOwner } from "@ember/application"`                     | `Ember.setOwner`        |
| `import { deprecate } from "@ember/application/deprecations"`       | `Ember.deprecate`       |
| `import { deprecateFunc } from "@ember/application/deprecations"`   | `Ember.deprecateFunc`   |
| `import GlobalsResolver from "@ember/application/globals-resolver"` | `Ember.DefaultResolver` |
| `import Resolver from "@ember/application/resolver"`                | `Ember.Resolver`        |

### `@ember/array`
| Module                                            | Global               |
| ---                                               | ---                  |
| `import EmberArray from "@ember/array"`           | `Ember.Array`        |
| `import { A } from "@ember/array"`                | `Ember.A`            |
| `import { isArray } from "@ember/array"`          | `Ember.isArray`      |
| `import { makeArray } from "@ember/array"`        | `Ember.makeArray`    |
| `import MutableArray from "@ember/array/mutable"` | `Ember.MutableArray` |
| `import ArrayProxy from "@ember/array/proxy"`     | `Ember.ArrayProxy`   |

### `@ember/component`
| Module                                                | Global                |
| ---                                                   | ---                   |
| `import Component from "@ember/component"`            | `Ember.Component`     |
| `import Checkbox from "@ember/component/checkbox"`    | `Ember.Checkbox`      |
| `import Helper from "@ember/component/helper"`        | `Ember.Helper`        |
| `import { helper } from "@ember/component/helper"`    | `Ember.Helper.helper` |
| `import TextArea from "@ember/component/text-area"`   | `Ember.TextArea`      |
| `import TextField from "@ember/component/text-field"` | `Ember.TextField`     |

### `@ember/controller`
| Module                                       | Global                    |
| ---                                          | ---                       |
| `import Controller from "@ember/controller"` | `Ember.Controller`        |
| `import { inject } from "@ember/controller"` | `Ember.inject.controller` |

### `@ember/debug`
| Module                                                                     | Global                        |
| ---                                                                        | ---                           |
| `import { assert } from "@ember/debug"`                                    | `Ember.assert`                |
| `import { debug } from "@ember/debug"`                                     | `Ember.debug`                 |
| `import { inspect } from "@ember/debug"`                                   | `Ember.inspect`               |
| `import { runInDebug } from "@ember/debug"`                                | `Ember.runInDebug`            |
| `import { warn } from "@ember/debug"`                                      | `Ember.warn`                  |
| `import ContainerDebugAdapter from "@ember/debug/container-debug-adapter"` | `Ember.ContainerDebugAdapter` |
| `import DataAdapter from "@ember/debug/data-adapter"`                      | `Ember.DataAdapter`           |

### `@ember/enumerable`
| Module                                       | Global             |
| ---                                          | ---                |
| `import Enumerable from "@ember/enumerable"` | `Ember.Enumerable` |

### `@ember/instrumentation`
| Module                                                 | Global              |
| ---                                                    | ---                 |
| `import { instrument } from "@ember/instrumentation"`  | `Ember.instrument`  |
| `import { reset } from "@ember/instrumentation"`       | `Ember.reset`       |
| `import { subscribe } from "@ember/instrumentation"`   | `Ember.subscribe`   |
| `import { unsubscribe } from "@ember/instrumentation"` | `Ember.unsubscribe` |

### `@ember/map`
| Module                                                 | Global                 |
| ---                                                    | ---                    |
| `import EmberMap from "@ember/map"`                    | `Ember.Map`            |
| `import MapWithDefault from "@ember/map/with-default"` | `Ember.MapWithDefault` |

### `@ember/object`
| Module                                                      | Global                            |
| ---                                                         | ---                               |
| `import EmberObject from "@ember/object"`                   | `Ember.Object`                    |
| `import { aliasMethod } from "@ember/object"`               | `Ember.aliasMethod`               |
| `import { computed } from "@ember/object"`                  | `Ember.computed`                  |
| `import { get } from "@ember/object"`                       | `Ember.get`                       |
| `import { getProperties } from "@ember/object"`             | `Ember.getProperties`             |
| `import { observer } from "@ember/object"`                  | `Ember.observer`                  |
| `import { set } from "@ember/object"`                       | `Ember.set`                       |
| `import { setProperties } from "@ember/object"`             | `Ember.setProperties`             |
| `import { trySet } from "@ember/object"`                    | `Ember.trySet`                    |
| `import { alias } from "@ember/object/computed"`            | `Ember.computed.alias`            |
| `import { and } from "@ember/object/computed"`              | `Ember.computed.and`              |
| `import { bool } from "@ember/object/computed"`             | `Ember.computed.bool`             |
| `import { collect } from "@ember/object/computed"`          | `Ember.computed.collect`          |
| `import { deprecatingAlias } from "@ember/object/computed"` | `Ember.computed.deprecatingAlias` |
| `import { empty } from "@ember/object/computed"`            | `Ember.computed.empty`            |
| `import { equal } from "@ember/object/computed"`            | `Ember.computed.equal`            |
| `import { filter } from "@ember/object/computed"`           | `Ember.computed.filter`           |
| `import { filterBy } from "@ember/object/computed"`         | `Ember.computed.filterBy`         |
| `import { filterProperty } from "@ember/object/computed"`   | `Ember.computed.filterProperty`   |
| `import { gt } from "@ember/object/computed"`               | `Ember.computed.gt`               |
| `import { gte } from "@ember/object/computed"`              | `Ember.computed.gte`              |
| `import { intersect } from "@ember/object/computed"`        | `Ember.computed.intersect`        |
| `import { lt } from "@ember/object/computed"`               | `Ember.computed.lt`               |
| `import { lte } from "@ember/object/computed"`              | `Ember.computed.lte`              |
| `import { map } from "@ember/object/computed"`              | `Ember.computed.map`              |
| `import { mapBy } from "@ember/object/computed"`            | `Ember.computed.mapBy`            |
| `import { mapProperty } from "@ember/object/computed"`      | `Ember.computed.mapProperty`      |
| `import { match } from "@ember/object/computed"`            | `Ember.computed.match`            |
| `import { max } from "@ember/object/computed"`              | `Ember.computed.max`              |
| `import { min } from "@ember/object/computed"`              | `Ember.computed.min`              |
| `import { none } from "@ember/object/computed"`             | `Ember.computed.none`             |
| `import { not } from "@ember/object/computed"`              | `Ember.computed.not`              |
| `import { notEmpty } from "@ember/object/computed"`         | `Ember.computed.notEmpty`         |
| `import { oneWay } from "@ember/object/computed"`           | `Ember.computed.oneWay`           |
| `import { or } from "@ember/object/computed"`               | `Ember.computed.or`               |
| `import { readOnly } from "@ember/object/computed"`         | `Ember.computed.readOnly`         |
| `import { reads } from "@ember/object/computed"`            | `Ember.computed.reads`            |
| `import { setDiff } from "@ember/object/computed"`          | `Ember.computed.setDiff`          |
| `import { sort } from "@ember/object/computed"`             | `Ember.computed.sort`             |
| `import { sum } from "@ember/object/computed"`              | `Ember.computed.sum`              |
| `import { union } from "@ember/object/computed"`            | `Ember.computed.union`            |
| `import { uniq } from "@ember/object/computed"`             | `Ember.computed.uniq`             |
| `import Evented from "@ember/object/evented"`               | `Ember.Evented`                   |
| `import { on } from "@ember/object/evented"`                | `Ember.on`                        |
| `import { addListener } from "@ember/object/events"`        | `Ember.addListener`               |
| `import { removeListener } from "@ember/object/events"`     | `Ember.removeListener`            |
| `import { sendEvent } from "@ember/object/events"`          | `Ember.sendEvent`                 |
| `import { cacheFor } from "@ember/object/internals"`        | `Ember.cacheFor`                  |
| `import { copy } from "@ember/object/internals"`            | `Ember.copy`                      |
| `import { guidFor } from "@ember/object/internals"`         | `Ember.guidFor`                   |
| `import Mixin from "@ember/object/mixin"`                   | `Ember.Mixin`                     |
| `import { addObserver } from "@ember/object/observers"`     | `Ember.addObserver`               |
| `import { removeObserver } from "@ember/object/observers"`  | `Ember.removeObserver`            |

### `@ember/polyfills`
| Module                                                    | Global                                |
| ---                                                       | ---                                   |
| `import { assign } from "@ember/polyfills"`               | `Ember.assign`                        |
| `import { create } from "@ember/polyfills"`               | `Ember.create`                        |
| `import { defineProperty } from "@ember/polyfills"`       | `Ember.platform.defineProperty`       |
| `import { hasPropertyAccessors } from "@ember/polyfills"` | `Ember.platform.hasPropertyAccessors` |
| `import { keys } from "@ember/polyfills"`                 | `Ember.keys`                          |

### `@ember/routing`
| Module                                                          | Global                  |
| ---                                                             | ---                     |
| `import AutoLocation from "@ember/routing/auto-location"`       | `Ember.AutoLocation`    |
| `import HashLocation from "@ember/routing/hash-location"`       | `Ember.HashLocation`    |
| `import HistoryLocation from "@ember/routing/history-location"` | `Ember.HistoryLocation` |
| `import LinkComponent from "@ember/routing/link-component"`     | `Ember.LinkComponent`   |
| `import Location from "@ember/routing/location"`                | `Ember.Location`        |
| `import NoneLocation from "@ember/routing/none-location"`       | `Ember.NoneLocation`    |
| `import Route from "@ember/routing/route"`                      | `Ember.Route`           |
| `import Router from "@ember/routing/router"`                    | `Ember.Router`          |

### `@ember/runloop`
| Module                                          | Global                   |
| ---                                             | ---                      |
| `import { begin } from "@ember/runloop"`        | `Ember.run.begin`        |
| `import { bind } from "@ember/runloop"`         | `Ember.run.bind`         |
| `import { cancel } from "@ember/runloop"`       | `Ember.run.cancel`       |
| `import { debounce } from "@ember/runloop"`     | `Ember.run.debounce`     |
| `import { end } from "@ember/runloop"`          | `Ember.run.end`          |
| `import { join } from "@ember/runloop"`         | `Ember.run.join`         |
| `import { later } from "@ember/runloop"`        | `Ember.run.later`        |
| `import { next } from "@ember/runloop"`         | `Ember.run.next`         |
| `import { once } from "@ember/runloop"`         | `Ember.run.once`         |
| `import { run } from "@ember/runloop"`          | `Ember.run`              |
| `import { schedule } from "@ember/runloop"`     | `Ember.run.schedule`     |
| `import { scheduleOnce } from "@ember/runloop"` | `Ember.run.scheduleOnce` |
| `import { throttle } from "@ember/runloop"`     | `Ember.run.throttle`     |

### `@ember/service`
| Module                                    | Global                 |
| ---                                       | ---                    |
| `import Service from "@ember/service"`    | `Ember.Service`        |
| `import { inject } from "@ember/service"` | `Ember.inject.service` |

### `@ember/string`
| Module                                       | Global                    |
| ---                                          | ---                       |
| `import { camelize } from "@ember/string"`   | `Ember.String.camelize`   |
| `import { capitalize } from "@ember/string"` | `Ember.String.capitalize` |
| `import { classify } from "@ember/string"`   | `Ember.String.classify`   |
| `import { dasherize } from "@ember/string"`  | `Ember.String.dasherize`  |
| `import { decamelize } from "@ember/string"` | `Ember.String.decamelize` |
| `import { fmt } from "@ember/string"`        | `Ember.String.fmt`        |
| `import { htmlSafe } from "@ember/string"`   | `Ember.String.htmlSafe`   |
| `import { loc } from "@ember/string"`        | `Ember.String.loc`        |
| `import { underscore } from "@ember/string"` | `Ember.String.underscore` |
| `import { w } from "@ember/string"`          | `Ember.String.w`          |

### `@ember/utils`
| Module                                     | Global            |
| ---                                        | ---               |
| `import { compare } from "@ember/utils"`   | `Ember.compare`   |
| `import { isBlank } from "@ember/utils"`   | `Ember.isBlank`   |
| `import { isEmpty } from "@ember/utils"`   | `Ember.isEmpty`   |
| `import { isNone } from "@ember/utils"`    | `Ember.isNone`    |
| `import { isPresent } from "@ember/utils"` | `Ember.isPresent` |
| `import { tryInvoke } from "@ember/utils"` | `Ember.tryInvoke` |
| `import { typeOf } from "@ember/utils"`    | `Ember.typeOf`    |

### `jquery`
| Module                   | Global    |
| ---                      | ---       |
| `import $ from "jquery"` | `Ember.$` |

### `rsvp`
| Module                    | Global       |
| ---                       | ---          |
| `import RSVP from "rsvp"` | `Ember.RSVP` |

## Addendum 3 - Table of Modules with Side Effects

| Module                               | Description                                |
| ---                                  | ---                                        |
| `import "@ember/extensions"`         | Adds all of Ember's prototype extensions.  |
| `import "@ember/extensions/string"`  | Adds just `String` prototype extensions.   |
| `import "@ember/extensions/array"`   | Adds just `Array` prototype extensions.    |
| `import "@ember/extensions/function"`| Adds just `Function` prototype extensions. |


---

---
stage: recommended
start-date: 2016-11-18T00:00:00.000Z
release-date: 2017-03-14T00:00:00.000Z
release-versions:
  ember-source: v2.12.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/178
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/issues/14746
---

# Summary

The `Ember.K` utility function is a low level utility that has lost most of its value today.

# Motivation

Let's start explaining what `Ember.K` is.

It is an utility function to avoid boilerplace code and limit the creation of function instances
in Ember's internals. The source code for this API is the following:

```js
Ember.K = function() {
  return this;
}
```

In a world of globals, writing `somefn: Ember.K` was effectively shorter
than writing

```js
someFn: function() {
  return this;
}
```

and generated fewer function allocations.

However with the introduction of ES6 modules and the modularization of Ember
in process (#176), keeping this feature would require to design an import path for it.

While doable, the transpiled output is actually bigger then defining the functions
inline, specially with the ES6 shorthand method syntax, and the perf difference
of saving a few function allocations is negligible.

The second downside of reusing the same instance in many places is that if for
some reason the VM deoptimizes that function, that deoptimization is spreaded
across all the usages of `Ember.K`.

Third, the chainable nature of `Ember.K` tends to surprise the users:

```js
let derp = {
  foo: Ember.K,
  bar: Ember.K,
  baz: Ember.K
}

derp.foo().bar().baz(); // O_o
```

And lastly but more importantly for simplicity. Consider the following code:

```js
export default Component.extend({
  onSubmit() {}
});
```

Any JS developer will understand that this is an empty function and will probably understand
that is a placeholder to provide your own function instead. However, JS developers that come
across `Ember.K` for the first time will se this:


```js
export default Component.extend({
  onSubmit: Ember.K
});
```

and will think that it is some cryptic Ember magic that they have to learn.

# Transition Path

The necessary first step is to make sure Ember, Ember Data and other pieces of the
ecosystem don't use `Ember.K` internally.

Phased approach:
* Deprecate `Ember.K`: Use the deprecation API to signal the deprecation, and deprecation guide entry.
  Target version will be 3.0, as usual.
* Add rule to ember-watson
* Do not include export path in https://github.com/emberjs/rfcs/pull/176, but include it until 3.0 in the "globals" build.

# How We Teach This

Since it is a very low-level utility,
the amount of people that will have to update their code should be a limited set of developers, working mostly on addons.
This allows us to cover most use cases with the following strategy:
* Improve the current documentation to help developers finding the API for the first time in the future;
* Provide an automated path forward through tooling such as [ember-watson](https://github.com/abuiles/ember-watson). (see Addendum 1)
* Introduce the mandatory entry in the deprecations guide referencing the automated tooling.

If this RFC is done as part of https://github.com/emberjs/rfcs/pull/176 as suggested,
it will be in the document or blog post announcing the final transition to modules.

# Drawbacks

Although this utility is not very used, there is a chance that is used by some
addons and as a placeholder of a hook that is called a lot and would trigger
hundreds of deprecation warnings.

# Alternatives

The feature could continue to exist.

# Addenda

## Addendum 1 - Codemod to automatically remove all usages of `Ember.K` on any project.

https://github.com/cibernox/ember-k-codemod

To use it you can install it globally and invoke the command on any app or addon.

The commands **requires** the user to decide the approach to replace occurenced of `Ember.K`. The
possible flags are `--empty` and `--return-this`.

- `--empty` replaces `Ember.K` with an empty function. This leads to the most idiomatic and
  intention-revealing code, but does not allow chaining, like the original `Ember.K` did.
  Despite of that, chaining `Ember.K` was such an uncommon patterns that we thing virtually
  everybody can use this option.
- `--return-this` replaces `Ember.K` with a function that just returns `this`. This allows chaining
  like the original one.


Example usage:

```
npm install -g ember-k-codemod && ember-k-codemod --empty
```

Versions of [ember-watson](https://github.com/abuiles/ember-watson) starting in `0.8.5` wrap this
codemod so you can achieve the same transformation with it:

```
ember-watson remove-ember-k --empty

// or if installed as an addon

ember watson:remove-ember-k --empty
```

## Addendum 2 - `Ember.K` usage across published addons

```
ae-select/addon/components/ae-select.js:  action: Ember.K, // action to fire on change
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-change': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-add': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-search': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-add') !== Ember.K;
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-search') === Ember.K;
ella-list-view/addon/views/list-item.coffee:  prepareContent: Ember.K
ella-list-view/addon/views/list-item.coffee:  teardownContent: Ember.K
ella-list-view/addon/views/list.coffee:  arrayWillChange: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToTop: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToBottom: Ember.K
ella-list-view/addon/views/list.coffee:  visibleItemsDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    if @didRequestRange isnt Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    unless (@didRequestLength is Ember.K) or get(@, 'isRequestingLength')
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentWillChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didReplaceSparseArrayItem: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestIndex: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestRange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestLength: Ember.K
elvis-network/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
elvis-network/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-animate/ember-animate.js:        willAnimateIn : Ember.K,
ember-animate/ember-animate.js:        willAnimateOut : Ember.K,
ember-animate/ember-animate.js:        didAnimateIn : Ember.K,
ember-animate/ember-animate.js:        didAnimateOut : Ember.K,
ember-animate/ember-animate.js:        _currentViewWillChange : Ember.K,
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  action: Ember.K, //@public
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  source : Ember.K, //@public
ember-autoresize/addon/mixins/autoresize.js:let trim = Ember.K;
ember-bootstrap/addon/components/bs-form-element.js:  setupValidations: Ember.K,
ember-bootstrap/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bootstrap-components/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bugsnag/app/instance-initializers/bugsnag.js:  let originalOnError = Ember.onerror || Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeStart: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeEnd: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResize: Ember.K,
ember-cli-adapter-pattern/tests/dummy/app/starships/starship.js:  _makeItSo: Ember.K
ember-cli-airbrake/README.md:In all cases, an `airbrake` service will be exposed. If airbrake isn't configured the airbrake service uses the Ember.K "no-op" function for its methods. This facilitates the usage of the airbrake service without having to add environment-checking code in your app.
ember-cli-airbrake/README.md:exist, but all its methods will be no-ops (`Ember.K`). This way your tests will still run happily even
ember-cli-airbrake/app/instance-initializers/ember-cli-airbrake.js:  let originalOnError = Ember.onerror || Ember.K;
ember-cli-analytics/addon/integrations/base.js:  trackPage: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackEvent: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackConversion: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  identify: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  alias: Ember.K
ember-cli-analytics/tests/unit/mixins/trackable-test.js:  const analytics = { trackPage: Ember.K };
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      initialValue: Ember.K
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      key: Ember.K
ember-cli-bugsnag/app/instance-initializers/bugsnag.js:      const originalDidTransition = router.didTransition || Ember.K;
ember-cli-coreweb/app/initializers/ember-coreweb.js:  initialize: Ember.K
ember-cli-dialog/packages/ember-dialog/lib/ember-initializer.js:// var K = Ember.K;
ember-cli-dimple/addon/components/dimple-chart/component.coffee:  customizeChart: Ember.K
ember-cli-dimple/addon/components/dimple-chart/component.js:  customizeChart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeStart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeEnd: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResize: Ember.K,
ember-cli-dynamic-forms/addon/components/dynamic-form.js:  renderSchema: Ember.K,
ember-cli-erraroo/addon/erraroo.js:    const oldEmberOnerror = Ember.onerror || Ember.K;
ember-cli-fullpagejs-view/addon/initializers/remove-fullpage.js:  initialize: Ember.K
ember-cli-infinite-scroll/addon/mixins/infinite-scroll.js:  beforeInfiniteQuery: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:          onChange: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:      options.onFinish = Ember.K;
ember-cli-jsoneditor/addon/components/json-editor.js:  onChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onError: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onModeChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onEditable: Ember.K,
ember-cli-maskedinput/addon/components/masked-input.js:  'on-change': Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  beforeSetup: Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  afterSetup: Ember.K,
ember-cli-nvd3-multichart/addon/components/nvd3-multichart.js:  chartContextFn: Ember.K,
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-selectize/addon/components/ember-selectize.js:  _groupedContentArrayWillChange: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-concurrency/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-confirm-dialog/addon/components/confirm-dialog.js:  confirmAction: Ember.K,//optional action executed when user confirms the dialog
ember-confirm-dialog/addon/components/confirm-dialog.js:  cancelAction: Ember.K,//optional action executed when user cancels confirmation dialog
ember-cookie-consent-cnil/app/mixins/click-else-where.js:  onOutsideClick: Ember.K,
ember-data-model-fragments/addon/states.js:  propertyWasReset: Ember.K,
ember-data-model-fragments/addon/states.js:  becomeDirty: Ember.K,
ember-data-model-fragments/addon/states.js:  rolledBack: Ember.K,
ember-data-model-fragments/addon/states.js:      pushedData: Ember.K,
ember-data-model-fragments/addon/states.js:      didCommit: Ember.K,
ember-data-sails/addon/initializers/ember-data-sails.js:      methods[level] = Ember.K;
ember-dev-fixtures/private/utils/dev-fixtures/module.js:      define(this.get('fullPath'), ['exports'], Ember.K);
ember-dp-map/addon/components/_dp-base-map-element.js:  didLoadMap: Ember.K
ember-drag-drop/addon/mixins/droppable.js:  acceptDrop: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOver: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOut: Ember.K,
ember-form-object/tests/unit/forms/model-form-test.js:  }).catch(Ember.K);
ember-froala/addon/components/froala-editor.js:        var buttons = this.get('customButtons') || Ember.K;
ember-google-charts/tests/integration/components/options-change-test.js:    this.on('chartDidRender', Ember.K);
ember-img-cache/app/initializers/ember-img-cache.js:  initialize: Ember.K
ember-img-manager/app/utils/img-manager/img-clone-holder.js:  this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:      this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:   * @param {Function} [handler=Ember.K]
ember-img-manager/app/utils/img-manager/img-clone-holder.js:    this.handler = handler || Ember.K;
ember-infinity/tests/unit/mixins/route-test.js:      pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-jsonapi-resources/addon/adapters/application.js:    let cleanup = Ember.K;
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = {deserialize: sandbox.spy(), deserializeIncluded: Ember.K};
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = { deserialize: sandbox.spy(), deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/fetch-test.js:  this.subject.serializer = { deserialize: function(res) { return res.data; }, deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:        trigger: Ember.K
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      guns: {kind: 'hasMany', mapBy: Ember.K }, // hasMany('guns')
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      horse: {kind: 'hasOne', get: Ember.K } // hasOne('horse')
ember-jsonapi-resources-form/addon/components/resource-form.js:    if (!action) { return Ember.K; /* fail silently if no action */ }
ember-jsonapi-resources-list/addon/mixins/controllers/jsonapi-list.js:    filtering: Ember.K,
ember-key-responder/app/key-responder.js:    comments for Ember.KeyResponderStack above for more insight.
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onSelect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onDeselect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown.js:  onItemSelect: Ember.K,
ember-list-card/addon/components/list-card/header.js:  onQueryOptionSelect: Ember.K,
ember-material-design/addon/mixins/events.js:    start: Ember.K,
ember-material-design/addon/mixins/events.js:    move: Ember.K,
ember-material-design/addon/mixins/events.js:    end: Ember.K
ember-material-design/addon/mixins/gesture-events.js:    onStart: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onMove: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onEnd: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onCancel: Ember.K,
ember-material-design/app/services/ripple.js:            return Ember.K;
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  init: Ember.K,
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  willDestroy: Ember.K
ember-mixpanel/addon/mixpanel.js:          return Ember.K;
ember-mixpanel/addon/mixpanel.js:      return Ember.K;
ember-notifyme/addon/objects/notification-message.js:  onClick: Ember.K,
ember-notifyme/addon/objects/notification-message.js:  onClose: Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClick: options.onClick || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClose: options.onClose || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onCloseTimeout: options.onCloseTimeout || Ember.K,
ember-off-canvas-components/addon/initializers/custom-events.js:  initialize: Ember.K
ember-pardon/addon/mixins/ember-pardon.js:	beforeDestroy: Ember.K,
ember-phoenix-channel/tests/integration/components/socket-message-log-test.js:  on: Ember.K
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayOpen: Ember.K,
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onOpen: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onSelection: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onDraw: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayOpen: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayRedraw: Ember.K,
ember-processes/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-render-stack/addon/route-mixin.js:  renderStack: Ember.K,
ember-restless/dist/ember-restless.js:  var noop = Ember.K;
ember-restless/dist/ember-restless.js:    _onPropertyChange: Ember.K
ember-restless/src/model/read-only-model.js:  _onPropertyChange: Ember.K
ember-restless/src/model/state.js:var noop = Ember.K;
ember-reveal-js/addon/components/reveal-presentation/component.js:      before: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onOpen: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onClose: Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-change': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-add': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-search': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-close': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-add') !== Ember.K;
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-search') === Ember.K;
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-change                 | Specify your own named action to trigger when the selection changes. eg. <code>(action "update")</code> <br> For single selection (default behaviour), the selected object is sent as an argument. For multiple selections, an array of options is sent. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-add                    | Allow unfound items to be added to the content array by specifying your own named action. eg. `(action "addNew")` The new item name is sent as an argument. You must handle adding the item to the content array and selecting the new item outside the component. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    provided.     | Ember action    | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-close                  | Specify your own named action to trigger when the menu closes. Useful hook for clearing out content that was previously passed in with AJAX. | Ember action | Ember.K
ember-select-list/addon/components/select-list.js:  action: Ember.K, // action to fire on change
ember-smart-banner/addon/components/smart-banner.js:      const visitFn = Ember.getWithDefault(this, 'attrs.onvisit', Ember.K);
ember-smart-banner/addon/components/smart-banner.js:      const closeFn = Ember.getWithDefault(this, 'attrs.onclose', Ember.K);
ember-sqlite-adapter/addon/migration.js:  run: Ember.K,
ember-stripe-service/addon/services/stripe.js:      this.card[name] = Ember.K;
ember-table/addon/components/ember-table.js:    addColumn: Ember.K,
ember-table/addon/components/ember-table.js:    sortByColumn: Ember.K
ember-table/addon/mixins/mouse-wheel-handler.js:  onMouseWheel: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-table/addon/mixins/scroll-handler.js:  onScroll: Ember.K,
ember-table/addon/mixins/touch-move-handler.js:  onTouchMove: Ember.K,
ember-table/addon/models/column-definition.js:  setCellContent: Ember.K,
ember-table/addon/views/lazy-item.js:  prepareContent: Ember.K,
ember-table/addon/views/lazy-item.js:  teardownContent: Ember.K,
ember-ted-select/README.md:      <td><code>Ember.K</code> (noop)</td>
ember-ted-select/tests/dummy/app/pods/application/template.hbs:        <td><code>Ember.K</code> (noop)</td>
ember-theater/addon/ember-theater/director/directions/sound.js:  fadeTo(volume, duration, callback = Ember.K) {
ember-to-string/tests/unit/helpers/to-string-test.js:    lookup: Ember.K
ember-ui-components/addon/mixins/click-outside.js:  handleClickOutside: Ember.K,
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/route-access-test.js:      transitionTo: Ember.K
ember-watson/tests/fixtures/resource-router-mapping/new-complex-ember-cli-sample.js:    }, Ember.K);
ember-watson/tests/fixtures/resource-router-mapping/old-complex-ember-cli-sample.js:    this.resource('dashboard', Ember.K);
emberx-select/addon/components/x-select.js:  "on-blur": Ember.K,
emberx-select/addon/components/x-select.js:  "on-click": Ember.K,
emberx-select/addon/components/x-select.js:  "on-change": Ember.K,
emberx-select/addon/components/x-select.js:  "on-focus-out": Ember.K,
fireplace/addon/collections/indexed.js:      then(Ember.K.bind(this));
fireplace/addon/collections/object.js:    const promise = this.listenToFirebase().then(Ember.K.bind(this));
justa-table/addon/components/table-vertical-collection.js:  'on-row-click': Ember.K
list-view/addon/list-view-mixin.js:  _scrollTo: Ember.K,
list-view/addon/list-view-mixin.js:  arrayWillChange: Ember.K,
list-view/addon/reusable-list-item-view.js:  prepareForReuse: Ember.K,
mantel/addon/fireplace/collections/indexed.js:      then(Ember.K.bind(this));
mantel/addon/fireplace/collections/object.js:    var promise = this.listenToFirebase().then(Ember.K.bind(this));
plaid/addon/mixins/dimensions.js:  didMeasureDimensions: Ember.K,
plaid/addon/mixins/global-resize.js:  didResize: Ember.K
spree-ember-paypal-express/addon/services/paypal-express.js:  spree: Ember.K,
torii/addon/services/torii-session.js:  setUnknownProperty: Ember.K,
torii/tests/unit/redirect-handler-test.js:    close: Ember.K
torii/tests/unit/services/popup-test.js:    focus: Ember.K,
torii/tests/unit/services/popup-test.js:    close: Ember.K
```

## Addendum 3 - `Ember.K` usage via destructuring across published addons

```
CogAuth/tests/helpers/flash-message.js:const { K } = Ember;
ember-annotative-models/addon/utils/action.coffee:{K, isBlank, A} = Ember
ember-annotative-models/tests/unit/utils/action-test.coffee:{K} = Ember
ember-cli-airbrake/addon/utils/get-client.js:const { K } = Ember;
ember-cli-flash/blueprints/ember-cli-flash/files/tests/helpers/flash-message.js:const { K } = Ember;
ember-cli-mapkit/addon/components/ui-abstract-map.js:const {isEmpty, computed, on, K, run} = Ember;
ember-cli-pixijs/addon/components/pixi-canvas.js:const { Component, computed, K } = Ember;
ember-click-outside/addon/mixins/click-outside.js:const { computed, K } = Ember;
ember-composable-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-composable-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-composable-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-d3-helpers/tests/unit/helpers/d3-line-test.js:const { K } = Ember;
ember-form-object/addon/forms/model-form.js:const { ObjectProxy, computed, computed: { readOnly }, assert, Logger, run, A: createArray, K: noop, String: { camelize } } = Ember;
ember-form-tool/addon/mixins/drag-drop.coffee:{K, Mixin, computed: {equal}} = Ember
ember-functional-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-functional-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-functional-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-imdt-magic-crud/tests/helpers/flash-message.js:const { K } = Ember;
ember-keyword-complete/addon/components/keyword-complete.js:const {observer, computed, run, assert, K, $} = Ember;
ember-leaflet/addon/components/base-layer.js:const { assert, computed, Component, run, K, A, String: { classify } } = Ember;
ember-light-table/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-metrics/tests/unit/services/metrics-test.js:const { get, set, K } = Ember;
ember-paper/addon/components/paper-autocomplete.js:const { assert, computed, inject, isNone, defineProperty, K: emberNop } = Ember;
ember-paper/addon/mixins/events-mixin.js:const { Mixin, K } = Ember;
ember-redux/app/services/redux.js:const { assert, isArray, K } = Ember;
ember-responsive/blueprints/ember-responsive/files/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-select-box/addon/mixins/select-box/select-box/inputtable.js:const { K } = Ember;
ember-shepherd/addon/services/tour.js:const { Evented, K, Service, isPresent, run, $, isEmpty, observer } = Ember;
ember-simple-auth/addon/session-stores/cookie.js:const { RSVP, computed, run: { next, cancel, later, scheduleOnce }, isEmpty, typeOf, testing, isBlank, isPresent, K, A } = Ember;
ember-simple-auth/tests/unit/internal-session-test.js:const { RSVP, K, run: { next } } = Ember;
ember-simple-auth/tests/unit/session-stores/shared/store-behavior.js:const { run: { next }, K } = Ember;
ember-simple-auth-chrome-app/tests/unit/session-stores/shared/store-behavior.js:const { K, run: { next } } = Ember;
ember-sinon-qunit/tests/helpers/assert-sinon-in-test-context.js:const { K: EmptyFunc, typeOf } = Ember;
ember-user-activity/tests/unit/services/user-activity-test.js:const { A: emberArray, K: noOp, typeOf } = Ember;
ui-bootstrap/tests/helpers/flash-message.js:const { K } = Ember;
yes-or-no/tests/helpers/responsive.js:const { K, getOwner } = Ember;
```


---

---
stage: recommended
start-date: 2016-11-22T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/181
project-link:
---

# Summary

The goal of this RFC is to remove the `data-adapter`, `injectStore`,
`transforms`, and `store` Ember application initializers that Ember Data injects
into apps.  The `ember-data` initializer will not be changed and any code
that previously depended on the ordering of these initializers (via
the `before` or `after` properties on an initalizer) can be
changed to use the `ember-data` initializers for ordering.

# Motivation

The initializers `data-adapter`, `injectStore`, `transforms`, and
`store` have not been used by Ember Data since
[Apr 8, 2014](https://github.com/emberjs/data/commit/d25e23f622a3677b8372db535b2ab824ad306a16). However,
they are still injected into every Ember app that depends on Ember
Data because existing apps may depend on these initializers
for ordering their own initializers to run before or after Ember
Data's setup code.

Removing these initializers will help reduce the amount of code Ember
Data needs to support.

Since these initializers are noop functions that run after the
`ember-data` initializer, any initializers that depends on one of the
deprecated initializers listed in this rfc can easly be replaced by
depending on the `ember-data` initializer instead.

# Detailed design

Ember Data's instance initializer will start checking for any
initializers whose `before` or `after` properties depend on one of
these deprecated initalizer. If it finds an initalizer that references
one of the deprecated initalizers, Ember Data will then log a
deprecation message that states the name of the offending initalizers
and suggest changing the `before` or `after` property (the deprecation
message will refer to the correct property dynamically) to depend on
Ember Data instead.

This deprecation message will continue to appear until Ember Data
3.0.0 when these initalizers and the deprecation code will be finally
removed.


# How We Teach This

This change should have no impact on how we teach Ember or Ember
Data. The initalizers that will be removed have been unused for a long
time and are not mentioned anywhere in today's guides or API docs.

Users who need to run initalizer code before or after Ember Data
injects the store into routes should be taught to use `before:
'ember-data'`, or `after: 'ember-data'` on their initializers.

# Drawbacks

- This change will require users who depend on these deprecated initalizers to update their code.

# Alternatives

- We could leave the noop initalizers in Ember Data and continue to support them in Ember Data 3.0.0 and beyond.

# Unresolved questions

None


---

---
stage: recommended
start-date: 2016-12-05T00:00:00.000Z
release-date: 2017-04-27T00:00:00.000Z
release-versions:
  ember-source: v2.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/186
project-link:
---

# Summary

Track unique history location states

# Motivation

The path alone does not provide enough information. For example, if you
visit page A, scroll down, then click on a link to page B, then click on
a link back to page A. Your actual browser history stack is [A, B, A].
Each of those nodes in the history should have their own unique scroll
position. In order to record this position we need a UUID
for each node in the history.

This API will allow other libraries to reflect upon each location to
determine unique state. For example,
[ember-router-scroll](https://github.com/dollarshaveclub/ember-router-scroll)
is making use of a [modified `Ember.HistoryLocation` object to get this
behavior](https://github.com/dollarshaveclub/ember-router-scroll/blob/master/addon/locations/router-scroll.js).

Tracking unique state is required when setting the scroll position
properly based upon where you are in the history stack, as described in
[Motivation](#motivation)

# Detailed design

Code: [PR#14011](https://github.com/emberjs/ember.js/pull/14011)

We simply unique identifier (UUID) so we can track uniqueness on two
dimensions. Both `path` and the generated `uuid`. A simple UUID
generator such as
https://gist.github.com/lukemelia/9daf074b1b2dfebc0bd87552d0f6a537
should suffice.

# How We Teach This

We could describe what meta data is generated for each location in the
history stack. For example, it could look like:

```js
// visit page A

[
  { path: '/', uuid: 1 }
]

// visit page B

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// visit page A

[
  { path: '/', uuid: 3 },
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// click back button

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]
```

# Drawbacks

* The property access is writable

# Alternatives

The purpose for this behavior is to enable scroll position libraries.
There are two other solutions in the wild. One is in the guides that
suggests resetting the scroll position to `(0, 0)` on each new route
entry. The other is
[ember-memory-scroll](https://github.com/ef4/memory-scroll) which I
believe is better suited for tracking scroll positions for components
rather than the current page.

However, in both cases neither solution provides the experience that
users have come to expect from server-rendered pages. The browser tracks
scroll position and restores it when you revisit the page in the history
stack. The scroll position is unique even if you have multiple instances
of the same page in the stack.

# Unresolved questions

None at this time.


---

---
stage: recommended # FIXME: Is this Discontinued now?
start-date: 2016-12-14T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/191
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/14711
---

# Summary

We would like to deprecate and remove the **arguments** passed to the `didInitAttrs`, `didReceiveAttrs` and `didUpdateAttrs` component lifecycle hooks. These arguments are currently undocumented on purpose and considered a private API, imposes an unnecessary performance hit on *all* components whether they are used or not, and can be easily replicated by the users in cases where they are needed.

# Motivation

In the road leading up to Ember.js 2.0, [new lifecycle hooks](http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html#toc_component-lifecycle-hooks) were introduced to components in order to help users shift to a new mental model, dubbed Data Down Actions Up. The hooks were introduced by name, and their semantics explained, but there were no mentions of possible arguments received by them.

This lack of documentation for lifecycle hook arguments was deliberate. The hooks were introduced as an experiment with an eye to the then-upcoming angle bracket components, so the arguments to the hooks were considered private by the framework maintainers, as their design was still ongoing.

However, references to the lifecycle hook arguments started appearing in community resources. Users started betting on these arguments as the way forward, which in conjunction with the lack of an RFC process and clear messaging from the Ember.js maintainers lead to confusion.

This left the core team in a difficult position. Despite no longer endorsing lifecycle hook arguments, trying to communicate such could have the reverse effect by pointing a spotlight at them. The purpose of this RFC is then to clarify that lifecycle hook arguments have no future in the framework, and you should update your code to not make use of them.

The reason to officially deprecate lifecycle hook arguments is not only about messaging, but also because providing these arguments imposes an unnecessary performance penalty to every component in your application even if the arguments are not used.

To provide the arguments to the lifecycle hooks, Ember.js has to eagerly "reify" and save-off any passed-in attributes to allow diffing and construct several wrapper objects. In the few occasions where this logic is actually necessary, developers should be able to use programmatic patterns familiar to them and manually track changes as needed, as exemplified in the Transition Path section below.

# Transition Path

The transition path followed will be the standard one, which encompasses using the deprecation API to deprecate the feature and the related deprecation guide. While the lifecycle hooks share a deprecation identifier, they will be addressed in turn.

### `didInitAttrs`

Since this lifecycle hook is [already deprecated](http://emberjs.com/deprecations/v2.x/#toc_ember-component-didinitattrs), we suggest taking this chance to address two deprecations at the same time. Imagine you have a component that stores a timestamp when it's initialized for later comparison.

Before:

``` javascript
Ember.Component.extend({
  didInitAttrs({ attrs }) {
    this.set('initialTimestamp', attrs.timestamp);
  }
});
```
After:

``` javascript
Ember.Component.extend({
  init() {
    this._super(...arguments);

    this.set('initialTimestamp', this.get('timestamp'));
  }
});
```
### `didReceiveAttrs`

Let's say you want to animate a map widget from the old coordinates to the new coordinates.

Before:

``` javascript
Ember.Component.extend({
  didReceiveAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs && oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
```
After:

``` javascript
Ember.Component.extend({
  didReceiveAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates && oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
```
### `didUpdateAttrs`

This hook is very similar to `didReceiveAttrs`, except it only runs on re-renders and not the initial render.

Before:

``` javascript
Ember.Component.extend({
  didUpdateAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs && oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
```
After:

``` javascript
Ember.Component.extend({
  didUpdateAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates && oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
```
# How We Teach This

Due to the previous undocumented nature of the arguments, there is no official documentation that will require updating deprecated usage.

As required for framework deprecations, there will be a deprecation guide written up and linked from within the deprecation message. This deprecation guide will address the more common usage patterns associated with lifecycle hook arguments, such as the Transition Path example.

Additionally, the usage patterns present in the deprecation guide could also be documented in the component section of the official Guides, as a proactive approach for teaching newcomers.

# Drawbacks

One immediate drawback of this proposal is that due to references to the arguments in community resources, there are uses of them in the wild. Updating deprecated code will have to be done mostly manually, as automation might prove difficult.

Another drawback is that by the very nature of publishing this RFC, attention will be drawn to the arguments. It is our hope that the increased awareness will be a net positive due to the clear guidance gained by users of the framework.

It is then our assessment that these drawbacks are outweighed by the benefits of the change.

# Alternatives

There are two standout alternatives to the proposal presented here which are doing nothing, or making the arguments public and supporting them going forward, both of which are less than ideal for reasons stated previously.

Doing nothing would perpetuate the confusion surrounding lifecycle hook arguments. While it might be argued that that ship has sailed, we prefer to think that it's never too late to provide users of the framework with clearer messaging regarding usage of certain features.

Making the arguments public and supported would mean supporting APIs that did not go through the RFC process, meaning they do not align with some of the current values of the framework, nor would iteration on them would be possible without introducing breakage. Additionally, there are some performance penalties to supporting these arguments, mentioned in the Motivation section.

# Unresolved questions

None.


---

---
stage: recommended
start-date: 2016-12-24T00:00:00.000Z
release-date: 2018-02-13T00:00:00.000Z
release-versions:
  ember-source: v3.0.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/194
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/issues/14754
---

# Summary

Support for component `eventManger`s is a seldom used feature and should
be deprecated.

# Motivation

We should strive to simplify the Ember API and source code where possible. As
the custom `eventManager` feature is rarely used in apps, we should deprecate
it.

# Detailed design

We'll introduce a deprecation warning which will be displayed when a component
defines an `eventManager` property or when `canDispatchToEventManager` is set to
true on `EventDispatcher`. The warning will have a target version of `3.0`.

If required, we can create an addon which extends the `EventDispatcher` allowing
for opt-in custom `eventManager`s in Ember apps.

# How We Teach This

As this is a seldom used feature, we can simply note the deprecation in a
future release blog post.

# Drawbacks

This adds a little more churn for apps that rely on this feature.

# Alternatives

This feature was [recently made pay-as-you-go](https://github.com/emberjs/ember.js/pull/14756),
so the immediate performance concerns have been addressed. We could decide to
leave this in the framework as an opt-in feature.


---

---
stage: released # FIXME: Is this recommended?
start-date: 2017-03-13T00:00:00.000Z
release-date: 2018-08-27T00:00:00.000Z
release-versions:
  ember-source: v3.4.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/213
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/issues/16301
---

# Summary

This RFC aims to expose a _low-level primitive_ for defining _custom
components_.

This API will allow addon authors to provide special-purpose component base
classes that their users can subclass from in apps. These components are
invokable in templates just like any other Ember components (descendants of
`Ember.Component`) today.

# Motivation

The ability to author reusable, composable components is a core feature of
Ember.js. Despite being a [last-minute addition](http://emberjs.com/blog/2013/06/23/ember-1-0-rc6.html)
to Ember 1.0, the `Ember.Component` API and programming model has proven itself
to be an extremely versatile tool and has aged well over time into the primary
unit of composition in Ember's view layer.

That being said, the current component API (hereinafter "classic components")
does have some noticeable shortcomings. Over time, classic components have also
accumulated some cruft due to backwards compatibility constraints.

These problems led to the original "angle bracket components" proposal (see RFC
[#15](https://github.com/emberjs/rfcs/blob/master/text/0015-the-road-to-ember-2-0.md)
and [#60](https://github.com/emberjs/rfcs/pull/60)), which promised to address
these problems via the angle bracket invocation opt-in (i.e. `<foo-bar ...>`
instead of `{{foo-bar ...}}`).

Since the transition to the angle bracket invocation syntax was seen as a rare,
once-in-a-lifetime opportunity, it became very tempting to debate every single
shortcomings and missing features in the classic components API in the process
and attempt to design solutions for all of them.

While that discussion was very helpful in capturing constraints and guiding the
overall direction, designing that One True API™ in the abstract turned out to
be extremely difficult. It also went against our philosophy that framework
features should be extracted from applications and designed iteratively with
feedback from real-world usage.

Since that original proposal, we have rewritten Ember's rendering engine from
the ground up (the "Glimmer 2" project). One of the goals of the Glimmer 2
effort was to build first-class support for Ember's view-layer features into
the rendering engine. As part of the process, we worked to rationalize these
features and to re-think the role of components in Ember.js. This exercise has
brought plenty of new ideas and constraints to the table.

The initial Glimmer 2 integration was completed in [Ember 2.10](http://emberjs.com/blog/2016/11/30/ember-2-10-released.html).
As of that version, classic components have been re-implemented using the new
primitives provided by the rendering engine, and we are very happy with the
results.

This approach yielded a number of very powerful and flexible primitives:
in addition to classic components, we were able to implement Ember's
`{{mount}}`, `{{outlet}}` and `{{render}}` helpers as "components" under the
hood.

Based on our experience, we believe it would be beneficial to open up these new
primitives to the wider community. Specifically, there are at least two clear
benefits that comes to mind:

First, it provides addon authors fine-grained control over the exact behavior
and semantics of their components in cases where the general-purpose components
are a poor fit. For example, a low-overhead component designed to be used in
performance hotspot can opt-out of certain convinence features using this API.

Second, it allows the community to experiment with and iterate on alternative
component APIs outside of the core framework. Following the success of FastBoot
and Engines, we believe the best way to design the new "Glimmer Components" API
is to first stablize the underlying primitives in the core framework and
experiment with the surface API through an addon.

# Detailed design

This RFC introduces the concept of *component managers*. A component manager is
an object that is responsible for coordinating the lifecycle events that occurs
when invoking, rendering and re-rendering a component.

## Registering component managers

Component managers are registered with the `component-manger` type in the
application's registry. Similar to services, component managers are singleton
objects (i.e. `{ singleton: true, instantiate: true }`), meaning that Ember
will create and maintain (at most) one instance of each unique component
manager for every application instance.

To register a component manager, an addon will put it inside its `app` tree:

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
```

(Typically, the convention is for addons to define classes like this in its
`addon` tree and then re-export them from the `app` tree. For brevity, we will
just inline them in the `app` tree directly for the examples in this RFC.)

This allows the component manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, component managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:

```js
// ember-basic-component/app/initializers/register-basic-component-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('component-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
```

## Determining which component manager to use

For the purpose of this section, we will assume components with a JavaScript
file (such as `app/components/foo-bar.js` or the equivilant in "pods" and
[Module Unification](https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md)
apps) and optionally a template file (`app/templates/components/foo-bar.hbs`
or equivilant). The example section has additional information about how this
relates to [template-only components](https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md).

When invoking the component `{{foo-bar ...}}`, Ember will first resolve the
component class (`component:foo-bar`, usually the `default` export from
`app/components/foo-bar.js`). Next, it will determine the appropiate component
manager to use based on the resolved component class.

Ember will provide a new API to assign the component manager for a component
class:

```js
// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('awesome', EmberObject.extend({
  // ...
}));
```

This tells Ember to use the `awesome` manager (`component-manager:awesome`) for
the `foo-bar` component. `setComponentManager` function returns the class.

In the future, this function can also be invoked as a decorator:

```js
// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default @componentManager('awesome') EmberObject.extend({
  // ...
});
```

In reality, an app developer would never have to write this in their apps,
since the component manager would already be assigned on a super-class provided
by the framework or an addon. The `setComponentManager` function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers.

For example, the `Ember.Component` class would have the `classic` component
manager pre-assigned, therefore the following code will continue to work as
intended:

```js
// my-app/app/components/foo-bar.js

import Component from '@ember/component';

export default Component.extend({
  // ...
});
```

Similarly, an addon can provided the following super-class:

```js
// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  // ...
}));
```

With this, app developers can simply inherit from this in their app:

```js
// my-app/app/components/foo-bar.js

import BasicComponent from 'ember-basic-component';

export default BasicComponent.extend({
  // ...
});
```

Here, the `foo-bar` component would automatically inherit the `basic` component
manager from its super-class.

It is not advisable to override the component manager assigned by the framework
or an addon. Attempting to reassign the component manager when one is already
assinged on a super-class will be an error. If no component manager is set, it
will also result in a runtime error when invoking the component.

## Component Lifecycle

Back to the `{{foo-bar ...}}` example.

Once Ember has determined the component manager to use, it will be used to
manage the component's lifecycle.

### `createComponent`

The first step is to create an instance of the component. Ember will invoke the
component manager's `createComponent` method:

```javascript
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  // ...
});
```

The `createComponent` method on the component manager is responsible for taking
the component's factory and the arguments passed to the component (the `...` in
`{{foo-bar ...}}`) and return an instantiated component.

The first argument passed to `createComponent` is the result returned from the
[`factoryFor`](https://github.com/emberjs/rfcs/blob/master/text/0150-factory-for.md)
API. It contains a `class` property, which gives you the the raw class (the
`default` export from `app/components/foo-bar.js`) and a `create` function that
can be used to instantiate the class with any registered injections, merging
them with any additional properties that are passed.

The second argument is a snapshot of the arguments passed to the component in
the template invocation, given in the following format:

```js
{
  positional: [ ... ],
  named: { ... }
}
```

For example, given the following invocation:

```hbs
{{blog-post (titleize post.title) post.body author=post.author excerpt=true}}
```

You will get the following as the second argument:

```js
{
  positional: [
    "Rails Is Omakase",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit..."
  ],
  named: {
    "author": #<User name="David Heinemeier Hansson", ...>,
    "excerpt": true
  }
}
```

The arguments object should not be mutated (e.g. `args.positional.pop()` is no
good). In development mode, it might be sealed/frozen to help prevent these
kind of mistakes.

### `getContext`

Once the component instance has been created, the next step is for Ember to
determine the `this` context to use when rendering the component's template by
calling the component manager's `getContext` method:

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  // ...
});
```

The `getContext` method gets passed the component instance returned from
`createComponent` and should return the object that `{{this}}` should refer to
in the component's template, as well as for any "fallback" property lookups
such as `{{foo}}` where `foo` is neither a local variable or a helper (which
resolves to `{{this.foo}}` where `this` is here is the object returned by
`getContext`).

Typically, this method can simpliy return the component instance, as shown in
the example above. The reason this exists as a separate method is to enable the
so-called "state bucket" pattern which allows addon authors to attach extra
book-keeping metadata to the component:

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  // ...
});
```

Since the "state bucket", not the "context", is passed back to other hooks on
the component manager, this allows the component manager to access the extra
metadata but otherwise hide them from the app developers.

We will see an example that uses this pattern in a later section.

At this point, Ember will have gathered all the information it needs to render
the component's template, which will be rendered with ["Outer HTML" semantics](https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md).

In other words, the content of the template will be rendered as-is, without a
wrapper element (e.g. `<div id="ember1234" class="ember-view">...</div>`),
except for subclasses of `Ember.Component`, which will retain the current
legacy behavior (the internal `classic` manager uses private capabilities to
achieve that).

This API does not currently provide any way to fine-tune the rendering behavior
(such as dynamically changing the component's template) besides `getContext`,
but future iterations may introduce extra capabilities.

### `updateComponent`

When it comes time to re-render a component's template (usually because an
argument has changed), Ember will call the manager's `updateComponent` method
to give the manager an opportunity to reflect those changes on the component
instance, before performing the re-render:

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  // ...
});
```

The first argument passed to this method is the component instance returned by
`createComponent`. As mentioned above, using the "state bucket" pattern will
allow this hook to access the extra metadata:

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let { metadata, instance } = bucket;
    // do things with metadata
    instance.setProperties(args.named);
  },

  // ...
});
```

The second argument is a snapshot of the updated arguments, passed with the
same format as in `createComponent`. Note that there is no guarentee that
anything in the arguments object has _actually_ changed when this method is
called. For example, given:

```hbs
{{blog-post title=(uppercase post.title) ...}}
```

Imagine if `post.title` changed from `fOo BaR` to `FoO bAr`. Since the value
is passed through the `uppercase` helper, the component will see `FOO BAR` in
both cases.

Generally speaking, Ember does not provide any guarentee on how it determines
whether components need to be re-rendered, and the semantics may vary between
releases – i.e. this method may be called more or less often as the internals
changes. The _only_ guarentee is that if something _has_ changed, this method
will definitely be called.

If it is important to your component's programming model to _only_ notify the
component when there are actual changes, the manager is responsible for doing
the extra book-keeping.

For example:

```js
// ember-basic-component/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('basic', EmberObject.extend({
  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentWillChange: NOOP,

  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentDidChange: NOOP,

  // ...
}));
```

```js
// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return {
      args: args.named,
      instance: factory.create(args.named)
    };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let instance = bucket.instance;
    let oldArgs = bucket.args;
    let newArgs = args.named;
    let changed = false;

    // Since the arguments are coming from the template invocation, you can
    // generally assume that they have exactly the same keys. However, future
    // additions such as "splat arguments" in the template layer might change
    // that assumption.
    for (let key in oldArgs) {
      let oldValue = oldArgs[key];
      let newValue = newArgs[key];

      if (oldValue !== newValue) {
        instance.argumentWillChange(key, oldValue, newValue);
        instance.set(key, newValue);
        instance.argumentDidChange(key, oldValue, newValue);
      }
    }

    bucket.args = newArgs;
  },

  // ...
});
```

This example also shows when the "state bucket" pattern could be useful.

The return value of the `updateComponent` is ignored.

After calling the `updateComponent` method, Ember will update the component's
template to reflect any changes.

## Capabilities

In addition to the methods specified above, component managers are required to
have a `capabilities` property.  This property must be set to the result of
calling the `capabilities` function provided by Ember.

### Versioning

The first, mandatory, argument to the `capabilities` function is the component
manager API, which is denoted in the `${major}.${minor}` format, matching the
minimum Ember version this manager is targeting. For example:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  }
});
```

This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.

Here is a hypothical scenario for such a change:

1. Ember 3.2 implemented and shipped the component manager API as described in
   this RFC.

2. The `ember-basic-component` addon released version 1.0 with the component
   manager shown above (notably, it declared `capabilities('3.2')`).

3. In Ember 3.5, we determined that constructing the arguments object passed to
   the hooks is a major performance bottleneck, and changes the API to pass a
   "proxy" object with getter methods instead (e.g. `args.getPositional(0)` and
   `args.getNamed('foo')`).

   However, since Ember sees that the `basic` component manager is written to
   target the `3.2` API version, it will retain the old behavior and passes the
   old (more expensive) "reified" arguments object instead, to avoid breakage.

4. The `ember-basic-component` addon author would like to take advantage of
   this performance optimization, so it updates its component manager code to
   work with the arguments proxy and changes its capabilities declaration to
   `capabilities('3.5')` in version 2.0.

This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.

Note that addon authors are not _required_ to update to the newer API.
Concretely, component manager APIs have the following support policy:

* API versions will continue to be supported in the same major release of
  Ember. As shown in the example above, `ember-basic-component` 1.0 (which
  targets component manager API version 3.2), will continue to work on
  Ember 3.5. However, the reverse is not true – component manager API version
  3.5 will (somewhat obviously) not work in Ember 3.2.

* In addition, to ensure a smooth transition path for addon authors and app
  developers across major releases, each Ember version will support (at least)
  the previous LTS version as of the release was made. For example, if 3.16 is
  the last LTS release of the 3.x series, the component manager API version
  3.16 will be supported by Ember 4.0 through 4.4, at minimum.

Addon authors can also choose to target multiple versions of the component
manager API using [ember-compatibility-helpers](https://github.com/pzuraq/ember-compatibility-helpers/):

```js
// ember-basic-component/app/component-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.5'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.2'),

    // ...
  });
}

export default ComponentManager;
```

Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.

### Optional Features

The second, optional, argument to the `capabilities` function is an object
enumerating the optional features requested by the component manager.

In the hypothical example above, while the "reified" arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical components. A component
manager written for Ember 3.5 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.5', {
    reifyArguments: true
  }),

  // ...
});
```

In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.

## Optional Capabilities

The following optionally capabilities will be available with the first version
of the component manager API. We expect future RFCs to propose additional
capabilities within the framework provided by this initial RFC.

### Async Lifecycle Callbacks

When the `asyncLifecycleCallbacks` capability is set to `true`, the component
manager is expected to implement two additional methods: `didCreateComponent`
and `didUpdateComponent`.

`didCreateComponent` will be called after the component has been rendered the
first time, after the whole top-down rendering process is completed. Similarly,
`didUpdateComponent` will be called after the component has been updated, after
the whole top-down rendering process is completed. This would be the right time
to invoke any user callbacks, such as `didInsertElement` and `didRender` in the
classic components API.

These methods will be called with the component instance (the "state bucket"
returned by `createComponent`) as the only argument. The return value is
ignored.

These callbacks are called if and only if their synchronous APIs were invoked
during rendering. For example, if `updateComponent` was called on during
rendering (and it completed without errors), `didUpdateComponent` will always
be called. Conversely, if `didUpdateComponent` is called, you can infer that
the `updateComponent` was called on the same component instance during
rendering.

This API provides no guarentee about ordering with respect to siblings or
parent-child relationships.

### Destructors

When the `destructor` capability is set to `true`, the component manager is
expected to implement an additional method: `destroyComponent`.

`destroyComponent` will be called when the component is no longer needed. This
is intended for performing object-model level cleanup.

Because this RFC does not provide ways to access or observe the component's DOM
tree, the timing relative to DOM teardown is undefined (i.e. whether this is
called before or after the component's DOM tree is removed from the document).

Therefore, this hook is not suitable for invoking user callbacks intended for
performing DOM cleanup, such as `willDestroyElement` in the classic components
API. We expect a subsequent RFC addressing DOM-related functionalities to
clarify this issues or provide another specialized method for that purpose.

Similar to the other async lifecycle callbacks, this API provides no guarentee
about ordering with respect to siblings or parent-child relationships. Further,
the exact timing of the calls are also undefined. For example, the calls from
several render loops might be batched together and deferred into a browser idle
callback.

# Examples

## Basic Component Manager

Here is the simpliest end-to-end component manager example that uses a plain
`Ember.Object` super-class (as opposed to `Ember.Component`) with "Outer HTML"
semantics:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  destroyComponent(component) {
    component.destroy();
  }
});
```

```js
// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend());
```

### Usage

```js
// my-app/app/components/x-counter.js

import BasicCompoment from 'ember-basic-component';

export default BasicCompoment.extend({
  init() {
    this.count = 0;
  },

  down() {
    this.decrementProperty('count');
  },

  up() {
    this.incrementProperty('count');
  }
});
```

```hbs
{{!-- my-app/app/templates/components/x-counter.hbs --}}

<div>
  <button {{action this.down}}>🔽</button>
  {{this.count}}
  <button {{action this.up}}>🔼</button>
</div>
```

## Template-only Components

This example implements a kind of component similar to what was proposed in the
[template-only components](https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md)
RFC.

Since the custom components API proposed in this RFC requires a JavaScript
files, we cannot implement true "template-only" components. We will need to
create a component JS file to export a dummy value, for the sole purpose of
indicating the component manager we want to use.

In practice, there is no need for an addon to implement this API, since it is
essentially re-implementing what the "template-only-glimmer-components"
optional feature does. Nevertheless, this example is useful for illustrative
purposes.

```js
// ember-template-only-component/app/component-managers/template-only.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent() {
    return null
  },

  getContext() {
    return null;
  },

  updateComponent() {
    return;
  }
});
```

```js
// ember-template-only-component/addon/index.js

import { setComponentManager } from '@ember/component';

// Our `createComponent` method does not actually do anything with the factory,
// so we don't even need to export a class here, `{}` would work just fine.
export default setComponentManager('template-only', {});
```

### Usage

```js
// my-app/app/components/hello-world.js

import TemplateOnlyComponent from 'ember-template-only-component';

export default TemplateOnlyComponent;
```

```hbs
Hello world! I have no backing class! {{this}} would be <code>null</code>.
```

## Recycling Components

This example implements an API which maintain a pool of recycled component
instances to avoid allocation costs.

This example also make use of the "state bucket" pattern.

```js
// ember-component-pool/app/component-managers/pooled.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

// How many instances to keep (per type/factory)
const LIMIT = 10;

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  init() {
    this.pool = new Map();
  },

  createComponent(factory, args) {
    let instances = this.pool.get(factory);
    let instance;

    if (instances && instances.length > 0) {
      instance = instances.pop();
      instance.setProperties(args.named);
    } else {
      instance = factroy.create(args.named);
    }

    // We need to remember which factory does the instance belong to so we can
    // check it back into the pool later.
    return { factory, instance };
  },

  getContext({ instance }) {
    return instance;
  },

  updateComponent({ instance }, args) {
    instance.setProperties(args.named);
  },

  destroyComponent({ factory, instance }) {
    let instances;

    if (this.pool.has(factory)) {
      instances = this.pool.get(factory);
    } else {
      this.pool.set(factory, instances = []);
    }

    if (instances.length >= LIMIT) {
      instance.destroy();
    } else {
      // User hook to reset any state
      instance.willRecycle();
      instances.push(instance);
    }
  },

  // This is the `Ember.Object` lifecycle method, called when the component
  // manager instance _itself_ is being destroyed, not to be confused with
  // `destroyComponent`
  willDestroy() {
    for (let instances of this.pool.values()) {
      instances.forEach(instance => instance.destroy());
    }

    this.pool.clear();
  }
});
```

```js
// ember-component-pool/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('pooled', EmberObject.extend({
  // Override this to implement reset any state on the instance
  willRecycle(): NOOP,

  // ...
}));
```

# How We Teach This

What is proposed in this RFC is a *low-level* primitive. We do not expect most
users to interact with this layer directly. Instead, most users will simply
benefit from this feature by subclassing these special components provided by
addons.

At present, the classic components APIs is still the primary, recommended path
for almost all use cases. This is the API that we should teach new users, so we
do not expect the guides need to be updated for this feature (at least not the
components section).

For documentation purposes, each Ember.js release will only document the latest
component manager API, along with the available optional capabilities for that
realease. The documentation will also include the steps needed to upgrade from
the previous version. Documentation for a specific version of the component
manager API can be viewed from the versioned documentation site.

# Drawbacks

In the long term, there is a risk of fragmentating the Ember ecosystem with
many competing component APIs. However, given the Ember community's strong
desire for conventions, this seems unlikely. We expect this to play out similar
to the data-persistence story – there will be a primary way to do things (Ember
Data), but there are also plenty of other alternatives catering to niche use
cases that are underserved by Ember Data.

Also, because apps can mix and match component styles, it's possible for a
library like smoke-and-mirrors or Liquid Fire to take advantage of the
enhanced functionality internally without leaking those implementation
details to applications.

# Alternatives

Instead of focusing on exposing enough low-level primitives to build the new
components API, we could just focus on building out the user-facing APIs
without rationalizing or exposing the underlying primitives.

# Appendix

## Follow-up RFCs

We expect to rapidly iterate and improve the component manager API through the
RFC process and in-the-field usage/implementation experience. Here are a few
examples of additional capabilities that we hope to see proposed after this
initial (and intentionally minimal) proposal is finalized:

1. Expose a way to access to the component's DOM structure, such as its bounds.
   This RFC would also need to introduce a hook for DOM teardown and address
   how event handling/delegation would work.

2. Expose a way to access to the [reference][1]-based APIs. This could include
   the ability to customize the component's "tag" ([validator][2]).

   [1]: https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md
   [2]: https://github.com/glimmerjs/glimmer-vm/blob/master/guides/05-validators.md

3. Expose additional features that are used to implement classic components,
   `{{outlet}}` and other built-in components, such as layout customizations,
   and dynamic scope access.

4. Angle bracket invocation.

## Using ES6 Classes

Although this RFC uses `Ember.Object` in the examples, it is not a "hard"
dependency.

### Using ES6 Classes For Components

The main interaction between the Ember object model and the component class
is through the DI system. Specifically, the factory function returned by
`factoryFor` (`factoryFor('component:foo-bar').create(...)`), which is passed
to the `createComponent` method on the component manager, assumes a static
`create` method on the class that takes the "property bag" and returns the
created instance.

Therefore, as long as your ES6 super-class provides such a function, it will
work with the rest of the system:

```js
// ember-basic-component/addon/index.js

import { setComponentManager } from '@ember/component';

class BasicComponent {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  // ...
}

export default setComponentManager('basic', BasicComponent);
```

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This Just Works™ since we have a static create method on the class
    return factory.create(args.named);
  },

  // ...
});
```

```js
// my-app/app/components/foo-bar.js

import BasicCompoment from 'ember-basic-component';

export default class extends BasicCompoment {
  // ...
};
```

Alternatively, if you prefer not to add a static create method to your
super-class, you can also instantiate them in the component manager without
going through the DI system:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This does not use the factory function, thus no longer require a static
    // create method on the class
    return new factory.class(args.named);
  },

  // ...
});
```

However, doing do will prevent your components from receiving injections (as
well as setting the appropiate owner, etc). Therefore, when possible, it is
better to go through the DI system's factory function.

### Using ES6 Classes For Component Managers

It is also possible to use ES6 classes for the component managers themselves.
The main interaction here is that they are automatically instantiated by the DI
system on-demand, which again assumes a static `create` method:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';

export default class BasicComponentManager {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  capabilities = capabilities('3.2');

  // ...
};
```

Alternatively, as shown above, you can also register the component manager
with `{ instantiate: false }`:

```js
// ember-basic-component/app/initializers/register-basic-component-manager.js

import BasicComponentManager from 'ember-basic-component';

export function initialize(application) {
  application.register('component-manager:basic', new BasicComponentManager(), { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
```

Note that this behaves a bit differently as the component manager instance is
shared across all application instances and is never destroyed, which might
affect stateful component managers such as the one shown in the "Recycling
Components" example above.


---

---
stage: released # FIXME: Is this recommended?
start-date: 2017-04-26T00:00:00.000Z
release-date: 2017-08-31T00:00:00.000Z
release-versions:
  ember-source: v2.15.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/225
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/15174
---

# Summary

This RFC proposes allowing parameters to be passed to the `{{mount}}` syntax.

# Motivation

This will enable developers to pass contextual data into routeless engines at
runtime, allowing individual engines to be used multiple times through a single
application under different contexts.

An example could be a dashboard of charts where each chart is a routeless engine.
Each chart could be of a different type and would require different data. This
RFC would enable the following:

```hbs
{{!-- app/templates/application.hbs --}}
{{#each charts as |chart|}}
  {{mount "chart" type=chart.type data=chart.data}}
{{/each}}
```

# Detailed design

You can see the implementation for this RFC [here](https://github.com/emberjs/ember.js/pull/15174).

Implementing this functionality turns out to be relatively straight forward. With
routeless engines already supporting an application controller, we can use this
as a means of providing access to the parameters.

Parameters would be passed to the `{{mount}}` syntax in the same way that
they are currently passed to components and helpers.

```hbs
{{mount "foo" bar="baz"}}
```

These parameters would then be set as the `model` property on the engines
application controller; making them accessible from both a JS and HBS context.

```js
// foo/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({

  actions: {
    exampleAction() {
      let barParam = this.get("model.bar");
    }
  }

});
```

```hbs
{{!-- foo/templates/application.hbs --}}
The value of the bar param is: {{model.bar}}
```

# How We Teach This

This RFC re-uses concepts that are already heavily used throughout other areas
of the framework.

Updates will need to be made to the Ember API docs and [ember-engines.com](http://ember-engines.com) guides in order to explain that
routeless engines can now accept parameters being passed via the `{{mount}}` syntax.

In addition, updates would need to include examples of both how to pass parameters
to `{{mount}}` as well as how any passed parameters can be accessed from within
the context of an engine.

# Drawbacks

### Increased risk of runtime dependencies [[reference](https://github.com/ember-engines/ember-engines/issues/98#issuecomment-217347193)]
This RFC does increase the risk of introducing runtime dependencies.

Example:

```js
import Ember from 'ember';

export default Ember.Component.extend({
  geo: Ember.inject.service('geolocation')
})
```
```hbs
{{mount "blog" (hash geo=geo)}}
```

# Alternatives

### Application route `model` hook
This solution suggested that the parameters were provided to the engines
application route via the `model` hooks `params` argument. While viable,
this solution didn't _feel_ quite right as you were using a route within a _routeless_
engine.

### Introduction of new `routelessEngine` primitive
This solution suggested that routeless engines should be given their own primitive
similar to that of a component. The primitive would follow a construct to
components and use the same hooks `(e.g., didReceiveAttrs)` for working with
parameters.

This solution was decided against for following main reasons:

1. The current public API is that we use `application` controller to back the
`application.hbs` of a route-less engine.  Adding a new conceptual primitive
here would be a fairly difficult change without breakage.
2. Introducing a new primitive (e.g. not controller and not a component) is a
*very* heavy handed thing, and should not be taken lightly. We don't think this
rises to that level of need.
3. This is an ideal case for "just using a component", but that would be roughly
akin to "routable components" and we should follow Ember's lead.  When routeable
components are introduced, we can refactor this in the same way with the same
backwards compatibility guarantees.

# Unresolved questions

### Positional parameters
In addition to supporting named parameters, should the `{{mount}}` syntax also
support positional parameters? If so, should this be covered in this RFC, or
in a follow up RFC?


---

---
stage: recommended
start-date: 2017-05-05T00:00:00.000Z
release-date: 2021-02-08T00:00:00.000Z
release-versions:
  ember-source: v3.25.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/226
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/13
---

# Summary

Introduce syntax for passing in multiple named template blocks into a component, and
unify the rendering syntaxes / semantics for
blocks/primitives/component-factories passed into a component.

This RFC is focused chiefly on bringing named blocks to Ember Components,
but it was necessary to define a basic roadmap of functionality for
Glimmer Components as well, but keep in mind that some of the Glimmer-centric details may
change and should hence be considered non-normative.

# Motivation

There are limitations to composition due to the inability to pass more than one block to a component (or 2 blocks if you include the inverse block).

The result of this is that Ember developers have this ultra-powerful, compositional API for overriding portions of a component, but they can only use it in one place in the component invocation; any remaining overrides/configuration needs to be expressed as data and passed in as attributes to the component when it'd be vastly preferable to just pass in a chunk of DOM.

Example:

```html
{{#x-modal headerText=page.title as |c|}}
  <p>Modal Content {{foo}}</p>
  <button onclick={{c.close}}>
     Close modal
  </button>
{{/x-modal}}
```

This works, but the moment you need to render a component in the header (rather than just `headerText`), you end up having to add more config/data/attrs to `x-modal` just to support every one of those overrides, when really you just should be able to pass in another block of DOM to define what the header looks like. The API in this proposal would allow you to express this use case via:

```html
{{#x-modal}}
  <@header as |c|>
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  </@header>

  <@main as |c|>
    <p>Modal Content {{foo}}</p>
    <button onclick={{c.close}}>
       Close modal
    </button>
  </@main>
{{/x-modal}}
```

and with Glimmer components:

```html
<x-modal>
  <@header as |c|>
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  </@header>

  <@main as |c|>
    <p>Modal Content {{foo}}</p>
    <button onclick={{c.close}}>
       Close modal
    </button>
  </@main>
</x-modal>
```

Other RFCs/addons that have attempted to address this:

- [named yields](https://github.com/emberjs/rfcs/pull/72)
- [multiple yields](https://github.com/emberjs/rfcs/pull/43)
- [yet another named yields rfc](https://github.com/emberjs/rfcs/pull/193)
- [ember-block-slots](https://github.com/ciena-blueplanet/ember-block-slots)
- [ember-named-yields](https://github.com/knownasilya/ember-named-yields)
- [local template blocks](https://github.com/emberjs/rfcs/pull/199)

# Detailed design

## Invocation Syntax is separate from Component type

The features specified in this RFC require us to nail down
some specifics as to how Ember and
Glimmer components interop, which syntaxes can be used to render
them, and the mental/teaching model behind how it all works.

- Invocation Syntax (curly vs angle brackets) is conceptually separate from Component
  type (Ember vs Glimmer component)
- "Curly Components" is a misnomer since curly syntax can render both Ember
  components AND Glimmer components
- Angle-bracket syntax can only render Glimmer components
- `{{x-foo @k=v}}` will remain invalid curly syntax due to the `@k=v`
- The way KV pairs provided at invocation is handled depends on the
  component type:
  - Given `{{x-foo k=v}}`, Ember Component `x-foo` will assign/bind `v`
    to property `k` on the component instance, which can be rendered
    within the component layout template as `{{k}}` (same behavior as always).
    `{{@k}}` in an Ember component layout will remain a syntax error
  - Given `{{x-foo k=v}}`, Glimmer Component `x-foo` treats `k=v` as
    assigning/binding arg `@k` to `v`; it will assign/bind `this.args.k`, and expose
    the value as `{{@k}}` within the template. This example invocation
    is functionally equivalent to `<x-foo @k={{v}} />`
  - The mental model is that with curly syntax, `k=v` is the syntax
    for "passing data" to a component; Ember components receive/expose
    this data via the properties on the component instance, and Glimmer
    components receive the data as `@arg`s.
- Curly syntax will not be enhanced with syntax for passing HTML attrs
  (at this time)
- Angle-bracket syntax does not support passing positional params

Implementation-wise, these varying semantics will be defined/implemented via
[Component Managers](https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md#registering-component-managers).

## Multi-block Syntax

Both curly and angle-bracket component invocation syntax will be enhanced
with a nested syntax for passing multiple blocks into a component.

The syntax for curly invocation is as follows:

```html
{{#x-foo}}
  <@header>
    Howdy.
  </@header>

  <@body as |foo|>
    Body {{foo}}
  </@body>
{{/x-foo}}
```

and for angle-bracket invocation:

```html
<x-foo>
  <@header>
    Howdy.
  </@header>

  <@body as |foo|>
    Body {{foo}}
  </@body>
</x-modal>
```

As demonstrated above, the _nested_ syntax for both curly and
angle-bracket multi-block syntax has the format `<@blockName>...</@blockName>`.

This multi-block syntax cannot be mixed with other syntaxes; either ALL
the nested "children" of a component invocation need to be
`<@blockName>...</@blockName>` (multi-block syntax), or none of them do
(classic single-block syntax). The presence of any non-whitespace
character between or around `<@blockName>...</@blockName>`s is a
compile-time error.

Passing two blocks with the same name is a compiler error (though this
might be relaxed in a future RFC).

### Blocks are just (opaque) data

This RFC introduces the concept that blocks are just opaque values
passed into components as data, rather than living in what is
essentially a separate namespace only accessible to `{{yield}}`.

In the above example (with curly syntax), Ember Component `x-foo` would
have its `header` and `body` properties set on its instance. This means,
among other things, that there's no need for a
[hasBlock API for JavaScript](https://github.com/emberjs/rfcs/pull/102);
you can just use normal property lookup / computed properties / etc to
determine whether a block is provided. This means that blocks can
be stashed on services and rendered elsewhere, e.g. the
[ember-elsewhere use case](https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000).

### Unified Renderable Syntax

Rather than continuing to enhance the `{{yield}}` syntax, we should take
this opportunity to unify the various syntaxes for rendering things,
from blocks to primitive values to component factories.

We'll use the following example component invocation to explore
what this syntax looks like: the following (curly syntax) invocation is valid syntax for
rendering either an Ember.Component or a Glimmer Component named
`x-modal` and passing it 3 named blocks: `header`, `body`, and `footer`:

```html
{{#x-modal}}
  <@header as |title|>
    Header {{title}}
  </@header>

  <@body>
    Body
  </@body>

  <@footer>
    Footer
  </@footer>
{{/x-modal}}
```

Given the above invocation, here's how you could render these blocks:

```
{{! within ember-component layout }}
{{this.header "ima title"}}
{{this.body}}
{{this.footer}}

{{! within glimmer-component layout }}
{{@header "ima title"}}
{{@body}}
{{@footer}}
```

Both of these Ember/Glimmer layouts would render:

```
Header ima title
Body
Footer
```

The mental modal here is that is that for ECs, named blocks are
set/bound as a properties on the instance, which we're rendering the
same way we always rendering properties on the instance. For GCs, blocks
are just args that we're rendering with the standard @arg syntax

#### Why `{{this.header}}` and not just `{{header}}`?

Unfortunately, we are constrained by the fact that `{{foo}}` means:

- Try and find a helper named `foo`, and render it
- If no such helper exists, fall back to rendering property `foo`
  on the template context

There is a risk that still exists today that any time you introduce a
new helper to your codebase, for example, a `time` helper, you will break any
templates that try to render a `time` property via `{{time}}`. This is
an unfortunate hangover from the past, and we don't want to continue to
expand the scope of this footgun with this RFC. Hence, to render
blocks/component factories, you must use `{{this.time}}` in your Ember
Component templates.

This is actually an extension to behavior introduced by the
[Contextual Component Lookup
RFC](https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md);
today, the following is supported:

```hbs
<!-- invocation -->
{{x-foo header=(component 'x-header')}}
```

```hbs
<!-- x-foo layout -->
{{this.header}}
```

In the above example, `{{this.header}}` will actually render the
`x-header` component factory; this RFC merely proposes extending this
syntax so that it can render blocks as well.

Since the potential for forgetting this rule is somewhat high, we
should consider detecting when you use `{{foo}}` syntax when `foo` is a
component factory or a block, and provide a useful warning or error
message to use `{{this.foo}}` instead.

#### Rendering primitives

Consider the following example, which modifies above example by changing
the `footer` block to a string:

```html
{{#x-modal footer="ima footer"}}
  <@header as |title|>
    Header {{title}}
  </@header>
{{/x-modal}}
```

If `x-modal` renders footer via `{{this.footer}}`, then it'll just
render the "ima footer" string just fine; this a nice benefit of having
a Unified Renderable syntax
and supports a common workflow where string args can be promoted
to full-on blocks without having to rework the component code
to support an alternative/parallel API.

#### Call syntax with primitives (or undefined)

If you try to render a block/component with args, e.g. `{{this.foo 1 2 3}}`,
then `foo` MUST be a block or a component. If `foo` is any kind of
non-callable primitive, including undefined, it will be an error.

#### Unified Renderable Syntax: component factories

The following invocation using component factories is also supported:

```html
{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  <@main>
    Main
  </@main>
{{/x-modal}}
```

(It's worth mentioning that since we're only defining the `main` block
here, this could also be expressed simply as:)

```html
{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  Main
{{/x-modal}}
```

This demonstrates that the unified renderable syntax is also capable of
rendering component factories (previously only renderable via
`{{component header}}`).

Note since we're passing a positional param `"ima title"` to `header`,
the `my-modal-header` component would only be able to access that param if it were
using the `positionalParams` API with (`reopenClass`), which is a bit of
a clunky / pro-user API.

As a component author, if you want to write your components to support
passing data to both blocks (which accept positional params) and
components (which accept KV pairs), you can pass in both formats
of the same data, e.g.:

```
// Ember.component layout
{{this.header headerTitle title=headerTitle}}

// Glimmer Component layout
{{@header headerTitle title=headerTitle}}
```

#### Named block params

Prior to this RFC, there were only two ways to pass in overridable
chunks of DOM to a component:

- Passing in a block, which only accepts positional block params
  (or a `(hash)` object of named params)
- Passing in a component factory, which only accepts KV args (unless
  you use the `reopenClass-positionalParams` api)

Given that we're introducing a Unified Renderable syntax, it would be
unfortunate if we did nothing to address this impedance mismatch between
named and positional params. The goal is for component consumers/invokers to
be able to pass the most "convenient" kind of Renderable for their use
case, be it a simple primitive string value, a block if they want the
lexical scope + block params, or a component factory for rendering
a shared component that might be used in many places throughout the app.
Unfortunately, the component author will have to choose whether they
want to pass positional params (which would push consumers towards
only using  blocks) or named params (which are presently only supported
by component factories).

Hence, for this reason (among others), it makes sense to introduce a
syntax for named block params; with this syntax, there will be an
organic shift towards component authors using named KV pairs for passing
data in most cases (while still allowing positional params in certain
simpler cases were it only really makes sense to use a block, e.g.
control flow components that wrap `if` or `each`, etc.)

Here is the syntax for named block params:

```html
{{#x-modal}}
  <@header as |@title @data|>
    The title: {{@title}}
    The data: {{@data}}
  </@header>
{{/x-modal}}
```

There is also a "soaking" syntax which is useful in cases where nested
blocks might introduce new named block params that clobber preexisting
identifiers in the scope, as well as cases where spelling out each
named block param consumes too much rightward space. The above example
can be expressed using the soaking syntax as follows:

```html
{{#x-modal}}
  <@header as |@...d|>
    The title: {{d.title}}
    The data: {{d.data}}
  </@header>
{{/x-modal}}
```

(The `@` is not included as part of the identifier as that would
suggest it was a KV arg rather than essentially a hash of args.)

#### Block form of Unified Renderable syntax

It should be possible to pass a block TO the
block/component-factory that's been passed into a component.
The common use cases for this are:

##### Passing a block to a component factory

Given the following invocation:

```
{{x-modal header=(component 'my-header')}}
```

It should be possible for `x-modal` to pass a block to the `header`
renderable:

```
// ember-component x-modal layout
{{#this.header title="ima title"}}
  I'm a block provided by the component layout template.
{{/this.header}}
```

Assuming `my-header` had a layout of:

```
<div class="my-header-inner">
  title is {{title}}
  {{yield}}
</div>
```

This would render the following (assuming `x-modal` and `my-header` are
Ember components with `tagName: 'div'` with `classNames` set):

```
<div class="x-modal">
  <div class="my-header">
    <div class="my-header-inner">
      title is ima title
      I'm a block provided by the component layout template.
    </div>
  </div>
</div>
```

##### Passing a block to a block (aka contextual components)

Given the following invocation:

```
{{#x-modal}}
  <@header as |@title @main|>
    <div class="header-block-content">
      title is {{@title}}
      {{@main}}
    </div>
  </header>
{{/x-modal}}
```

This would render the following (assuming the same `x-modal` layout
as the previous example:

```
<div class="x-modal">
  <div class="header-block-content">
    title is ima title
    I'm a block provided by the component layout template.
  </div>
</div>
```

It would also be possible to pass a component factory to the header
block from `x-modal`'s layout:

```
// ember-component x-modal layout
{{this.header title="ima title"
         main=(component 'x-modal-inner-content')}}
```

The multi-block syntax can be used as well with Unified Renderable
syntax:

```
{{#header}}
  <@main>
    I'm a block provided by the component layout template.
  </@main>

  <@title>
    ima title
  </@title>
{{/header}}
```

##### Block form of `@`-prefixed identifiers

The syntax for passing a block to an `@`-prefixed identifier
(named block params and Glimmer `@arg`s) will be
`{{#@thing}} ... {{/@thing}}`, e.g.:

```
{{#x-layout as |@widget|}}
  {{#@widget as |a b c|}}
    Hi.
  {{/@widget}}
{{/x-layout}}
```

### Classic single-block syntax: `main` and `else` args

It would be unfortunate if component authors had to use different
syntaxes for rendering named blocks vs the traditional "default"
and "inverse" blocks provided by the classic single-block syntax.

Hence, the blocks provided in classic single-block syntax should also
be exposed as properties (Ember) and args (Glimmer), and should have
conventional, meaningful names: instead of "default" (which is a
bit misleading) and "inverse", we standardize on `main` and `else`.

#### Glimmer Components: `@main` and `@else`

Given Glimmer component invocation:

```
{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-component}}
```

The component layout could be:

```
{{#if cond}}
  {{@main}}
{{else}}
  {{@else}}
{{/if}}
```

Note that angle-bracket syntax doesn't support passing in an
inverse/else block, but the block provided to angle-bracket invocation
would be passed in as `@main`.

#### Ember Components: `main` and `else`

For Ember, we can't suddenly start setting `main` and `else` properties
on the component instances as this would be a breaking change, and
`main` in particular is not an uncommon property name.

We also shouldn't punt on this feature for Ember components for the
following reasons/use cases:

- [ember-elsewhere](https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000)
  (and other similar patterns) require having access to the opaque block
  so that it can be stashed on a service and rendered elsewhere
- wrapper components that forward args/properties/blocks to another
  internal component; blocks need to be accessible as properties in order
  to pass them into another component (otherwise you'd have to use a
  combinatoric mess of block syntax + `if hasBlock` checks to forward
  blocks through to the inner component)

So we need an opt-in API; any Ember Component that wants `main`/`else`
properties to be set on the component instance need to opt into this
behavior via a mixin provided by Ember:

```
import { ImplicitBlockPropertyMixin } from "@ember/implicit-block-property-support";

export default Ember.Component.extend(ImplicitBlockPropertyMixin, {
  blockManager: inject.service(),
  init() {
    this._super();
    this.get('blockManager').registerBlock(this.get('main'));
  },
});
```

So if `fancy-if` were an Ember component that used this mixin, then
given the component invocation:

```
{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-if}}
```

The following ember component layout would work:

```
{{#if cond}}
  {{this.main}}
{{else}}
  {{this.else}}
{{/if}}
```

# How We Teach This

We teach this as a followup to classic block syntax; once the user is comfortable with single-block syntax, we can introduce named block syntax for more complex use cases.

We teach that what `<@blockName></@blockName>` syntax really means is
that we're just passing in an arg named `@blockName`, which is like
any other arg we might pass into a component, but it happens to point
to a template block than, say, some simple string value.

# Drawbacks

### Different from WC slot syntax

This isn't really anything like the
[WebComponents slot syntax](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot)
that intends to address similar use cases, so there is some risk of
introducing an API that doesn't fit in with what the rest of the world
is doing.

### Syntax highlighting changes

Some syntax highlighters might have trouble with this syntax; all
the editors I've tried it on look reasonable, but GitHub's Handlebars
parser isn't too kind (hence I've been using `html` snippets instead
of `handlebars` snippets):

```hbs
<x-modal>
  <@header as |c|>
    ...
  </@header>

  <@main as |c|>
    ...
  </@main>
</x-modal>
```

### Conditionally passing blocks?

This RFC does NOT introduce any kind of facility for conditionally passing
blocks, e.g.:

```html
{{! this syntax is INVALID! }}
<x-layout>
  <@header>...</@header>
  <@main>...</@main>

  {{#if userCanProceed}}
    <@footer>
      {{submit-button}}
    </@footer>
  {{/if}}
</x-layout>
```

This might be desirable in the future, particularly for use cases
involving flex-ish layouts where the component changes behavior /
appearance based on whether blocks on passed in.

# Alternatives

I'd proposed a JSX-y [attr/component-centric](https://github.com/emberjs/rfcs/pull/203) syntax for passing what are essentially DOM lambdas, rendered with `{{component}}`. Perhaps we'll add something like that feature in the future, but it's a much less natural enhancement to Ember than named blocks.

# Considerations for Future RFCs

## Defining Default Blocks

There's not really a nice way defining default blocks inside your
component layout (i.e. the block you render when known is provided at
invocation time), but then again I believe the following would be
a workable approach that is probably support by the features proposed in
this RFC?

```
{{#with-blocks}}
  <@mainOrDefault>
    {{#if main}}
      {{main}}
    {{else}}
      I am the default main block when none is passed in.
    {{/if}}
  </@mainOrDefault>

  <@footerOrDefault>
    {{#if footer}}
      {{footer}}
    {{else}}
      I am the default footer block when none is passed in.
    {{/if}}
  </@footerOrDefault>

  <@render as |@mainOrDefault @footerOrDefault|>
    {{! this specially-named block gets passed all the other blocks above}}

    {{mainOrDefault}}
    {{footerOrDefault}}
  </@render>
{{/with-blocks}}
```

Either way, it feels hacky and weird and I would be surprised if we'd
want/need a future RFC to define a nicer way to support default blocks.

## Allow passing multiple blocks with the same name

e.g.

```html
{{#power-select}}
  <@option value="foo">
    <em>Foo</em>
  </@option>
  <@option value="bar">
    <blink>Bar</blink>
  </@option>
{{/power-select}}
```

This RFC defines that passing multiple blocks with the same name is a
syntax error, but it's something we might want to relax in the future
for certain cases where you want to pass arrays of blocks, such as
`power-select` or use cases involving tables.



---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2017-06-11T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework ## FIXME - added automatically as it was missing during migration'
prs:
  accepted: https://github.com/emberjs/rfcs/pull/229
project-link:
---

# Summary

In order to largely reduce the brittleness of tests, this RFC proposes to
remove the concept of artificially restricting the resolver used under
testing.

# Motivation

Disabling the resolver while running tests leads to extremely brittle tests.

It is not possible for collaborators to be added to the object (or one
of its dependencies) under test, without modifying the test itself (even if
exactly the same API is exposed).

The ability to restrict the resolver is **not** actually a feature of Ember's
container/registry/resolver system, and has posed as significant maintenance
challenge throughout the lifetime of ember-test-helpers.

Removing this system of restriction will make choosing what kind of test to
be used easier, simplify many of the blueprints, and enable much simpler refactoring
of an applications components/controllers/routes/etc to use collaborating utilties
and services.

# Transition Path

## Deprecate Functionality

Issue a deprecation if `integration: true` is not included in the specified
options for the APIs listed below. This specifically includes specifying
`unit: true`, `needs: []`, or specifying none of the "test type options"
(`unit`, `needs`, or `integration` options) to the following `ember-qunit`
and `ember-mocha` API's:

* `ember-qunit`
  * `moduleFor`
  * `moduleForComponent`
  * `moduleForModel`
* `ember-mocha`
  * `setupTest`
  * `setupComponentTest`
  * `setupModelTest`

### Non Component Test APIs

The migration path for `moduleFor`, `moduleForModel`, `setupTest`, and
`setupModelTest` is very simple:

```js
// ember-qunit

// before
moduleFor('service:session');

moduleFor('service:session', {
  unit: true
});

moduleFor('service:session', {
  needs: ['type:thing']
});

// after
moduleFor('service:session', {
  integration: true
});
```

```js
// ember-mocha

// before
describe('Session Service', function() {
  setupTest('service:session');

  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { unit: true });

  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { needs: [] });

  // ...snip...
});

// after

describe('Session Service', function() {
  setupTest('service:session', { integration: true });

  // ...snip...
});
```

The main change is adding `integration: true` to options (and removing `unit` or `needs`
if present).

### Component Test APIs

Implicitly relying on "unit test mode" has been deprecated for quite some time
([introduced 2015-04-07](https://github.com/emberjs/ember-test-helpers/pull/38)),
so all consumers of `moduleForComponent` and `setupComponentTest` are specifying
one of the "test type options" (`unit`, `needs`, or `integration`).

This RFC proposes to deprecate completely using `unit` or `needs` options with
`moduleForComponent` and `setupComponentTest`. The vast majority of component tests
should be testing via `moduleForComponent` / `setupComponentTest` with the `integration: true`
option set, but on some rare occaisions it is easier to use the "unit test" style is
desired (e.g. non-rendering test) these tests should be migrated to using `moduleFor`
/ `setupTest` directly.

```js
// ember-qunit

// before
moduleForComponent('display-page', {
  unit: true
});

moduleForComponent('display-page', {
  needs: ['type:thing']
});

// after

moduleFor('component:display-page', {
  integration: true
});
```

```js
// ember-mocha
describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { unit: true });

  // ...snip...
});

describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { needs: [] });

  // ...snip...
});

// after

describe('DisplayPageComponent', function() {
  setupTest('component:display-page', { integration: true });

  // ...snip...
});
```

## Ecosystem Updates

The blueprints in all official projects (and any provided by popular
addons) will need to be updated to avoid triggering a deprecation.

This includes:

* `ember-source`
* `ember-data`
* `ember-cli-legacy-blueprints`
* Others?

## Remove Deprecated `unit` / `needs` Options

Once the changes from this RFC are made, we will be able to remove
support for the `unit` and `needs` options from `ember-test-helpers`,
`ember-qunit`, and `ember-mocha`. This would be a "semver major"
version bump for all of the related libraries to properly signal that
functionality was removed.

Once the underlying libraries have done a major version bump, we will
introduce a deprecation for using the `integration` option. This
deprecation would be issued once for the entire test suite (not once
per test module which has `integration` passed in). We will also update
the blueprints to remove the extraneous `integration` option.

# How We Teach This

This RFC would require an audit of the main Ember.js guides to ensure
that all usages of the APIs in question continue to be non-deprecated
valid usages.

# Drawbacks

## Churn

One drawback to this deprecation proposal is the churn associated with
modifying the options passed for each test. This can almost certainly
be mitigated by providing a codemod to enable automated updating.

There are additional changes being entertained that would require changes
for the default testing blueprints, we should ensure that these RFCs do not
conflict or cause undue churn/pain.

## `integration: true` Confusion

Prior to this deprecation we had essentially 4 options for testing components:

* `moduleFor(..., { unit: true })`
* `moduleFor(..., { integration: true })`
* `moduleForComponent(..., { unit: true })`
* `moduleForComponent(..., { integatrion: true })`

With this RFC the option `integration` no longer provides value (we aren't talking
about "unit" vs "integration" tests), and may be seen as confusing.

I believe that this concern is mitigated by the ultimate removal of the `integration`
(it is only required in order to allow us a path forward that is compatible with
todays ember-qunit/ember-mocha versions).


---

---
stage: recommended
start-date: 2017-06-13T00:00:00.000Z
release-date: 2018-02-13T00:00:00.000Z
release-versions:
  ember-source: v3.0.0

teams:
  - framework
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/232
project-link:
---

# Summary

In order to embrace newer features being added by QUnit (our chosen default
testing framework), we need to reduce the brittle coupling between `ember-qunit`
and QUnit itself.

This RFC proposes a new testing syntax, that will expose QUnit API directly while
also making tests much easier to understand.

# Motivation

QUnit feature development has been accelerating since the ramp up to QUnit 2.0.
A number of new features have been added that make testing our applications
much easier, but the current structure of `ember-qunit` impedes our ability
to take advantage of some of these features.

Developers are often confused by our `moduleFor*` APIs, questions like these
are very common:

* What "magic" is `ember-qunit` doing?
* Where are the lines between QUnit and ember-qunit?
* How can I use QUnit for plain JS objects?

The way that `ember-qunit` wraps QUnit functionality makes the division
of responsiblity much harder to understand, and leads folks to believe that there
is much more going on in `ember-qunit` than there is. It should be much clearer
what `ember-qunit` is responsible for and what we rely on QUnit for.

This RFC also aims to remove a number of custom testing only APIs that exist today
(largely because the container/registry system was completely private when the
current tools were authored). Instead of things like `this.subject`, `this.register`,
`this.inject`, or `this.lookup` we can rely on the standard way of performing these
functions in Ember via the owner API.

When this RFC has been implemented and rolled out, these questions should all be
addressed and our testing system will both: embrace QUnit much more **and**
be much more framework agnostic, all the while dropping custom testing only APIs
in favor of public APIs that work across tests and app code.

Sounds like a neat trick, huh?

# Detailed design

The primary change being proposed in this RFC is to migrate to using the QUnit
nested module syntax, and update our custom setup/teardown into a more functional
API.

Lets look at a basic example:

```js
// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name="red"}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name="red"}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
```

As you can see, this proposal leverages QUnit's nested module API in a way that
makes it much clearer what is going on. It is quite obvious what QUnit is doing
(acting like a general testing framework) and what `ember-qunit` is doing
(setting up rendering functionality).

This API was heavily influenced by the work that
[Tobias Bieniek](https://github.com/Turbo87) did in
[emberjs/ember-mocha#84](https://github.com/emberjs/ember-mocha/pull/84).

## QUnit Nested Modules API

Even though it is not a proposal of this RFC, the QUnit nested module
syntax may seem foreign to some folks so lets briefly review.

With nested modules, a normal 1.x QUnit module setup changes from:

```js
QUnit.module('some description', {
  before() {},
  beforeEach() {},
  afterEach() {},
  after() {}
});

QUnit.test('it blends', function(assert) {
  assert.ok(true, 'of course!');
});
```

Into:

```js
QUnit.module('some description', function(hooks) {

  hooks.before(() => {});
  hooks.beforeEach(() => {});
  hooks.afterEach(() => {});
  hooks.after(() => {});

  QUnit.test('it blends', function(assert) {
    assert.ok(true, 'of course!');
  });
});
```

This makes it much simpler to support multiple `before`, `beforeEach`, `afterEach`,
and `after` callbacks, and it also allows for arbitrary nesting of modules.

You can read more about QUnit nested modules
[here](http://api.qunitjs.com/QUnit/module#nested-module-nested-hooks-). The new APIs
proposed in this RFC expect to be leveraging nested modules.

## New APIs

The following new methods will be exposed from `ember-qunit`:

```ts
interface QUnitModuleHooks {
  before(callback: Function): void;
  beforeEach(callback: Function): void;
  afterEach(callback: Function): void;
  after(callback: Function): void;
}

declare module 'ember-qunit' {
  // ...snip...
  export function setupTest(hooks: QUnitModuleHooks): void;
  export function setupRenderingTest(hooks: QUnitModuleHooks): void;
}
```

### `setupTest`

This function will:

* invoke `ember-test-helper`s `setContext` with the tests context
* create an owner object and set it on the test context (e.g. `this.owner`)
* setup `this.set`, `this.setProperties`, `this.get`, and `this.getProperties` to
  the test context
* setup `this.pauseTest` and `this.resumeTest` methods to allow easy pausing/resuming
  of tests

### `setupRenderingTest`

This function will:

* run the `setupTest` implementation
* setup `this.$` method to run jQuery selectors rooted to the testing container
* setup a getter for `this.element` which returns the DOM element representing
  the element that was rendered via `this.render`
* setup Ember's renderer and create a `this.render` method which accepts a
  compiled template to render and returns a promise which resolves once rendering
  is completed
* setup `this.clearRender` method which clears any previously rendered DOM (
  also used during cleanup)

When invoked, `this.render` will render the provided template and return a
promise that resolves when rendering is completed.

## Changes from Current System

Here is a brief list of the more important but possibly understated changes
being proposed here:

* the various setup methods no longer need to know the name of the object under test
* `this.subject` is removed in favor of using the standard public API for looking up
  and creating instances (`this.owner.lookup` and `this.owner.factoryFor`)
* `this.inject` is removed in favor of using `this.owner.lookup` directly
* `this.register` is removed in favor of using `this.owner.register` directly
* `this.render` will begin being asynchronous to allow for further iteration in the
  underlying rendering engines ability to speed up render times (by yielding back
  to the browser and not blocking the main thread)
* `this.pauseTest` and `this.resumeTest` are being added
* `this.element` is being introduced as a public API for DOM assertions in a jQuery-less
  environment
* QUnit nested modules are required

These changes generally do not affect our ability to write a codemod to aide in the migration.

## Migration Examples

The migration can likely be largely automated (following the
[excellent codemod](https://github.com/Turbo87/ember-mocha-codemods) that
[Tobias Bieniek](https://github.com/turbo87) wrote for a similar `ember-mocha`
the transition), but it is still useful to review concrete scenarios
of tests before and after this RFC is implemented.

### Component / Helper Integration Test

```js
// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name="red"}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name="red"}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
```

### Component Unit Test

```js
// **** before ****

import { moduleForComponent, test } from 'ember-qunit';

moduleForComponent('x-foo', {
  unit: true
});

test('computes properly', function(assert) {
  assert.expect(1);

  let subject = this.subject({
    name: 'something'
  });

  let result = subject.get('someCP');
  assert.equal(result, 'expected value');
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('x-foo', function(hooks) {
  setupTest(hooks);

  test('computed properly', function(assert) {
    assert.expect(1);

    let Factory = this.owner.factoryFor('component:x-foo');
    let subject = Factory.create({
      name: 'something'
    });

    let result = subject.get('someCP');
    assert.equal(result, 'expected value');
  });
});
```

### Service/Route/Controller Test

```js
// **** before ****

import { moduleFor, test } from 'ember-qunit';

moduleFor('service:flash', 'Unit | Service | Flash', {
  unit: true
});

test('should allow messages to be queued', function (assert) {
  assert.expect(4);

  let subject = this.subject();

  subject.show('some message here');

  let messages = subject.messages;

  assert.deepEqual(messages, [
    'some message here'
  ]);
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('Unit | Service | Flash', function(hooks) {
  setupTest(hooks);

  test('should allow messages to be queued', function (assert) {
    assert.expect(4);

    let subject = this.owner.lookup('service:flash');

    subject.show('some message here');

    let messages = subject.messages;

    assert.deepEqual(messages, [
      'some message here'
    ]);
  });
});

```

## Ecosystem Updates

The blueprints in all official projects (and any provided by popular addons)
will need to be updated to detect `ember-qunit` version and emit the correct
output.

This includes:

* ember-source
* ember-data
* ember-cli-legacy-blueprints
* others?

This exact process was done for `ember-mocha`'s migration, making this a well
trodden path.

## Update Guides

The guides includes a section for testing, this section needs to be reviewed
and revamped to match the proposal here.

## Deprecate older APIs

Once this RFC is implemented, the older APIs will be deprecated and retained
for a full LTS cycle (assuming speedy landing, this would mean the older APIs
would be deprecated around Ember 2.20). After that timeframe, the older APIs
will be removed from `ember-qunit` and `ember-test-helpers` and they will
release with SemVer major version bumps.

Note that while the older `moduleFor` and `moduleForComponent` APIs will be
deprecated, they will still be possible to use since the host application can
pin to a version of `ember-qunit` / `ember-test-helpers` that support its own
usage. This is a large benefit of migrating these testing features away from
`Ember`'s internals, and into the addon space.

## Relationship to "Grand Testing Unification"

This RFC is a small stepping stone towards the future where all types of tests
share a similar API. The API proposed here is much easier to extend to provide
the functionality that is required for [emberjs/rfcs#119](https://github.com/emberjs/rfcs/pull/119).

# How We Teach This

This change requires updates to the API documentation of `ember-qunit` and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.

# Drawbacks

## Churn

As mentioned in [emberjs/rfcs#229](https://github.com/emberjs/rfcs/pull/229), test
related churn is quite painful and annoying. In order to maintain the general
goodwill of folks, we must ensure that we avoid needless churn.

This RFC should be implemented in conjunction with
[emberjs/rfcs#229](https://github.com/emberjs/rfcs/pull/229) so that we can avoid
multiple back to back changes in the blueprints.

## [qunitjs/qunit#977](https://github.com/qunitjs/qunit/issues/977)

Until very recently, the QUnit nested module API was only able to allow a single
callback for each of the hooks per-nesting level. This means that the proposal in
this RFC (which requires the hooks to be setup by `ember-qunit`) would disallow
user-land `beforeEach`/`afterEach` hooks to be setup.

The work around is "simple" (if somewhat annoying), which is to "just nest another
level". The good news is that [Trent Willis](https://github.com/trentwillis) fixed
the underlying problem in [qunitjs/qunit#1188](https://github.com/qunitjs/qunit/pull/1188),
which should be released as 2.3.4 well before this RFC is merged.

# Alternatives

The simplest alternative is to do nothing. This would loose all of the positive
benefits mentioned in this RFC, but should still be considered a possibility...

# Unanswered Questions

## `hooks` argument

A few folks (e.g. [@ebryn](https://github.com/ebryn) and [@stefanpenner](https://github.com/stefanpenner))
have approached me with concerns around the `hooks` argument I have mentioned/used here. The concerns
are generally an initial reaction to the QUnit nested modules API in general and not directly related
to this RFC (other than it highlighting a new feature that they haven't used before).

The main concerns are:

* Teaching folks what `hooks` means is a bit more difficult because it does not represent the "test
  environment", but rather just a way to invoke the callbacks for `before` / `beforeEach` / `after` /
  `afterEach`.
* Passing only `hooks` to the helper functions proposed in the RFC means that if we ever need to thread
  more information through, we either have to use `hooks` as a transport or change our API to add more
  arguments.
* It seems somewhat impossible to communicate across multiple helpers (again without using `hooks`
  as a state/transport mechanism).

I've kicked off a conversation over with the QUnit folks in https://github.com/qunitjs/qunit/issues/1200.
If that PR were merged this proposal would be modified to the following syntax:

```js
// current proposal
module('x-foo', function(hooks) {
  setupRenderingTest(hooks);
  // ....snip....
});

// after qunitjs/qunit#1200
module('x-foo', function(hooks) {
  setupRenderingTest(this);
  // ....snip....
});
```

Another possible solution is to rename the argument (here and in the blueprints) to `module`.
This is more in line with what the QUnit folks view it as: the "module context" that
is being created for that specific `QUnit.module` invocation.


---

---
stage: recommended
start-date: 2017-07-14T00:00:00.000Z
release-date: 2023-01-12T00:00:00.000Z
release-versions:
  ember-source: v4.10.0
teams:
  - framework
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/236'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/892'
  released: 'https://github.com/emberjs/rfcs/pull/897'
  recommended: 'https://github.com/emberjs/rfcs/pull/898'
project-link:
meta:
  tracking: 'https://github.com/emberjs/ember.js/issues/20340'
  legacy-tracking: 'https://github.com/emberjs/rfc-tracking/issues/26'
---

# Summary

This RFC proposes to deprecate the prototype extensions done by `Ember.String`, deprecate the `loc` method, and moving `htmlSafe` and `isHTMLSafe` to `@ember/template`.

# Motivation

Much of the public API of Ember was designed and published some time ago, when the client-side landscape looked much different. It was a time without many utilities and methods that have been introduced to JavaScript since, without the current rich npm ecosystem, and without ES6 modules. On the Ember side, Ember CLI and the subsequent addons were still to be introduced. Global mode was the way to go, and extending native prototypes like Ember does for `String`, `Array` and `Function` was a common practice.

With the introduction of [RFC #176](https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md), an opportunity to reduce and reorganize the API that is shipped by default with an Ember application appears. A lot of nice-to-have functionality that was added at that time can now be moved to optional packages and addons, where they can be maintained and evolved without being tied to the core of the framework.

In the specific case of `Ember.String`, our goal is that users that need these utility functions will include `@ember/string` in their dependencies, or rely on common utility packages like [`lodash.camelcase`](https://lodash.com/docs/#camelCase).

To achieve the above goal we will move the `isHTMLSafe`/`htmlSafe` pair into a new package, deprecate `String.prototype` extensions, and deprecate the utility functions under the `Ember.String` namespace.

The ["Organize by Mental Model"](https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#organize-by-mental-model) section of RFC #176 mentions the concept of chunking. In the current setup, `isHTMLSafe`/`htmlSafe` make sense in the `Ember.String` namespace because they operate on strings, and they are available on the prototype, `"myString".htmlSafe()`.
However, once prototype extensions are removed it becomes clearer that while this pair operates on strings, they don't transform them in the same way as `capitalize` or `dasherize`. They are instead a way for the user to communicate to the templating engine that this string should be safe to render. For this reason, moving to `@ember/template` seems appropriate.

Extending native prototypes, like we do for `String` with `"myString".dasherize()` and the rest of the API, has been falling out of favour more as time goes by.
While the tradeoff might have been positive at the beginning, as it allowed users access to a richer API, prototype extensions blur the line between what is the framework and what is the language in a way that is not benefitial in the current module-driven and package-rich ecosystem.

Relatedly, deprecating `Ember.String` and requiring `@ember/string` as a dependency allows Ember to provide a leaner default core to all users, as well as iterate faster on the `@ember/string` package if desired.
Doing this will also open a path to extract more packages in the future.

# Transition Path

It is important to understand that the transition path will be done in the context of the new modules API defined in RFC #176, which is scheduled to land in 2.16.
As this will likely be first of many packages to be extracted from the Ember source, the transition path arrived on needs to be clear and user-friendly.

## What is happening for framework developers?

The order of operations will be as follows:

1. Move `htmlSafe` and `isHTMLSafe` to `@ember/template`
   * Update https://github.com/ember-cli/ember-rfc176-data
2. Create an `@ember/string` package with the remaining public API
3. Create an `ember-string-prototype-extensions` package that introduces `String` prototype extensions to aid in transitioning
4. Make `ember-cli-babel` aware of the `@ember/string` package so it tells `babel-plugin-ember-modules-api-polyfill` not to convert those imports to the global `Ember` namespace
5. Update usages in Ember and Ember Data codebases so that the projects do not trigger deprecations
6. Deprecate `Ember.String`
   * Write deprecation guide which mentions minimum version of `ember-cli-babel`, and how/when to use `@ember/string` and `ember-string-prototype-extensions` packages
7. Deprecate `loc` in `@ember/string`

## What is happening for framework users?

If you are using `Ember.String.loc`, you will be instructed to move to a dedicated localization solution, as this method will be completely deprecated.

If you are using `Ember.String.htmlSafe` or `Ember.String.isHTMLSafe`, you will be instructed to run the [`ember-modules-codemod`](https://github.com/ember-cli/ember-modules-codemod) and it will update to the correct imports from the `@ember/template` package.

If you are using one of the other `Ember.String` methods, like `Ember.String.dasherize`, you will receive a deprecation warning to inform you that you should run the [`ember-modules-codemod`](https://github.com/ember-cli/ember-modules-codemod), update `ember-cli-babel` to a specific minor version, and add `@ember/string` to your application's or addon's dependencies.

If you are using the `String` prototype extensions, like `'myString'.dasherize()`, on top of the previous instructions you will be instructed to install `ember-string-prototype-extensions` in case updating the code to `dasherize('myString')` is not trivial.

## Timeline

* Deprecations are introduced - Ember 2.x
  * `String` protoype extensions are deprecated
  * `Ember.String` functions are deprecated
  * `loc` is completely deprecated
  * `isHTMLSafe` and `htmlSafe` are moved to `@ember/template`
* Transition packages are introduced - Ember 2.x
  * `@ember/string`, which replaced `Ember.String`
  * `ember-string-prototype-extensions`, which brings `String` prototype extensions back
* Deprecations are removed - Ember 3.x, `@ember/string` 2.x
  * New major version of Ember is released
  * New major version of `@ember/string` is released

# How We Teach This

## Official code bases and documentation

The official documentation –website, Guides, API documentation– should be updated not to use `String` prototype extensions.
This documentation should already use the new modules API from an effort to update it for Ember 2.16.

The Guides section on _disabling prototype extension_ will need to be updated when `String` prototype extensions are removed from Ember.

Resources owned by the Ember teams, such and Ember and Ember Data code bases, the Super Rentals repository, or the builds app for the website, will be updated accordingly.

## `Ember.String.htmlSafe` and `Ember.String.isHTMLSafe`

The move of `htmlSafe` and `isHTMLSafe` from `Ember.String` to `@ember/template` should be documented as part of the [ember-rfc176-data](https://github.com/ember-cli/ember-rfc176-data) and related codemods efforts, as that project is the source of truth for the mappings between the `Ember` global namespace and `@ember`-scoped modules.

## `Ember.String.loc` and `import { loc } from '@ember/string';`, `Ember.String` to `@ember/string`, `String` prototype extensions

An entry to the [Deprecation Guides](https://emberjs.com/deprecations/) will be added outlining the different recommended transition strategies.

### `Ember.String.loc`, `import { loc } from '@ember/string';`

As this function is deprecated, users will be recommended to use a [dedicated localization solution](https://emberobserver.com/categories/internationalization).

### `Ember.String` to `@ember/string`

The way that `@ember`-scoped modules will work in 2.16 is that `ember-cli-babel` will convert something like `import { dasherize } from '@ember/string';` to `import Ember from 'Ember'; const dasherize = Ember.String.dasherize;`.
What this means is that `import { dasherize } from '@ember/string';` will trigger a deprecation if you do not have the `@ember/string` package in your dependencies.

To address the above deprecation you will need to update `ember-cli-babel` to a a specific minor version or higher, to make sure it has the logic to detect `@ember/string`. The specific minor version will be known at the time the deprecation guide is written.
You will also need to add `@ember/string` to your application's development dependencies, or your addon's dependencies.

### `String` prototype extensions

If you are using `'myString'.dasherize()` or one of the other functions added to `String`, you will be instructed to replace that usage with `import { dasherize } from '@ember/string'; dasherize('myString')`, in addition to the changes on the previous section.

In case your code base is complicated enough that migrating all these usages at the same time is not convenient, you will be able to add `ember-string-prototype-extensions` to your dependencies, which will bring back extensions, without deprecations.

# Drawbacks

A lot of addons that deal with names depend on this behaviour, so they will need to install the addon. Also, Ember Data and some external serializers require these functions.

`htmlSafe` and `isHTMLSafe` would need to change packages, thus the reason to try and provide an Ember Watson recipe.

Another side-effect of this change is that certain users might be shipping duplicated code between `Ember.String` and `@ember/string`, but it is a necessary stepping stone and might be able to be addressed via svelting.

# Alternatives

Leave things as they are.

# Unresolved questions

None.


---

---
stage: recommended
start-date: 2017-07-20T00:00:00.000Z
release-date: 2018-07-16T00:00:00.000Z
release-versions:
  ember-source: v3.3.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/237
project-link:
---

# Summary

This RFC proposes the deprecation of the following classes:

- `Ember.OrderedSet`
- `Ember.Map`
- `Ember.MapWithDefault`

These classes need to be moved to an external addon given they are private classes and unused in Ember.js itself.

# Motivation

These classes have not been used in Ember itself for a while now. They have always been private but they are used in a few addons, and in particular Ember Data is using them.

# Transition Path

`Ember.Map` and `Ember.MapWithDefault` will be deprecated and not extracted, but not before the fix mentioned in the following paragraph is landed in Ember Data. There is already an addon with `Ember.OrderedSet` extracted ([@ember/ordered-set](https://github.com/emberjs/ember-ordered-set)).

Ember Data is quite likely the biggest project using these classes. There is already a PR that needs merging before deprecating `Ember.Map` and `Ember.MapWithDefault` https://github.com/emberjs/data/pull/5255. Ember Data still needs to migrate to `@ember/ordered-set` to its relationship logic.

Once Ember Data is updated to not use the classes from Ember, and that fix is released, the `Ember.Map` and `Ember.MapWithDefault` can be deprecated in Ember itself.

# How We Teach This

These classes being private would make this simple than other deprecations. People were not supposed to be using a private API and the few that were, would just need to use a new addon.

This should not impact many codebases.

# Drawbacks

This requires cooperation with Ember Data, the main user of these classes. It would be nice to have moved Ember Data to using the addon before releasing Ember with the deprecation so the average user does not see any deprecation warning.

# Alternatives

Other option would be moving these classes to Ember Data itself or leaving things as they are now.

# Unresolved questions


---

---
stage: recommended
start-date: 2017-07-28T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/240
project-link:
---

# Summary

This RFC aims to solidify the usage of ES2015 Classes as a public API of Ember so
that users can begin building on them, and projects like `ember-decorators` can
continue to push forward with experimental Javascript features. This includes:

* Making the class `constructor` function a public API
* Modifying some of the internals of `Ember.Object` to support existing features
and make the usage of ES Classes cross-compatible with `Ember.Object`

It does _not_ propose additions in the form of helpers or decorators, which should
continue to be iterated on in the community as the spec itself is finalized. It also
does not propose deprecating or removing existing functionality in `Ember.Object`.

# Motivation

The Ember Object model has served its purpose well over the years, but now that
ES Classes are becoming prevalent throughout the wider Javascript community
it is beginning to show its age. With class properties at stage 3 and decorators at
stage 2 in the TC39 process, classes are finally at a point where we can start
integrating them into Ember.

The [ember-decorators](https://github.com/rwjblue/ember-decorators) project has been
experimenting with using ES Classes and filling out the Ember feature-set,
allowing us to write Ember classes like so:

```javascript
export default class MyComponent extends Ember.Component {
  didInsertElement() {
    // do stuff
  }

  @computed
  get foo() {
    // do stuff
  }

  @action
  bar() {
    // do stuff
  }
}
```

Using classes makes Ember easier to teach and understand by normalizing it with
standard Javascript coding practices, and allows us to share code and solutions
with other frameworks and libraries. It also brings with it all the benefits of
ES Class syntax:

* More aligned with the greater Javascript community
* Ability to share code more easily with other libraries and frameworks
* Easier to statically analyze
* Cleaner and easier to read (subjective)

The Ember Object model already works extremely well with ES classes, as
demonstrated above, but there several failure scenarios. Furthermore, because
they are not officially supported as a public API, there is no guarantee
that they will continue to work well. Thus, this RFC seeks to solidify the
behavior of ES Classes so that the community can continue to experiment with
new Javascript features and build on a stable API.

# Detailed Design

Many of the standard features of Ember classes work out of the box today, either with
vanilla ES Classes or through `ember-decorators`, including:

* Inheritance
* Lifecycle hooks
* Computeds
* Injections
* Actions

However, the following features either do not exist or do not work as a
user familiar with `Ember.Object` would expect:

* Extending from ES Classes using `extend`
* Class properties
* Mixins
* Observers and events
* Merged and concatenated properties

These features will require changes to `Ember.Object`

## Extend

Currently, once a class is defined using ES Classes it is not possible for users
to extend it using the previous CoreObject style of writing and extending classes.
This can limit the rate of adoption because ES Classes would become a trapdoor -
once you begin using them, you must continue to use them. It would be a particularly
thorny issue for addon developers, who may design components which their users
expect to be able to extend and modify.

This RFC proposes that `extend` be fixed on ES Classes to make them fully
cross-compatible with the existing syntax. There are two general approaches to
making this work:

1. Modify CoreObject to use prototypes/ES Classes internally. This would bring
CoreObject more inline with ES Classes, but would be a significant internal change.

2. Modify CoreObject to have different behavior if it is extending an ES Class
using `extend`.

Both approaches should be explored and benchmarked to determine if there are an
significant advantages to one over the other.

## Class Properties

When using `Ember.Object.extend`, properties that are passed in on the object
are assigned to the prototype of the class:

```javascript
const Foo = Ember.Object.extend({ bar: 'baz' });
const foo = Foo.create();

console.log(Foo.prototype.bar) // 'baz'
foo.hasOwnProperty('bar') // false
```

This differs from the behavior of ES Class properties, which initialize their
value on the instance of the class.

```javascript
class Foo {
  bar = 'baz'
}

const foo = new Foo();

console.log(Foo.prototype.bar) // undefined
foo.hasOwnProperty('bar') // true
```

The above is essentially currently compiled down by Babel to the following:

```javascript
class Foo {
  constructor() {
    this.bar = 'baz';
  }
}
```

Property assignments like this are always done at the end of the constructor,
and given the requirement that `super` must always be called before properties
are assigned it is unlikely that this will change as the spec progresses.

While one might intuitively expect class properties to function the same in
ES Classes as they do with Ember Objects, this difference in behavior means that
class properties will always be assigned after properties passed into `create`
are initialized on the object, and thus will always win:

```javascript
const Foo = Ember.Object.extend({ testProp: 'default value' });

class Bar extends Ember.Object {
  testProp = 'default value'
}

const foo = Foo.create({ testProp: 'new value' });
const bar = Bar.create({ testProp: 'new value' });

console.log(foo.get('testProp')); // 'new value'
console.log(bar.get('testProp')); // 'default value'
```

This behavior makes sense when you consider that it is equivalent to assigning
values in `init` rather than on the object when it is defined. Rather than modify
`Ember.Object` to treat class properties as default values, this RFC proposes that
we accept the difference in behavior and utilize the constructor to allow users
to set default values, as in the following example:

```javascript
class Foo extends Ember.Object {
  constructor(props) {
    props.testProp = props.testProp || 'default value';

    super(props);
  }
}
```

This enforces a public API rather than allowing `create` to override values as
it pleases, and is more inline with the behavior of components in Glimmer today -
args that are passed into the class are distinguished from properties that are
defined on the class.

## Mixins

Mixins are a contentious part of both the Ember Object model and the wider
Javascript community - some swear by the pattern, and others believe it fundamentally
flawed. While Ember mixins are at the core of Ember Object, the fact is that
no standard solution for them has arisen in the wider Javascript community as
of yet.

Additionally, while concepts like computed properties, actions, and
service injection are either unique to Ember or highly dependent on implementation,
mixins can be implemented in a generic way which could be used across all of
Javascript, independent of one's framework or library of choice. With that in
mind, this RFC considers mixins out of scope and suggests that in the future Ember
users can choose to use a mixin library if it suits their needs.

It should also be noted that existing classes which have used mixins can still be
extended using ES Class syntax:

```javascript
const Mix = Ember.Mixin.create({ bar: 'baz' });
const Foo = Ember.Object.extend(Mix, { /* ... */ });

class Bar extends Foo { /* ... */ }

const bar = Bar.create();

console.log(bar.get('bar')); // 'baz'
```

## Observers and Events

Observers and events both fail to work properly when using ES Class syntax. The root
of the issue here is how `Ember.Object` works at a fundamental level, and will require
some refactoring to fix.

Currently, each time `Ember.Object.extend` is used, it stores the list of mixins and
objects passed in on a list which also contains the superclass's properties and mixins,
and so on. A class is then returned which has access to a closure variable, `wasApplied`:

```javascript
makeCtor = function() {
  wasApplied = false;

  return class {
    constructor() {
      if (!wasApplied) {
        this.proto();
      }
    }
  }
}
```

The `proto` function walks the chain of stored mixins, collapsing them into a single object
prototype the first time the class is created. It is during this walk that observers and
events listeners are applied and finalized, as well as merged and concatenated properties
applied (this will be touched on more in the next section).

Unfortunately, due to the nature of how observers and event listeners work, they cannot be
applied at class definition time without a class decorator. For example:

```javascript
const Foo = Ember.Object.extend({
  fooObserver: Ember.observer('foo', function() { /* ... */m })
});

class Bar extends Foo {
  fooObserver() { /* ... */ }
}
```

When `proto` walks the mixin chain for Foo, it will add an observer that triggers the
`fooObserver` function whenever `foo` changes. Bar, however, overloads the `fooObserver`
function with a function that is _not_ observed, and thus should not trigger (this is
analagous to how Ember Object's work today). Currently there is no time at which
Bar can inspect undecorated properties to determine if the superclass has already defined
them and if they are observed and thus should have the observer removed.

To fix this, the `wasApplied` state should be moved to the ember meta object on the
class itself, so that both Ember Objects and ES Classes can track if they have had it
applied. Additional logic will also need to be added to allow the current "squashing"
behavior of `proto` to work with Prototypes instead of a list of mixins as well.

## Merged and Concatenated Properties

Ember Objects currently have the ability to define special properties which are
merged or concatenated with their superclass when extended. This is most commonly
seen with `actions` and `classNames` among others.

As mentioned in the last section, merged and concatenated properties are also
combined during the `proto` "squash" phase, and so it is also broken in ES Classes
currently. This RFC proposes that their behavior also be fixed as part of the refactors
to Ember.Object.

# How We Teach This

The sole purpose of this RFC is to make the behavior of ES Classes within Ember a
public API so that projects like `ember-decorators` can continue to build and experiment
with confidence that the underlying behavior will not change. The Ember Object model
will remain exactly the same as today, and will continue to be the recommended path
for Ember users. Thus, we will not need to add new documentation for the time being.

# Drawbacks

* Making `constructor` a public API means we are solidifying the lifecycle of
objects, locking us into a particular sequence of events (`init` occurs within
the `super()` portion of the constructor).
* Lack of mixin support may make it difficult for mixin heavy codebases to utilize
ES Classes.
* ES Class features/usage such as getters and setters may confuse users in general
(getter functions will _appear_ to work, but without a `computed` decorator will
not update, etc.)

# Alternatives

* Class property initialization can be changed such that properties are initialized
after the constructor runs entirely, allowing them to be overwritten by values
passed to `create`

# Topics for Future RFCs

While working on this RFC, some issues were brought into focus regarding existing
features in CoreObject that are seen as problematic or unintuitive. In order to
avoid bikeshedding these have been slated for discussion in future RFCs, but the
discussion points have been included below.

## Merged and Concatenated Properties

Merged and concatenated properties are pain points for new Ember developers,
specifically because they give no lexical hint that they are special in any way.
Developers must know that these particular properties will be merged with the
superclass, and there is no way to opt out of this behavior.

With decorators, this same behavior can be accomplished in a much clearer and
more straightforward way:

```javascript
class FooComponent extends Ember.Component {
  @concatenated classNameBindings = ['foo']

  @computed
  get foo() { /* ... */ }

  @merged actions = {
    bar() { /* ... */ }
  }
}
```

They could also be accomplished more ergonomically with specialized decorators:

```javascript
class FooComponent extends Ember.Component {
  @className
  @computed
  get foo() { /* ... */ }

  @action
  bar() { /* ... */ }
}
```

This approach has two distinct advantages over the existing behavior:

1. It is less magical. The decorators indicate to new users that the properties are
special in some way, and ultimately they are just plain decorators, which are
compatible with ES Classes as a whole and can be reused anywhere.
2. It provides a way to opt out of the behavior. Currently, there is no easy
way to prevent properties which were marked to be merged from being merged,
meaning subclasses are stuck with the values that their superclass provided.

## Observers and Listeners

Observers and event listeners are a powerful pattern that saw a lot of usage in Ember 1.
However, it is now widely accepted that they are problematic when overused, and using
computed properties and lifecycle hooks are better patterns in most cases.

As such, rather than having events and observers turned on by default it may make
more sense to have them be opt-in APIs. This could be accomplished by making new
class decorators like so:

```javascript
@evented
class Foo extends Ember.Object {
  @on('init')
  onInit() {
    // do something
  }
}
```

Or it could be accomplished with new base classes that include the functionality:

```javascript
class Foo extends EventedObject {
  @on('init')
  onInit() {
    // do something
  }
}
```

# Unresolved questions

None currently


---

---
stage: recommended
start-date: 2017-09-25T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/252
project-link:
---

# Summary

Solicit feedback on dropping support for IE9, IE10, and PhantomJS.

# Motivation

As Ember heads towards version 3.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 3.0 until Ember 4.0.

We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.
Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, we did not generally support IE9, IE10, and PhantomJS.

Because of this, the core team's impression is that the costs support now far exceed the benefits, and we are considering dropping support for them in Ember 3.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE9, IE10, and PhantomJS incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.

Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. **All of these, including addons that follow Ember’s lead, are shackled to the limitations of these legacy browsers.** By dropping support for them, people can begin to rely on the improved baseline of features.

Some of the features (unavailable in IE9, IE10, or PhantomJS) that addons will be able to freely take advantage of include:

- requestAnimationFrame ([caniuse](http://caniuse.com/#feat=requestanimationframe), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame))
- CSS flexbox ([caniuse](http://caniuse.com/#search=flexbox), [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes))
- Websockets ([caniuse](http://caniuse.com/#feat=websockets), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API))
- let ([caniuse](http://caniuse.com/#feat=let), [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let))
- const ([caniuse](http://caniuse.com/#feat=const), [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const))
- TypedArray ([caniuse](http://caniuse.com/#feat=typedarrays), [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray))
- Geolocation API ([caniuse](https://caniuse.com/#search=Geolocation), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation))
- Online/offline API ([caniuse](http://caniuse.com/#feat=online-status), [MDN](https://developer.mozilla.org/en-US/docs/Online_and_offline_events))
- XHR advanced features ([caniuse](https://caniuse.com/#feat=xhr2), [specification](https://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/))
- HTTP2 ([caniuse](http://caniuse.com/#feat=http2), [wikipedia](https://en.wikipedia.org/wiki/HTTP/2))
- Web Workers ([caniuse](http://caniuse.com/#feat=webworkers), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers))
- IndexedDB ([caniuse](http://caniuse.com/#feat=indexeddb), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API))
- WebGL ([caniuse](http://caniuse.com/#feat=webgl), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API))
- File API ([caniuse](http://caniuse.com/#feat=fileapi), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/File))
- PageTransitionEvent ([caniuse](http://caniuse.com/#feat=page-transition-events), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/PageTransitionEvent))
- SVG filters ([caniuse](http://caniuse.com/#feat=svg-filters), [MDN](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial))
- MutationObserver ([caniuse](http://caniuse.com/#feat=mutationobserver), [MDN](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver))

Below, we’ve outlined several specific features we’re interested in using to improve the Ember framework itself. We’ve also included some other supporting arguments for this decision.

## Vendor Support

Microsoft dropped most support and maintenance for IE9 and IE10 on 2016-01-16 (IE9 on Vista SP2 [expired in April 2017](http://www.allyncs.com/docs/lifecyclesupport.html)).

With the advent of headless Chrome and Firefox, PhantomJS is now [effectively unmaintained](https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE). The default testing boilerplate for Ember CLI-generated applications was changed to headless Chrome in Ember CLI 2.15.

## WeakMap, Map, Set

From a framework perspective, being able to rely on native `WeakMap` support will allow us to remove a significant number of fallback paths that are used in browsers without `WeakMap`. Using `WeakMap` results in better developer ergonomics as it allows us to remove many of the random properties that we currently have to assign to an object which makes interacting with your objects in the devtools much less noisy. Minimal support for WeakMap was [introduced in IE11](http://kangax.github.io/compat-table/es6/#test-WeakMap).

## Better ES Class Support

In order to support static class methods (with inheritance) transpilers (e.g. Babel) need to leverage the `Object.setPrototypeOf` / `Object.getPrototypeOf` APIs. Without the ability to rely on `Object.setPrototypeOf` we will not be able to continue iterating slowly towards leveraging ES classes as a replacement for the custom object model functionality that we have known and loved for so many years. Specifically, there is no replacement / capability to support proper inheritance with `.reopenClass`. There are several lower-fidelity hacks you might opt into, but none that we think satisfy the needs of the Ember community.

Generally this means IE11 is the oldest browser we can reliably transpile ES classes for reliably.

## Typed Arrays

Typed arrays are not currently used in Ember, but experimentation is underway deep in the internals of Glimmer VM to be able to further reduce template size *and* the costs associated with expanding the wire format (currently a JSON structure) into a runnable program. Leveraging typed arrays would allow Ember and Glimmer apps to completely avoid the wire format to opcode compilation that currently happens before initial render. It also significantly reduces the resulting memory footprint for the same runnable program.

## DOM API Improvements

Although IE9 introduced JavaScript engine with support for much of ES5, it was not until IE10 that the browser began to support much of what developers consider modern web platform APIs. Littered throughout the Ember and Glimmer VM codebase are [many](https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L54) [examples](https://github.com/glimmerjs/glimmer-vm/blob/9ecc88504c81469ba20dba3ed3f37d373a998355/packages/%40glimmer/test-helpers/lib/helpers.ts#L170) [of](https://github.com/glimmerjs/glimmer-vm/blob/bfed16af6a5ecce4fbe9f27783245fe0f8b03480/build/broccoli/transpile-to-es5.js#L25) IE9 workarounds (and [PhantomJS workarounds](https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L49), in fact). We’ve worked hard to make these fixes free at runtime for modern browsers, but some cost is unavoidable.

PhantomJS in particular is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And "how to debug in Phantom" is an entire extra skill people are forced to learn. Testing your app in PhantomJS is generally a form of “testing theater”, since it fails to execute your code in a realistic environment.

## `requestAnimationFrame`

IE10 introduced support for `requestAnimationFrame`, an efficient way to schedule work in the browser environment. We’re interested in using this API to explore incremental rendering strategies, and as a way to improve Ember’s coordination with the browser when native promises are used in application code.

# Detailed Design

When using Ember applications in IE9, IE10, or PhantomJS, Ember will cause an appropriate deprecation to be issued. The deprecation will be “until 3.0” and will reference an entry in the deprecation guide. The guide entry will describe For example:

> Using Ember.js in IE9, IE10, or PhantomJS is deprecated and will be unsupported in Ember.js 3.0. We recommend using Ember’s 2.x LTS releases if your applications must support those browsers.
>
> PhantomJS is often used for continuous integration testing. We strongly suggest adopting headless Chrome or Firefox to run CI tests.

# Drawbacks

Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. There will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.

However, in many cases, the requirement for supporting these legacy browsers is driven by non-technical management who do not have a strong sense of the experience of using apps in IE9/IE10. In practice, many applications are not rigorously tested in older browsers, and the performance is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with legacy DOM and JavaScript engines.

Still, some people make it work, and dropping support may prevent those teams from staying with the community as it migrates to Ember 3.0.

As a mitigation for these concerns, the final release of Ember 2.x will itself be made an LTS release. This will ensure a 2.x platform supporting IE9+ with critical bugfix for roughly 8 months following the 3.0 release and security fixes for roughly 14 months after 3.0 release.

# Alternatives

## Bring Your Own Compatibility

Some libraries attempt to thread the needle of compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if these older browsers did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers.

We have spent considerable effort on first-class support in Ember 2.x, and we feel that users who require IE9 and IE10 support will have a better experience using Ember 2.x. (with the subset of the ecosystem that supports 2.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.


---

---
stage: recommended
start-date: 2017-11-05T00:00:00.000Z
release-date: 2018-02-13T00:00:00.000Z
release-versions:
  ember-source: v3.0.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/268
project-link:
---

# Summary

The testing story in Ember today is better than it ever has been. It is now
possible to test individual component/template combos, register your own mock
components/services/etc, build complex acceptance tests, and almost anything else
you would like.

Unfortunately, there is a massive disparity between different types of tests.
In acceptance tests, you use well designed global helpers to deal with async
related interactions; whereas in integration and unit tests you are forced to
manually deal with this asynchrony.
[emberjs/rfcs#232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md)
introduced us to QUnit's nested modules API, made integration and unit testing
modular, and greatly simplified the concepts needed to learn how to write unit
and integration tests. The goal of this RFC is to leverage what we have learned
in prior RFCs and apply that knowledge to acceptance testing. Once this RFC has
been implemented all test types in Ember will have a unified cohesive structure.

# Motivation

Usage of rendering tests is becoming more and more common, but these tests
often include manual event delegation (`this.$('.foo').click()` for
example), and assumes most (if not all) interactions are synchronous.  This is
a major issue due to the fact that the vast majority of interactions will
actually be asynchronous. There have been a few recent additions to
`@ember/test-helpers` that have made dealing with asynchrony better (namely
[emberjs/rfcs#232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md))
but forcing users to manually manage all interaction based async is a recipe
for disaster.

Acceptance tests allow users to handle asynchrony with ease, but they rely on
global helpers that automatically wrap a single global promise which makes
testing of interleaved asynchronous things more difficult. There are a number
of limitations in acceptance tests as compared to integration tests (cannot
mock and/or stub services, cannot look up services to setup test context, etc).

We need a single unified way to teach and understand testing in Ember that
leverages all the things we learned with the original acceptance testing
helpers that were introduced in Ember 1.0.0.  Instead of inventing our own
syntax for dealing with the async (`andThen`) we should use new language
features such as `async` / `await`.

# Detailed design

The goal of this RFC is to introduce new system for acceptance tests that follows in the footsteps of
[emberjs/rfcs#232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md)
and continues to enhance the system created in that RFC to share the same structure and helper system.

This new system for acceptance tests will be implemented in the
[@ember/test-helpers](https://github.com/emberjs/ember-test-helpers/) library so
that we can iterate faster while supporting multiple Ember versions
independently and easily support multiple testing frameworks build on top of
the primitives in `@ember/test-helpers`. Ultimately, the existing [ember-testing](https://github.com/emberjs/ember.js/tree/master/packages/ember-testing) system
will be deprecated but that deprecation will be added well after the new system has been
released and adopted by the community.

Lets take a look at a basic example (lifted from [the guides](https://guides.emberjs.com/v2.16.0/testing/acceptance/)):

```js
// **** before ****
import { test } from 'qunit';
import moduleForAcceptance from '../helpers/module-for-acceptance';

moduleForAcceptance('Acceptance | posts');

test('should add new post', function(assert) {
  visit('/posts/new');
  fillIn('input.title', 'My new post');
  click('button.submit');
  andThen(() => assert.equal(find('ul.posts li:first').text(), 'My new post'));
});

// **** after ****
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { visit, fillIn, click } from '@ember/test-helpers';

module('Acceptance | login', function(hooks) {
  setupApplicationTest(hooks);

  test('should add new post', async function(assert) {
    await visit('/posts/new');
    await fillIn('input.title', 'My new post');
    await click('button.submit');

    assert.equal(this.element.querySelectorAll('ul.posts li')[0].textContent, 'My new post');
  });
});
```

As you can see, this proposal unifies on Qunit's nested module syntax following
in emberjs/rfcs#232's footsteps.

## New APIs Proposed

The following new methods will be exposed from `ember-qunit`:

```ts
declare module 'ember-qunit' {
  // ...snip...
  export function setupApplicationTest(hooks: QUnitModuleHooks): void;
}
```

### DOM Interaction Helpers

New native DOM interaction helpers will be added to both `setupRenderingTest`
and (proposed below) `setupApplicationTest`. The implementation for these
helpers has been iterated on and is quite stable in the
[ember-native-dom-helpers](https://github.com/cibernox/ember-native-dom-helpers)
addon.

The helpers will be migrated to `@ember/test-helpers` and eventually
(once "the dust settles") `ember-native-dom-helpers` will be able to reexport
the versions from `@ember/test-helpers` directly (which means apps that have
already adopted will have very minimal changes to make).

The specific DOM helpers to be added to the `@ember/test-helpers` module are:

```ts
/**
  Clicks on the specified selector.
*/
export function click(selector: string | HTMLElement): Promise<void>;

/**
  Taps on the specified selector.
*/
export function tap(selector: string | HTMLElement): Promise<void>;

/**
  Triggers a keyboad event on the specified selector.
*/
export function triggerKeyEvent(
  selector: string | HTMLElement,
  eventType: 'keydown' | 'keypress' | 'keyup',
  keyCode: string,
  modifiers?: {
    ctrlKey: false,
    altKey: false,
    shiftKey: false,
    metaKey: false
  }
): Promise<void>;

/**
  Triggers an event on the specified selector.
*/
export function triggerEvent(
  selector: string | HTMLElement,
  eventType: string,
  eventOptions: any
): Promise<void>;

/**
  Fill in the specified selector's `value` property with the provided text.
*/
export function fillIn(selector: string | HTMLElement, text: string): Promise<void>;

/**
  Focus the specified selector.
*/
export function focus(selector: string | HTMLElement): Promise<void>;

/**
  Unfocus the specified selector.
*/
export function blur(selector: string | HTMLElement): Promise<void>;

/**
  Returns a promise which resolves when the provided callback returns a truthy value.
*/
export function waitUntil<T>(Function: Promise<T>, { timeout = 1000 }): Promise<T>;

/**
  Returns a promise which resolves when the provided selector (and count) becomes present.
*/
export function waitFor(selector: string, { count?: number, timeout = 1000 }): Promise<HTMLElement | HTMLElement[]>;
```

### `setupApplicationTest`

This function will:

* invoke `ember-test-helper`s `setupContext` with the tests context (which does the following):
  * create an owner object and set it on the test context (e.g. `this.owner`)
  * setup `this.pauseTest` and `this.resumeTest` methods to allow easy pausing/resuming
    of tests
* add routing related helpers
  * setup importable `visit` method to visit the given url
  * setup importable `currentRouteName` method which returns the current route name
  * setup importable `currentURL` method which returns the current URL
* add DOM interaction helpers (heavily influenced by @cibernox's lovely addon [ember-native-dom-helpers](https://github.com/cibernox/ember-native-dom-helpers))
  * setup a getter for `this.element` which returns the DOM element representing
    the applications root element
  * setup importable `click` helper method
  * setup importable `tap` helper method
  * setup importable `triggerKeyEvent` helper method
  * setup importable `triggerEvent` helper method
  * setup importable `fillIn` helper method
  * setup importable `focus` helper method
  * setup importable `blur` helper method
  * setup importable `waitUntil` helper method
  * setup importable `waitFor` helper method

### `setupRenderingTest`

The `setupRenderingTest` function proposed in
[emberjs/rfcs#232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md)
(and implemented in
[ember-qunit](https://github.com/emberjs/ember-qunit)@3.0.0) will be modified to add the same DOM interaction helpers mentioned above:

* setup importable `click` helper method
* setup importable `tap` helper method
* setup importable `triggerKeyEvent` helper method
* setup importable `triggerEvent` helper method
* setup importable `fillIn` helper method
* setup importable `focus` helper method
* setup importable `blur` helper method
* setup importable `waitUntil` helper method
* setup importable `waitFor` helper method

Once implemented, `setupRenderingTest` and `setupApplicationTest` will diverge from each other in very few ways.

## Changes from Current System

Here is a brief list of the more important but possibly understated changes
being proposed here:

* The global test helpers that exist now, will no longer be present (e.g.
  `click`, `visit`, etc) and instead will be available on the test context as
  well as importable helpers.
* `this.owner` will now be present and allow (for the first time 🎉) overriding
  items in the container/registry.
* The new system will leverage the `Ember.Application` /
  `Ember.ApplicationInstance` split so that we can avoid creating an
  `Ember.Application` instance per-test, and instead leverage the same system
  that FastBoot itself uses to avoid running initializers for each acceptance
  test.
* Implicit promise chaining will no longer be present. If your test needs to
  wait for a given promise, it should use `await` (which will wait for the
  system to "settle" in similar semantics to today's `wait()` helper).
* The test helpers that are included by a new default ember-cli app will be no
  longer needed and will be removed from the new application blueprint. This
  includes:
  * `tests/helpers/resolver.js`
  * `tests/helpers/start-app.js`
  * `tests/helpers/destroy-app.js`
  * `tests/helpers/module-for-acceptance.js`

## Examples

### Test Helper

Assuming the following input:

```js
import Ember from 'ember';

export function withFeature(app, featureName) {
  let featuresService = app.__container__.lookup('service:features');
  featuresService.enable(featureName);
}

Ember.Test.registerHelper('withFeature', withFeature);
```

In order for an addon to support both the existing acceptance testing system, and the new system it could replace that helper with the following:

```js
import { registerAsyncHelper } from '@ember/test';

export function enableFeature(owner, featureName) {
  let featuresService = owner.lookup('service:features');
  featuresService.enable(featureName);
}

registerAsyncHelper('withFeature', function(app, featureName) {
  enableFeature(app.__container__, featureName);
});
```

This allows both the prior API (without modification) and the following:

```js
// Option 2:
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { enableFeature } from 'addon-name-here/test-support';

module('asdf', function(hooks) {
  setupApplicationTest(hooks);

  test('awesome test title here', function(assert) {
    enableFeature(this.owner, 'feature-name-here');

    // ...snip...
  });
});
```

### Registering Factory Overrides

Overriding a factory is generally done to allow the test to have more control
over the thing being tested. This is sometimes used to prevent side effects
that are not related to the test (i.e. to prevent network calls), other times
it is used to allow the test to inject some known state to make asserting the
results much easier.

It is currently possible to register custom factories in integration and unit
tests, but not in acceptance tests (without using private API's that is).

As of [emberjs/rfcs#232](https://github.com/emberjs/rfcs/pull/232) the
integration/unit test API for this registration is:

```js
this.owner.register('service:stripe', MockService);
```

This RFC will allow this invocation syntax to work in all test types
(acceptance, integration, and unit).


## Migration

It is important that both the existing acceptance testing system, and the
newly proposed system can co-exist together. This means that new tests can be generated
in the new style while existing tests remain untouched.

However, it is likely that
[ember-qunit-codemod](https://github.com/rwjblue/ember-qunit-codemod) will be
able to accurately rewrite acceptance tests into the new format.

# How We Teach This

This change requires updates to the API documentation of `ember-qunit` and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.

# Drawbacks

* This is a relatively large set of changes that are arguably not needed (things mostly work today).
* One of the major hurdles in upgrading larger applications to newer Ember versions, is updating their tests to follow "new" patterns.  This RFC introduces yet another "new" thing (and proposes to deprecate the old thing), and could therefore be considered "just more churn".

# Alternatives

* Do nothing?
* Make `ember-native-dom-helpers` a default addon (removing the need for DOM interaction helpers proposed here).


---

---
stage: recommended
start-date: 2017-11-20T00:00:00.000Z
release-date: 2019-03-11T00:00:00.000Z
release-versions:
  ember-source: v3.11.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/272
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/12
---

# Deprecate Function.prototype.on, Function.prototype.observes and Function.prototype.property

## Summary

This RFC proposes to deprecate `Function.prototype.on`,
`Function.prototype.observes` and `Function.prototype.property`

## Motivation

Ember has been moving away from extending native prototypes due to the confusion
that this causes users: is it specifically part of Ember, or JavaScript?

Continuing in that direction, we should consider recommending the usage of
[`on` (`@ember/object/evented`)](https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject%2Fevented/methods/on?anchor=on), [`observer` (`@ember/object`)](https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/observer?anchor=observer) and [`computed` (`@ember/object`)](https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/computed?anchor=computed) as opposed to their native
prototype extension equivalents.
We go from two ways to do something, to one.

[`eslint-plugin-ember` already provides this as a rule](https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md).

## Transition Path

The replacement functionality already exists in the form of `on`, `observer`, and `computed`.

We don't need to build anything new specifically, however, the bulk of the transition will be
focused on deprecating the native prototype extensions.

A codemod for this deprecation has to take into consideration that while `foo: function() { /* custom logic */ }.property('bar')` is a `Function.prototype` extension, `foo: observer(function () { /* some custom logic */ }).on('customEvent')` is not.

## How We Teach This

On the deprecation guide, we can showcase the same example as above. We can explain why
the proposal was necessary, followed by a set of examples highlighting the deprecated
vs current style.

Borrowing from the [ESLint plugin example](https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md):

```js
import { computed, observer } from '@ember/object';
import { on } from '@ember/object/evented';

export default Component.extend({
  // deprecated
  abc: function() { /* custom logic */ }.property('xyz'),
  def: function() { /* custom logic */ }.observe('xyz'),
  ghi: function() { /* custom logic */ }.on('didInsertElement'),
  jkl: function() { /* custom logic */ }.on('customEvent'),

  // current
  abc: computed('xyz', function() { /* custom logic */ }),
  def: observer('xyz', function() { /* custom logic */ }),
  didInsertElement() { /* custom logic */ }),
  jkl: on('customEvent', function() { /* custom logic */ }),
});
```

The official Guides currently [discourage the use of `Function.prototype` extensions](https://guides.emberjs.com/v2.17.0/configuring-ember/disabling-prototype-extensions/):

> Function is extended with methods to annotate functions as computed properties,
> via the property() method, and as observers, via the observes() method. Use of
> these methods is now discouraged and not covered in recent versions of the Guides.

After the deprecated code is removed from Ember, we need to remove the section
about `Function` prototypes altogether.

## Alternatives

None.


---

---
stage: recommended
start-date: 2017-12-10T00:00:00.000Z
release-date: 2018-04-10T00:00:00.000Z
release-versions:
  ember-source: v3.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/276
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/15968
---

# Summary

Introduce `{{@foo}}` in as a dedicated syntax for a component's template to
refer to named arguments passed in by the caller.

For example, given the invocation `{{hello-world name="Godfrey"}}` and this
component template in `app/templates/components/hello-world.hbs`:

```hbs
Hello, {{@name}}
```

Ember will render "Hello, Godfrey".

# Motivation

Currently, the way to access named arguments passed in from the caller is to
reference `{{name}}` in the template. This works because when Ember creates
the component instance, it automatically [assigns](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
all named arguments as properties on the component instance.

The first problem with this approach is that the `{{name}}` syntax is highly
ambigious, as it could be referring to a local variable (block param), a
helper or a named argument from the caller (which actually works by accessing
auto-reflected `{{this.name}}`) or a property on the component class (such as
a computed property).

This can often lead to confusion for readers of the template. Upon encountering
`{{foo}}` in a component's template, the reader has to check all of
these places: first you need to scan the surrounding lines for block
params with that name; next you check in the helpers folder to see if there
is a helper with that name (it could also be coming from an addon!); then you
check if it is an argument provided by the caller; finally, you check the
component's JavaScript class to look for a (computed) property. If you _still_
did not find it, maybe it is a named arguments that is passed only sometimes,
or perhaps it is just a leftover reference from a previous refactor?

Providing a dedicated syntax for referring to named arguments will resolve the
ambiguity and greatly improve clarity, especially in big projects with a lot
of files (and uses a lot of addons). (The existing `{{this.name}}` syntax can
already be used to disambiguate component properties from helpers.)

As an aside, the ambiguity that causes confusion for human readers is also a
problem for the compiler. While it is not the main goal of this proposal,
resolving this ambiguity also helps the rendering system. Currently, the
"runtime" template compiler has to perform a helper lookup for every `{{name}}`
in each template. It will be able to skip this resolution process and perform
other optimizations (such as reusing the internal [reference](https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md)
object and caches) with this addition.

Another problem with the current approach of automatically "reflecting" named
arguments on the instance is that they can unexpectedly overwrite other
properties defined on the component's class. It also defeats performance
optimizations in JavaScript engines as this approach creates many different
polymorphic "shapes" for instances that otherwise belong to the same
component class.

While this proposal does not directly solve this problem (we are not proposing
that we deprecate or remove the "auto-reflection" on `Ember.Component`), it
paves the way for a future world where components can work without them.

Notably, the current iteration of the [Glimmer Components](https://glimmerjs.com/guides/templates-and-helpers)
have adopted this design for over a year now and the experience has been very
positive. This would be one of the first pieces (admittedly, only a tiny piece)
of the Glimmer.js experiment to make its way into Ember. We think this feature
is small, self-contained but useful enough to be the ideal candidate to kick
off this process.

# Detailed design

This feature was baked into the Glimmer VM very early on. In fact, the
only thing that is stopping them from working in Ember is [an AST transform](https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/assert-reserved-named-arguments.js)
that specifically disallows them. Therefore, "implementing" this feature is
just a matter of deleting that file.

Additionally, the legacy `{{attrs.foo}}` syntax (which more or less tries to
accomplish the same thing) has actually been [implemented using `{{@foo}}`](https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/transform-attrs-into-args.js)
under-the-hood since Ember 2.10.

## Reserved Names

We will reserve `{{@args}}`, `{{@arguments}}` and anything that does not
start with a lowercase letter (such as `@Foo`, `@0`, `@!` etc) in the first
version. This is purely speculative and the goal is to carve out some space
for future features. If we don't end up needing them, we can always relax
the restrictions down the road.

# How We Teach This

`{{@foo}}` is the way to access the named arguments passed from the caller.

Since the `{{foo}}` syntax still works on `Ember.Component` (which is the
only kind of components available today) via the auto-reflection mechanism,
we are not really in a rush to migrate the community (and the guides, etc)
to using the new syntax. In the meantime, this could be viewed as a tool to
improve clarity in templates, similar to how the optional "explicit `this`"
syntax (`{{this.foo}}`).

While we think writing `{{@foo}}` would be a best practice for new code
going forward, the community can migrate at its own pace one component at a
time.

We can also encourage the community to supplement this effort by wiring
linting tools and code mods.

# Drawbacks

This introduces a new piece of syntax that one would need to learn in order to
understand Ember templates.

This mostly affects "casual" readers (as this should be very easy for an Ember
developer to learn, understand and remember after encounting/learning it for
the first time). However, since these casual readers are also among those
who are most acutely affected by the ambiguity, we believe this is still a
net improvement over the status-quo.

# Alternatives

We have `{{attrs.foo}}` today. In React, there is `this.props.foo`.

Given how common this is, we think it deserves its own dedicated, succinct
syntax. The other alternatives that involve reflecting them on the component
instances also would not allow for the internal optimizations in the Glimmer
VM.


---

---
stage: recommended
start-date: 2017-12-11T00:00:00.000Z
release-date: 2018-04-10T00:00:00.000Z
release-versions:
  ember-source: v3.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/278
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/15974
---

# Summary

Introduce a low-level "flag" to remove the automatic wrapper `<div>` for
template-only components (templates in the `components` folder that do not
have a corresponding `.js` file).

In other words, given there is NO `app/components/hello-world.js` and there
exists `app/templates/components/hello-world.hbs` which contains the
following markup:

```hbs
Hello world!
```

When this template-only component is invoked as `{{hello-world}}` with the
flag unset or disabled (i.e. today's semantics), Ember will render:

```html
<div id="ember123" class="ember-view">Hello world!</div>
```

When the flag is enabled, the same invocation will render:

```html
Hello world!
```

# Motivation

With today's component system (i.e. `Ember.Component`), a wrapper element (a
`div` by default, along with an ID like `ember123` and the `ember-view` class)
is automatically added for every component.

Customizing this wrapper element (such as changing the tag name – or removing
it altogether) requires making changes to the component's JavaScript class,
such as:

```js
import Component from "@ember/component";

export Component.extend({
  tagName: "footer",
  classNames: ["legalese"]
});
```

While we acknowledge this API is quite cumbersome, it is sufficient to "get
things done" for regular components, and Glimmer Components will address
the usability aspect once they land.

However, this API does not work for template-only components, as they do
not have a component JavaScript class by definition. Therefore, in practice,
template-only components always come with a `<div>` wrapper, along with the
default `id` and `class` attributes, with no obvious ways to customize it.

This is quite problematic, as it is often desirable to use a template-only
component to organize content that requires a certain markup structure. The
most common workaround for this problem is to use a partial instead, which
comes with [a host of issues](https://github.com/emberjs/rfcs/pull/262). I
will discuss other workarounds in the section below.

This RFC proposes to add a global flag to remove this wrapper element around
template-only components. This will allow the component author to specify the
wrapper element in the component template, offering direct control over the
tag name and other attributes. It would also allow the component to have more
than one top-level element, or none at all.

In other words, this flag changes template-only components in the app to have
"Outer HTML" semantics. _What you type is what you get._

Notably, [Glimmer Components](https://glimmerjs.com/guides/templates-and-helpers)
have adopted the "Outer HTML" semantics long ago and the experience has been
very positive. This would be one of the first pieces of the Glimmer.js experiment
to make its way into Ember. We think this feature is small, self-contained but
useful enough to be integrated back into Ember at this point.

If accepted, this RFC will fully subsume the [Non-context-shifting partials](https://github.com/emberjs/rfcs/pull/262)
RFC. We can therefore (at a later time, in a separate RFC) explore deprecating
partials in favor of wrapper-free template-only components.

# Detailed design

## API Surface

We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a "privileged addon" whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the _addon_ that provides this functionality. The
flag is simply an internal implementation detail.

We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.

When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that _disables_ the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is *not set*, with
a message that directs the user to install one of the two addons.

## Single Global "Flag"

The proposed flag will be truly global in scope. That is, setting this flag
will change the semantics of all template-only components in the entire app,
even for components that were included by addons.

However, we believe this would not affect any addon components in practice,
as the predominant pattern for addons to expose components currently
necessitates a JavaScript class. Addon authors would create the component
(with or without a JavaScript class) in the `/addon` folder, but exposing
it for consumption in apps requires creating a corresponding JavaScript class
in the `/app` folder to "re-export" the component. Therefore, in practice,
it is not actually possible for addons to have a truly template-only
component today (something to address in a future RFC).

## Leakage Of `Ember.Component` Semantics

While the primary purpose of this flag is to remove the wrapper element from
template-only components, there are a few other observable semantics changes
that comes with it as well.

Currently, template-only components are "backed" by an instance of `Ember.Component`.
That is, Ember will create an instance of `Ember.Component` and set it as the
`{{this}}` context for the template.

With the flag enabled, there will be *no* component instance for the template
and `{{this}}` will be set to `undefined` (or `null`, perhaps). This would
improve performance for template-only components significantly.

Since there is no JavaScript file for the component, this is only observable
in a few limited ways:

1. The most noticable artifact is the component's arguments will not be
   auto-reflected on the component instance (as there is no component
   instance at all). Therefore, the only way to access the component's
   arguments is to use the `{{@foo}}` syntax proposed in [RFC #276](https://github.com/emberjs/rfcs/pull/276).

2. Because of the named arguments auto-reflection, it is actually possible
   to configure the `tagName` and classes on the "hidden" component
   instance on the invocation (e.g. `{{foo-bar tagName="footer" class="legalese"}}`).
   This will obviously stop working, but it is also not necessary anymore
   as the component author can simply include the tag in the template.
   Alternatively, the component author can choose to leave out the tag
   and let the caller wrap it in their template.

3. It is possible (but very rare) to configure global injections on the
   component type. Since no component is being instantiated here, those
   properties will not be accessible in the template.

   More broadly, `{{this.foo}}` or the shorthand `{{foo}}` (where it
   would have resolved into a `this` lookup) will always be `undefined`
   (or `null`, perhaps).

## Migration Path

Given the subtle semantics differences enumerated above, it is
not necessarily safe to simply turn on the flag in bigger applications
as it is quite likely that some of the template-only components might be
relying on one or more of these features. Further, removing the wrapper
element might break the layout.

Therefore, the only safe, mechanical transformation is to generate a
JavaScript file for each template-only component (turning them into non-
template only components). We should supplement the change by providing
a codemod that does this for you.

While this would mean that apps would not be able to immediately take
advantage of the feature, it will open the door for new template-only
components to be written in the new semantics.

The user can also audit the components we identified and decide to
delete the JavaScript and migrate them on a case-by-case basis.

The codemod can also come with a more aggressive (and unsound) mode that
simply wraps each template in a `<div>` (to avoid breaking layout in most
cases). This might be acceptable for smaller apps.

For what it's worth, the Ember CLI component blueprint always generate a
JavaScript and a template file, so it might not be that common to find
existing template-only components in an average app.

## Implementation Plan

Finally, for the actual implementation, this would be implemented using
the internal Component Manager API that has already been available for a long
time (and how Curly Components, outlets etc are implemented internally).

It should be very straightforward implementation – essentially just a
Component Manager that requires no capabilities and returns `null` in
`getSelf`.

# How We Teach This

Going forward, the "Outer HTML" semantics will be the default for
template-only components, Glimmer Components and other custom component
types (when the Component Manager API is available), so over time it
should feel quite natural. The experience from the Glimmer experiment
has also proven that this is the more natural programming model for
components.

In the mean time, we still have to deal with the consequence that
existing `Ember.Component` comes with a wrapper element by default. The
mental model for users to understand this is that the `Ember.Component`
class is what is giving you the wrapper element (therefore, template-only
components, which is not an `Ember.Component` does not get one of those).

This should feel quite natual, as the component class is where you
configure the wrapper element (and where you would lookup the API
documentation). You could imagine that the `Ember.Component` is doing
something like this under-the-hood as a convenience feature (which turned
out to be not very convenient after all, but that's a different story):

```js
export const Component = Object.extend({
  tagName: "div",
  classNames: ["ember-view"],

  // This is not real code that exists in the implementation
  render(buffer, template) {
    buffer.append(`<${this.tagName} class="${this.classNames.join(' ')}">`);
    buffer.append(template(this));
    buffer.append(`</${this.tagName}>`);
  }
});
```

# Drawbacks

In general, we avoid flags that puts Ember into very different "modes" as
they causes complication across the whole addon ecosystem. However, as
mentioned above, we don't believe this would be the case here.

# Alternatives

We could keep the current semantics for template-only components. However,
this is usually undesirable, and would only grow to feel more unnatural
as Glimmer Components and friends adopt the "Outer HTML" semantics.

Alternatively, we can make this opt-in per template using a pragma or magic
comment. However, this would be needed for a lot of templates and become
very noisy, and the alternative strategy proposed here (by keeping around
the `Ember.Component` JavaScript file as needed) would be able to accomplish
the same goal with less noise.


---

---
stage: recommended
start-date: 2017-12-11T00:00:00.000Z
release-date: 2018-04-10T00:00:00.000Z
release-versions:
  ember-source: v3.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/280
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/15981
---

# Summary

Introduce a low-level "flag" to remove the automatic wrapper `<div>` around
Ember apps and tests.

# Motivation

In Ember applications today, applications are anchored to some existing HTML
element in the page. Usually, this element is the `<body>` of the document, but it
can be configured to be a different one when the application is defined,
passing a CSS selector to the `rootElement` property:

```js
export default Ember.Application.extend({
  rootElement: '#app'
});
```

However, whatever the root is, the application adds another `<div>` wrapper
that is not required anymore. It's a vestigial remainder of some implementation
detail of how views worked in Ember 1.x. Some sort of wisdom tooth of the original
rendering system that serves no purpose today.

Furthermore, much like a wisdom tooth, it can give us problems. In the past, this element
was configurable using the `ApplicationView`, but when views were removed we lost that
ability. Right now we are stuck with a wrapper element we can't remove nor customize,
which is why some apps target the selector `body > .ember-view` to style this element.

Similarly, in testing there is another `.ember-view` wrapper inside the
`#ember-testing` container for no good reason.

This RFC proposes to add a global flag to remove those wrapper elements,
effectively making the `application.hbs` template have "Outer HTML" semantics, which aligns
well with [the changes recently proposed](https://github.com/emberjs/rfcs/pull/278)
for template-only components, as well as the way Glimmer apps work.

The same flag will also remove the unnecessary extra wrapper inside the testing
container.

# Detailed design

## API Surface

The proposed approach is identical to the one proposed in #278, quoted below:

> We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a "privileged addon" whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the addon that provides this functionality. The
flag is simply an internal implementation detail.

> We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.

> When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that _disables_ the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is *not set*, with
a message that directs the user to install one of the two addons.

## Migration Path

Given that this change only affects one single point in your application,
I do not believe we need any specific strategy. If the users want to bring
back the wrapper because it breaks their styles or some other reason,
they can just add it manually on the `application.hbs` template, with
any class or id they want.

# How We Teach This

This addon will be opt-in, but at some point it will become part of
the default blueprint. This change, rather than introducing a new concept, *removes*
an old one. Users won't have to google what is the way to remove or customize
the implicit application wrapper of the app (to sadly discover that is not
even possible), but instead they will add a wrapper only if they want,
and in the same way they would add a wrapper in any other point of their application,
with regular Handlebars.

# Drawbacks

There is a possibility that removing the wrapper can break styles for some apps,
but since adding the wrapper back is just editing the `application.hbs` template,
that is probably a minor drawback.

There is also a non-zero chance that some testing addon is relying on the `#ember-testing > .ember-view`
HTML hierarchy for some reason, and those addons would have to be updated.

# Alternatives

Leave things as they are today.


---

---
stage: recommended
start-date: 2017-12-12T00:00:00.000Z
release-date: 2018-04-10T00:00:00.000Z
release-versions:
  ember-source: v3.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/281
project-link:
---

# Summary

Install ES5 getters for computed properties on object prototypes, thus
eliminating the need to use `this.get()` or `Ember.get()` to access them.

Before:

```js
import Object, { computed } from '@ember/object';

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.get('firstName')} ${this.get('lastName')}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.get('fullName'); // => 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.get('fullName'); // => 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode.getProperties('firstName', 'lastName', 'fullName');
```

After:

```js
import Object, { computed } from "@ember/object";

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.fullName; // => 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.fullName; // => 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode; // No problem!
```

# Motivation

Ember inherited its computed properties functionality from [SproutCore](http://guides.sproutcore.com/core_concepts_kvo.html).
The feature was designed at a time before [ES5 getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)
were widely available. This necessitated using a special function such as
`this.get()` or `Ember.get()` to access the values of computed properties.

Since all of our [target browsers](https://github.com/emberjs/rfcs/pull/252)
support ES5 getters now, we can drop the need of this special function,
improving developer ergonomics and interoperability between other libraries
and tooling (such as TypeScript).

Note that at present, using `this.set()` or `Ember.set()` is still mandatory
for the property to recompute properly. In the future, we might be able to
loosen this requirement, perhaps with the help of ES5 setters. However, that
would require more design and is out-of-scope for this RFC.

`this.get()` and `Ember.get()` will still work. This RFC does not propose
removing or deprecating them in the near term. They support other use cases
that ES5 getters do not, such as "safe" path chaining (`get('foo.bar.baz')`)
and `unknownProperty` (and Proxies by extension), so any future plans to
deprecate them would have to take these features into account.

Addon authors would likely need to continue using `Ember.get()` for at least
another two LTS cycles (8 releases) to support older versions of Ember (and
possibly longer to support proxies). It is, however, very unlikely that the
everyday user would need to use this.

# Detailed design

The computed property function, along with any caches, can be stored in the
object's "meta". We will then define a getter on the object's prototype to
compute the value.

One caveat is that the computed property function is currently stored on the
instances for implementation reasons that are no longer relevant. However,
it is possible that some developers have observed their existance and have
accidentally relied on these private semantics (e.g. `chancancode.fullName.get()`
or `chancancode.fullName.isDescriptor`).

Before landing this change, we should turn the property into an assertion
so that in these unlikely scenarios, developers will at least receive
some warning.

Another thing to consider is that there is this Little Known Trick™ to add
Computed Properties to POJOs:

```js
import { computed, get } from "@ember/object";

let foo = {
  bar: computed(function() { return 'bar'; })
};

get(foo, 'bar'); // => 'bar'
```

In this case, there is no opportunity for us to install an ES5 getter, and
`Ember.get` is the only solution. This is very rare in practice and is more
or less just a party trick. We should deprecate this use case (in `Ember.get`)
and suggest the alternative:

```js
import Object, { computed } from "@ember/object";

let foo = Object.extend({
  bar: computed(function() { return 'bar'; })
}).create();

foo.bar; // => 'bar'
```

Or simply...

```js
let foo = {
  get bar() {
    return 'bar';
  }
};

foo.bar; // => 'bar'
```

# How We Teach This

For the most part, this RFC _removes_ a thing that we need to teach new
users.

It might, however, come across as slightly strange that `set()` is still
required. However, many other libraries share the same model, and
empricially, this does not appear to be an issue. For example, in React,
you can freely access `this.state.foo` but must use `this.setState('foo', ...)`
to update it. Even Vue has [the same API](https://vuejs.org/v2/api/#Vue-set)
for some cases.

The mental model for this is that you must use the `set()` in order for
Ember to notice your mutations, so that it can update the caches, rerender
things on the screen, etc.

As for users who already learned to use `get()` everywhere, that would
continue to work. Ideally, this would be a Cool Trick™ they pick up some day
(as in "Oh, I don't have to do _that_ anymore? Cool."), at which point the
old habit would quickly die. If this turned out to be too confusing, we
could always explore deprecating `this.get()`; we will just have to weigh
the cost-benefits of the confusion (if any) versus churn.

# Drawbacks

As mentioned, not removing `set()` at the same time might be a source of
confusion. However, removing `set()` would require significantly more
upfront design work, and it [might not even be possible](https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats)
to completely remove the need of `set()` (as the system is designed today)
in all cases (see `Vue.set()`).

Since removing `get()` would unlock so many benefits, and since there are
plenty of other libraries that uses the same model, the case for decoupling
the two seems overwhemlingly positive.

# Alternatives

* Hold off until we also remove `set`
* Hold off until we transition to something like [Glimmer's `@tracked`](https://glimmerjs.com/guides/tracked-properties)

In my opinion, these alternatives do not make a lot of sense, as neither
of these hypothetical systems appear to require (or would benefit from)
having a user-land getter system.


---

---
stage: recommended
start-date: 2017-12-21T00:00:00.000Z
release-date: 2018-05-31T00:00:00.000Z
release-versions:
  ember-source: v3.2.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/286
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/16076
---

# Block `let` template helper

## Summary

Introduce the `let` template helper in block form.

## Motivation

The goal of this RFC is to introduce a `let` template helper that allows to create new bindings in templates.
The design of this helper is similar to `with`,
but without the conditional rendering of the block depending on the values passed into the helper.

While the conditional semantics of `with` are coherent with the other built-in helpers like `each` and `if`,
users often find this unexpected.
The fact that only the first positional parameter of `with` controls whether the block is rendered might also add to the confusion.

Taking an example from [RFC #200](https://github.com/emberjs/rfcs/pull/200),
let's consider we have the following template:

```handlebars
Welcome back {{concat (capitalize person.firstName) ' ' (capitalize person.lastName)}}

Account Details:
First Name: {{capitalize person.firstName}}
Last Name: {{capitalize person.lastName}}
```

Because you have to know to capitalize every time you want to display a name,
errors might be introduced if we forget to do it when adding the name somewhere else in the template.
Using the `let` helper, this could be done like so:

```handlebars
{{#let (capitalize person.firstName) (capitalize person.lastName)
  as |firstName lastName|
}}
  Welcome back {{concat firstName ' ' lastName}}

  Account Details:
  First Name: {{firstName}}
  Last Name: {{lastName}}
{{/let}}
```

Now you can use `firstName` and `lastName` inside the `let` block with the knowledge that that logic is in a single place.

With the introduction of template-only components in [RFC #278](https://github.com/emberjs/rfcs/pull/278),
having the capability to create additional bindings in the template would prove useful.
Another aspect to consider is related to the [Named Blocks RFC](https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md).
In both the case of named blocks and block let, you can achieve most of the same functionality by using components.
The components approach has its own drawbacks, which are explored in Alternatives below.

## Detailed design

The `let` helper should be implemented as a built-in helper, with the following semantics:

* **Only** the block form is available
* The block is always rendered
* It should support however many positional arguments are passed to the helper
* Positional arguments passed to the helper should be yielded back out in the same order
* Inline form issues an error, linking users to documentation

There already exists [an implementation in the codebase](https://github.com/emberjs/ember.js/blob/9536e137b9e1a39411b7fd4e8ca0e7fbb341ef17/packages/ember-glimmer/tests/integration/syntax/experimental-syntax-test.js#L6-L37) that can be used as a basis.

## How We Teach This

The introduction of the `let` helper brings no new concepts.
It touches on the concepts of block helpers, how to pass arguments to them,
and how to use block parameters (`as |foo|`), which should already be introduced in the literature.

Current Ember developers should find it familiar to use `let`, as it is very similar to `with`.

JavaScript developers should also be familiar with `let` bindings,
as recent specifications of the language introduced that keyword.

The Guides already possess a section dedicated to Templates, with multiple mentions of helpers.
`let` would likely be documented in the [Built-in Helpers](https://guides.emberjs.com/v2.17.0/templates/built-in-helpers/) guide alongside the others.

If this RFC is approved, the `let` will initially only support the block form.
This means that only the following form is available for users:

```handlebars
{{#let 1 2 3 as |one two three|}}
  A, B, C, easy as {{one}}, {{two}}, {{three}}
{{/let}}
```

This could also be enforced by issuing a helpful error when `let` is used in the inline form.

## Drawbacks

As is the case when adding any sort of API, we will be increasing the cognitive load of learners and users,
as it is one more piece of information to obtain and retain.

The cost of learning this API is mitigated by the fact that its effects are very localized.
It is a template helper, so it will only affect templates.
It is not required for general usage of Ember, unlike something like `link-to`,
so you can learn the helper at your own pace.

And lastly, if you do use it or encounter it in code, only the markup inside the `{{#let}}{{/let}}` block is affected,
making it easier to reason about.

## Alternatives

### Inline form

At the moment, the only way to introduce a new binding in a template is through block params.
For example, if you are iterating over an array with `each`, you
introduce a binding named `item` for the item currently being iterated:

```handlebars
{{#each myArray as |item|}}
  I am item {{item}}.
{{/each}}
```

The inline form of `let` would be an additional way of introducing bindings in templates.
Using the names example from the RFC, it would look like the following in inline form:

```handlebars
{{let
  firstName=(capitalize person.firstName)
  lastName=(capitalize person.lastName)
}}

Welcome back {{concat firstName ' ' lastName}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
```

This syntax raises questions about the semantics of the inline form,
such as what is the scope of the binding, that are better left to a subsequent RFC.

### Using components

In a similar situation to [Named Blocks RFC](https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md),
it is also possible to replicate some of the behavior of the proposed `let` helper using components.
However, using components also presents some drawbacks.

You can extract the template and do:

```handlebars
// app/templates/components/person-tile.hbs
Welcome back {{concat firstName ' ' lastName)}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
```

```handlebars
{{person-tile firstName=(capitalize person.firstName) lastName=(capitalize person.lastName)}}
```

This addresses not having to repeat `capitalize` wherever the names are used,
but splits the content into multiple files for the sake of it.
While [module unification](https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md) mitigates the locality problem by putting related files in the same folder,
there is still the overhead of having to consult multiple files.

You can instead use a block version of the component as a wrapper to the content.
Some variations are possible: you can pass data into the component as either positional or named arguments;
you can export either an object with the arguments as keys, or export multiple block parameters.

Passing positional arguments to components is onerous,
and necessitates having a JavaScript file to define which positional arguments it accepts.

Passing named arguments to components would be the closest to `let`,
but it would still require a componente template file which would yield them as block parameters.

Yielding out the values is where it gets tricky in components,
regardless of returning a hash or multiple block parameters,
due to the lack of a "splat" operator in Handlebars.

Since you cannot do something like this at the moment:

```handlebars
// app/templates/components/person-tile.hbs
{{yield ...arguments}}
```

You would have to explicitly encode all of the arguments:

```handlebars
// app/templates/components/person-tile.hbs
{{yield firstName lastName}}
```

Or

```handlebars
// app/templates/components/person-tile.hbs
{{yield args=(hash firstName=firstName lastName=lastName)}}
```

Leading to some repetition of names.

This makes the solution of using components brittle to changes,
as typos or ordering mistakes can introduce silent errors in your application.

### Adding named arguments to `with`

[RFC #202](https://github.com/emberjs/rfcs/pull/202) proposes to add named arguments to `with`.

I feel it is less practical to add a new mode to the helper where it always renders,
when its semantics are already confusing to users.
The RFC #202 proposal also presents the problem of bringing back context-switching helpers,
as it proposes omitting block arguments (`as |bar|` in `{{#with foo as |bar|}}`).

### Remove the conditional behavior of `with`

Making the `with` helper unconditionally render the block would be a major breaking change of its semantics,
and would likely affect existing applications in insidious ways.
For this reason, I reject this alternative out of the gate.

### Support `let` via the `ember-let` addon

There is an [`ember-let`](https://github.com/thefrontside/ember-let) addon which implements both the block and the inline forms of `let`.
To implement the necessary functionality, the addon had to resort to private API usage, which is brittle and subject to breakage.

Having `let` available from Ember itself would make sure that it would not be subject to breakage the same way,
and the end user would not have to worry about version compatibility.

## Unresolved questions

None.

## Future work

### Deprecating `with`

With the introduction of the `let` helper, `with` should likely be deprecated.

### `if-let`, `let*` and others

RFC #200 also proposes the `if-let` and `let*` helpers.

`if-let` mimics the behaviour of `with`,
enabling the user to introduce bindings and conditionally rendering the block.
The advantage of introducing `if-let` over using `with` would be to define its semantics without worrying about making breaking changes to `with`.

`let*` would allow bindings to happen sequentially, that is,
`let` (`{{let* a=1 b=(sum a 5)}}` would be valid instead of throwing an error about `a` in `(sum a 5)`.

These could also be addressed in subsequent RFCs, focused on the specificities of each proposal.


---

---
stage: recommended
start-date: 2017-12-22T00:00:00.000Z
release-date: 2020-07-13T00:00:00.000Z
release-versions:
  ember-source: v3.20.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/287
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/25
---

# Summary

Promote the private API `{{-in-element}}` to public API as `{{in-element}}`.

# Motivation

Sometimes developers need to render content out of the regular HTML flow. This concept is often also
called "portals". Some components like dropdowns and modals use this technique to render stuff close
to the root of the page to bypass CSS overflow rules. Some apps that are embedded into static pages
even use this technique to update parts of the page **outside** the app itself.

This need need has been covered by solutions developed in the user space but it was so common that
glimmer baked it into the VM in the form of `{{-in-element}}`, but it remains private (or _intimate_) API.
People is usually wary of using private APIs (and for good reason) as they may get removed at any time.

If the core team and the community is happy with the current behavior of `{{-in-element}}` it's
time to make it public.

# Detailed design

The existing API of `{{-in-element}}` is very simple:

* It takes a single positional param `destinationElement` that is a DOM element, and a block.
* The given block is rendered not where it is located, but inside the given `destination` element, at
the end of it if there is any other content on the destination element.
* If `destinationElement` is null/undefined then it doesn't render anything but it doesn't error.
* If `destinationElement` is false/0/"" it raises an assertion in development but fails silently in production.
* If `destinationElement` changes the block is removed from the previous destination and added to the new one. This
process tears down the rendered content on the initial destination and renders it again on the new one, meaning
that any component withing the block will be destroyed and instantiated again (calling the appropiate lifecycle hooks),
so transient HTML state like the value of an input will be lost unless manually preserved somewhere else, like a service.
* If the destination element is an invalid value (a string, a number ...) it throws an `parent.insertBefore is not a function` error. I think
that throwing an error is correct but the error message could be improved.
* If the destination element has a different context (like SVG) the content will be appended normally by the glimmer VM,
which doesn't try to validate the correctness of the generated HTML. This is normal behavior in Glimmer, not
an exception, and users must be aware that rendering invalid markup might be interpreted or auto-corrected in
unexpected ways by the browser when in SSR mode.
* Rendering into a foreign object (an element within an `<iframe>`) should be disallowed initially. If someone
asks for this feature it would require an RFC to explore the consequences.

Example usage:

```hbs
{{#-in-element destinationElement}}
  <div>Some content</div>
{{/-in-element}}
```

The current implementation only suggests creating a new `{{in-element}}` construct that is a simple
alias of `{{-in-element}}` with the exact same params and behavior, and then, after a while, remove
the private one.

Although `{{-in-element}}` is technically private, there there is enough people using it to deserve
a deprecation. I suggest keeping the deprecated private API will until the first LTS release of the
3.X cycle (3.4) to be finally removed in the next one (3.5).

### Small proposed changes

There is however one part of the behavior that the core team wants to make explicit before promoting
the private API to public, and that is how the content is added to the destination when there is other
content already there.

The desired behavior is that, by default, the rendered content will **replace all the content of the destination**,
effectively becoming the its `innerHTML`.
In the current behaviour the rendered content is appended as the end of any existing content. This will still
be supported by passing `insertBefore=null`, but it will not be the default anymore.
Any other value passed to `insertBefore` must produce an error.


# How We Teach This

This will be a new build-in helper and must be added to the guides and the API.
For most usages, it will replace some community solution created with the same goal, like
[ember-wormhole](https://github.com/yapplabs/ember-wormhole) or [ember-elsewhere](https://github.com/ef4/ember-elsewhere).
It would be for the best to let the authors of those addons know about this feature so they can
deprecate their packages if they feel there is no longer a need for them, or at least update their
Readme files to let their users know that there is a built-in solution in Ember that might cover
their needs.

# Drawbacks

By augmenting the public API of the framework, the framework is committing to support it for the lifespan
of an entire mayor version (Ember 4.0).

# Alternatives

We can decide that the framework does not want to make public and support this feature, and continue
to rely on community-built addons like we've done until today.

# Unresolved questions

Do we want to make any improvement to `{{-in-element}}` before making it public API?

Some possible ideas:
- Allow to _conditionally_ render the block in place. See https://github.com/DockYard/ember-maybe-in-element
- Allow to receive not only DOM elements as first argument, but also strings, representing the ID of
  other CSS selector.
- Modify or improve the way it behaves during SSR using ember-fastboot.


---

---
stage: released # FIXME: This may be Recommended
start-date: 2018-01-10T00:00:00.000Z
release-date: 2018-10-12T00:00:00.000Z
release-versions:
  ember-data: v3.5.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/293
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/24
---

### Summary

Currently, incrementally experimenting with Ember Data internals is hard both for addon authors
and Ember Data contributors. This RFC rationalizes the internals and establishes clear boundaries
for record data storage and manipulation allowing us to expose a public api for addon authors to experiment with.

### Motivation

Externally, addons can customize how apps communicate with the server by implementing the Adapter/Serializer APIs but changing how ED deals with relationships, attribute buckets, rollbacks, dirtyness
and similar issues is extremely challenging and impossible without extremely internal hacks. One can look at popular addons like EmberDataModelFragments
and see how many private APIs they had to override and hack to implement their funcionality.

Internally, while ED is reasonably well factored between data coming into the system through
Adapter/Serializers/IdentityMap/Store and data going out through DS.Model/Snapshots/Adapters/Serializers
, internal handling of the data including relationships and attributes has extremely fuzzy and unclear boundaries.

Data currently lives in internalModels, relationship state objects, computed property caches, relationship
payload caches, etc.

#### before
 ![image](https://user-images.githubusercontent.com/715175/33340994-6380c66a-d432-11e7-9f00-ed905e78915a.png)

This RFC proposes rationalizing and extracting ED's core record data handling layer into a RecordData class.

#### after
![image](https://user-images.githubusercontent.com/715175/33341155-e5f170c2-d432-11e7-9c50-4a3e977331fe.png)

This will allow us to rationalize internal ED APIs, establish clearer internal boundaries,
allow experimentation by addon authors, and create a path for internal ED experimentation.

You can think of Record Data as a layer that can receive JSON api payloads for a record,
apply local changes to it, and can be queried for the current state of the data.

Examples of things this would enable:

1) By shipping a custom RecordData, EmberDataModelFragments can implement a large part of their
funcionality without relying on private apis. Spike at [model fragments](https://github.com/igorT/ember-data.model-fragments/tree/igor/model-data)

2) A spike of Ember Data backed by Orbit, can be implemented as an addon, where most of the work
is in implementing a Record Data backed by Orbit. Spike at [data-orbit](https://github.com/igorT/data-orbit/tree/orbit-model-data)

3) By using an ES6 class for Record Data implementation, this brings us closer to an Emberless
Ember Data running.

4) If you needed to implement a GraphQL like projection API, Adapters and Serializers would be enough
for the loading data, but currently there is no good place to handle client side data interactions.
RecordData would make it much easier to have a GraphQL ED addon

5) Certain apps and models have a large amount of read only data, which is currently very performance heavy
to implement in ED. They could use a read only fast record data addon, which would enable a large perf win.

6) Experimenting with schemaless approaches is currently very hard in ED, because internal
models encode assumptions of how attributes and relationships work. Having a swappable RecordData would
make it easier for us to implement schemaless approaches in addons.

7) By having Record Data fully expressed in JSON API apis, the current state of the store becomes serializable.

By designing a public interface for RecordData that dosen't rely on any other part of EDs current system,
we can use RecordData as the main building block around which we can refactor the rest of ED.


### Detailed design


#### High level design

Ember Data would define a RecordData interface, and ship a default implementation. Addons would
be able to swap their own implementation of the RecordData interface.

RecordData is an interface defining the api for how the store and DS.Models
store and apply changes to data. RecordDatas hold
the backing data for each record, and act as a bridge between the Store, DS.Model, and Snapshots.
 It is per record, and defines apis that respond to
store api calls like `pushData`, `adapterDidCommit` and DS.Model updates like `setAttribute`.
RecordData represents the bucket of state that is backing a particular DS.Model.

The store instantiates the RecordData, feeds it JSON API data coming from the server and
tells it about state changes. DS.Model queries the RecordData for the attribute
and relationship values and sends back the updates the user has made.

Other than the `storeApisWrapper` passed to it, RecordData does not assume existence of
any other Ember or Ember Data object. It is a fully self contained system, that might serve
as a basic building block of non Ember/ED data libraries and could be extracted into a separate
library.

#### Interface

The interface for RecordData is:

```js
export default class RecordData {
  constructor(modelName: string, clientId?: string, id?: string, storeApisWrapper: StoreApisWrapper) {
    /*
      Exposing the entire store api to the RecordData seems very risky and would
      limit the kind of refactors we can do in the future. We would provide a wrapper
      to the RecordData that would enable funcionality MD absolutely needs
    */
  }


  /*
    Hooks through which the store tells the Record Data about the data
    changes. They all take JSON API and return a list of keys that the
    record will need to update
  */

  pushData(data: JsonApi, shouldCalculateChanges: boolean/* if false, don't need to return changed keys*/) {
  }

  adapterDidCommit(data: JsonApi) {
  }

  didCreateLocally(properties) {
  }

  /*
    Hooks through which the store tells RecordData about the lifecycle of the data,
    allowing it to keep track of dirtyness
  */

  adapterWillCommit(modelName: string, id?: string, clientId?: string) {
  }

  saveWasRejected(modelName: string, id?: string, clientId?: string) {
  }

  adapterDidDelete(modelName: string, id?: string, clientId?: string) {
  }

  recordUnloaded(modelName: string, id?: string, clientId?: string) {
  }


  /*
   Rollback handling
  */

  rollbackAttributes(modelName: string, id?: string, clientId?: string) {
  }

  rollbackAttribute(modelName: string, id?: string, clientId?: string, attribute: string) {
  }

  changedAttributes(modelName: string, id?: string, clientId?: string) {
  }

  hasChangedAttributes(modelName: string, id?: string, clientId?: string) {
  }


  /*
    Methods through which DS.Model interacts with RecordData, by setting and getting local state
  */

  setAttr(modelName: string, id?: string, clientId?: string, key: string, value: string) {
  }

  getAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  hasAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  /*
    Relationships take and return json api resource objects
    The store takes those references and decides whether it needs to load them, or
    it can serve them from the cache
  */

  getHasMany(modelName: string, id?: string, clientId?: string, key: string) {
  }

  addToHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources, idx: number) {
  }

  removeFromHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  setHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  getBelongsTo(modelName: string, id?: string, clientId?: string, key: string) {
  }

  setBelongsTo(modelName: string, id?: string, clientId?: string, key: string, jsonApiResource) {
  }

```


```js

export default class StoreApiWrapper {
  /* clientId is used as a fallback in the case of client side creation */
  createRecordDataFor(modelName, id, clientId)
  notifyPropertyChanges(modelName, id, clientId, keys)
  /*
  in order to not expose ModelClasses to RecordData, we need to supply it with
  model schema information. Because a schema design is out of scope for this RFC,
  for now we expose these two methods we intend to deprecate once we have a schema
  interpretation
   */
  attributesDefinitionFor(modelName, id)
  relationshipsDefinitionFor(modelName, id)

}
```


#### ED's usage of RecordData
We would refactor internal models, DS.Models and Snapshots to use RecordData's apis.

Reimplementation of ED current internals on top of RecordData apis would consist of the store
pushing the json api payload to the backing record data and the record data setting up internal
data tracking, as well as storing relationship data on any additional needed recordDatas.


```js
let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};

store.push(data);

// internal store method
_internalMethod() {
  let recordData = store.recordDataFor('user', 1, this._storeWrapperApi)
  recordData.pushData(data, false)
}

->

// model-data.js
pushData(data, shouldCalculateChanges) {
  this._data = this.data.attributes;
  this._setupRelationships(data);
}
->
// model-data.js
_setupRelationships(data) {
  this.storeWrapperApi.recordDataFor('house', 1);
  ....
}
```

The DS.Model interactions would look like:

```js
let user = store.peekRecord('user', 1);
user.get('name');
->
// DS.Model
get(key) {
  let recordData = _internalMethodForGettingTheCorrespondingRecordData(this);
  return recordData.getAttr('name');
}
```

#### Relationships

##### Basic loading of relationships

RecordData's relationship hooks would receive and return json api relationship objects with
additional metadata meaningful to Ember Data.

Lets say that we started off with the same user data as above

```js
let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};
let clemens = store.push(data);
```

Getting a relationships from Clemens would trace a path from the DS.Model to backing record data,
which would then give the store a json api object, and the store would instantiate a ManyArray
with the records


```js
clemens.get('houses');
// DS.Model
get() {
  let clemensRecordData = _internalApiGetsUsTheRecordDataFromIDMMAP();
  return clemens.getHasMany('houses');
}
->
// Record Data returns
{[
  data: { id: 5, type: 'house'},
  links: { related: '/houses' },
  meta: { realMetaFromServer: 'hi', _ED: { hasAllIds: true, needToLoadLink: false } }
}
-> //store takes the above, figures out that it needs to fetch house with id 5
  // and returns a promise which resolves into a ManyArray

```

ED extends the relationship payload with a custom meta, which gives the store information
about whether we have information about the entire relationship (we couldn't be sure we
have all the ids if we loaded from the belongsTo side) and whether the link should be refetched
(we might need to refetch the link in the case it potentially changed)


##### Setting relationship data locally

Similarly to the attributes, changing relationships locally tells record data to update
the backing data store
```js
let anotherHouse = store.push({data: { type: 'house', id: '5' }});
clemens.get('houses').then((houses) => {
  houses.pushObject(anotherHouse);
  ->
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: '5' } })
});
```


##### Dealing with newly created records in relationships

Unfortunately, because ED does not have first class clientId support, we need a special case
for handling locally created records, and pushing them to relationships.

We extend JSON API resource object with a `clientId` meta field.
A locally created record, will also have a ED specific internal client id, which will take preference;

```js
let newHouse = store.createRecord('house');
clemens.get('houses').then((houses) => {
  houses.pushObject(newHouse);
  ->
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: null, { meta: _ED: { clientId: 1}} } })
});
clemens.get('houses') ->
{ data:
  [ { id: 5, type: 'house'},
    { id: null, type: 'house', meta: { _ED: { clientId: 1 } } }],
  links: { related: '/hi' },
  meta: { realMetaFromServer: 'hi', _ED: { loaded: true, needToLoadLink: false } }
}
```


ED internals would keep a separate cache of client ID and resolve the correct record


#### Addon usage

The Store provides a public api for looking up a recordData which the store has not seen before.

```
recordDataFor(modelName, id, options) {

}
```

If an Addon wanted to implement custom data handling functionality, it would subclass the store
and implement their own RecordData handler.

There are three main reasons to do this.

1. Full replacement of Ember Data's data handling mechanisms

Best example would be the Ember Data backed by Orbit.js experiment. EmberDataOrbit Addon replaces
Ember Data's backing data implementation with Orbit.js. Most of this work can be done by EmberDataOrbit
replacing ED's Record Data implementation

```
recordDataFor(modelName, id, options, storeWrapper) {
  return new OrbitRecordData(modelName, id, storeApisWrapper)
}
```

2. Per Model replacement of Ember Data's data handling

If a large app was loading thousands of instances of a particular record type, which was read-only,
it could use a read only ED addon, which implemented a simplified RecordData without any change tracking.

The addon would implement a `recordDataFor` on the store as

```
recordDataFor(modelName, id, options, storeWrapper) {
  if (addonDecidesIfReadOnly(modelName))  {
    return new ReadOnlyRecordData(modelName, id, storeApisWrapper)
  }
  return this._super(modelName, id, options, storeWrapper);
}
```

3. Adding common funcionality to all ED models

Ember Data Model Fragments Addon adds support for handling of embedded data fragments.
In order to manage the handling of fragments, Model Fragments would compose ED's default
RecordData with it's own for handling fragments.


```js
recordDataFor(modelName, id, options, storeWrapper) {
  let EDRecordData = this._super(modelName, id, options, storeWrapper);
  return new ModelFragmentsRecordData(modelName, id, options, storeWrapper, EDRecordData);
}
```

When receiving a payload, ModelFragments would handle the fragment part and delegate the rest
to ED's implementation

```js
pushData(data, shouldCalculateChanges) {
  let keysThatChanged = this.extractAndHandleFragments(data);
  return keysThatChanged.concat(this.EDRecordData.pushData(data, shouldCalculateChanges))
}
```

### How we teach this

These APIs are not meant to be used by most users, or app level code, and should be hidden away and
described in an api/guides section meant for ED addon authors. Currently there are a few widely used
addons which would greatly benefit from this, so we can also reach out in person. I have already implemented
a spike of ModelFragments using RecordData. Having couple addons implement different RecordDatas would be
a great way to teach new addon authors about the purpose and implementation of the API.

### Drawbacks

#### Defines a bigger API surface area

This change would increase the public API surface area, in a codebase that is already pretty complex.
However, this would codify and simplifyA APIs addon authors have already had to interact with, while
creating a path for future simplification of the codebase.

#### It allows people to do very non-standard changes that will complexify their app needlessly

The main mitigation, is only giving RecordData access to a small amount of knowledge of the external world,
and keeping most APIs pull only thus discouraging trying to do innapropriate work in the RecordData layer

#### The new JSON api interaction might preclude performance improvements, or reduce current performance


### Alternatives

#### We could do this work as an internal refactor, and not expose it to public.

I believe that this approach is valid as an internal architecture, so would like to do it even if
we did not expose any of it to addons/apps.

#### Make RecordData's looked up from the resolver

Currently RecordData is a dumb ES6 class and does not live in the Ember resolver system, for performance
and simplicity reasons. We could alternatively look it up from the resolver, allowing people
to mock it and inject into it easier.

#### Don't expect a per record Record Data

Currently, the MD layer semantics mimics current ED's data storage, where data is stored per record in
internalModels. You could alternatively do this using an app wide cache, like Orbit.js does, or
using any number of other approaches. This approach while valid, would be harder to implement and
it's apis would not map as well to ED behavior.

### Open Questions

#### Versioning and stability

Our current implementation of `internalModel` is deeply monkeypatched by at least few addons. I think
we have to consider it as an semi-intimate api, even though it literally has `internal` in the name(I've been told adding couple undescores to the name would have helped).
Because the number of addons monkeypatching it is limited, we can manually migrate them onto the new
apis. However this requires us to make the new apis public from the get go, and doesn't allow for a long period of api evolution.

The following options are available, none of them great:

1) Feature flag RecordData work. The scope of this refactor is large enough, that doing a full feature
flagging would be an enourmous burden to bear, and I would advise against it. We can proxy some basic
things, to allow for simpler changes and as a way of warning/deprecating

2) Move from the internals to public RecordData in a single release cycle, and hope public apis we created
make sense, and will not be performance issues in the future. I am reasonably confident having implemented
several addons using RecordData that the basic design works, but things can always come up.

3) Move from private internals to private RecordData, and then feature flag the public apis over couple
versions. In this case the addons monkeypatching the internals, would monkeypatch the new nicer apis
for a while, and then easily switch to the public api. This feel a bit like SemVer cheating.

#### ClientID passing to store api methods

We use `recordDataFor(modelName, id, clientId)` as the api to look up recordDatas. Passing an often
null clientId seems annoying. Orbit.js uses an identity object instead, and if we did the api would look like `recordDataFor(identityObject)`, where `identityObject` would look like `{ type, id, meta: { _ED: { clientId }}}`. This seem a bit more correct, but doesn't look like any existing ED api, and could create
a lot of allocations.

#### RecordDatas might need to do some global setup/communication, how does that work?

Normally you would do this in an initializer, but becasue MDs aren't resolved, the only way would be
to do it in RecordDataFor or by using a singleton import. Some ceremony being required to using RecordData
isn't super bad, because it will discourage app authors from customizing it for trivial/innapropriate
things.

#### What do we do with the record state management?

Currently RecordData has no interaction with the state machine. I think we should punt on this
for now.

#### { meta: { _ED: { props here } } } alternatives?

We could put the ED internal data outside of meta, and keep meta only for actual meta that comes from
the server.

#### Naming of everything

Please help with better names for things if you have ideas

#### Snapshot interface

How does a Snapshot ask Record Data for it's attributes

#### Real life perf impact

Need benchmarks


---

---
stage: recommended
start-date: 2018-01-11T00:00:00.000Z
release-date: 2018-07-16T00:00:00.000Z
release-versions:
  ember-source: v3.3.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/294
project-link:
---

# Make jQuery optional

## Summary

For the past Ember has been relying and depending on jQuery. This RFC proposes making jQuery optional and having a well
defined way for users to opt-out of bundling jQuery.

## Motivation

### Why we don't need jQuery any more

One of the early goals of jQuery was cross-browser normalization, at a time where browser support for web standards was
incomplete and inconsistent, and Internet Explorer 6 was the dominating browser. It provided a useful and convenient
API for DOM traversal and manipulation as well as event handling, that hid the various browser differences and bugs from
the user. For example `document.querySelector` wasn't a thing at that time, and browsers were using very different event
models ([DOM Level 0, DOM Level 2 and IE's own proprietary model](https://en.wikipedia.org/wiki/DOM_events#Event_handling_models)).

But this level of browser normalization is not required anymore, as today's browsers all support the basic DOM APIs well
enough. Even more so that the upcoming Ember 3.0 will drop support for all versions of Internet Explorer except 11.

Furthermore Ember users will need to directly traverse and modify the DOM or manually attach event listeners in very
special cases only. Most of these low level interactions are taken care of by Ember's templates and its underlying
Glimmer rendering engine, as well as action helpers or the component's event handler methods.

So having jQuery included by default does not provide that much value to users most of the time, and Ember itself is
expected to be fully functional and tested without jQuery, presumably for the upcoming 3.0 stable release.

### What are the drawbacks of bundling jQuery

The major drawback is the increased bundle size, which amounts to [~29KB](https://mathiasbynens.be/demo/jquery-size)
(minified and gzipped). This not only increases the loading time, but also parse and compile times, thus increasing the
total time to interactive. This is especially true for mobile devices, where slow connectivity and weak CPU performance
is not uncommon.

Having jQuery not included will improve the suitability of Ember for mobile applications considerably. Even
if the raw number is not that huge, it all adds up. And it plays together with other efforts to make leaner Ember builds
possible, like enabling tree shaking with the new [Module API](https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md),
moving code from core to addons (e.g. the [`Ember.String` deprecation](https://github.com/emberjs/rfcs/blob/master/text/0236-deprecation-ember-string.md))
or the ["Explode RFC"](https://github.com/emberjs/rfcs/blob/explode/text/0000-explode.md). In that regard removing the
dependency on jQuery is a rather low hanging fruit with an high impact.

### But this is already possible, why this RFC?

There is indeed a somewhat quirky way to build an [app without jQuery](https://github.com/rwjblue/no-jquery-app) even
today.
Although this *happens* to work, it is not sufficient to consider this officially supported for these reasons:
* Ember itself must be fully tested to work without jQuery
* the public APIs that depend on and/or expose jQuery need to have some well defined behavior when jQuery is not
available
* there should be a way to technically opt-out (other than fiddling with [`vendorFiles`](https://github.com/rwjblue/no-jquery-app/commit/34c40fc2cfc5e2ce0c39e5e906448c46af699d26))
that is easier to use, understand and maintain
* addons should mostly default to not use jQuery, to make removing jQuery practically possible for their consuming
apps

## Detailed design

### Remove internal jQuery usage

As of writing this, there are [major efforts](https://github.com/emberjs/ember.js/issues/16058) underway to remove and
cleanup the Ember codebase and especially its tests from jQuery usage. Having a way to fully test Ember without jQuery
is a prerequisite to officially support jQuery being optional. When this is done, it will enable a "no jQuery" mode,
that will make it not use jQuery anymore, but only native DOM APIs.

### Add an opt-out flag

There should be a global flag that will toggle the optional jQuery integration (true by default). When this is disabled,
it will make Ember CLI's build process *not* include jQuery into the `vendor.js` bundle, *and* it will explicitly put
Ember itself into its "no jQuery" mode.

The flag itself will not be made a public API. Rather it will be handled by a privileged addon, that will allow to
disable the integration flag, thus to opt out from jQuery integration. This approach is in line with
[RFC 278](https://github.com/emberjs/rfcs/pull/278) and [RFC 280](https://github.com/emberjs/rfcs/pull/280), to allow
for some better implementation flexibility.

### Introduce `@ember/jquery` package

Currently Ember CLI itself is importing jQuery into the app's `vendor.js` file. To decouple it from this task, and
to allow for some better flexibility in the future, the responsibility for importing jQuery is moved to a dedicated
`@ember/jquery` addon.

To not create any breaking changes, Ember CLI will have to check the app's dependencies for the presence of this addon.
If it is not present, it will continue importing jQuery *unless* the jQuery integration flag is disabled.
If it is present, it will stop importing jQuery at all, and delegate this responsibility to the addon.

To nudge users to install `@ember/jquery` when they need jQuery, some warning/deprecation messages should be issued when
the addon is *not* installed and the integration flag is either not specified or is set to true. To ease
migration the addon should be placed in the default blueprint (until an eventual more aggressive deprecation of
jQuery). Only in the case the app is actively opting out of jQuery integration the addon is not needed.

The addon itself has to make sure the Ember CLI version in use is at least the one that introduced the above mentioned
logic, to prevent importing jQuery twice.

### Assertions for jQuery based APIs

Apart from testing (see below), Ember features some APIs that directly expose jQuery, which naturally cannot continue
to work without it. For these APIs some assertions have to be added when running in "no jQuery" mode (and not in
production), that provide some useful error messages for the developer:

* `Ember.$()`
  should throw an assertion stating that jQuery is not available.
* `this.$()` in components
  should throw an assertion stating that jQuery is not available and that `this.element` and native DOM APIs should be
  used instead.

### Introducing `ember-jquery-legacy` and deprecating `jQuery.Event` usage

Event handler methods in components will usually receive an instance of [`jquery.Event`](http://api.jquery.com/category/events/event-object/) as an argument, which is very
similar to native event objects, but not exactly the same. To name a few differences, not all properties of the native
event are mapped to the jQuery event, on the other hand a jquery event has a `originalEvent` property referencing the
native event.

The updated event dispatcher in Ember 3.0 is capable of working without jQuery (similar to what
`ember-native-dom-event-dispatcher` provided for Ember 2.x). When jQuery is not available, it will naturally not be
able to pass a `jquery.Event` instance but a native event instead. This creates some ambiguity for addons, as they
cannot know in advance how the consuming app is built (with or without jQuery).

For code that does not rely on any `jQuery.Event` specific API, there is no need to change anything as it will continue
to work with native DOM events.

But there are cases where jQuery specific properties have to be used (when jQuery events are passed). This is especially
true for the `originalEvent` property, for example to access `TouchEvent` properties that are not exposed on the
`jQuery.Event` instance itself. So there has to be a way to make the code work with either jQuery events or native
events being passed to the event handler (especially important for addons). Moreover this should be done in a way that
uses native DOM APIs only, to support the migration away from jQuery coupled code.

To solve this issue another addon `ember-jquery-legacy` will be introduced, which for now will only expose a single
`normalizeEvent` function. This function will accept a native event as well as a jQuery event (possibly distinguishing
between those two modes at build time, based on the jQuery integration flag), but will always return a native event
only.

This will allow addon authors to work with both event types, but start to only use native DOM APIs:

```js
import Component from '@ember/component';
import { normalizeEvent } from 'ember-jquery-legacy';

export default Component.extend({
  click(event) {
    let nativeEvent = normalizeEvent(event);
    // from here on use only native DOM APIs...
  }
})
```

To encourage addon authors to refactor their jQuery coupled event code, the use of `jQuery.Event` specific APIs used for
jQuery events passed to component event handlers should be deprecated and a deprecation message be shown when accessing
them (e.g. `event.originalEvent`). Care must be taken though that this warning will not be issued when `normalizeEvent`
has to access `originalEvent`.

Also for apps that do not want to transition away from jQuery and would be overloaded with unnecessary warnings, the
deprecations should be silenced when the jQuery integration flag is explicitly set to true (and not just true by
default). By doing so users effectively state their desire to continue using jQuery, thus any needless churn should
be avoided for them.

### Testing

Ember's test harness has been based on jQuery for a long time. Most global acceptance test helpers like `find` or
`click` rely on jQuery. For integration tests the direct use of jQuery like `this.$('button').click()` to trigger
events or assert the state of the DOM is still the standard, based on `this.$()` returning a jQuery object representing
the rendered result of the tests `render` call.

To be able to reliably run tests in a jQuery-less world, we need to run our tests without jQuery being included,
so our test harness has to work without jQuery as well.

Fortunately this is well underway already. [ember-native-dom-helpers](https://github.com/cibernox/ember-native-dom-helpers)
introduced native DOM test helpers for integration and acceptance tests as an user space addon. The recent acceptance
testing [RFC 268](https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md) provides
similar test helpers, implemented in the `@ember/test-helpers` package, and envisages deprecating the global test
helpers.

However while the existing jQuery based APIs are still available, when these are used without jQuery they have to throw
an assertion with some meaningful error message:

* global acceptance test helpers that expect jQuery selectors (which are a potentially incompatible superset of standard
CSS selectors)

* `this.$()` in component tests, provided currently by `@ember/test-helpers` in `moduleForComponent` and
`setupRenderingTest`

In both cases the error message should state that jQuery is not available and that the native DOM based test helpers
of the `@ember/test-helpers` package should be used instead.

The transitioning to these new test helpers can be eased through a codemod. For `ember-native-dom-helpers` there already
exists  [ember-native-dom-helpers-codemod](https://github.com/simonihmig/ember-native-dom-helpers-codemod), which
could be adapted to the very similar RFC 268 based interaction helpers in `@ember/test-helpers`.

### Implementation outline

The following outlines how a possible implementation of the jQuery integration flag *could* look like. This
is just to provide some additional context, but is *intentionally not* meant to be normative, to allow some flexibility
for the actual implementation.

The addon that will handle the flag is expected to be [ember-optional-features](https://github.com/emberjs/ember-optional-features),
which will read from and write to a `config/optional-features.{js,json}` file. This will hold the `jquery-integration`
flag (amongst others). This flag in turn will be added to the `EmberENV` hash, which will make Ember go into its
"no jQuery" mode when set to `false`.

Ember CLI and the `@ember/jquery` addon will also look for `jquery-integration` in this configuration file, and will
opt-out of importing jQuery when this file is present and the flag is set to `false`.

## How we teach this

### Guides

The existing "Managing Dependencies" chapters in the Ember Guides as well as on ember-cli.com provide a good place to
explain users how to set the jQuery integration flag by means of the mentioned [privileged addon](#add-an-opt-out-flag)
that handles this flag.

The section on components should be updated to remove any eventually remaining references to `this.$`, to not let users
fall into the trap of creating an implicit dependency on jQuery by "accidental" use of it. These should be changed to
refer to their native DOM counterparts like `this.element` or `this.element.querySelector()`.

The section on acceptance tests will have been updated as per [RFC 268](https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md)
to use the new `@ember/test-helpers` based test helpers instead of the jQuery based global helpers.

The section on component tests should not use `this.$()` anymore as well, and instead also according to [RFC 268](https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md)
use `this.element` to refer to the component's root element, and use the new DOM interaction helpers instead of jQuery
events triggered through `this.$()`.

### Deprecation guide

The deprecation warnings introduced for using `jQuery.Event` specific APIs should explain the use of the
`normalizeEvent` helper function to migrate towards native DOM APIs on the one side, and on the other side the effect of
setting the jQuery integration flag to explicitly opt into jQuery usage thus suppressing the warnings.

### Addon migration

One of the biggest problems to easily opt-out of jQuery is that many addons still depend on it. Many of these usages
seem to be rather "accidental", in that the full power of jQuery is not really needed for the given task, and could
be fairly easily refactored to use only native DOM APIs.

For this reason this RFC encourages addon authors to not use jQuery anymore and to refactor existing usages whenever
possible! This certainly does not apply categorically to all addons, e.g. those that wrap jQuery plugins as
components and as such cannot drop this dependency.

#### ember-try

`ember-try`, which is used to test addons in different scenarios with different dependencies, should provide some means
to define scenarios without jQuery, based on the jQuery integration flag introduced in this RFC.

Furthermore the Ember CLI blueprint for addons should be extended to include no-jQuery scenarios by default, to make
sure addons don't cause errors when jQuery is not present.

#### emberobserver.com

It would be very helpful to have a clear indication on [emberobserver.com](https://emberobserver.com/) which
addons depend on jQuery and which not. This would benefit users as to know which addons they can use without
jQuery, but also serve as an incentive for authors to make their addons work without it.

Given the jQuery integration flag introduced in this RFC, this paves the way to automatically detect addons that are
basically declaring their independence from jQuery by having this flag set to `false`  (in their own repository).

## Drawbacks

### Churn

A vast amount of addons still depend on jQuery. While as far as this RFC is concerned no jQuery based APIs will be
deprecated and the default will still be to include jQuery, addons are nevertheless encouraged to remove their
dependency on jQuery, which will add some considerable churn to the addon ecosystem. As of writing this, there are:
* [475 addons](https://emberobserver.com/code-search?codeQuery=Ember.%24) using `Ember.$`
* [479 addons](https://emberobserver.com/code-search?codeQuery=this.%24&fileFilter=addon%2Fcomponents) using `this.$` in
components
* [994 addons](https://emberobserver.com/code-search?codeQuery=this.%24&fileFilter=tests) using `this.$` in tests

Among these are still some very essential addons like `ember-data`, which still relies on `$.ajax`, see
[#5320](https://github.com/emberjs/data/issues/5320).

A good amount of that churn can be mitigated by having a codemod that migrates tests (see "Testing" above).

## Alternatives

Continue to depend on jQuery.

## Unresolved questions

None so far.


---

---
stage: recommended
start-date: 2018-01-17T00:00:00.000Z
release-date: 2018-05-31T00:00:00.000Z
release-versions:
  ember-source: v3.20.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/297
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/issues/16231
---

# Deprecation of Ember.Logger

## Summary

This RFC recommends the deprecation and eventual removal of `Ember.Logger`.

## Motivation

There are a variety of features of Ember designed to support old browsers,
features that are no longer needed. `Ember.Logger` came into being because
the browser support for the console was inconsistent. In some browsers,
like Internet Explorer 9, the console only existed when the developer tools
panel was open, which caused null references and program crashes when run
with the console closed. `Ember.Logger` provided methods that would route to
the console when it was available.

With Ember 3.x, Ember no longer supports these older browsers, and hence this
feature no longer serves a purpose. Removing it will make Ember smaller and
lighter.

## Detailed design

For the most part, this is a 1:1 substitution of the global `console` object
for `Ember.Logger`.

Node only added support for `console.debug` in Node version 9. Where we wish
to support earlier versions of Node, we will need to use `console.log`, rather than
`console.debug`, as the replacement for `Logger.debug`. Apps and addons
which don't care about Node or are specifying Node version 9 as their minimum can
use `console.debug`.

Internet Explorer 11 and Edge both require console methods to be bound to the
console object when the developer tools are not showing. This diverges from the
expectations of other browsers. Direct calls to console methods will work correctly,
but constructs which involve explicitly or implicitly binding the console methods to
other objects or using them unbound will fail. This is straightforward to work around.

You can address the issue by binding the method to the console object:

``` javascript
// Before - assigning raw method to a variable for later use
var print = Logger.log; // assigning method to variable
print('Message');

// After - assigning console-bound method to variable for later use
var print = console.log.bind(console);
print('Message');
```

In some cases, you can use rest parameter syntax to avoid the issue entirely:

``` javascript
// Before
Logger.info.apply(undefined, arguments); // or
Logger.info.apply(null, arguments); // or
Logger.info.apply(this, arguments); // or

// After
console.info(...arguments);
```

### Within the framework

Remove the following direct uses of `Ember.Logger` from the ember.js and
ember-data projects:

* `ember-debug`:
    *  deprecate (`ember-debug\lib\deprecate.js`) - `Logger.warn`
    *  debug (`ember-debug\lib\index.js`) - `Logger.info`
    *  warn (`ember-debug\lib\warn.js`) - `Logger.warn`
* `ember-routing` (`ember-routing\lib\system\router.js`):
    *  transitioned to - `Logger.log`
    *  preparing to transition to - `Logger.log`
    *  intermediate-transitioned to - `Logger.log`
* `ember-testing`:
    *  Testing paused (`ember-testing\lib\helpers\pause_test.js`) - `Logger.info`
    *  Catch-all handler (`ember-testing\lib\test\adapter.js`) - `Logger.error`
* `ember-data`:
    *  `tests\test-helper.js`- `Logger.log`

Adjust all test code that redirects logging and sets it back:

* `ember\tests\routing\basic_test.js` (adjust)
* `ember-application\tests\system\dependency_injection\default_resolver_test.js` (adjust)
* `ember-application\tests\system\logging_test.js` (remove?)
* `ember-glimmer\tests\integration\helpers\log-test.js` (remove?)

Note: None of the uses of `Ember.Logger` in `ember.js` or `ember-data` involve
`Ember.debug`, so that issue doesn't affect the Ember.js code directly.

Add deprecation warnings to the implementation: `ember-console\lib\index.js`.
Bear in mind that `Ember.deprecate` in `ember-debug` currently calls
`Logger.warn`, so the `ember-debug` code should be changed _first_ or adding
the deprecation warning will create a deep recursion.

The `Ember.assert`, `Ember.warn`, `Ember.info`, `Ember.debug`, and
`Ember.deprecate` methods suppress their output on production builds.
However, they are suppressing them in the `ember-debug` module, which
currently consumes `Ember.Logger`, _not_ by `Ember.Logger` itself. Hence,
replacing calls to `Ember.Logger` with direct calls to the console will not
affect this behavior.

### Add-On Developers

The following high-impact add-ons (9 or 10 or a * on EmberObserver) use
`Ember.Logger` and should probably be given an early heads-up to adjust
their code to use `console` before this RFC is implemented. This will limit
the level of pain that their users experience when the deprecation is released.

Add-ons that need to also support Ember 2.x will need to make their console
references conditional on console being "truthy", of course, to support Internet
Explorer 9.

In the order of their number of references to `Ember.Logger`:

* `ember-concurrency` (15)
* `ember-cli-deprecation-workflow` (9)
* `ember-stripe-service` (9)
* `semantic-ui-ember` (7)
* `ember-resolver` (6)
* `ember-cli-page-object` (4)
* `ember-cli-sentry` (3)
* `ember-islands` (3)
* `ember-states` (3)
* `ember-cli-pagination` (2)
* `ember-cli-clipboard` (1)
* `ember-cli-fastboot` (1)
* `ember-elsewhere` (1)
* `ember-i18n` (1)
* `ember-simple-auth-token` (1)
* `ember-svg-jar` (1)
* `liquid-fire` (1)

For details, see https://emberobserver.com/code-search?codeQuery=Ember.Logger.

## How we teach this

### Communication of change

We need to inform users that `Ember.Logger` will be deprecated and in what
release it will occur.

### Official code bases and documentation

We do not currently actively teach the use of `Ember.Logger`. We will need to
remove any passing references to `Ember.Logger` from the Ember guides
from the Super Rentals tutorial, and anywhere else it appears on the website.

Once it is gone from the code, we also need to verify it no longer appears in
the API listings.

We must provide an entry in the deprecation guide for this change:
* describing relevant divergences remaining in the handling of the console in
Internet Explorer 11 and Edge browsers.
* describing the issue with using console.debug on node versions
earlier than Node 9.
* describing alternative ways of dealing with eslint's `no-console` messages.

## Drawbacks

191 add-ons in Ember Inspector are using `Ember.Logger`. It has been there and
documented for a long time. So this deprecation will cause some level of change
on many projects.

This, of course, can be said for almost any deprecation, and Ember's
disciplined approach to deprecation has been repeatedly shown to ease things.
These particular changes are proving easy to locate and replace by hand. Also,
only twenty of those add-ons have more than six references to `Ember.Logger`.
If this is characteristic of the user base, the level of effort to make
the change, even by hand, should be very small for most users.

Those using `Logger.debug` as something different from `Logger.log` may have
at least a theoretical concern. Under the covers `Logger.debug` only calls
`console.debug` if it exists, calling `console.log` otherwise. The only
platform where the difference between the two is visible in the console is on
Safari. We can encourage folks with a tangible, practical concern about this to
speak up during the comment period, but I don't anticipate this will have much
impact.

## Alternatives

1. Leave things as they are, perhaps providing an `@ember/console` module
interface.

2. Extract `Ember.Logger` into its own (tiny) `@ember/console` package as
a shim for users.

## Unresolved questions

None at this point. The answers from prior drafts have been promoted into the text.


---

---
stage: recommended
start-date: 2018-02-04T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - steering
prs:
  accepted: https://github.com/emberjs/rfcs/pull/300
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/1
---

# RFC (Request for Comments) Process Update

## Summary

Refine the Ember RFC process and have it apply to all Ember teams.

## Motivation

The Ember community has been using the RFC process to great effect over the last few years.
Proposals by both Core and community members are discussed and refined
with the result coming out much stronger.

During this time, the community and the core teams have identified shortcomings
of the RFC process as well as new requirements, which this RFC intends to address:

### Confusion between emberjs/rfcs and ember-cli/rfcs

The Ember project currently has two separate RFC processes for Ember.js and Ember CLI.

This leads to confusion because the community needs to keep track of two different repositories.
For contributors there is the overhead of having to decide where to file their RFC if the proposal involves both projects,
as well as being aware of the differences in the processes.

### The process does not cover the entire project

RFCs to emberjs/rfcs and ember-cli/rfcs have traditionally concerned themselves with features or deprecations to Ember.js and Ember CLI respectfully, with some Ember Data proposals in emberjs/rfcs.

We have already begun to use emberjs/rfcs for other initiatives, such as the project-wide Ember.js 2018 Roadmap but have not codified or updated the process to make it clear that it should be used for efforts such as a website redesign,
information architecture suggestions, SEO suggestions, and the like.

### Lingering RFCs

Both the emberjs/rfcs and the ember-cli/rfcs repositories have many open issues and pull-requests.
A percentage of these have not been active in the recent past.

We have kept PRs and issues open so people could more easily find the discussions,
but this has instead given a negative impression of staleness, as RFCs linger open without new feedback.

### The process for an RFC after it has been accepted

At the moment the process does not specify what happens when an RFC is accepted and merged. This has led to many questions about the status of merged RFCs.

## Detailed design

### One RFC Process for all of Ember

Ember is [organized into teams](https://emberjs.com/team/), with each team being responsible for certain projects.
The RFC process will be a useful tool for all of those projects.
The header of the RFC template will be updated to include a spot to specify the relevant team(s). The header will have "Ember Issue:" removed.

A list of the teams and respective projects will be added to the instructions,
possibly with the addition of per-team instructions on specifics of the project.
Additional templates might be created as well, such a design work template.

Each team will be responsible for reviewing new RFCs and, if an RFC requires work from their team, ensuring that the RFC reflects that.
As it is with the wider community, the RFC process is the time for teams and team members to push back on, encourage, refine, or otherwise comment on proposals.

### Require a Core Champion

To make sure that RFCs receive adequate support from the team, Ember CLI has implemented the idea of a champion associated with each RFC.
One goal is that in seeking a champion from the team,
the RFC author starts a dialogue with the team and gets some early feedback.
That champion is then responsible for representing the RFC in team meetings, and for shepherding its progress. We will import a version of this process to emberjs/rfcs:

Each RFC will require a champion from the primary core team to which the RFC has been marked relevant.
The champion must be found by the opener of the RFC or other community member. They are not assigned by the core teams.
The champion will assign themselves on the RFC on Github.
The champion will be responsible for:
 - achieving consensus from the team(s) to move the RFC through the stages of the RFC process.
 - ensuring the RFC follows the RFC process.
 - shepherding the planning and implementation of the RFC.
Before the RFC is accepted, the champion may remove themselves.
The champion may find a replacement champion at any time.

A section on 'Finding a champion' will be added to the instructions on proposing an RFC.

### Introduce the concept of "FCP to close"

To address the problem of RFC triage and inactivity, this RFC introduces the concept of FCP to close.

Closing an RFC should be viewed as another triage tool, not as a rejection of the RFC.
Sometimes a rewrite of an RFC would be so fundamental that it would benefit of a fresh discussion in a new thread.
Sometimes the original author is no longer active (Champions should help here as well),
and someone else might want to take over the work in a new RFC.
Sometimes the timing might not be right, or the feature might have been addressed some other way, and yes,
sometimes it might be something that is not aligned with the team's values for the project.

A good example of this is the [Named Blocks RFC](https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md#motivation),
which lists in the motivation section previous attempts at similar ideas.

Like the FCP to merge process, once an RFC is marked as FCP to close there will be a period of one week where people can raise new concerns.
After that period of one week, the respective team will review and close the RFC or extend the period for another week.

### Merge ember-cli/rfcs into emberjs/rfcs

We will have a single repository for all Ember Project RFCs.

To achieve merging ember-cli/rfcs into emberjs/rfcs the following will be done:

- Add to the RFC header to indicate it applies to ember-cli
- Copy both active and completed RFC files into `text` of emberjs/rfcs
- Transfer active PRs and Issues to emberjs/rfcs
- Archive ember-cli/rfcs

There are some concerns about links breaking when we move the files to emberjs/rfcs,
but given the fact that ember-cli/rfcs had the concept of active/completed by moving the files into different folders,
links were already being broken.

The ember-cli/rfcs do not need name or numbering changes, as there is currently no duplicated name.
Going forward, the numbering should be unified by virtue of having a single repository.

### Track RFCs after they are accepted

At the moment it is not clear what happens to an RFC after it has been merged.

This RFC proposes that after an RFC is merged, the relevant teams, guided by the champion,
will plan implementation by creating tracking issues in the relevant projects.

This RFC proposes having a single place to track the implementation of each RFC.
Each RFC will have a header `Tracking:` that will be filled out with a link. At that link all issues related to that RFC, across all projects and organizations, will be enumerated.

## How We Teach This

To ensure that contributors are updated on the RFC process and the process is clear,
the documentation should be improved in a couple of ways.

The README will be updated to reflect process changes described in this RFC.
We will add checklists to the instructions for each stage of the RFC process to make it very clear what needs to happen.

## Drawbacks

### Adjustment period

There are active RFCs in ember-cli/rfcs. Moving these discussions would be onerous, so they should be kept there until completion, and no new RFCs accepted.

### Permalinks to ember-cli/rfcs proposals

Moving the RFC files from ember-cli/rfcs (active or completed) to emberjs/rfcs can be seen as a breaking change, and could lead to someone linking to ember-cli/rfcs and then the RFC being updated in emberjs/rfcs. However, ember-cli/rfcs already suffers from a linking problem due to the active/completed folders, as RFCs need to be moved from one to the other even after being accepted.
This could be mitigated by introducing a warning in the RFC text directing people to the new source.

## Alternatives

None at the moment.

## Unresolved questions

None at the moment.

---

## Glossary

- **RFC**: Request For Comments. The process by which a proposal is discussed by the community and then approved by an Ember team.
- **FCP**: Final Comment Period. Period of one week at the end of which an RFC is to be accepted or rejected by an Ember team. Extended in periods of one week if new concerns are raised.


---

---
stage: recommended
start-date: 2018-02-15T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/308
project-link:
---

# Summary

Beginning the transition to deprecate the fallback behavior of resolving `{{foo}}` by requiring the usage of `{{this.foo}}` as syntax to refer to properties of the templates' backing component. This would be the default behavior in Glimmer Components.

For example, given the following component class:

```js
import Component from '@ember/component';
export default Component.extends({
  init() {
    super(...arguments);
    this.set('greeting', 'Hello');
  }
});
```

One would refer to the `greeting` property as such:

```hbs
<h1>{{this.greeting}}, Chad</h1>
```

Ember will render "Hello, Chad".

To make this deprecation tractable, we will provide a codemod for migrating templates.

# Motivation

Currently, the way to access properties on a components class is `{{greeting}}` from a template. This works because the component class is one of the objects we resolve against during the evaluation of the expression.

The first problem with this approach is that the `{{greeting}}` syntax is ambiguous, as it could be referring to a local variable (block param), a helper with no arguments, a closed over component, or a property on the component class.

## Exemplar

Consider the following example where the ambiguity can cause issues:

You have a component class that looks like the following component and template:

```js
import Component from '@ember/component';
import computed from '@ember/computed';

export default Component.extend({
  formatName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
});
```

```hbs
<h1>Hello {{formatName}}!</h1>
```

Given `{ firstName: 'Chad', lastName: 'Hietala' }`, Ember will render the following:

```html
<h1>Hello Chad Hietala!</h1>
```

Now some time goes on and someone adds a `formatName` helper at `app/helpers/fortmatName.js` that looks like the following:

```js
export default function formatName([firstName, lastName]) {
  return `${firstName} ${lastName}`;
}
```

Due to the fact that helpers take precedence over property lookups, our `{{formatName}}` now resolves to a helper. When the helper runs it doesn't have any arguments so our template now renders the following:

```html
<h1>Hello !</h1>
```

This can be a refactoring hazard and can often lead to confusion for readers of the template. Upon encountering `{{greeting}}` in a component's template, the reader has to check all of these places: first, you need to scan the surrounding lines for block params with that name; next, you check in the helpers folder to see if there is a helper with that name (it could also be coming from an addon!); finally, you check the component's JavaScript class to look for a (computed) property.

Like [RFC#0276](https://github.com/emberjs/rfcs/blob/68812bf2d439c6bb77ad491e0159b371b68c5c35/text/0276-named-args.md) made argument usage explicit through the `@` prefix, the `this` prefix will resolve the ambiguity and greatly improve clarity, especially in big projects with a lot of files (and uses a lot of addons).

As an aside, the ambiguity that causes confusion for human readers is also a problem for the compiler. While it is not the main goal of this proposal, resolving this ambiguity also helps the rendering system. Currently, the "runtime" template compiler has to perform a helper lookup for every `{{greeting}}` in each template. It will be able to skip this resolution process and perform other optimizations (such as reusing the internal [reference](https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md)
object and caches) with this addition.

Furthermore, by enforcing the `this` prefix, tooling like the [Ember Language Server](https://github.com/emberwatch/ember-language-server) does not need to know about fallback resolution rules. This makes common features like ["Go To Definition"](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition) much easier to implement since we have semantics that mean "property on class".

# Transition Path

We intend this to be a _very slow_ process as we understand it is a large change. Because of this we will be doing a phased rollout to help guide people in transtion. Below is an outline of how we plan to roll this change out.

**Phase 1:**
- Add [template lint rule](https://github.com/ember-template-lint/ember-template-lint/pull/392) to [ember-template-lint](https://github.com/ember-template-lint/ember-template-lint) as an **opt-in** rule
- Document the [codemod infrastructure](https://github.com/dyfactor/dyfactor) and [codemod](https://github.com/dyfactor/dyfactor-plugin-disambiguate-locals). Make it available for early adopters
- Start updating docs to use `this.`

**Phase 2:**
- Add the lint rule by default _in the apps_ `.template-lintrc.js`
- Complete doc migration to use `this.`

**Phase 3:**
- Enable the lint rule by default in the `recommended` config

**Phase 4:**
- Introduce deprecation **app only** fallbacks

**Phase 5:**
- Introduce deprecation for **any** fallbacks

**Phase 6:**
- Rev major to 4.0.0
- Add assert for fallback behavior

**Phase 7:**
- Remove fallback functionality in 4.5, post 4.4.0 LTS

# How We Teach This

`{{this.foo}}` is the way to access the properties on the component class. This also aligns with property access in JavaScript.

Since the `{{this.foo}}` syntax has worked in Ember.Component (which is the only kind of component available today) since the 1.0 series, we are not really in a rush to migrate the community (and the guides, etc) to using the new syntax. In the meantime, this could be viewed as a tool to improve clarity in templates.

While we think writing `{{this.foo}}` would be a best practice for new code going forward, the community can migrate at its own pace one component at a time. However, once the fallback functionality is eventually removed this will result in a "Helper not found" error.

## Syntax Breakdown

The follow is a breakdown of the different forms and what they mean:

- `{{@foo}}` is an argument passed to the component
- `{{this.foo}}` is a property on the component class
- `{{#with this.foo as |foo|}} {{foo}} {{/with}}` the `{{foo}}` is a local
- `{{foo}}` is a helper

# Drawbacks

The largest downside of this proposal is that it makes templates more verbose, causing developers to type a bit more. This will also create a decent amount of deprecation noise, although we feel like tools like [ember-cli-deprecation-workflow](https://github.com/mixonic/ember-cli-deprecation-workflow) can help mitigate this.

# Alternatives

This pattern of having programming model constructs to distinguish between the backing class and arguments passed to the component is not unique to Ember.

## What Other Frameworks Do

React has used `this.props` to talk about values passed to you and `this.state` to mean data owned by the backing component class since it was released. However, this approach of creating a specific object on the component class to mean "properties available to the template", would likely be even more an invasive change and goes against the mental model that the context for the template is the class.

Vue requires enumeration of `props` passed to a component, but the values in the template suffer from the ambiguity that we are trying to solve.

Angular relies heavily on the dependency injection e.g. `@Input` to enumerate the bindings that were passed to the component and relies heavily on TypeScript to hide or expose values to templating layer with `public` and `private` fields. Like Vue, Angular does not disambiguate.

## Introduce Yet Another Sigil

We could introduce another sigil to remove ambiguity. This would address the concern about verbosity, however it is now another thing we would have to teach.

## Change Resolution Order

The other option is to reverse the resolution order to prefer properties over helpers. However this has the reverse problem as described in the exemplar.

## Do Nothing

I personally don't think this is an option, since the goal is to provide clarity for applications as they evolve over time and to provide a more concise mental model.

# Unresolved questions
TBD



---

---
stage: recommended
start-date: 2018-03-09T00:00:00.000Z
release-date: 2018-08-27T00:00:00.000Z
release-versions:
  ember-source: v3.4.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/311
project-link:
---

# Angle Bracket Invocation

## Summary

This RFC introduces an alternative syntax to invoke components in templates.

Examples using the classic invocation syntax:

```hbs
{{site-header user=this.user class=(if this.user.isAdmin "admin")}}

{{#super-select selected=this.user.country as |s|}}
  {{#each this.availableCountries as |country|}}
    {{#s.option value=country}}{{country.name}}{{/s.option}}
  {{/each}}
{{/super-select}}
```

Examples using the angle bracket invocation syntax:

```hbs
<SiteHeader @user={{this.user}} class={{if this.user.isAdmin "admin"}} />

<SuperSelect @selected={{this.user.country}} as |Option|>
  {{#each this.availableCountries as |country|}}
    <Option @value={{country}}>{{country.name}}</Option>
  {{/each}}
</SuperSelect>
```

## Motivation

The original [angle bracket components](https://github.com/emberjs/rfcs/pull/60)
RFC focused on capitalizing on the opportunity of switching to the new syntax
as an opt-in to the "new-world" components programming model.

Since then, we have switched to a more iterative approach, favoring smaller
RFCs focusing on one area of improvement at a time. Collectively, these RFCs
have largely accomplished the goals in the original RFC without the angle
bracket opt-in.

Still, separate from other programming model improvements, there is still a
strong desire from the Ember community for the previously proposed angle
bracket invocation syntax.

The main advantage of the angle bracket syntax is clarity. Because component
invocation are often encapsulating important pieces of UI, a dedicated syntax
would help visually distinguish them from other handlebars constructs, such as
control flow and dynamic values. This can be seen in the example shown above –
the angle bracket syntax made it very easy to see the component invocations as
well as the `{{#each}}` loop, especially with syntax highlight:

```hbs
<SuperSelect @selected={{this.user.country}} as |Option|>
  {{#each this.availableCountries as |country|}}
    <Option @value={{country}}>{{country.name}}</Option>
  {{/each}}
</SuperSelect>
```

This RFC proposes that we adopt the angle bracket invocation syntax to Ember as
an alternative to the classic ("curlies") invocation syntax.

Unlike the original RFC, the angle bracket invocation syntax proposed here is
purely syntactical and does not affect the semantics. The invocation style is
largely transparent to the invokee and can be used to invoke both classic
components as well as [custom components](https://github.com/emberjs/rfcs/pull/213).

Since the original angle bracket RFC, we have worked on a few experimental
implementation of the feature, both and in Ember and Glimmer. These experiments
allowed us to attempt using the feature in real apps, and we have learned some
valuable insights throughout these usage.

The original RFC proposed using the `<foo-bar ...>` syntax, which is the same
syntax used by web components (custom elements). While Ember components and web
components share a few similarities, in practice, we find that there are enough
differences that causes the overload to be quite confusing for developers.

In addition, the code needed to render Ember components is quite different
from what is needed to render web components. If they share the same syntax,
the Glimmer template compiler will not be able to differentiate between the two
at build time, thus requiring a lot of extra runtime code to support the
"fallback" scenario.

In conclusion, the ideal syntax should be similar to HTML syntax so it doesn't
feel out of place, but different enough that developers and the compiler can
easier tell that they are not just regular HTML elements at a glance.

## Detailed design

### Tag Name

The first part of the angle bracket invocation syntax is the tag name. While
web components use the "dash rule" to distinguish from regular HTML elements,
we propose to use capital letters to distinguish Ember components from regular
HTML elements and web components.

The invocation `<FooBar />` is equivalent to `{{foo-bar}}`. The tag name will
be normalized using the `dasherize` function, which is the same rules used by
existing use cases, such as service injections. This allows existing components
to be invoked by the new syntax.

Another benefit of the capital letter rule is that we can now support component
names with a single word, such as `<Button>`, `<Modal>` and `<Tab>`.

> Note: Some day, we may want to explore a file system migration to remove the
> need for the normalization rule (i.e. also use capital case in filenames).
> However, that is out-of-scope for this RFC, as it would require taking into
> consideration existing code (like services), transition paths and codemods.

### Arguments

The next part of the invocation is passing arguments to the invoked component.
We propose to use the `@` syntax for this purpose. For example, the invocation
`<FooBar @foo=... @bar=... />` is equivalent to `{{foo-bar foo=... bar=...}}`.
This matches the [named arguments syntax](https://github.com/emberjs/rfcs/pull/276)
in the component template.

If the argument value is a constant string, it can appear verbatim after the
equal sign, i.e. `<FooBar @foo="some constant string" />`. Other values should
be enclosed in curlies, i.e. `<FooBar @foo={{123}} @bar={{this.bar}} />`.
Helpers can also be used, as in `<FooBar @foo={{capitalize this.bar}} />`.

#### Reserved Names

`@args`, `@arguments` and anything that does not start with a lowercase letter
(such as `@Foo`, `@0`, `@!` etc) are reserved names and cannot be used. These
restrictions may be relaxed in the future.

#### Positional Arguments

Positional arguments (`{{foo-bar "first" "second"}}`) are not supported.

### HTML Attributes

HTML attributes can be passed to the component using the regular HTML syntax.
For example, `<FooBar class="btn btn-large" role="button" />`. HTML attributes
can be interleaved with named arguments (it does not make any difference). This
is a new feature that is not available in the classic invocation style.

These attributes can be accessed from the component template with the new
`...attributes` syntax, which is available only in element positions, e.g.
`<div ...attributes />`. Using `...attributes` in any other positions, e.g.
`<div>{{...attributes}}</div>`, would be a syntax error. It can also be used on
multiple elements in the same template. If attributes are passed but the
component template does not contain `...attributes` (i.e. the invoker passed
some attributes, but the invokee does not take them), it will be a development
mode error.

It could be thought of that the attributes in the invocation side is stored in
an internal block, and `...attributes` is the syntax for yielding to this
internal block. Since the `yield` keyword is not available in element position,
a dedicated syntax is needed.

Classic components (`Ember.Component`) will implicitly have an `...attributes`
added to the end of the wrapper element (if `tagName` is not an empty string),
after any attributes added by the component itself (using `attributeBindings`,
`classNames` etc). This means that attributes provided by the caller will
override (replace) those added by the component (except for `class`, which is
merged).

### Block

A block can be passed to the invokee using the angle bracket invocation syntax.
For example, the invocation `<FooBar>some content</FooBar>` is equivalent to
`{{#foo-bar}}some content{{/foo-bar}}`. As with the classic invocation style,
this block will be accessible using the `{{yield}}` keyword, or the `@main`
named argument per the [named blocks RFC](https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md).

Block params are supported as well, i.e. `<FooBar as |foo bar|>...</FooBar>`.

There is no dedicated syntax for passing an "else" block directly. If needed,
that can be passed using the named blocks syntax.

### Closing Tag

The last piece of the angle bracket invocation syntax is the closing tag, which
is mandatory. The closing tag should match the tag name portion of the opening
tag exactly. If no block is passed, the self-closing tag syntax `<FooBar />`
can also be used (in which case `{{has-block}}` will be false).

### Dynamic Invocations

In additional to the static invocation described above (where the tag name is a
statically known component name), it is also possible to use the angle bracket
invocation syntax for dynamic invocations.

The most common use case is for invoking "contextual components", as shown in
the first example:

```hbs
<SuperSelect @selected={{this.user.country}} as |Option|>
  {{#each this.availableCountries as |country|}}
    <Option @value={{country}}>{{country.name}}</Option>
  {{/each}}
</SuperSelect>
```

Because `Option` is the name of a local variable (block param), the `<Option>`
invocation will invoke the yielded value instead of looking for a component
named "option".

Similar to curly invocations, most valid Handlebars path expressions are
invokable in this manner:

```hbs
{{!-- LOCAL VARIABLES --}}

{{#form-for model=user as |f|}}
  {{f.fieldset}}
    {{f.input name="username" type="text"}}
    {{f.input name="password" type="password" }}
  {{/f.fieldset}}

  {{!-- is equivilant to --}}

  <f.fieldset>
    <f.input @name="username" @type="text" />
    <f.input @name="password" @type="text" />
  </f.fieldset>
{{/form-for}}

{{!-- NAMED BLOCKS OR CURRIED COMPONENTS --}}

{{@content}}

{{!-- is equivilant to --}}

<@content />

{{!-- THIS LOOKUP --}}

{{#this.container}}
  {{this.child}}
{{/this.container}}

<this.container>
  <this.child />
</this.container>
```

> Note: The [named blocks RFC](https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md)
> proposed to use the `<@foo>...</@foo>` syntax on the invocation side to mean
> providing a block named `@foo`, which creates a conflict with this proposal.
> [RFC #317](https://github.com/emberjs/rfcs/pull/317) propose to change the
> block-passing syntax to `<@foo=>...</@foo>` to avoid this conflict.

Notably, based on the rules laid out above, the following is perfectly legal:

```hbs
{{!-- DON'T DO THIS --}}

{{#let (component "my-div") as |div|}}
  {{!-- here, <div /> referes to the local variable, not the HTML tag! --}}
  <div id="my-div" class="lol" />
{{/let}}
```

From a programming language's perspective, the semantics here is quite clear. A
local variable is allowed to override ("shadow") another variable on the outer
scope (the "global" scope, in this case), similar to what is possible in
JavaScript:

```js
let console = {
  log() {
    alert("I win!");
  }
};

console.log("Hello!"); // shows alert dialog instead of logging to the console
```

While this is semantically unambiguous, it is obviously very confusing to the
human reader, and we don't recommend anyone actually doing this.

A previous version of this RFC recommended statically disallowing these cases.
However, after giving it more thoughts, we realized it should not be the
programming language's job to dictate what are considered "good" programming
patterns. By statically disallowing arbitrary expressions, it actually makes it
more difficult to learn and understand the underlying programming model.

Instead, we recommend [including a template linter](https://github.com/ember-cli/rfcs/pull/114)
in the default stack and defer to the linter to make such recommendations. At
minimum, we recommend linting against invoking local variables with lowercase
names without a path segment, regardless of whether the name actually collide
with a known HTML tag – human readers of an Ember template should be able to
safely assume lowercase tags refer to HTML.

Eventually, we might want to provide stronger guidance with via the linter. For
example, we may want to recommend capitalizing invokable local variables, as in
`<F.Input />`. We will let the community experiment and coalesce around these
conventions before recommending them by default.

Finally, there are two exceptions to the general rule where certain technically
valid Handlebars path expressions are not supported for dynamic invocations:

* Implicit `this` lookups (a.k.a. "property fallback" in [RFC #308](https://github.com/emberjs/rfcs/pull/308)
* Slash lookups

First, while `{{foo}}` or `{{Foo}}` can normally refer to `{{this.foo}}` or
`{{this.Foo}}` normally, allowing this implicitly lookup will mean _any_ tag
in the template (i.e. `<foo />` or `<Foo />`) can possibly refer to a property
on the current `this` context.

This ambiguity is highly undesirable for both human readers and the compiler,
therefore implicitly `this` lookup is not allowed in angle bracket invocations.
This explicit form, `<this.foo />` and `<this.Foo />` is required.

This requirement aligns well with [RFC #308](https://github.com/emberjs/rfcs/pull/308)
and the current curly invocation semantics, due to the ["dot rule"](https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#component-helper-shorthand)
that requires a dot in the path. Note that this is actually more restrictive
than the proposed angle bracket invocation semantics, since it is not possible
to invoke a local variable without a dot:

```hbs
{{#super-select selected={{this.user.country}} as |option|>
  {{#each this.availableCountries as |country|}}
    {{!-- this is not legal today, since `option` does not contain a dot --}}
    {{#option value=country}}{{country.name}}{{/option}}
  {{/each}}
{{/super-select}}
```

We propose to relax that rule to match the proposed angle bracket invocation
semantics (i.e. allowing local variables without a dot, as well as `@names`,
but disallowing implicit `this` lookup).

Second, while Handlebars technically allows `{{foo/bar}}` as an equivalent
alternative to the `{{foo.bar}}` path lookup (and therefore `foo/bar` is
technically a valid Handlebars path expression), it will not be supported in
angle bracket invocation. This is both because the `/` conflicts with the HTML
closing tag syntax, and the fact that Ember overrides that syntax with a
different semantic.

In today's semantics, `{{foo/bar}}` does not try to lookup `this.foo.bar` and
invoke it as a component. Instead, it is used as a filesystem scoping syntax.
Since this feature will be rendered unnecessary with [Module Unification](https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md),
we recommend apps using "slash components" to migrate to alternatives provided
by Module Unification (or, alternatively, keep using curly invocations for this
purpose).

## How we teach this

Over time, we will switch to teaching angle bracket invocation as the primary
invocation style for components. The HTML-like syntax should make them feel
more familiar for new developers.

Classic invocation is here to stay – the ability to accept positional arguments
and "else" blocks makes them ideal for control-flow like components such as
`{{liquid-if}}`.

## Drawbacks

Because angle bracket invocation is designed for the future in mind, allowing
angle bracket invocations on classic components might introduce some temporary
incoherence (such as the interaction between the attributes passing feature and
the "inner HTML" semantics). However, in our opinion, the upside of allowing
incremental migration outweighs the cons.

## Alternatives

We could just stick with the classic invocation syntax.


---

---
stage: recommended
start-date: 2018-03-24T00:00:00.000Z
release-date: 2019-04-01T00:00:00.000Z
release-versions:
  ember-source: v3.9.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/318
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/23
---

# `array` helper

## Summary

This RFC proposes to add an `array` template helper for creating arrays in templates.

The helper would be invoked as `(array arg1 ... argN)` and return the value `[arg1, ..., argN]`. For example, `(array 'a' 'b' 'c')` would return the value `['a', 'b', 'c']`.


## Motivation

Objects (or hashes) and arrays are the two main data structures in JavaScript. Ember already has a `hash` helper for building objects, so it makes sense to also include an `array` helper for building arrays.

## Detailed design

The design is straightforward and mirrors the design of the `hash` helper. In particular, the important thing to note is that if any of the arguments to the `array` helper change then an entirely new array will be returned, rather than updating the existing array in place.

The implementation would also mirror the [implementation of the `hash` helper](https://github.com/emberjs/ember.js/blob/ec9f4e5e5f4099a77a73bc5a9aa41916f0d15d6d/packages/ember-glimmer/lib/helpers/hash.ts#L49-L51) and would simply capture the positional arguments instead.

## How we teach this

This helper is not an important part of the programming model and can just be mentioned in the [API docs](https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers) like its sibling the `hash` helper.

## Drawbacks

As usual, adding new helpers increases the surface area of the API and file size but in this case it is justified because the file size change is extremely small and its actually filling an existing hole in the API.

## Alternatives

This helper could be left to addons, and indeed there are addons that include this helper. It's also trivial to generate
your own `array` helper with `ember generate helper array`. Humorously, the default helper blueprint generates a helper that already acts like the `array` helper ;)

Nevertheless, I believe it's preferable to include this helper in Ember to fill the hole in Ember's API.


---

---
stage: recommended
start-date: 2018-03-24T00:00:00.000Z
release-date: 2018-07-16T00:00:00.000Z
release-versions:
  ember-source: v3.3.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/322
project-link:
---

# Deprecation of Ember.copy and Ember.Copyable

## Summary

This RFC recommends the deprecation and eventual removal of `Ember.copy` and the `Ember.Copyable` mixin.

## Motivation

A deep-copy mechanism is certainly useful, but it is a general JavaScript problem. Ember itself doesn't need to offer one, especially one that Ember itself isn't using internally. This function and its accompanying mixin arrived with SproutCore, a long time ago, and are not used by Ember itself, even though they currently reside in `@ember/object/internals`.

`ember-data` uses `Ember.copy` to do deep-copies. However, the `ember-data` team finds its needs would be better served by a private deep-copy mechanism that doesn't flow inadvertently through external interfaces into the `Ember.copy` methods of user-supplied objects. These interfaces are not designed to support deep copies of user-supplied data, and it can raise havoc in the form of hard-to-diagnose bugs, especially in test scenarios.

Since `ember` and `ember-data` do not intend to use this mechanism going forward, it would be better to remove it from the Ember codebase and extract it into an add-on for those who wish to continue to use it.

## Detailed design

There are four steps to deprecating any function:
* logging the deprecation in the call
* removal of calls to the function from ember and any add-ons that ship with ember-cli
* extraction to an add-on
* eventual removal of the feature in the stated release (in this case 4.0.0).

This RFC deprecates the `copy` function and `Copyable` mixin of `@ember/object/internals`.

Shallow copies of the form  `copy(x)`  or `copy(x, false)` can be replaced mechanically with `Object.assign({}, x)`. The simplest way to deal with deep copies in any situation depends upon the nature of the data involved.

### Current internal uses

#### `ember-source`

This following modules in `packages/ember-runtime/lib` implement the code being deprecated:

* `copy.js` contains the `copy()` function that will log the deprecation before executing,
* `mixins/copyable.js` provides the `Copyable` mixin, but it contains no executable code to deprecate.
* `mixins/array.js` - The `NativeArray` mixin extends the `Copyable` mixin and implements `copy()`.

The following tests in `packages/ember-runtime/tests` use the implementation above:

* `core/copy_test.js` tests the `copy()` method itself.
* `copyable-array/copy-test.js` tests the `copy()` method of a `NativeArray` for identical results.
* `helpers/array.js` provides the arrays used by the `NativeArray` test above.
* `system/native_array/copyable_suite_test.js` tests the independence of the results of deep copying a `NativeArray`

The route  `packages/ember-routing/lib/system/route.js` has one shallow copy, but the test  `packages/ember/tests/routing/decoupled_basic_test` is using deep copy.

The `copy()` methods in `packages/ember-metal/lib/map.js` and  `chains.js` and their use in `meta.js`, and  `map_test.js` are unrelated.

At present, the handling of arrays in `Ember.copy` is inconsistent. `NativeArray` uses the `Copyable` mixin and implements a `copy` method. When calling `Ember.copy`, passing a `NativeArray`, it will note that the passed parameter uses `Copyable` and call the copy method inside  `NativeArray`. However, the recursive `_copy` method that `Ember.copy` calls for other objects has its own generic mechanism for copying arrays. If `copy` is passed a non-`Copyable` object that contains a `NativeArray` as a member, when the recursion gets to that member, it will use the generic mechanism rather than delegating to the `copy` method within the  `NativeArray`.

The recursive  `_copy` method also has an assertion that will fail if it is called with any `EmberObject` that is not also `Copyable`. This assertion occurs before (and hence affects) the code which handles arrays, even though, for arrays, the object's `copy` method isn't then used.

During the deprecation period, the `Ember.copy` method and the `NativeArray.copy` methods will carry a deprecation warning. We will remove `Copyable` from `NativeArray` and change  `Ember.copy` to consistently use the common array copy mechanism to copy arrays rather than sometimes delegating. We will move the assertion that an `EmberObject` must be  `Copyable` to the clause that handles non-array objects.

We need a way to deprecate use of the `Copyable` mixin. If the penalty for adding code in such a common place isn't too high, we could have `core_object.extend()`  check for `Copyable` and deprecate accordingly. We will also supply a new eslint warning that flags the deprecated use of `Copyable`. (This may be our first eslint check for deprecations. We may want to consider adding others at the same time.)

Those using the add-on will need to mechanically adjust any uses of  `myArray.copy(deep)` to  `copy(myArray, deep)` in order to avoid the deprecation message.

At the end of this period, we will remove the deprecated copy() method, the Copyable mixin, and the deprecated NativeArray.copy() method.

#### `ember-data`

The following code in `ember-data` uses `copy()`, but only for shallow copies:
* `addon/-private/system/model/internal-model.js` - one use
* `addon/-private/system/snapshot.js` - two uses
* `addon/-private/system/store.js` - one use

All of the following uses in tests perform deep copies:
* `tests/integration/adapter/build-url-mixin-test.js` - two uses
* `tests/integration/adapter/rest-adapter-test.js` - two uses
* `tests/integration/store-test.js` - two uses
* `tests/unit/system/relationships/polymorphic-relationship-payloads-test.js` - four uses

The `copy()` methods referenced in `addon/-private/system.map.js` and  `addon/-private/system/relationships/state/relationship.js` are unrelated.

It would appear that deep copy is used within these packages only during testing, and generally to ensure fresh test data without side-effects.

### Current external uses

The key considerations for add-ons or apps looking for an alternative to copy() and Copyable are:
* Do they call `copy()` to do shallow copies or deep copies?
* If deep copies are being performed, are the objects involved POJOs or are they derived from `EmberObject`?
* Do they provide objects that use the `Copyable` mixin with `copy()` methods intended for use in deep copies by other classes?
* Is the data you are copying the sort of thing where you can do the copy in its behalf, or does it require collaboration from the object itself? Or are the contents so open-ended that you can't possibly know?

Shallow copies are directly supported by ES6. It's easy to perform recursive deep copies for most simple POJOs without delegating work to the object you are copying. For more complex data, you may need some kind of recursive delegation. `Copyable` is a delegation mechanism, and apps and add-ons that require delegation will probably want to use the proposed add-on.

The Code Search capabilities of emberobserver are a wonderful way to get a glimpse of how code in the wild is using particular features.

A quick search of the top-scoring add-on packages revealed that most, but by no means all, of the uses of `copy()` in the modules were for shallow copies that can be accomplished using Object.assign, so a lot of the code affected by this deprecation can rely on a simple substitution.

Very few packages used `Copyable` - only 9 across the whole set - and most used the feature for only one class.   `ember-data-copyable` is probably most wedded to the mechanism: it delivers a  `Copyable`-based mixin for asynchronous copying.  `ember-data-model-fragments` has pretty open-ended properties. These add-ons would be likely to use the proposed add-on moving forward.   `ember-restless`, and `ember-calendar` appear more bounded. Any deep copy mechanism for POJOs may meet their needs.

### Add-on

The add-on will supply the `copy()` function and the `Copyable` mixin based on the existing code, modified as indicated above for handling of arrays.

We could treat the add-on as the extraction of a feature from the monolithic `ember-source`, as was recently done for strings. If we choose to frame it in that way, the naming should follow the conventions set out for extracting elements of Ember into their own packages. If we choose not to frame it that way, then naming is one of the things this section should specify clearly.

## How we teach this

### Communication of change

We need to inform users that `Ember.copy` and `Ember.Copyable` will be dprecated and in what release it will occur. This notification should also point them to the add-on for those who need it.

### Official code bases and documentation

We do not actively teach the use of `Ember.copy`. It doesn't appear anywhere in our guides, website, or tutorial. Once it is gone from the code, we also need to verify it no longer appears in the API listings.

We must provide an entry in the deprecation guide for this change:
* describing the use of `to = Object.assign({},from)` for shallow copies.
* pointing out viable alternatives for deep copies.
* directing heavy users of deep copies to the addon.

## Drawbacks

The primary drawback is the API churn of people pulling it out of their code. However, for most uses, the change will be straightforward, and the add-on will be available for the foreseeable future for those who want to continue with the implementation.

## Alternatives

We could simply leave it in place as a utility for others to use. Even then, it would make sense to split it out into its own module, as has already been done for strings, so the work would be much the same.

## Unresolved questions

None at the moment...




---

---
stage: recommended
start-date: 2018-03-28T00:00:00.000Z
release-date: 2019-12-09T00:00:00.000Z
release-versions:
  ember-source: v3.15.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/324
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/22
---

# Summary

The aim of this RFC is to deprecate the component's `isVisible` property.
It is not used by Ember internally and left undefined unless manually set.
It's poorly documented and component visibility it better managed in
template space rather than JS.

# Motivation

Setting the isVisible property on a component instance as a way to toggle
the visibility of the component is confusing. The majority of its usage
predates even Ember 1.0.0, and modern Ember applications already completely
avoid using isVisible in favor of simpler conditionals in the template
space.

In addition, when `isVisible` is used today it often introduces subtle (and
difficult to track down) bugs due to its interaction with the `style`
attribute (toggling `isVisible` clobbers any existing content in `style`).

Simply put, removing `isVisible` will reduce confusion amongst users.

# Transition Path

Whenever `isVisible` is used a deprecation will be issued with a link to
the deprecation guide explaining the deprecation and how to refactor in order
to avoid it.

Given that `Component#isVisible` is a public API, deprecating now would
schedule for removal in the next major version release (4.0).

There are several options available to hiding elements
such as `<div hidden={{boolean}}></div>`(hidden is valid for all elements
and is semantically correct) or wrapping the component in a template
conditional `{{#if}}` statement. Components `classNames` and `classNameBindings`
could also be used to add hidden classes.

# How We Teach This

The `isVisible` property is rarely used, the deprecation along with a mention
in a future blog post would be sufficient.

We should consider adding documentation on hiding components to the Ember
guides with the conditional handlebar helper or via the widely supported `hidden`
attribute.

```hbs
{{#if showComponent}}
  {{component}}
{{/if}}

{{! or }}
<div hidden={{isHidden}}></div>
```

# Alternatives

An alternative option would be to to keep `isVisible`.


---

---
stage: recommended
start-date: 2018-04-18T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/326
project-link:
---

# Ember Data Filter Deprecation

## Summary

Deprecate the `store.filter` API. This API was previously gated
behind a private `ENV` variable that was enabled by the addon
[`ember-data-filter`](https://github.com/ember-data/ember-data-filter/tree/b62c992186c00dce8cc81f1fb0cf5e2e6fee0f6b#ember-data-filter).

## Motivation

The `filter` API was a "memory leak by design". [Patterns exist](https://github.com/ember-data/ember-data-filter#recommended-refactor-guide)
with no-worse ergonomics that have better performance and do not incur memory leak penalties.

While the change in ergonomics for end consumers in minimal, the change to `ember-data` is substantial.
The code for this feature required significant amounts of confusing internal plumbing to ensure that
filters were rerun every time any form of mutation (update, addition, deletion) occurred to any record.

In addition to maintenance costs, this plumbing negatively affects the performance of all `RecordArray`s,
 and slow any operations that count as mutations (such as pushing new records into the store).

By removing this feature, we significantly simplify and streamline the core of `Ember Data`.

## Detailed design

We will provide 3 new deprecations with links to a [guide on how to refactor](https://github.com/ember-data/ember-data-filter#recommended-refactor-guide).
These deprecations will target `3.5`, meaning that the `ember-data-filter` addon will continue to
work and be supported through the release of ember-data `3.4`.

**Deprecation: ember-data-filter:filter**

Deprecate the primary case (`store.filter('posts', filterFn)`).
Instead, users can combine `store.peekAll` with a computed property.

**Deprecation: ember-data-filter:query-for-filter**

This deprecation is specific to folks providing a `query` to be requested the
first time a filter is run. To do this better, users can separate their usage
of `filter` from their usage of `query`.

**Deprecation: ember-data-filter:empty-filter**

In the case that users were creating a `filter` with no method for filtering by,
a deprecation is printed letting them know that the easiest path forward is to
use `peekAll`, which would return the same record result set.

## How we teach this

The `filter` API is rarely used, having been discouraged for many years. A simple post
 alerting users to it's deprecation should be sufficient. The refactoring guide is
 sufficiently simple that teaching folks a better way should not be much of a hurdle.

## Drawbacks

Minor churn for folks that did use this API; however, the end result will improve the
performance of apps using filters more so than anyone else.

## Alternatives

There's been some talk of an API for local querying; however, said alternative RFC
 would only result in deprecating this API as well.

## Unresolved questions

None


---

---
stage: recommended
start-date: 2018-05-01T00:00:00.000Z
release-date: 2019-09-20T00:00:00.000Z
release-versions:
  ember-data: v3.13.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/329
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/21
---

# Deprecate Usage of Ember Evented in Ember Data

## Summary

`Ember.Evented` functionality on `DS.Model`, `DS.ManyArray`,
`DS.Errors`, `DS.RecordArray`, and `DS.PromiseManyArray` will be
deprecated and eventually removed in a future release. This includes
the following methods from the
[Ember.Evented](https://www.emberjs.com/api/ember/2.15/classes/Ember.Evented/methods/on?anchor=off)
class: `has`, `off`, `on`, `one`, and `trigger`. Additionally the
following lifecycle methods on `DS.Model` will also be deprecated:
`becameError`, `becameInvalid`, `didCreate`, `didDelete`, `didLoad`,
`didUpdate`, `ready`, `rolledBack`.

## Motivation

The use of `Ember.Evented` is mostly a legacy from the pre 1.0 days of
Ember Data when events were a core part of the Ember Data programming
model. Today there are better ways to do everything that once needed
events. Removing the usage of the `Ember.Evented` mixin will make it
easier for Ember Data to eventually transition to using native ES2015
JavaScript classes and will reduce the surface area of APIs that Ember
Data must support in the long term.

## Detailed design

`Ember.Evented` mixin will be scheduled to be removed from the
following classes in a future Ember Data release: `DS.Model`,
`DS.ManyArray`, `DS.Errors`, `DS.RecordArray`, and
`DS.PromiseManyArray`.

The `has`, `off`, `on`, `one`, and `trigger` methods will be trigger a
deprecation warning when called and will be completly in a future
Ember Data release.

A special deprecation will be logged when users of a
`DS.adapterPopulatedRecordArray` attempt to listen to the `didLoad`
event. This depecations will prompt users to use a computed property
instead of the `didLoad` event.

`DS.Model` will also recieve deprecation warnings when a model is
defined with the following methods: `becameError`, `becameInvalid`,
`didCreate`, `didDelete`, `didLoad`, `didUpdate`, `ready`,
`rolledBack`.

When a model is instantiated for the first time with any of these
methods a deprecation warning will be logged notifiying the user that
this method will be deprecated and the user should use an computed or
overide the model's init method instead.

## How we teach this

Today we do not teach the use of any of the Ember Data lifecycle
events in the guides. They are referenced in the API docs but they
will be updated to mark the APIs as deprecated and show alternative
examples of how to achieve the same functionality using a non event
pattern.

The deprecation guide app will be updated with examples showing how to
migrate away from an evented pattern to using a computed or imperative
method to achieve the same results.

## Drawbacks

The drawback to making this change is existing code that takes
advantage of the Ember Data lifecycle events will need to be updated
to use a different pattern.

## Alternatives

We could leave the `Ember.Evented` mixin on all of the Ember Data
objects that currently support it and continue to support this
interface for the foreseeable future. However, Ember Data itself
doesn't require these events internally. There is only one place in
the `DS.Error` code that takes advantage of the `Ember.Evented` system
and that code can be easilly re-written to avoid `Ember.Evented` APIs.

## Unresolved questions

None


---

---
stage: recommended
start-date: 2018-05-08T00:00:00.000Z
release-date: 2020-01-20T00:00:00.000Z
release-versions:
  ember-source: v3.16.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/331
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/20
---

# Summary

Deprecate all use of:

- Ember Globals Resolver (looks up a class via a global namespace such as "App")
- Creation of a Global Namespace (`var App = Ember.Namespace.create();`)
- Ember.TEMPLATES array
- &lt;script type="text/handlebars" data-template-name="path/to/template"&gt;

Use of any of the above should trigger a deprecation warning, with a target
of version 4.0

# Motivation

Over the past years we have transitioned to using Ember-CLI as the main way
to compile Ember apps. The globals resolver is a holdover and primarily
facilitates use of Ember without Ember-CLI.

# The Globals Resolver

For those who are not aware, the globals resolver is available via `@ember/globals-resolver` or
`Ember.DefaultResolver`. For more information, see the
[api](https://www.emberjs.com/api/ember/release/classes/GlobalsResolver/properties).
Using it looks like the following:

```js
// app.js
var App = Ember.Application.create();

App.Router.map(function() {
  this.route('about');
});

App.AboutRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});
```

```html
// index.html
<script type="text/x-handlebars" data-template-name="about">
  <ul>
    {{#each model as |item|}}
      <li>{{item}}</li>
    {{/each}}
  </ul>
</script>
```

# Implementation Details

One small detail required to implement this RFC: ember-cli's own default resolver,
[ember-resolver](https://github.com/ember-cli/ember-resolver)
currently still extends from the globals resolver.
In order to implement this RFC, the ember-cli resolver will need to be changed
so that it does *not* extend from the globals resolver, or otherwise ember-cli users
will get a deprecation warning as well.
However, changing the base class of the ember cli classic resolver is a breaking change,
so prior to ember/ember-cli version 4.0 we need to take another step.
In the ember-cli classic resolver, deprecate any runtime calls where there is fallback to the globals mode resolver. This would be a deprecation in ember-cli's resolver. We could bump a major version of ember-cli-resolver removing the base class and release it in ember-cli after an LTS of ember-cli.

# Transition Path

Primarily, the transition path is to recommend using Ember-CLI.

During the 3.x timeframe, it MAY become increasingly difficult to use this old functionality.
For example, with the release of 3.0, we already stopped publishing builds that support
globals mode. Here are some of the changes that have impacted or may soon impact users of globals mode:

## Impact of ES6 modules

Users of ES6 modules must use their own build tooling to convert them to named AMD modules via Babel.
No support is provided for &lt;script type="module"&gt; at this time, although that may change.

## Impact of New Module Imports

Globals based apps are only able to use new module imports via the polyfill available at
https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill No build support for this is provided.

## Impact of not publishing globals builds

It is necessary to get a globals build of Ember.js from the npm package now that globals builds
are no longer published to S3, builds.emberjs.com, and CDNs.

## Impact of not Generating a Globals Build in Ember.js Package

At some point during the 3.x cycle, it may be that we no longer publish a globals build in the
npm package. At that point, it may become necessary to use Ember-CLI to generate a globals build
of Ember.js

## Impact of Package Splitting

Work has started on package splitting. It is likely that the globals resolver may not be included
in a default partial build of Ember.js and may be moved to its own package for easy removal.

## Impact of Tree Shaking

If the globals resolver is moved to a separate package, it will likely not be included in a build
of Ember.js by default unless tree shaking is turned off.

# How We Teach This

We already do teach this and don't teach the globals resolver. No changes required here.

## Deprecation Guide

A draft deprecation guide has been pull requested at https://github.com/ember-learn/deprecation-app/pull/155

# Drawbacks

A drawback is that people may want alternate build tooling to Ember-CLI.
We have mitigated this by openly publishing the ember-cli resolver and all parts of the
ember-cli ecosystem under the MIT license.
Alternate build tooling may simply use this open source code to build a competing
infrastructure to ember-cli.

# Alternatives

Without doing this, we will have to continue to ship and maintain this rarely used functionality.
We don't believe this is a reasonable alternative.

# Unresolved questions

There has never been a transition guide for transitioning an old codebase to Ember-CLI.
Do we want to create one at this late date?


---

---
stage: accepted # FIXME: Appears to be at least partially released in v3.15
start-date: 2018-10-24T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/332
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/19
---

# Ember Data Record Links & Meta

## Summary

Enable users to associate `links` and `meta` information with individual records
  in a manner accessible via the template.

## Motivation

Sometimes users have meta or links information to associate with a specific record.
Users of the `json-api` specification will commonly understand this information as
belonging to an individual `resource`.

While `ember-data` allows for this information to exist on relationships, it does
 not allow for it to exist on records, which has to this point been a glaring omission
 for users of `json-api` and similar specifications.

## Detailed design

In keeping with the current design of the `store.push` API which expects the `json-api` format,
users would include optional `meta` and `links` information as member properties of a resource.

```js
store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {},
    meta: {
      // ... <any>
    },
    links: {
      self: './person/1', // ... <String>
    }
  }
});
```

--------------------------------

`links` and `meta` will be accepted anywhere a `resource` may be encountered in a payload.

```js
store.push({
  data: [
    {
      type: 'contributor',
      id: '1',
      attributes: {},
      relationships: {
        projects: {
          data: [
            { type: 'project', id: '1' }
          ]
        }
      },
      meta: {
        // ... <any>
      },
      links: {
        self: './person/1', // ... <String>
      }
    }
  ],
  included: [
    {
      type: 'project',
      id: '1',
      attributes: {},
      relationships: {
        contributors: {
          data: [
            { type: 'contributor', id: '1' }
          ]
        }
      },
      meta: {
        // ... <any>
      },
      links: {
        self: './github-projects/1', // ... <String>
      }
    }
  ]
})
```

--------------------------------

Links & Meta on objects used as `ResourceIdentifiers` (e.g. to link to another resource within a relationship)
 will not be used for the associated resource and will be silently ignored.

```js
let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',
            meta: {}, // ignored
            links: {} // ignored
          }
        ]
      }
    },
  }
});
```
--------------------------------

Links & Meta on objects provided for `Relationships` will continue to work (as they do today).

```js
let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',
          }
        ],
        meta: {}, // available on the Record's hasMany relationship
        links: {} // available on the Record's hasMany relationship
      }
    },
  }
});
```
--------------------------------

`links` and `meta` properties will be exposed as getters on instances of `DS.Model` and will default to `null` if
no `meta` or `links` have been provided.

```js
let record = store.push({
  data: {
    type: 'person',
    id: '1',
    attributes: { name: '@runspired' },
    meta: {
      expiresDate: '2018-05-10'
    },
    links: {
      self: './people/runspired'
    }
  }
});

record.meta.expiresDate; // '2018-05-10'
record.links.self; // './people/runspired'
```

--------------------------------

`links` and `meta` will similarly be exposed as on instances of `Snapshot` given to
adapter and serializer methods. In keeping with `Snapshot#attributes()`, they will
be exposed as methods.  Should users desire to reload a record via link, they could
achieve such by utilizing the `links()` method to check for a link when making a request.

```js
class Snapshot {
  links() {}
  meta() {}
}
```

--------------------------------

#### The shared namespace problem and interop with existing workaround for `links` and `meta`.

The `json-api` spec places `type`, `id`, and all members of `attributes` and `relationships` into
a single shared flattened namespace.  This flattened namespace is what `records` expose.

The spec does not put `links` and `meta` into this namespace, and it is valid to have `links` and `meta`
as member names of either `attributes` or `relationships`.

Some apps have taken advantage of this to move `links` and `meta` into `attributes` on their serializer
and to expose them via `DS.attr` on their records.

The `getter` we are proposing adding to `DS.Model` would be overwriteable. In the case that there is a
 conflict, the version defined by the end user model would win. It would be up to consuming apps to
 decide whether they wish to avoid this conflict by renaming the non-resource `links` and `meta` either
 in their serializer or in their API responses.

## How we teach this

Documentation for `DS.Model` should be updated to reflect these properties, the potential conflict
 (and the default conflict resolution) explained in said documentation, and guides on working with
 Models should reflect this capability.

## Drawbacks

Users may sometimes encounter confusion when `links` or `meta` is a member of attributes or
relationships.

## Alternatives

- Rename `links` and `meta` to a name less likely to collide and which we fully reserve, such as
`recordLinks` and `recordMeta`. We felt this would be confusing.

- Enforce accessing `links` and `meta` via some other object such as the `Reference` API. In addition
  to being cumbersome and confusing, this would lack discoverability and be unergonomic in templates.

- Enforce accessing `links` and `meta` via some imported helper, e.g. `recordMetaFor(record)` or `recordLinksFor(record)`.
  We felt this would be confusing and unergonomic for templates.

## Unresolved questions

None


---

---
stage: accepted
start-date: 2018-05-22T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/334
project-link:
---

# Deprecate Ember Utils & dependent Computed Properties

## Summary

This RFC proposes the deprecation of the following [methods](https://api.emberjs.com/ember/4.4/modules/@ember%2Futils):
- `compare`
- `isBlank`
- `isEmpty`
- `isEqual`
- `isNone`
- `isPresent`
- `typeOf`

As well as [computed properties](http://api.emberjs.com/ember/4.4/modules/@ember%2Fobject#functions-computed) that rely on these methods:
- `notEmpty`
- `empty`
- `none`

Once deprecated, these methods will move to an external addon to allow users to still take advantage of the succinctness these utility methods provide.

## Motivation

To further Ember's goal of a svelte core and moving functionality to separate packages, this RFC attempts to deprecate a few utility methods and extract them to their own addon.  A part from the aforementioned goal, in many cases, these utility methods do not add a whole lot of value over writing plain old JavaScript.  Moreover, these methods generally have a negative cognitive impact on the code in question.  In order to reduce code liability and advocate for users to write plain JavaScript, these methods could be removed from Ember core and extracted to an addon.

A simple example of this cognitive load would be checking for the presence of a variable of type String that can only have four states - `undefined`, `null`, `''` or `'MYSTRING'`.  One might check if the variable is truthy with `!!myVariable`.  However, a utility method such as `isPresent(myVariable)` can increase the cognitive load of the truthy check in question as it checks for many different types.

In addition, when checking whether a primitive value is truthy, a user can choose from `isPresent`, `isBlank`, `isNone`, or `isEmpty`.  This can can lead to some confusion for users as there are many options to do the same thing.

Lastly, `isEmpty` documented [here](https://www.emberjs.com/api/ember/release/functions/@ember%2Futils/isEmpty) will return false for an empty object.  Defining what an empty object is can be a bit tricky and `isEmpty` provided specific semantics that may not fit a users definition.  This problem of specific semantics not fitting a users definition also applies to the other utility methods as well.

## Detailed design

`compare`, `isBlank`, `isEmpty`, `isEqual`, `isNone`, `isPresent`, `typeOf`, `notEmpty`, `empty`, and `none` will be deprecated at first with an addon that extracts these methods for users that still find value in these utility methods.  Any instantiation of one of these functions imported from `@ember/utils` will log a deprecation warning, notifying the user that this method is deprecated and provide a link to the supported addon.

Addons that previously relied on these utility methods would also be expected to install this package. Moreover, to ease adoption of the external addon, a codemod will become available for the community.

## How we teach this

ES5/ES6 brings improved language semantics. Moreover, using Ember in IE9, IE10, and PhantomJS is not supported as of Ember 3.0.  As a result, we as a community can guarantee results across browsers when using just JavaScript.  Some of the benefits from these utility methods eminated from a need to guarantee results with ES3 browsers.  Today, we can nudge users to use JavaScript where needed and install an addon in cases where they feel it is necessary.

This would require an update to the guides to indicate that the use of any of these utility methods are now available in an addon.  Moreover, in the README of the addon, we can provide specific examples of when using JavaScript is easier than reaching for one of these utility methods.

```js
// Current state
import { isEmpty } from '@ember/utils';

function isTomster(attributes) {
  if (isEmpty(attributes)) {
    return false;
  }
}
```

If you prefer to install the addon directly, we will provide a codemod to update the import path.

```js
// With an addon
import { isEmpty } from 'ember-utils';

function isTomster(attributes: any): boolean {
  if (isEmpty(attributes)) {
    return false;
  }
}
```

However, depending on the source data, this logic can be migrated to the following. Let us assume the shape of attributes is an object:

```js
function isTomster(attributes?: Record<string, any>): boolean {
  if (!attributes || Object.keys(attributes).length === 0) {
    return false;
  }
}
```

If it is an array:

```js
function isTomster(attributes?: Array<string>): boolean {
  if (!attributes || attributes.length === 0) {
    return false;
  }
}
```

Lastly, the guides can also point users to a utility library like [lodash](https://lodash.com/docs).

For many existing codebases, it should be as simple as installing the extracted addon and running the codemod.  However, users not utilizing these methods will not have these methods bundled by default.

## Deprecation Guide

### compare

Install and import `ember-util` to `compare` two types.
until: 5.0.0
id: use-ember-util-package--compare

```js
import { compare } from '@ember/util';

compare(['code'], ['code', 'is', 'lovely']); // -1
compare(['code'], ['code']); // 0
compare(['code'], []); // 1
```

To avoid the `compare` deprecation, you can install the `ember-util` package and do the following

```js
import { compare } from 'ember-util';

compare(['code'], ['code', 'is', 'lovely']); // -1
compare(['code'], ['code']); // 0
compare(['code'], []); // 1
```

### isBlank

Install and import `ember-util` to check `isBlank` status.
until: 5.0.0
id: use-ember-util-package--isBlank

```js
import { isBlank } from '@ember/util';

isBlank(['code']); // false
isBlank([]); // true
```

To avoid the `isBlank` deprecation, you can install the `ember-util` package and do the following

```js
import { isBlank } from 'ember-util';

isBlank(['code']); // false
isBlank([]); // true
```

### isEmpty

Install and import `ember-util` to check `isEmpty` status.
until: 5.0.0
id: use-ember-util-package--isEmpty

```js
import { isEmpty } from '@ember/util';

isEmpty(['code']); // false
isEmpty([]); // true
```

To avoid the `isEmpty` deprecation, you can install the `ember-util` package and do the following

```js
import { isEmpty } from 'ember-util';

isEmpty(['code']); // false
isEmpty([]); // true
```

### isEqual

Install and import `ember-util` to check `isEqual` status.
until: 5.0.0
id: use-ember-util-package--isEqual

```js
import { isEqual } from '@ember/util';

isEqual({}, { a: 'key' }); // false
isEqual({ a: 'key' }, { a: 'key' }); // true
isEqual(['code'], ['code']); // false
```

To avoid the `isEqual` deprecation, you can install the `ember-util` package and do the following

```js
import { isEqual } from 'ember-util';

isEqual({}, { a: 'key' }); // false
isEqual({ a: 'key' }, { a: 'key' }); // true
isEqual(['code'], ['code']); // false
```

### isNone

Install and import `ember-util` to check `isNone` status.
until: 5.0.0
id: use-ember-util-package--isNone

```js
import { isNone } from '@ember/util';

isNone(undefined); // true
isNone([]); // false
isNone(''); // false
```

To avoid the `isNone` deprecation, you can install the `ember-util` package and do the following

```js
import { isNone } from 'ember-util';

isNone(undefined); // true
isNone([]); // false
isNone(''); // false
```

### isPresent

Install and import `ember-util` to check `isPresent` status.
until: 5.0.0
id: use-ember-util-package--isPresent

```js
import { isPresent } from '@ember/util';

isPresent(undefined); // false
isPresent([]); // false
isPresent('hi der'); // true
```

To avoid the `isPresent` deprecation, you can install the `ember-util` package and do the following

```js
import { isPresent } from 'ember-util';

isPresent(undefined); // false
isPresent([]); // false
isPresent('hi der'); // true
```

### typeOf

Install and import `ember-util` to check `typeOf` on an input.
until: 5.0.0
id: use-ember-util-package--typeOf

```js
import { typeOf } from '@ember/util';

let noop = () => {};
typeOf(noop); // 'function'
```

To avoid the `typeOf` deprecation, you can install the `ember-util` package and do the following

```js
import { typeOf } from 'ember-util';

let noop = () => {};
typeOf(noop); // 'function'
```

### notEmpty

Install and import `ember-util` to check `notEmpty` on a property.
until: 5.0.0
id: use-ember-util-package--notEmpty

```js
import { notEmpty } from '@ember/object/computed';

class ToDoList {
  constructor(todos) {
    set(this, 'todos', todos);
  }

  @notEmpty('args.todos') isDone;
}
```

To avoid the `notEmpty` deprecation, you can install the `ember-util` package and do the following

```js
import { notEmpty } from 'ember-util';

class ToDoList {
  constructor(todos) {
    set(this, 'todos', todos);
  }

  @notEmpty('todos') isDone;
}
```

### empty

Install and import `ember-util` to check `empty` on a property.
until: 5.0.0
id: use-ember-util-package--empty

```js
import { empty } from '@ember/object/computed';

class ToDoList {
  constructor(todos) {
    set(this, 'todos', todos);
  }

  @empty('todos') isDone;
}
```

To avoid the `empty` deprecation, you can install the `ember-util` package and do the following

```js
import { empty } from 'ember-util';

class ToDoList {
  constructor(todos) {
    set(this, 'todos', todos);
  }

  @empty('todos') isDone;
}
```

### none

Install and import `ember-util` to check `none` on a property.
until: 5.0.0
id: use-ember-util-package--none

```js
import { none } from '@ember/object/computed';

class ToDoList {
  @none('args.todos') isDone;
}
```

To avoid the `none` deprecation, you can install the `ember-util` package and do the following

```js
import { none } from 'ember-util';

class ToDoList {
  @none('args.todos') isDone;
}
```

## Drawbacks

This change may impact quite a few codebases.  Moreover, users who heavily rely on these utility methods will have to install another addon.  Some users may desire this functionality out of the box.

Given the example above, some users see a lot of value for the safety checks `isPresent(myVariable)` provides.  The type of variable could be of type String or of type Object and wiring this up to check manually is laborious.

## Alternatives

Another option would be to improve existing utility cases such as `isEmpty({}) === true`.  Moreover, we could also consider scoping existing utility methods to specific types. For example, `isEmpty` would be specific to checking objects, collections, maps or sets to reduce confusion of when these utility methods should be used.

Instead of deprecating the `notEmpty`, `empty`, `none` computed macros one-by-one, it would probably be good to deprecate the entire `@ember/object/computed` module because everything else in there is not aligned with current idioms.

## Unresolved questions



---

---
stage: recommended
start-date: 2018-05-29T00:00:00.000Z
release-date: 2018-08-27T00:00:00.000Z
release-versions:
  ember-source: v3.4.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/335
project-link:
---

# Deprecate `.sendAction`

## Summary

In old versions of Ember (< 1.13) `component#sendAction` was the only way for a component to call an
action on a parent scope. In 1.13 with the so called _closure actions_ a more intuitive and flexible
way of calling actions was introduced, yielding the old way redundant.

## Motivation

With the new _closure actions_ being the recommended way, `component#sendAction` is not even
mentioned in the guides.
With the goal of simplifying the framework I think we should remove what is not considered the
current best practice.
_Closure actions_ have been available since 1.13. That is 3 years ago, so deprecating `sendAction`
should not cause too much pain and yet addons can support still support the last version of the 1.X
cycle if they really want to.

It is out of the scope of this RFC to enumerate the reasons why _closure actions_ are preferred over
_sendAction_ but you can find an in depth explanation of _closure actions_ in [this blog post from 2016](http://miguelcamba.com/blog/2016/01/24/ember-closure-actions-in-depth).

## Detailed design

A deprecation message will appear when `sendAction` is invoked. The feature will be removed in
Ember 4.0. The deprecation message will use the arguments passed to `sendAction` to generate a dynamic
explanation that will make super-easy for developers to migrate to closure actions.

As it is mandatory with new deprecations, a new entry in the deprecation guides will be added
explaining the migration path in depth.

To refresh what the migration path would look like in the typical use case.

**BEFORE**
```js
// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
```

```hbs
{{!-- parent-component.hbs --}}
{{child-component salute="sayHi"}}
```

```js
// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.sendAction('salute');
    }
  }
});
```

```hbs
{{!-- child-component.hbs --}}
<button {{action "sendSalute"}}>Send salute</button>
```

**AFTER**
```js
// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
```

```hbs
{{!-- parent-component.hbs --}}
{{child-component salute=(action "sayHi")}}
```

```js
// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.salute();
      // if the salute action is optional you'll have to guard in case it's undefined:
      // if (this.salute) {
      //   this.salute()
      // }
      //
      // Alternatively, you can also define a noop salute function:
      // salute() {}
      //
      // This allows you to remove the guard while provinding an obvious place to add
      // docs for that action.
    }
  }
});
```

```hbs
{{!-- child-component.hbs --}}
<button {{action "sendSalute"}}>Send salute</button>
```

However _closure actions_ allow to be less verbose, so the same behavior could be attained using
less intermediate calls

```js
// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
```

```hbs
{{!-- parent-component.hbs --}}
{{child-component salute=(action "sayHi")}}
```

```hbs
{{!-- child-component.hbs --}}
<button onclick={{@salute}}>Send salute</button>
```

## How we teach this

There are no new concepts to teach, but the removal of an old concept now considered outdated.

## Drawbacks

There might be some churn following the deprecation, specially comming from addons that haven't been
updated in a while.
Addons that want to support the latest versions of Ember without deprecation messages and still work
past Ember 1.13 will have to do some gymnastics to do so.

## Alternatives

Wait longer to deprecate it and keep `sendAction` undocumented until it's usage is yet more minoritary
than it is today, to lower the churn.



---

---
stage: recommended
start-date: 2018-06-14T00:00:00.000Z
release-date: 2018-12-06T00:00:00.000Z
release-versions:
  ember-source: v3.6.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/337
project-link:
meta:
  ember-issue: https://github.com/emberjs/ember.js/pull/16795
---

# Native Class Constructor Update

## Summary

Update the behavior of EmberObject's constructor to defer object
initialization.

## Motivation

Using native class syntax with EmberObject has almost reached full feature
parity, meaning soon we'll be able to ship native classes and begin recommending
them. This will do wonders for the Ember learning story, and will bring us in
line with the wider Javascript community.

However, early adopters of native classes have experienced some serious
ergonomic issues due to the current behavior of the class constructor. The issue
is caused by the fact that properties passed to `EmberObject.create` are
assigned to the instance in the root class `constructor`. Due to the way that
native class fields work, this means that they are assigned _before_ any
subclasses' fields are assigned, causing subclass fields to overwrite any value
passed to `create`:

```js
class Foo extends EmberObject {
  bar = 'baz';
}

let foo = Foo.create({ bar: 'something different' });

console.log(foo.bar); // 'baz'
```

This has made adoption very difficult, and is a consistent stumbling block for
new users of native class syntax in Ember. Worse yet, it makes writing a codemod
for converting to native class syntax very difficult because we don't have a
clear target.

For instance, given the above class, how would we convert the class field? Let's
go through the various options:

```js
class Foo extends EmberObject {
  // Does not work, for the reasons described above
  bar = 'baz';

  // Does not cover all cases. If we did `Foo.create({ bar: false })` it would
  // still assign the default.
  bar = this.bar || 'baz';

  // This works, but is very verbose and not ideal
  bar = this.hasOwnProperty('bar') ? this.bar : 'baz';

  // This is one of the community accepted solutions, but it requires lodash
  bar = _.defaultTo(this.bar, 'baz');

  // This is another community accepted solution, but it requires
  // @ember-decorators/argument, which is a separate library
  @argument foo = 'bar';
}
```

None of these is ideal. Instead, we can change the behavior of the constructor
and the `create` method to circumvent this issue.

This change _would_ be a breaking change to the behavior of native classes
today, and a change from the previous class RFC. This will impact early adopters
and should be made with that in mind. It would _not_ be a change that breaks the
behavior of the community solutions to class fields mentioned above, and all
other changes would be relatively easy to create a safe codemod for (essentially
converting `constructor` -> `init` in affected classes), so the impact _should_
be minimal.

Because native classes never officially shipped as part of Ember's public API
(an announcement was not made, docs have not been written, etc), this RFC
proposes that the change would _not_ be considered a breaking change _for the
purposes of semver_. This would allow us to ship the change during the Ember v3
release cycle, and prevent more code from being built on top of the previous
behavior.

## Detailed design

One very important design constraint to making this change is that we _cannot_
break the behavior of EmberObject when used _without_ native classes. To do
this, we will leverage the fact that the static `create` method is the only
public way to create an instance of EmberObject.

Currently, the behavior of EmberObject is the following (simplified):

```js
class EmberObject {
  constructor(props) {
    // ..class setup things

    Object.assign(this, props);
    this.init();
  }

  static create(props) {
    let instance = new this(props);

    return instance;
  }
}
```

We can change it to the following (simplified):

```js
class EmberObject {
  constructor(props) {
    // ..class setup things
  }

  static create(props) {
    let instance = new this(props);

    Object.assign(instance, props);
    instance.init();

    return instance;
  }
}
```

This would assign the properties _after_ all of the class fields for any
subclasses have been assigned. Revisiting our previous example, the following
two class declarations would effectively be equivalent:

```js
const Foo = EmberObject.extend({
  bar: 'baz'
});

class Foo extends EmberObject {
  bar = 'baz';
}
```

Much easier to codemod! There are other subtle differences between native class
fields and EmberObject properties, such as the fact that class fields are
assigned each time a class is initialized, but these are easier to work around.

### Injections and the `init` hook

One side effect of this change is that injections will not be available on the
class instance during the `constructor` phase. This behavior is not very
commonly used - based on an informal community survey we found only a few usages
\- but it _does_ exist and have its use cases.

Figuring out the ideal behavior of injections during the constructor phase is
outside of the scope of this RFC, and is something that should be discussed in
future RFCs. For the time being, users can still rely on the `init` hook, which
will continue to be called after all injections and properties have been
assigned to the instance.

### `new EmberObject()`

It was previously possible to use `new` syntax with EmberObject. While this
was not considered public API, it has technically worked and been under test
since the early days of Ember, and may fall under the category of intimate API.
Ideally, we would deprecate this usage as a private/intimate API, which would
mean supporting it through the next LTS version, and dropping support after
(currently, this would mean dropping it at `v3.5.0`).

We can continue to support this behavior in a backwards compatible way while
deprecating it with one final tweak to the change above:

```js
const DEFER_INIT = new Symbol();

function initialize(instance, props) {
  Object.assign(instance, props);
  instance.init();
}

class EmberObject {
  constructor(props, maybeDefer) {
    // ..class setup things

    if (maybeDefer === DEFER_INIT) {
       return this;
    }

    deprecate('using `new` with EmberObject has been deprecated. Please use `create` instead.', false, {
      id: 'object.new-constructor',
      until: '3.5.0'
    });

    initialize(this, props);
  }

  static create(props) {
    let instance = new this(props, DEFER_INIT);
    initialize(instance, props);

    return instance;
  }
}
```

## How we teach this

If this PR is accepted, most of the major issues with classes will have been
resolved. We can begin working on a codemod to make converting easier, and move
toward officially making native classes a finalized part of the public API of
Ember. Pending decorators and class fields moving to a late enough stage in the
TC39 process, we can also begin converting the guides to use native class
syntax.

We can document the exact behavior of the new constructor in the API docs for
EmberObject. Most details won't have to change since this change only affects
native class syntax, which has not been documented much officially. We can also
demonstrate the behaviors of classes throughout the guides and API docs.

One thing we should make clear is that EmberObject will likely be deprecated
in the near future, and that ideally for non-Ember classes (things that aren't
Components, Services, etc.) users should drop EmberObject altogether and use
native classes only.

## Drawbacks

This would be a breaking change that could negatively affect early adopters.

## Alternatives

* We could leave the behavior as is, and choose a method for defaulting to
standardize on.

* We could make this change behind a feature flag and require users to opt-in
to the new behavior, like optional features that currently exist. This would
have to be a build time feature flag, since the area is very performance
sensitive. Given native classes are not yet public API, if we were to do this we
should probably still default to enabling the new behavior and recommending it
as the preferred path.

* We could not deprecate `new EmberObject` altogether, and instead only
deprecate passing properties to the constructor. While this would work as a
temporary solution, it may also encourage users to continue using EmberObject
instead of switching to native classes, which is ultimately the long term goal.

## Unresolved questions

How do we handle DI during the construction phase?


---

---
stage: recommended
start-date: 2018-06-19T00:00:00.000Z
release-date: 2018-12-06T00:00:00.000Z
release-versions:
  ember-source: v3.6.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/340
project-link:
---

# Deprecate Ember.merge in favor of Ember.assign

## Summary

The goal of this RFC is to remove `Ember.merge` in favor of using `Ember.assign`.

## Motivation

`Ember.assign` has been around quite awhile, and has the same functionality as `Ember.merge`.
With that in mind, we should remove the old `Ember.merge`, in favor of just having a single function.

## Detailed design

Ember will start logging deprecation messages that tell you to use `Ember.assign` instead of `Ember.merge`.

The exact deprecation message will be decided later, but something along the lines of:

```
Using `Ember.merge` is deprecated. Please use `Ember.assign` instead. If you are using a version of
Ember <= 2.4 you can use [ember-assign-polyfill](https://github.com/shipshapecode/ember-assign-polyfill) to make `Ember.assign`
available to you.
```

## How we teach this

This should be a simple 1 to 1 conversion, and the deprecation message should be clear enough for all to
understand what they need to do, and convert all usages of `Ember.merge` to `Ember.assign`.

### Deprecation Guide

An entry to the [Deprecation Guides](https://emberjs.com/deprecations/) will be added outlining the conversion from
`Ember.merge` to `Ember.assign`.

`Ember.merge` predates `Ember.assign`, but since `Ember.assign` has been released, `Ember.merge` has been mostly unnecessary.
To cut down on duplication, we are now recommending using `Ember.assign` instead of `Ember.merge`. If you are using a version of
Ember <= 2.4 you can use [ember-assign-polyfill](https://github.com/shipshapecode/ember-assign-polyfill) to make `Ember.assign`
available to you.

Before:
```js
import { merge } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
merge(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }

```

After:
```js
import { assign } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
assign(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }
```

### Codemod

A codemod will be provided to allow automatic conversion of `Ember.merge` to `Ember.assign`.

## Drawbacks

The only drawback, that I can think of, is people would need to convert `Ember.merge` to
`Ember.assign`, but this would be a very easy change and could easily be done via codemod.

## Alternatives

The impact of not doing this, is we continue to have two functions that do basically the same thing,
which we need to maintain.

Another alternative, could be to remove both `Ember.merge` and `Ember.assign`, in favor of `Object.assign`
or something similar.

## Unresolved questions

None, that I can think of.


---

---
stage: recommended
start-date: 2019-07-11T00:00:00.000Z
release-date: # FIXME
release-versions:
teams:
  - framework ## FIXME - added automatically as it was missing during migration'
prs:
  accepted: https://github.com/emberjs/rfcs/pull/345
project-link:
---

# RFC to move the Ember community chat to Discord

## Summary

Encourage the Ember community to adopt Discord for real-time chat (vs Slack or other options).

## Motivation

Real-time chat is essential to the function of online communities, particularly in open source. Chat fosters an informal, interactive style of communication that is important for building relationships, sharing community norms, coordinating on projects, and brainstorming ideas.

The Ember community predominantly uses [a Slack instance](https://ember-community-slackin.herokuapp.com/) as the gathering place of choice. While we have benefited enormously from Slack, there are significant downsides as well.

### Loss of History

Because we use Slack's free plan, the entire instance is limited to 10,000 messages in history at any time. Because of this hard cap, the amount of time messages persist continues to shrink as the community grows.

It's hard to quantify exactly how painful this limitation is, as it means that new community members can't search for the answer to a question that was likely answered in the past. We can never go back to reference how or when a decision was made, which can mean decision-making feels less transparent that it should be.

This limit applies not just to chat messages, but direct messages between community members as well. This leads to annoyance, as people have to ask for the same information over again if they forgot to save it, or data loss, as useful things like code snippets vanish into the ether.

### Performance

The architecture of the Slack native application relies on running a separate web application per Slack instance the user is signed into. For users who need to be in multiple Slack instances, this can add up to a significant tax on computer resources, particularly as the application starts up.

Once Slack is up and running, most people generally find the performance reasonable, but a solution that offers better startup and runtime performance would be ideal.

### Privacy Concerns

Slack is very clear that their target audience is companies, who often have strict compliance rules that they must follow. Unfortunately, those needs are often at odds with concerns about privacy in an open source community.

In particular, Slack recently added a feature called Corporate Export that theoretically allows administrators to export all messages, including private messages, without notifying users.

Now, the odds of this feature being abused are extremely low. It is only available on Slack's Plus plan, which means a malicious actor would need to be granted administrator priveleges, pony up at least $150,000 to upgrade our Slack plan for that month, apply for the the Corporate Export feature, have it granted by Slack, and then perform an export without anyone noticing.

Because the difficulty of exploiting this feature for evil is so remote, it's not a primary concern driving this change. But all things being equal, we prefer a solution that doesn't offer export of private messages at all, so it's never a concern at the back of someone's mind.

### Better Communication & Transparency

Out of frustration with Slack's disappearing messages, the Ember.js core team set up a Discord server to evaluate if it might be a better fit for open source communities.

While this was a public Discord server that anyone could sign up for, its existence was not widely publicized because we were unsure if Discord was the right solution.

Over time, the core team and many contributors gravitated towards the Discord, finding that it served our needs better. Because of how valuable the Slack instance is, no one wanted to propose a move to Discord until a plan (like, say, this RFC) could be put in place.

Unfortunately, this state of affairs has had several undesirable outcomes.

First, it has caused many of the most prolific contributors to be less active in Slack. This may give the appearance of stagnation or disinterest, when momentum on Ember has never been higher. It robs lurkers of the ability to become contributors if a good opportunity to help pops up. And it prevents some of the most experienced members of the community from being around to help answer questions they might have an off-hand answer to.

Second, and perhaps worst of all, it undermines the transparency and open governance that we have worked hard to create. Our bar is higher than just making it possible to contribute—we go out of our way to actively welcome and encourage everyone to participate, learn and contribute.

Finally, this is not intended to replace [the forum](https://discuss.emberjs.com/), and that should be made clear. The forum is still the preferred place for asyncronous, threaded conversations where in-depth discussion is desired.

## Detailed design

### Transition Plan

We will need these things to transition the community smoothly:

- a period of time when we use both chat platforms during the transition, put the equivalent Discord channel information in the Slack channel topic
- a clear guide (with illustrations)
- once all of the setup is complete, the Discord server invites can be distributed.

Note: the current Discord chat will be closed while this RFC is under consideration. If the RFC is accepted, then a detailed implementation plan (mostly role/channel/server setup) & invitation strategy will be carried out.

#### Initial Setup

Because Discord has fine-grained controls, we will be able to implement categories for chats.

We intend to have the "welcome" channel as the initial channel for everyone who joins the Discord server. This channel will be read-only and will list the rules for the Discord server.

We also intend to have a "setup" channel. This channel will give you a complete guide of how to take advantage of the personalization, privacy and security, and notification controls in Discord.

**Verification Level**
Initially, we will be implementing the "low" verification level, which means users will need to have a verified email on their Discord account. If this proves to be too easy of a target for spammers, we will implement a higher level of verification (levels include amount of time a user has to be a verified member of the server before they can post).

**Explicit Content Filter**
Since this is a public Discord server, we will be setting an explicit content filter- it will scan messages from all members without a role. Email-verified members will be given a community member role to start, and other roles may be added to users over time.

**Categories and Channels**
Community members will then have the option of visiting the "setup" channel and learning more about fine-grained controls, such as:

- notifications
- muting a channel
- muting a category

Because our goal is transparency, all of the channels that exist will be visible in the channel list. A lock icon will display if the user does not have the role necessary to join that channel. (_FWIW, the alternative is to not display locked channels at all, which we felt would be less ideal- it is better to know that there are channels where private conversations are necessary and see what they are._)

The following proposed initial category and channel list was chosen based on the current channel needs and evaluation of the channels with the most members on Slack. _Additional channels may be requested in the Admin/community-feedback channel._

**Category/Channel List:**
- (No Category)
  - welcome (community guidelines are posted here) <--readonly & the server invite puts users in this channel first.
  - setup-profile (how to setup your profile) <--readonly
- Admin
  - community-feedback (questions, comments, concerns, requests)
  - security
  - steering-committee 🔒 (locked to role “steering-committee”)
  - news & announcements
  - ember-jobs
  - bots
- Core Teams
  - ember-js 🔒 (locked to role “core-js”)
  - ember-data 🔒 (locked to role “core-data”)
  - ember-cli 🔒 (locked to role “core-cli”)
  - ember-learning 🔒 (locked to role “core-learning”)
- Working on Ember
  - ember-cli
  - ember-data
  - ember-engines
  - ember-js
  - glimmer-vm
  - triage
  - st-* (as needed)
- Using Ember
  - general-help
  - learning-ember
  - a11y
  - backend
  - internationalization
  - jsonapi
  - mobile
  - ember-js
  - ember-data
  - ember-cli
  - ember-engines
  - fastboot
  - ember-twiddle
  - e-*
- Supporting Ember
  - documentation
  - website
  - marketing-and-advocacy
  - infrastructure
- Event-Chat
  - EmberConf
  - EmberCamps
  - EmberFest
  - Talks
  - Other Conferences
  - Meetup organizers
- Social
  - Water-cooler (random)
  - Local-*
  - Media (livestreams, videos, podcasts)
  - Pets
  - Women in Ember 🔒

**Integrations**
Discord's integration game is strong. Discord has a [very detailed API](https://discordapp.com/developers/docs/intro) and many integrations already exist, and with no limitation (compared to free Slack instances, that have limited numbers of integrations).

## How do we teach this?

In addition to having a setup channel available upon login (with illustrated instructions), here are some links where community members can read more:

- [Discord Loves Open Source](https://discordapp.com/open-source)
- [Discord Community Guidelines](https://discordapp.com/guidelines)
- [How to use Discord](http://www.businessinsider.com/how-to-use-discord-the-messaging-app-for-gamers-2018-5)

## Drawbacks

### Supporting Learning vs Supporting Development

There is some concern that there is already some confusion on Slack about where to get help learning/using Ember, and where to coordinate working on Ember. We need to have a clear delineation so that the folks who are spending their volunteer time to ship Ember features can continue to concentrate and do that.

### Losing Community Members

There is some concern that we may lose some community members due to this move. This could happen for a variety of reasons- the nature of OSS work means that some are not always active on the chat community, or the user doesn't want a different chat app, etc. We believe that the former is probably more likely than the latter, since many of us are on at least 2-3 chat apps already.

## Alternatives

The alternative to this would be to temporarily remain on Slack until we are able to evaluate and choose another viable option. However, we believe that staying on Slack is not desirable.

List of Slack alternatives:

- riot.io
- mattermost.org
- rocket.chat
- spectrum.chat


## Unresolved questions & FAQ

- When will there be conversation threads? We have been told that it is in the works, but there is no ETA.
- Disqus, Discord, Discuss? Which is which? For clarity, we will encourage the use of the terms **chat** (Discord), **the forums** (Discuss), and **blog comments** (Disqus)- mostly so no one has to try to remember.





---

---
stage: recommended
start-date: 2018-08-24T00:00:00.000Z
release-date: # FIXME
release-versions:
teams:
  - framework ## FIXME - added automatically as it was missing during migration'
prs:
  accepted: https://github.com/emberjs/rfcs/pull/364
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/28
---

# Ember 2018 Roadmap RFC

# Summary

This RFC sets the Ember 2018 Roadmap. This year’s goals are to:

- Improve communication and streamline decision-making, and empower new leaders.
- Finish the major initiatives that we’ve already started.
- Ship a new *edition*, Ember Octane, focused on performance and productivity.

# Motivation

This document is a distillation of multiple sources:

1. The 2018 Community Survey.
2. Community #EmberJS2018 blog posts, authored in response to our call for posts.
3. Discussion on https://discuss.emberjs.com
4. Deliberations among the Ember core teams.

The goal of the RFC is to align the Ember community around a set of shared, achievable goals that balance the needs of existing users with the need to grow and support new use cases.

# Detailed design

This year is primarily about finishing initiatives that we’ve already started, fine-tuning our communication channels, and getting the world excited about Ember.

- **Improve communication and streamline decision-making**. We will expand and refine the core team structure, to ensure decisions are made quickly, communication is clear, and users feel empowered to become contributors. We will invest in mentoring new leaders, and cross-pollinating knowledge between teams. As a community, we will share our excitement about Ember with the wider web development world.
- **Finish what we started.** We need to focus on stabilizing and polishing the work that we’ve already started in 2018. We will add extension points to allow popular new tools to be quickly adopted in Ember apps. We will standardize around ES modules and npm packages, better enabling the sharing of Ember tools with the wider JavaScript community.
- **Ship Ember Octane**. We will ship a new *edition* of Ember, emphasizing its *modern productivity and performance*. We will polish our compatibility with new JavaScript language features like native classes, decorators, and async functions. We will continue efforts like optional jQuery and treeshaking that reduce file size. We will overhaul the Ember homepage to align with Octane and tell the story of modern Ember.

To help us deliver a polished, cohesive experience, we will focus on two end-to-end, real world use cases. Having concrete use cases in mind helps us improve our marketing as well as prioritize feature development. In 2018, our two use cases are:

- **Productivity apps.** Ember’s historical strength: sophisticated, highly interactive apps that users spend a lot of time in, getting things done.
- **Content apps**, where pages are text-heavy and where the first load is critical. In performance-constrained environments, Ember’s strong conventions can help developers build faster apps by default.

## Improve communication and streamline decision-making

> Silence is the only thing that cause developers to lose trust in Ember. And overcommunication is the cure to silence.
> —[Ryan Toronto and Sam Selikoff](https://embermap.com/notes/107-our-wish-for-ember-in-2018-overcommunication)

> Technical leadership seems to me to be about 10% technical brilliance and 90% clear communication. We have loads of technical brilliance; we need more communication!
> —[Chris Krycho](https://www.chriskrycho.com/2018/emberjs2018-part-3.html)

> Communication is well, not stellar. Newsletters do a great job at communicating what already happened, but future plans are largely unknown to public.
> —[V. Lascik](https://medium.com/@vlascik/honest-look-at-ember-in-the-middle-of-2018-a0dc2787e506)

> The Core Team is in a unique position to add external-facing commentary on the framework's vision. Our RFC process and release posts are awesome, and they have done great things internally, so I would like to encourage Core to look outwards next.
> —[Jen Weber](https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8)

> My hope is that Ember will continue to be an investment worth making. I see a growing, diverse community with lots of fresh faces as an essential part of that.
> —[Matt McManus](https://medium.com/@mattmcmanus/emberjs2018-2d28a441fadb)

> Finding how and where I can help feels scattered. Issues do not receive effective labeling. This has translated into me not contributing to varying projects.
> —[Eli Flanagan](https://www.typedspace.com/a-few-quick-thoughts-on-ember-for-2018-from-a-corporate-citizen/)

> What I’d wish for Ember’s 2018 Roadmap though is to find ways to lower the entry barriers for newcomers to get started in their attempt to advocate Ember and to be creative on how to encourage a sense of empowerment in the wider community regarding outreach efforts.
> —[Jessica Jordan](https://simplabs.com/blog/2018/05/30/a-little-encouragement-goes-a-long-way-in-2018.html)

> My hope is that we will continue to hand off the baton of the community values to developers who are new to Ember.
> —[Bill Heaton](https://pixelhandler.com/posts/emberjs2018-a-few-suggestions)

> A good idea would be to continue creating quests for small things like documentation, code-cleaning… And maybe add a place where this quest can be found
> —[Benjamin Jegard](https://medium.com/@KamiKillertO/my-emberjs-in-2018-bc7f52739e16)

There has never been more time and energy going into Ember, but we’ve heard loud and clear that this momentum is not as visible as it needs to be. We are going to prioritize sharing work as it happens, making planning and status updates more discoverable, and making it easier for would-be contributors to get involved.

We also need to double down on making Ember as friendly and inclusive as possible, particularly for folks who have never participated in an open source project before. As we bring in new community members, we will make changes to ensure that individuals can have a meaningful impact, no matter what time zone they live in.

Lastly, we need to make sure that our core teams are not so bogged down that they become a bottleneck for decision-making. Core teams and strike teams decentralize planning, empower new contributors to take ownership of community initiatives, and help to build and strengthen relationships among community members. We will invest in improving the organization and structure of these teams this year.

To accomplish these goals, this year we will:

- **Expand and refine our team structure**, breaking up work and delegating it to strike teams or new core teams as appropriate.
- **Move to discoverable communication tools**, such as our Discourse forum, which is visible to search engines, and Discord chat, which doesn't lose history.
- **Invest in mentoring**. This includes direct mentorship relationships, as well as written guides like quest issues that are helpful even for people in different time zones or who have difficulty with spoken English.
- **Track RFC implementation via GitHub issues**, so it's clear what the next steps are after an RFC is merged.
- **Automate communication and status updates.** For example, we will improve the [Statusboard](https://www.emberjs.com/statusboard) to automatically pull from RFCs and RFC tracking issues.
- **Document “best practices” for core teams**, spreading knowledge about what works and what doesn’t for building an active community.
- **Unify the RFC process** to ensure a consistent experience across all of Ember's sub-projects.

## Finish what we started

> The last few years have seen the Ember team do a lot of really important exploratory work, including projects like [Glimmer.js](https://glimmerjs.com/); and we have landed some of the initiatives we have started. But I think it’s fair to say that focus has not been our strong suit. It’s time for a year of shipping.—[Chris Krycho](https://www.chriskrycho.com/2018/emberjs2018-part-1.html)

> I think the goal of being able to just npm install or yarn install any package and having it "just work" should be high on the TODO list.
> —[Andrew Callahan](http://andrewcallahan.com/a-road-to-ember-4-0/)

> When [Yehuda Katz](https://mobile.twitter.com/wycats) [closed](https://github.com/emberjs/rfcs/pull/38#issuecomment-355800759) that RFC, I think a bit of that dream died, but at the same time I was happy. Not because it wasn't going to happen but because there was clear communication, finally.
> —[Ilya Radchenko](https://burstcreations.com/ember-in-2018-and-beyond/)

> I firmly believe that Ember needs to deliver all the great new features that are currently in flight before taking more to its plate.
> —[Josemar Luedke](https://josemarluedke.com/blog/ember-in-2018-getting-ready-for-the-next-major-release/)

This year, we **need a strong focus on shipping**. Huge improvements to Ember have either already landed or are in the pipeline. We need to cross the finish line on these before moving on to new initiatives, however important or exciting they might seem.

“Done” doesn’t mean behind a feature flag on canary. Finishing what we started means ensuring that features are discoverable, on by default, and that the guides and other documentation have been revised to take them into account. It means making sure they work well with the entire Ember ecosystem so that new developers get a seamless experience.

This year, we are going to ship:

- **Broccoli 2.0** in Ember CLI, as well as significant investment into Broccoli documentation, marketing and advocacy.
- **Module Unification** as the default file system layout.
- **Glimmer Components** as the default component API.
- **Native JavaScript classes** as the default object model.
- **Native JavaScript modules,** including:
  - **Exposing modules in the build pipeline** and allowing addons to integrate tools like Parcel, Rollup or Webpack.
  - **Publishing Ember as npm packages**.
  - **Importing npm packages** into your Ember apps with zero additional configuration. (This was, far and away, the most-mentioned feature request in all of the #EmberJS2018 blog posts.)

## Ember Octane

> The homepage looks a bit outdated and does not a very compelling job at selling Ember to new users, IMHO. This needs to change.
> —[Simon Ihmig](https://www.kaliber5.de/en/blog/ember-js-in-2018-get-better-at-marketing/)

> When you generate a project with `ember new`, you get a project that is almost “legacy” by standards of the wider JavaScript community.
> —[Gaurav Munjal](https://medium.com/@gauravmunjal_86037/stability-without-stagnation-in-2018-ce2d4f519991)

> Ember's custom object model isn't hard to learn, but it's a big reason people are turned off before learning why Ember is such a great choce. I'd like to see ES classes support finished and adopted in the Guides ASAP, followed by decorators.
> —[Michael Kaiser-Nyman](https://gist.github.com/michaelrkn/ffdd67906a724362bd8f5ccc3434db0f)

> ES6 syntax, the new file layout, new templating etc. — the new features will land in 3.x releases as non-breaking changes, but let’s prepare to show off the sum of all those amazing parts. Sell the vision, right now! A ‘relaunch’ of Ember in the minds of those who dismiss it.
> —[Will Viles](https://medium.com/@willviles/ember-js-in-2018-lets-market-the-future-e6be9c42cf86)

Ember releases a new, stable version every six weeks. For existing users, this drumbeat of incremental improvement is easier to keep up with than splashy, big-bang releases.

However, for people not following Ember closely, it’s easy to miss the significant improvements that happen over time. As detailed in the forthcoming Ember Editions RFC (being worked on by [Dave Wasmer](https://twitter.com/davewasmer)), every year or so **we will release a new edition of Ember**, focused on a particular theme. The set of improvements related to that theme, taken together, mark a meaningful change to how people should think about Ember.

In 2018, we will release the first edition of Ember, called *Ember Octane*. **Octane will focus on the themes of productivity and performance.** We’ll talk about how Ember excels in performance-constrained environments, particularly on mobile devices, as well as the productivity benefits of modern JavaScript features like classes, decorators, and async functions when paired with Ember’s strong conventions and community.

This is also a good time for us to review the new application blueprint, to ensure that it is up-to-date with the latest Ember Octane idioms and includes the right set of addons to help new users achieve our goals of productivity and performance.

Ember Octane is about *doing more with less*. Not only does this make Ember simpler to learn, it makes the framework smaller and faster, too. These are some of the highlights of Ember Octane:

- **No jQuery.** Currently available as an optional feature, we will enable this by default.
- **Svelte builds**, where deprecated features are stripped out of framework code. We will get more aggressive about deprecating code that is not widely used.
- **Native JavaScript classes** perform better and require less code, and integrate better with tools like TypeScript and ESLint.
- **Glimmer components** offer a greatly simplified API and remove common slow paths.
- **Incremental rendering and rehydration** that keeps even low-end devices responsive as the application boots.
- **Treeshaking** to automatically remove code unused by the application.
- **Eliminating the runloop** from the programming model, replaced by `async` and `await` in tests.
- **Stabilizing Ember Data** by streamlining internals and providing more extension points for applications and addons to customize behavior.

The final timeline and feature set of Ember Octane will be determined by the core teams and are not set in stone in this RFC.

In keeping with our commitment to finishing what we’ve started, these are all features that are either finished or being implemented now. We should not plan for Octane to have any features that are not already close to being done today, so that we have adequate time to make sure they all work well together as part a cohesive programming model.

The process of releasing a new edition also gives us an opportunity to evaluate what it’s like to use Ember end-to-end. We will overhaul the Ember homepage, focusing on Ember Octane and how it helps solve targeted use cases.

This is also a good time to perform a holistic review of the guides, making sure that examples use the latest idioms and set new learners on a good path.

# Non-goals

One of our most important goals this year is to focus on shipping. Focus means saying “no” to ideas that we really like.

- **Significant work on Glimmer.js**. We will instead focus on our efforts on incorporating the lessons of Glimmer.js into work that enables a smaller core in Ember.
- **Further Glimmer VM optimizations**. Glimmer performance is industry leading and not a bottleneck in most Ember.js apps. At this point, the Ember.js payload is the primary performance bottleneck, and we should turn our attention to enabling better performance there.
- **Brand new language features** in either Handlebars templates or Ember’s JavaScript files. There is already a full pipeline of features, such as Glimmer components, JavaScript classes with decorators, and module unification that we need to finish before starting any new major design.


---

---
stage: recommended
start-date: 2018-08-30T00:00:00.000Z
release-date: 2019-04-01T00:00:00.000Z
release-versions:
  ember-source: v3.9.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/369
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/18
---

# Summary

Deprecate computed overridability and `computed().readOnly()` in favor of
read-only computeds as the default.

# Motivation

Computed properties have existed in Ember long before class syntax and native
accessors (getters and setters) were readily available, and as such they have a
few notable behavioral differences. As we move toward adopting native class
syntax and using a decorator-based form of computeds, it makes sense to
reconcile these differences so that users can expect them to work the same as
their native counterparts.

The main and most notable difference this RFC seeks to deprecate is computed
overridability (colloquially known as "clobbering"). There are some other
notable differences, including the caching behavior of the `return` value of
setter functions, which may be addressed in future RFCs.

## Overridability

When defining a native getter without a setter, attempting to set the value will
throw a hard error (in strict mode):

```js
function makeFoo() {
  'use strict';

  class Foo {
    get bar() {
      return this._value;
    }
  }

  let foo = new Foo();

  foo.bar; // undefined
  foo.bar = 'baz'; // throws an error in strict mode
}
```

By constrast, computed properties without setters will be overridden when they
are set, meaning the computed property is removed from the object and replaced
with the set value:

```js
const Foo = EmberObject.extend({
  bar: computed('_value', {
    get() {
      return this._value;
    },
  }),
});

let foo = Foo.create();

foo.bar; // undefined
foo.set('bar', 'baz'); // Overwrites the getter
foo.bar; // 'baz'
foo.set('_value', 123);
foo.bar; // 'baz'
```

This behavior is confusing to newcomers, and oftentimes unexpected. Common best
practice is to opt-out of it by declaring the property as `readOnly`, which
prevents this overridability.

# Transition Path

This RFC proposes that `readOnly` properties become the default, and that in
order to override users must opt in by defining their own setters:

```js
class Foo {
  get bar() {
    if (this._bar) {
      return this._bar;
    }

    return this._value
  }

  set bar(value) {
    this._bar = value
  }
}
```

## Macros

Most computed macros are overridable by default, the exception being `readOnly`.
This RFC proposes that all computed macros with the exception of `reads` would
become read only by default. The purpose of `reads` is to _be_ overridable, so
its behavior would remain the same.

## Decorator Interop

It may be somewhat cumbersome to write overriding functionality or add proxy
properties when overriding is needed. In an ideal world, computed properties
would modify accessors transparently so that they could be composed with other
decorators, such as an `@overridable` decorator:

```js
class Foo {
  @overridable
  @computed('_value')
  get bar() {
    return this._value;
  }

  @overridable
  @and('baz', 'qux')
  quux;
}
```

Currently this is not possible as computed properties store their getter/setter
functions elsewhere and replace them with a proxy getter and the mandatory
setter assertion, respectively. In the long term, making computeds more
transparent in this way would be ideal, but it is out of scope for this RFC.

## Deprecation Timeline

This change will be a breaking change, which means we will not be able to change
the behavior of `computed` until Ember v4.0.0. Additionally, users will likely
want to continue using `.readOnly()` up until overriding has been fully removed
to ensure they are using properties safely. With that in mind, the ordering of
events should be:

1. Ember v3
    * Deprecate the default override-setter behavior immediately. This means that
      a deprecation warning will be thrown if a user attempts to set a
      non-`readOnly` property which does not have a setter. Users will still be
      able to declare a property is `readOnly` without a deprecation warning.
    * Add optional feature to change the deprecation to an assertion after the
      deprecation has been released, and to show a deprecation when using
      the `.readOnly()` modifier.
    * After the deprecation and optional feature have been available for a
      reasonable amount of time, enable the optional feature by default in new
      apps and addons. The main reason we want to delay this is to give _addons_
      a chance to address deprecations, since enabling this feature will affect
      both apps and the addons they consume.
2. Ember v4
    * Remove the override-setter entirely, making non-overrideable properties the
      default.
    * Make the `readOnly` modifier a no-op, and show a deprecation warning when it
      is used.

The warnings should explain the deprecation, and recommend that users do not
rely on setter behavior or opting-in to read only behavior.

# How We Teach This

In general, we can teach that computed properties are essentially cached native
getters/setters (with a few more bells and whistles). Once we have official
decorators in the framework, we can make this connection even more solid.

We should add notes on overridability, and we should scrub the guides of any
examples that make use of overriding directly and indirectly via `.readOnly()`.

# Drawbacks

Overriding is not a completely uncommonly used feature, and developers who have
become used to it may feel like it makes their code more complicated, especially
without any easy way to opt back in.

# Alternatives

We could convert `.readOnly()` into `.overridable()`, forcing users to opt-in
to overriding. Given the long timeline of this deprecation, it would likely be
better to work on making getters/setters transparent to decoration, and provide
a `@overridable` decorator either in Ember or as an independent package.


---

---
stage: recommended
start-date: 2018-08-31T00:00:00.000Z
release-date: 2019-04-01T00:00:00.000Z
release-versions:
  ember-source: v3.9.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/370
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/17
---

# Summary

Deprecate `computed().volatile()` in favor of undecorated native getters and
setters.

# Motivation

`computed().volatile()` is a commonly misunderstood API. On its surface,
declaring a computed as volatile causes the computed to recalculate every time
it is called. This actually works much like native, undecorated accessors do on
classes, with one key difference.

Volatile properties are meant to respresent fundamentally unobservable values.
This means that they swallow notification changes, and will not notify under any
circumstances, and that when setting a volatile value the user must notify
manually:

```js
const Foo = EmberObject.extend({
  bar: computed({
    get() {
      return this._value;
    }

    set(key, value) {
      return this._value = value;
    }
  }).volatile(),

  baz: computed('bar', {
    get() {
      return this.bar;
    }
  }),
});

let foo = Foo.create();

foo.set('bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

foo.set('bar', 456);
foo.baz; // 123, no property changes were made so the cache was not cleared
```

This behavior is useful at times for framework code, but is generally not what
users are expecting. By constrast, when using native accessors with `set` and
`get`, Ember treats them just like any other property. From its perspective,
they _are_ standard properties, so it'll continue to notify as expected.

```js
class Foo {
  get bar() {
    return this._value;
  }

  set bar(value) {
    this._value = value;
  }

  @computed('bar')
  get baz() {
    return this.bar;
  }
});

let foo = new Foo();

set(foo, 'bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

set(foo, 'bar', 456);
foo.baz; // 456, cache was cleared and value was updated
```

The most common use case for volatile computeds was when users wanted a computed
to behave like a native getter/setter. Now that we (almost) _have_ those in a
easy to use form, it makes more sense to deprecate the volatile API and rely
directly on native functionality.

# Transition Path

Native getters and setters will _only_ work on native classes, due to how the
internals of the old object model work. To ensure that users do not accidentally
try to replace volatile with getters/setters on non-native classes, we should
provide 2 deprecation warnings:

1. Deprecation when users use volatile on a computed which tells them that the
  API has been deprecated, and that they'll need to update native class syntax
  to remove the volatile property.

2. Deprecation when users use volatile on a computed decorator (to be RFC'd)
  which tells them to remove the computed decorator entirely from the getter.

Volatile properties will be removed once native classes are the default.

# How We Teach This

In general documentation should be updated to use native getters and setters
wherever `volatile` was used. This will have to happen after docs are updated to
use native classes, because native getters and setters do _not_ work with the
older object model.

# Drawbacks

Volatility is useful for framework level concerns, for instance if developing an
API or decorator that already handles notification. Addon authors may be able to
use this functionality.

Not having an alternative for old style classes or mixins could be problematic
for users who aren't ready to update to native class syntax.

# Alternatives

We could keep `volatile()` around for any potential addons that may want to use
it, but teach native getters/setters as the preferred path for most use cases.

We could provide `volatile` as a separate API/decorator to distinguish it from
computed properties, and discourage use for users.


---

---
stage: accepted
start-date: 2018-09-06T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/372
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/16
---

# ember-data | modelFactoryFor

## Summary

Promote the private `store._modelFactoryFor` to public API as `store.modelFactoryFor`.

## Motivation

This RFC is a follow-up RFC for [#293 RecordData](https://github.com/emberjs/rfcs/pull/293).

Ember differentiates between `klass` and `factory` for classes registered with the container.
 At times, `ember-data` needs the `klass`, at other times, it needs the `factory`. For this reason,
`ember-data` has carried two APIs for accessing one or the other for some time. The public `modelFor`
 provides access to the `klass` where schema information is stored, while the private `_modelFactoryFor`
 provides access to the factory for instantiation.

We provide access to the class with `modelFor` roughly implemented as `store._modelFactoryFor(modelName).klass`.
We instantiate records from this class roughly implemented as `store._modelFactoryFor(modelName).create({ ...args })`.

For symmetry, both of these APIs should be public. Making `modelFactoryFor` public would provide a hook
 that consumers can override should they desire to provide a custom `ModelClass` as an alternative
 to `DS.Model`.

## Detailed design
Due to previous complexity in the lookup of models in `ember-data`, we previously had both `modelFactoryFor`
and `_modelFactoryFor`. Despite the naming, both of these methods were private. During a recent cleanup phase,
we unified the methods into `_modelFactoryFor` and left a deprecation in `modelFactoryFor`. This RFC proposes
un-deprecating the `modelFactoryFor` method and making it public, while deprecating the private `_modelFactoryFor`.

More precisely:

- `store._modelFactoryFor` becomes deprecated and calls `store.modelFactoryFor`.
- `store.modelFactoryFor` becomes un-deprecated.

### The contract for `modelFactoryFor`

The return value of `modelFactoryFor` MUST be the result of a call to [`applicationInstance.factoryFor`](https://www.emberjs.com/api/ember/3.4/classes/ApplicationInstance/methods/factoryFor?anchor=factoryFor)
 where `applicationInstance` is the `owner` returned by using `getOwner(this)` to access the `owner` of the `store` instance.

```typescript
interface Klass {}

interface Factory {
  klass: Klass,
  create(): Klass
}

interface FactoryMap {
    [factoryName: string]: Factory
}

declare function factoryFor<K extends keyof FactoryMap>(factoryName: K): FactoryMap[K];

interface Store {
  modelFactoryFor(modelName: string): ReturnType<typeof factoryFor>;
}
```

Users interested in providing a custom class for their `records` and who override `modelFactoryFor`,
 would not need to also change `modelFor`, as this would be the `klass` accessible via the `factory`.

Users wishing to extend the behavior of `modelFactoryFor` could do so in the following manner:

**Example 1:**

**services/store.js**
```js
import { getOwner } from '@ember/application';
import Store from 'ember-data/store';

export default Store.extend({
  modelFactoryFor(modelName) {
    if (someCustomCondition) {
      return getOwner(this).factoryFor(someFactoryName);
    }

    return this._super(modelName);
  }
});
```

 #### `Model.modelName`

 `ember-data` currently sets `modelName` onto the `klass` accessible via the `factory`. For classes that do not
   inherit from `DS.Model` this would not be done, although end users may do so themselves in their implementations
   if so desired.

### What is a valid factory?

The default export of a custom ModelClass **MUST** conform to the requirements of `Ember.factoryFor`. The requirements
 of `factoryFor` are currently underspecified; however, in practice, this means that the default export is an
 instantiable class with a static `create` method and an instance `destroy` method or that inherits from `EmberObject`
 (which provides such methods).

**Example 2:**

```javascript
import { assign } from '@ember/polyfills';

export default class CustomModel {
  constructor(createArgs) {
    assign(this, createArgs);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
```

**Example 3:**

```javascript
import EmberObject from '@ember/object';

export default class CustomModel extends EmberObject {
  constructor(createArgs) {
    super(createArgs);
  }
}
```

Custom classes for models should expect their constructor to receive a single argument: an object with *at least*
 the following.

- A `recordData` instance accessible via `getRecordData` (see below)
- Any properties passed as the second arg to `createRecord`
- An `owner` accessible via `Ember.getOwner`
- Any DI injections
- any other properties that `Ember` chooses to pass to a class instantiated via `factory.create` (currently none)

### getRecordData

Every `record` (instance of the class returned by `modelFactoryFor`) will have an associated [RecordData](https://github.com/emberjs/rfcs/pull/293)
 which contains the backing data for the id, type, attributes and relationships of that record.

This backing data can be accessed by using the `getRecordData` util on the `record` (or on the `createArgs` passed to
 a record). Using `getRecordData` on a `record` is only guaranteed after the record has been instantiated. During
 instantiation, this call should be made on the `createArgs` object passed into the record.

**Example 4**

```javascript
import { getRecordData } from 'ember-data';

export default class CustomModel {
  constructor(createArgs) {
    // during instantiation, `recordData` is available by calling `getRecordData` on createArgs
    let recordData = getRecordData(createArgs);
  }
  someMethod() {
    // post instantiation, `recordData` is available by calling `getRecordData` on the instance
    let recordData = getRecordData(this);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
```

## How we teach this

This API would be intended for addon-authors and power users. It is not expected
that most apps would implement custom models, much as it is not expected that most
apps would implement custom `RecordData`. The teaching story would be limited to
documenting the nature and purpose of `modelFactoryFor`.

## Drawbacks

- Users may try to use the hook to instantiate records on their own. Ultimately, the store
  should still do the instantiating.

## Alternatives

Users could define models in `models/*.js` that utilize a custom `ModelClass`.
However, such an API for custom classes would exclude the ability to dynamically
generate classes.

## Unresolved questions

None


---

---
stage: recommended
start-date: 2018-09-10T00:00:00.000Z
release-date: 2019-02-18T00:00:00.000Z
release-versions:
  ember-source: v3.8.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/373
project-link:
---

# Element Modifier Manager

## Summary

This RFC proposes a low-level primitive for defining element modifiers. It is a parent to the [Element Modifiers RFC](https://github.com/emberjs/rfcs/pull/811).

## Motivation

Ever since Ember 1.0 we have had the concept of element modifiers, however Ember only exposes one modifier; `{{action}}`. We also do not provide a mechanism for defining your own modifiers and managing their life cycles.

As [pointed out](https://github.com/emberjs/rfcs/pull/353#issuecomment-417769349) in the original [Modifiers RFC](https://github.com/emberjs/rfcs/pull/353) we should expose the underlying infrastructure that makes element modifiers possible. Based on our experience, we believe it would be beneficial to open up these new primitives to the wider community. The largest benefit is that it allows the community to experiment with and iterate on APIs outside of the core framework.

This RFC is in the same spirit as the [custom components RFC](https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md).

## Detailed design

This RFC introduces the concept of _modifier managers_. A modifier manager is an object that is responsible for coordinating the lifecycle events that occurs when invoking, installing and updating an element modifier.

### Registering modifier managers

Modifier managers are registered with the `modifier-manager` type in the
application's registry. Similar to services, modifier managers are singleton
objects (i.e. `{ singleton: true, instantiate: true }`), meaning that Ember
will create and maintain (at most) one instance of each unique modifier
manager for every application instance.

To register a modifier manager, an addon will put it inside its `app` tree:

```js
// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
```

(Typically, the convention is for addons to define classes like this in its
`addon` tree and then re-export them from the `app` tree. For brevity, we will
just inline them in the `app` tree directly for the examples in this RFC.)

This allows the modifier manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, modifier managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:

```js
// ember-basic-modifier/app/initializers/register-basic-modifier-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('modifier-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-modifier-manager',
  initialize
};
```

## Determining which modifier manager to use

When invoking the modifier `<p {{foo baz bar=bar}} />`, Ember will first resolve the
modifier class (`modifier:foo`, usually the `default` export from
`app/modifiers/foo.js`). Next, it will determine the appropiate modifier
manager to use based on the resolved modifier class.

Ember will provide a new API to assign the modifier manager for a element modifier
class:


```js
// my-app/app/modifier/foo.js

import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setModifierManager } from '@ember/modifier';

export default setModifierManager(createManager, EmberObject.extend({
  // ...
}));
```

```js
// my-app/app/modifier/basic-manager.js

// ...

export function createManager(owner) {
  return new BasicManager(owner);
}
```

`setModifierManager` takes two parameters. The first parameter is a function that takes an `Owner` and returns an instance of a manager. The second parameter is the base class that applications would extend from.

In reality, an app developer would never have to write this in their apps,
since the modifier manager would already be assigned on a super-class provided
by the framework or an addon. The `setModifierManager` function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers. Attempting to reassign the modifier manager when one is already
assinged on a super-class will be an error. If no modifier manager is set, it
will also result in a runtime error when invoking the modifier.

## Modifier Lifecycle

Back to the `<p {{foo baz bar=bar}}></p>` example.

Once Ember has determined the modifier manager to use, it will be used to manage the modifiers's lifecycle.

### `createModifier`

The first step is to create an instance of the modifier. Ember will invoke the modifier manager's `createModifier` method:

```js
// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args);
  },
});
```

The `createModifier` method on the modifier manager is responsible for taking the modifier's factory and the arguments passed to the modifier (the ... in {{foo ...}}) and return an instantiated modifier.

The first argument passed to `createModifier` is the result returned from the `factoryFor` API. It contains a class property, which gives you the the raw class (the default export from app/modifiers/foo.js) and a create function that can be used to instantiate the class with any registered injections, merging them with any additional properties that are passed.

The second argument is a snapshot of the arguments passed to the modifier in the template invocation, given in the following format:

```js
{
  positional: [ ... ],
  named: { ... }
}
```

For example, given the following invocation:

```hbs
<p {{foo baz bar=bar}}></p>
```

You will get the following as the second argument:

```js
{
  positional: [true],
  named: {
    "bar": "Another RFC by Chad"
  }
}
```

The arguments object should not be mutated (e.g. args.positional.pop() is no good). In development mode, it might be sealed/frozen to help prevent these kind of mistakes.

This hook has the following timing semantics:

**Always**
- called as discovered during DOM construction
- called in defintion order in template

### `installModifier`

Once the modifier instance has been created, the next step is to install the modifier on to the underlying element.

```js
// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  // ...
});
```

`installModifer` is responsible for giving access to the underlying element and arguments to the modifier instance.

The first argument passed to `installModifer` is the result of `createModifier`. The second argument is the `element` the modifier was defined on. The third argument is the same snapshot of the arguments passed to the modifier in the template invocation that `createModifier` recieved.

This hook has the following timing semantics:

**Always**

- called after all children modifier managers `installModifer` hook are called
- called after DOM insertion

**May or May Not**

- be called in the same tick as DOM insertion
- have the sibling nodes fully initialized in DOM

### `updateModifier`

Modifiers are only updated when one of its arguments is changed. In this case Ember will call the manager's `updateModifier` method to give the manager the oppurtunity to reflect those changes on the modifier instance, before re-rendering.

```js
// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  updateModifier(instance, args) {
    if (instance.didUpdateArguments !== undefined) {
      instance.didUpdateArguments(args.positional, args.named);
    }
  }

  // ...
});
```

`updateModifier` recieves the modifier instance and also the the updated snapshot of arguments.

This hook has the following timing semantics:

**Always**

- called after the arguments to the modifier have changed

**Never**

- called if the arguments to the modifier are constants

### `destroyModifier`

`destroyModifier` will be called when the modifier is no longer needed. This is intended for performing object-model level cleanup.

```js
// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
```

This hook has the following timing semantics:

**Always**

- called after all children modifier manager's `destroyModifier` hook is called

**May or May Not**

- be called in the same tick as DOM removal

## Capabilities

In addition to the methods specified above, modifier managers are required to
have a `capabilities` property.  This property must be set to the result of
calling the `capabilities` function provided by Ember.

### Versioning

The first, mandatory, argument to the `capabilities` function is the modifier
manager API, which is denoted in the `${major}.${minor}` format, matching the
minimum Ember version this manager is targeting. For example:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/modifier';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.6'),

  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
```

This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.

Here is a hypothical scenario for such a change:

1. Ember 3.6 implemented and shipped the modifier manager API as described in
   this RFC.

2. The `ember-basic-modifier` addon released version 1.0 with the modifier
   manager shown above (notably, it declared `capabilities('3.6')`).

3. In Ember 3.8, we determined that constructing the arguments object passed to
   the hooks is a major performance bottleneck, and changes the API to pass a
   "proxy" object with getter methods instead (e.g. `args.getPositional(0)` and
   `args.getNamed('foo')`).

   However, since Ember sees that the `basic` modifier manager is written to
   target the `3.6` API version, it will retain the old behavior and passes the
   old (more expensive) "reified" arguments object instead, to avoid breakage.

4. The `ember-basic-modifier` addon author would like to take advantage of
   this performance optimization, so it updates its modifier manager code to
   work with the arguments proxy and changes its capabilities declaration to
   `capabilities('3.8')` in version 2.0.

This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.

Note that addon authors are not _required_ to update to the newer API.
Concretely, modifier manager APIs have the following support policy:

* API versions will continue to be supported in the same major release of
  Ember. As shown in the example above, `ember-basic-modifier` 1.0 (which
  targets modifier manager API version 3.6), will continue to work on
  Ember 3.8. However, the reverse is not true – modifier manager API version
  3.8 will (somewhat obviously) not work in Ember 3.6.

* In addition, to ensure a smooth transition path for addon authors and app
  developers across major releases, each Ember version will support (at least)
  the previous LTS version as of the release was made. For example, if 3.16 is
  the last LTS release of the 3.x series, the modifier manager API version
  3.16 will be supported by Ember 4.0 through 4.4, at minimum.

Addon authors can also choose to target multiple versions of the modifier
manager API using [ember-compatibility-helpers](https://github.com/pzuraq/ember-compatibility-helpers/):

```js
// ember-basic-modifier/app/modifier-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.8'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.6'),

    // ...
  });
}

export default ComponentManager;
```

Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.

### Optional Features

The second, optional, argument to the `capabilities` function is an object
enumerating the optional features requested by the modifier manager.

In the hypothical example above, while the "reified" arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical modifiers. A modifier
manager written for Ember 3.8 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:

```js
// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.8', {
    reifyArguments: true
  }),

  // ...
});
```

In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.

At this time this RFC does not specify any optional capabilties for the initial release.

## How we teach this

What is proposed in this RFC is a low-level primitive. We do not expect most users to interact with this layer directly. Instead, most users will simply benefit from this feature by subclassing these special modifiers provided by addons.

## Drawbacks

In the long term, there is a risk of fragmentating the Ember ecosystem with many competing modifier APIs. However, given the Ember community's strong desire for conventions, this seems unlikely. We expect this to play out similar to the data-persistence story – there will be a primary way to do things (Ember Data), but there are also plenty of other alternatives catering to niche use cases that are underserved by Ember Data.

## Alternatives
Instead of focusing on exposing enough low-level primitives we can just ship the high level API as described in [RFC#811](https://github.com/emberjs/rfcs/pull/811).

## Unresolved questions

TBD?


---

---
stage: recommended
start-date: 2019-09-13T00:00:00.000Z
release-date: 2019-04-01T00:00:00.000Z
release-versions:
  ember-source: v3.9.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/375
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/15
---

# Summary

Deprecate the computed `.property()` modifier which can be used to add dependent
keys to computed properties.

# Motivation

Currently, computed properties can use the `.property` modifier to add dependent
keys to a computed _after_ the computed has been declared:

```js
foo: computed('strings', {
  get() {
    return this.strings.filter(s => s.includes(this.filterText));
  }
}).property('filterText')
```

In most cases, this ability is redundant, since the dependent keys can be moved
into the original computed declaration and be equivalent:

```js
foo: computed('strings', 'filterText', {
  get() {
    return this.strings.filter(s => s.includes(this.filterText));
  }
})
```

The one exception is in the case of computed _macros_, specifically macros which
accept a _function_ such as `filter()` and `map()`:

```js
foo: filter('strings', function(s) {
  return s.includes(this.filterText);
}).property('filterText')
```

The issue stems from the fact that the inner function can access the class
instance and use dynamic properties from it, and this access is opaque to the
macro.

This API is confusing since it bears a strong resemblance to the older style
of computed property declarations, and at first glance appears to be invalid.
The few edge-case macros where it does legitimately apply can be rewritten to
accept more dependent keys, making it fully redundant.

# Transition Path

As mentioned above, macros which receive a callback function as an argument are
the only valid use of `.property()` in current Ember. Currently, there are two
such macros in Ember core: `map` and `filter`.

This RFC proposes that these macros be updated to receive additional dependent
keys via their public API directly via an optional second parameter which is an
array of the keys:

```ts
function filter(filteredPropertyKey: string, callback: Function): ComputedProperty;
function filter(
  filteredPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;

function map(mappedPropertyKey: string, callback: Function): ComputedProperty;
function map(
  mappedPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;
```

## Deprecation Timeline

The deprecation should follow these steps:

* Update `filter` and `map` to their new APIs
* Add a deprecation warning to uses of `.property` which add dependent keys to
  computed properties.
* Add an optional feature to turn the deprecation into an assertion
* After enough time has passed for addons and users to update, enable the
  optional feature by default in new addons and apps
* Fully remove `.property()` in Ember v4.0.0

# How We Teach This

In most cases, we shouldn't have to teach anything. There are already linting
rules prohibiting `.property()` usage, and the recommended path is to provide
all dependent keys in the original declaration of the computed property. For
users of `map` and `filter` we should ensure that they new documentation is
clear on how to add dependent keys to either macro.

For addon authors that have created their own macros which rely on callbacks and
have similar issues, we should demonstrate how they can structure their macro
API to accept additional dependent keys.

# Drawbacks

The new proposed APIs for `filter` and `map` may be somewhat confusing, since
only the first argument will be filtered/mapped

# Alternatives

We could allow additional dependent keys to be passed via an options argument:

```ts
filter(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;

map(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;
```

This is more verbose, but would be very clear.


---

---
stage: recommended
start-date: 2018-10-07T00:00:00.000Z
release-date: 2019-04-01T00:00:00.000Z
release-versions:
  ember-source: v3.9.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/386
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/3
---

# Remove jQuery by default

## Summary

This RFC proposes deprecating those public APIs that are coupled to jQuery, and to finally remove them (with an optional
backport), so Ember apps will be built *by default* without bundling jQuery.

While [RFC294](https://emberjs.github.io/rfcs/0294-optional-jquery.html), which is already implemented, provides
a way to opt out of jQuery, the intention of this RFC is to push this a step further and essentially move from the
current "included by default, allow opt out" strategy to "excluded by default, allow opt in".

In that way it is not meant as a replacement of the previous RFC, but rather as a continuation and the logical next step.

## Motivation

### Lean by default

This follows the philosophy of making Ember leaner (or *higher octane* if you want), by deprecating unused or
non-essential APIs.
New apps will be smaller and faster by default, while allowing to opt-in into using jQuery when needed.

### Why the current opt-out strategy is not sufficient

The biggest problem in the current opt-out strategy is that many addons still require jQuery. Many of these usages
seem to be rather "accidental", in that the full power of jQuery is not really needed for the given task, and could be
rather easily refactored to use only native DOM APIs. But as it is available anyway by default, and it is very convenient,
authors probably tend to use it without being fully aware of the consequences, that it prohibits jQuery-less builds for
all its consumers.

In that way the general availability of jQuery *by default* and Ember APIs around it like `this.$()` tend to manifest the
status quo, the coupling of Ember to jQuery. In fact I could observe an actual *increase* of jQuery usage numbers
(see below), rather than a decrease, which was an intention of the previous RFC. So it is not only a concern of the core
Ember library to enable jQuery-less builds, but the whole addon ecosystem has to go through that transition.

In that regard early deprecations will help prevent this accidental use of jQuery on the one side, and on the other side
for addons that depend on jQuery already they will provide an incentive and a long enough transition period to refactor
their jQuery usage to use standard DOM APIs.

### jQuery might still be needed

This RFC does not propose to discourage the use of jQuery. There are legitimate cases where you still want to have it.
And this is also true for addons, especially those that basically wrap other jQuery-based libraries like jQuery plugins
in an Ember friendly way. For those cases, there should be an *opt-in* path to continue bundling jQuery and to preserve
the existing APIs around it. This is what the `@ember/jquery` package is meant for.

## Transition path

### Add deprecations

All current public APIs that are coupled to jQuery should be deprecated via the usual deprecation process.
This specifically involves:

* adding a (universal, non-silenceable) deprecation warning to `Ember.$()`
* adding a deprecation warning to `this.$()` in an `Ember.Component`
* adding a deprecation warning to `this.$()` in component integration tests, based on `setupRenderingTest()`

### `this.$()` in old style tests

`this.$()` in tests based on the old `moduleForComponent()` based testing APIs will not be specifically deprecated,
as these legacy testing APIs will eventually be deprecated altogether, as already envisaged in RFC232.

### Extend `@ember/jquery` package

For apps and addons that have to or choose to still require jQuery, they can add this package to its dependencies.
This will provide a way to retain the deprecated and later removed APIs. So by adding this to your dependencies this
would effectively be the way to *opt-in* to require jQuery.

RFC294 already introduced this package, being responsible to include jQuery into the JavaScript bundle. As part of this
RFC the scope of this addon will be extended to also reintroduce the deprecated APIs, but *without* triggering any
deprecation warnings for `this.$()` in a component.

As the default `EventDispatcher`, which currently dispatches jQuery events when jQuery is enabled, will eventually
support native events only (see the Timeline below), the addon also needs to replace it with one that again dispatches
jQuery events for compatibility with existing jQuery-based code. This can happen in a similar way as
[ember-native-dom-event-dispatcher](https://github.com/rwjblue/ember-native-dom-event-dispatcher) did it, just the other
way around.

**This effectively makes the integration of jQuery a feature of this addon, rather than Ember itself, which is freed from
the burden to care about this.**

So effectively, for the Ember 3.x release cycle, adding this package will not change the behavior in any significant way,
other than removing the mentioned deprecation warnings, as Ember will still have these APIs available. However starting
with Ember 4.0, which will have these APIs removed and not include jQuery integration features anymore, this
package will make sure jQuery remains included and it will add the now removed APIs back again, so any jQuery depending
code will continue to work just as before. Also see the timeline below.

As `ember-cli-babel` will currently transform `import $ from 'jquery';` to use `Ember.$` again, it must be made aware of
the `@ember/jquery` package so it tells `babel-plugin-ember-modules-api-polyfill` not to convert those imports to the
global `Ember.$`. Instead the package itself should provide the necessary shim to make `import $ from 'jquery';` work.

Addons that continue to depend on jQuery would have to list this package as a dependency in their `package.json`,
to make their consuming app automatically include jQuery and the related APIs in its bundle as mentioned above.
Thereby they make their dependency on jQuery explicit, which in turn helps users to make an educated choice if they
deem this to be acceptable.

### Extend ember-fetch

The `ember-fetch` addon integrates the newer [`Fetch API`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
nicely into an Ember app, with an (optional) polyfill for older browsers. This can be used as a replacement for the
jQuery-based `ember-ajax`.

One piece that is missing so far when switching is a convenient way to customize all outgoing requests, e.g. to add
HTTP headers for authentication tokens. When using jQuery's AJAX implementation, this could be easily done using its
[`prefilter`](http://api.jquery.com/jquery.ajaxprefilter/) function. To facilitate something similar when using
`ember-fetch`, the addon should be extended with an appropriate API, e.g. by adding a simple service through which
fetch requests are issued, which provides similar features for customization. The exact API of such a service is however
out of scope for this RFC.

### Make ember-data use ember-fetch

It must be ensured that all parts of the core Ember experience work flawlessly without jQuery. Currently `ember-data`
is still relying on jQuery for its XHR requests. By the time this RFC is implemented (i.e. the deprecation messages are
added), it must work out of the box without jQuery.

Fortunately [migration efforts](https://github.com/emberjs/data/pull/5386) are well advanced to support the `fetch` API
through `ember-fetch`, so we can expect that to land soon enough that it does not block the transition.

### Update app blueprint

The blueprint to create a new app with `ember new` should be updated to not use jQuery by default. This involves to
* disable jQuery integration by default (in `config/optional-features.json`)
* remove the `@ember/jquery` package
* replace `ember-ajax` with `ember-fetch`
* add the [`no-jquery`](https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-jquery.md) rule to the
default ESLint config

### Timeline

During Ember 3.x:
1. migrate the jQuery integration features to the `@ember/jquery` package
2. update the blueprints as stated above
3. add deprecation warnings as stated above

Upon Ember 4.0
* remove deprecated functions
* remove the jQuery specific code paths in the `EventDispatcher`

## How we teach this

As part of the efforts to make jQuery optional, the guides have already been updated to have all examples teach native
DOM APIs instead of jQuery, and the new testing APIs.
The [jQuery migration guide](https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_jquery-integration)
already mentions the APIs that are not available anymore without jQuery and how to opt-out now.

Activating the `no-jquery` ESLint rule will warn developers about any usages of the jQuery-based APIs being deprecated
here.

The newly added deprecation messages should link to a deprecation guide, which will provide details on how to silence
these deprecations, either by using native DOM APIs only or by installing `@ember/jquery` to explicitly opt-in into
jQuery.

For apps the tone of it should be neutral regarding jQuery itself, in the sense that using jQuery is neither
bad nor good by itself. It depends on the context of the app if using jQuery makes sense or not. It is just that *Ember*
does no need it anymore, so it is not part of the default Ember experience anymore.

For addons the story is a bit different, in that they are not aware of their app's context, so they should abstain from
using jQuery if possible. See the [Motivation](#motivation) chapter above.

## Drawbacks

### Churn

A vast amount of addons still depend on jQuery, so adding the deprecations will add some considerable churn for the addon
ecosystem. As of writing this, there are:
* [407 addons](https://emberobserver.com/code-search?codeQuery=Ember.%24) using `Ember.$`
* [546 addons](https://emberobserver.com/code-search?codeQuery=this.%24&fileFilter=addon%2Fcomponents) using `this.$` in components
* [994 addons](https://emberobserver.com/code-search?codeQuery=this.%24&fileFilter=tests) using `this.$` in tests

A good amount of that churn can be mitigated by
* existing codemods that migrate tests
* having an easy way, given by the `@ember/jquery` package, to opt-in to continue bundling jQuery, and to restore the
deprecated APIs, so no further refactorings are required

## Alternatives

Stick to the current *opt-out* process.



---

---
stage: accepted
start-date: 2018-10-14T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/389
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/42
---

# Dynamic tag names in glimmer templates.

## Summary

With the transition from inner-html semantics to outer-html semantics in components, we lost one feature: Being
able dynamically define the tag name of components.

I think it was an useful feature and we should find a way to bring it back.

## Motivation

Although not something we use every day, there is a need for some components to have a dynamic tag name.

This is most often used for certain low-level _presentational_ components.

Take for instance a component named `<Panel>` that is used to encapsulate some presentation concerns.
The template of that component could be like this:

```hbs
<div class="pt-10 pb-10 ps-20 box-shadow" ...attributes>
  {{yield}}
</div>
```

For accessibility and semantic reasons, sometimes a `<div>` may not be the best kind of tag.
We might want the panel to be a `<section>` element, or an `<aside>` when it's content is somewhat unrelated
with the rest of the page. Or maybe a `<legend>` if it's and the end of a form.

With the `element` helper proposed in this RFC, this can be accomplished with something like this:

```hbs
{{#let (element @tagName) as |Tag|}}
  <Tag class="pt-10 pb-10 ps-20 box-shadow" ...attributes>
    {{yield}}
  </Tag>
{{/let}}
```

## Detailed design

We propose to add a new `element` helper that takes a single positional argument.

* When passed a non-empty string it generates a contextual component that, when invoked, renders an element with the same tag name as the passed string, along with the passed attributes (if any), modifiers (if any) and yields to given block (if any).
* When passed an empty string, it generates a contextual compoment that, when invoked, yields to the given block without wrapping it an element and ignores any passed modifiers and attributes.
* When passed `null` or `undefined`, it will return `null`.
* When passed any other values (e.g. a boolean or a number), it will result in a development mode assertion.

Example:

```hbs
{{#let (element @htmlTag) as |Tag|}}
  <Tag class="my-element" {{on "click" this.tagClicked}}>Hello</Tag>
{{/let}}

{{!-- when @htmlTag="button" --}}
<button class="my-element" {{on "click" this.tagClicked}}>Hello</button>

{{!-- when @htmlTag="" --}}
Hello

{{!-- when @htmlTag=null or @htmlTag=undefined, it renders nothing --}}

{{!-- when @htmlTag=true or @htmlTag=1, it throws in development mode --}}
```

Unlike ids, classes or other attributes, the tag name of DOM element cannot be changed in runtime.

To help the user understand that changing the tag of an element in runtime is an expensive operation,
the syntax is intentionally chosen to express that changes in the tag name will turn down the given block
and recreate it again.

Having dynamic tag names can also open the door to possible XSS vulnerabilities if developers allow user-input
to become tag names (e.g. `xlink:`) . To prevent that, this helper will throw an error for any tag name containing anyting
but lowercase letters and dashes.

A working proof of concept of this approach has been created in https://github.com/tildeio/ember-element-helper

Shall this RFC me accepted, that helper would be ported to Ember.js itself, perhaps making it more efficient
on the process.

## How we teach this

_It's vitally important that developers have awareness the negative impact that misuse of dynamic tags can have on the accessibility of an Ember application._

While dynamic tags enable a great deal of flexibility in components, it's essential to recognize that these can also negatively impact accessibility. Developers should be keenly aware of the appropriate role that should be applied per HTML element (as specified in the [WAI-ARIA specification](https://www.w3.org/WAI/PF/aria/roles)), and ensure that the role is also updated, if necessary, as the tag name is changed. In some cases, the use of native, semantic HTML elements may eliminate the need to apply a role at all, so developers should consult the WAI-ARIA specification until they are certain of the correct use for their specific use cases.

This new helpers will be added to the list of [built-in helpers](https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers) along
with its cousins `component`, `array`, `each`, etc...

Some meaningful example for the docs could look like this (extracted from a real use case):

```hbs
{{!-- sidebar.hbs, a template-only component --}}
{{#let (element (or @htmlTag "aside")) as |Tag|}}
  <Tag ...>...</Tag>
{{/let}}
```

```hbs
<Sidebar @htmlTag="nav">...</Sidebar>
```

Since this feature is not very commonly used, it should not be mentioned in the more beginner-friendly portion
of the guides. However, the _Components > Customizing a Component's Element_ section is a perfect fit for this.

## Drawbacks

Admittedly this syntax is somewhat convoluted, as it involves using the `let` helper, the new `element`
helper that yields a contextual component that is then invoked using angle-bracket syntax.

This syntax is intentional to make clear that any change in the tag name would yield a new contextual component,
effectively tearing down the previous one before rendering the new one, but I can see perceiving this
as unnecessarily complex.

## Alternatives

We can decide not to do anything and leave this problem to be solved in user space, as it can be
solved using only public APIs.

We can also propose other alternative syntaxes. For instance, we could have a special built-in component for this:

```hbs
<DynamicElement @tagName={{@tagName}} class="some-class" ...attributes>
</DynamicElement>
```

## Unresolved questions

---


---

---
stage: accepted
start-date: 2018-10-22T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/391
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/14
---

# Router Helpers

## Summary

This RFC introduces new router helpers that represent a decomposition of functionality of what we commonly use `{{link-to}}` for. Below is a list of the new helpers:

```hbs
{{url-for}}
{{root-url}}
{{is-active}}
{{is-loading}}
{{is-transitioning-in}}
{{is-transitioning-out}}
```

This represents a super set of the functionality provided by [Ember Router Helpers](https://github.com/rwjblue/ember-router-helpers/) which has provided this RFC that confidence that a decomposition is possible.

This RFC does **not** deprecate `{{link-to}}` or `{{query-params}}`. These deprecations will come in the form of a deprecation RFC.

## Motivation

`{{link-to}}` is the primary way for Ember applications to transition from route to route in your application. While this works for a lot of cases there are some use cases that are not well supported or supported at all by the framework. Below is an enumeration of cases that `{{link-to}}` does not address.

### Anchor Tags

We currently do not have a good solution for transitioning solely based on HTML anchors defined in the templating layer. For instance let say you are using [Ember Intl](https://github.com/ember-intl/ember-intl) to do internationalization for your application. Ember Intl uses the [ICU message format](http://userguide.icu-project.org/formatparse/messages) for the actual translation strings and supports having HTML within the string. Now lets say you want to put a link in a translation string and have it work like `{{link-to}}` works. In that case you either have to roll your own solution or use something like [Ember-href-to](https://github.com/intercom/ember-href-to). Another example where this would be useful is that links within markdown produced by addons like [Ember-CLI-Showdown](https://github.com/gcollazo/ember-cli-showdown) would just work. API's like `RouterService#transitionTo` can transition an application using relative URLs and we have an opportunity to leverage this functionality to support this use case.

### Extensibility Of `{{link-to}}`

In 2.11 we moved `LinkComponent` from `private` to `public` largely because there was no other way to modify the behavior of `{{link-to}}` and it had effectively become de-facto public API. That being said, it is less than desirable to `reopen` or `extend` framework objects to gain access to the functionality to create some application specific primitive. For example [Ember Bootsrap](https://github.com/kaliber5/ember-bootstrap/) extends the [`LinkComponent`](https://github.com/kaliber5/ember-bootstrap/blob/master/addon/components/base/bs-dropdown/menu/link-to.js) and then layers more functionality on top of it. Addons would be better served if they had access to more primitive functionality.

### CSS Class Magic

`{{link-to}}` adds some convienent, yet not obvious, classes to the element. These classes are:

- `active`: applied to any `{{link-to}}` that is on the "active" path
- `disabled`: applied depending on the evaluation of `disabled=someBool`
- `loading`: applied if one or more of the models passed are `undefined`
- `ember-transitioning-in`: applied to links that are about to be `active`
- `ember-transitioning-out`: applied to links that are about to be deactivated

The issue with these class names is that they are not declared anywhere in your templated and are provided by the `LinkComponent` as `classNameBindings`. This effectively creates a set of reserved class names that are highly prone to colissions in your typical application.

Furthermore, addons like [ember-cli-active-link-wrapper](https://github.com/alexspeller/ember-cli-active-link-wrapper) and [ember-bootstarp-nav-link](https://github.com/zoltan-nz/ember-bootstrap-nav-link) do a ton of work arounds to get things like the `.active` class to show up on wrapping elements instead of the element directly. This is a great example that shows we are missing some primitives.

### Default Query Param Serialization

Lastly, `{{link-to}}` has very strange behavior when it comes to serializing query params. On a controller you declare the query params for a specific route. These query params can have defaults for them. For example if you have a controller that looks like:

```js
// app/controllers/profile.js
import Controller from '@ember/controller';

export default Controller.extend({
  queryParams: ['someBool'],
  someBool: true,
})
```

and you to link to it like this:

```hbs
{{#link-to 'profile'}}Profile{{/link-to}}
```

In the DOM you will have an `href` on the anchor that gets serializes as:

```html
<a href="/profile?someBool=true" class="active ember-view">Profile</a>
```

Looking at a template you would have no idea that rendering the `{{link-to}}` would result in the query params being serialized. From an implementation point of view, this is problematic as we are forced to `lookup` the `Route` and the associated `Controller` to grab the query params. This can add a non-trivial amount of overhead during rendering, especially if you have many `{{link-to}}`s on a route that link many different parts of your application. As a side-note, this is one of the things  that needs to be dealt with if we are ever to kill controllers.

### Does Not Work With Angle Bracket Invocation

Since angle bracket invocation does not support positional params, `{{link-to}}` has to adapt its public API.

### Costly API

`{{link-to}}` has [a lot of functionality](#kitchen-sink), however this functionality does come at a cost for every instance of `{{link-to}}`. This is not ideal especially if you're just using `{{link-to}}` to generate a url that can be transitioned to. By providing fine grain control of the functionality, applications should see a performance boost.

## Detailed design

Below is a detailed design of all of the template helpers.

### URL Generation Helpers

The following helpers are to be used to construct a valid root-relative URL that will be used by the event dispatcher to perform a transition. These helpers **do not** pass the in memory model, meaning the model hook will always run for the route you are transitioning to.

### `{{url-for}}` Helper

```hbs
{{url-for routeName model queryParams=(hash a=a)}}
```

Or

```hbs
{{url-for routeName models=model queryParams=(hash a=a)}}
```

`{{url-for}}` generates a root-relative URL as a string (which will include the application's rootUrl). When the link is clicked it will cause a transition to occur. See the [Event Dispatcher Changes](#event-dispatcher-changes). It will not serialize the default query params on the controller.

#### Signature Explainer

Using the example above:

_Positional Params_
- **`routeName`** _String_: A fully-qualified name of this route, like `"people.index"`
- **`model`** _...Object|Array|Number|String_: Optionally pass an arbitrary amount of models or identifiers for each dynamic segment to be use for generation.

_Named Params_
- **`models`** _Object|Array|Number|String_: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.
- **`queryParms`** _Object_: Optionally pass key value pairs that will be serialized

_Returns_
- _String_: a root-relative URL as a string (which will include the application's `rootUrl`)

### `{{root-url}}` Helper

`{{root-url}}` simply returns the value from `Application.rootURL`. It can be used to prefix any `href` values you wish to hard code.

```hbs
<a href="{{root-url}}profile">Profile</a>
```

Will result in the following for the default configuration:

```html
<a href="/profile">Profile</a>
```

#### Signature Explainer

`{{root-url}}` does not take any parameters.

### Route State Helpers

The following helpers are all _context dependent_, not global. For instance you might have two copies of `(is-active "posts")` in your app simultaneously where one is `true` and one is `false`, because you're in the middle of an animated transition, or because you're pre-rendering a route that hasn't been entered yet.

### `{{is-active}}` Helper

```hbs
{{is-active 'people.index' model queryParams=(hash a=a)}}
```

or

```hbs
{{is-active 'people.index' models=model queryParams=(hash a=a)}}
```

The arguments to `{{is-active}}` have the same semantics as `{{url-for}}`, however the return value is a boolean. This should provide the same logic that determines whether to put an `active` class on a `{{link-to}}`.

#### Signature Explainer

Using the example above:

_Positional Params_
- **`routeName`** _String_: A fully-qualified name of this route, like `"people.index"`
- **`model`** _...Object|Array|Number|String_: Optionally pass an arbitrary amount of models to use for generation

_Named Params_
- **`models`** _Object|Array|Number|String_: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.
- **`queryParms`** _Object_: Optionally pass key value pairs that will be used to determine if the route is active.

_Returns_
- _Boolean_: Determines if the route is active or not.

### `{{is-loading}}` Helper

```hbs
{{is-loading 'people.index' model queryParams=(hash a=a)}}
```

Or

```hbs
{{is-loading 'people.index' models=model queryParams=(hash a=a)}}
```

The arguments to `{{is-loading}}` have the same semantics as `{{url-for}}` and `{{is-active}}`, however if any of the model(s) passed to it are unresolved e.g. evaluate to `undefined` the helper will return `true`, otherwise the helper will return `false`. This should provide the same logic that determines whether to put an `loading` class on a `{{link-to}}`.

#### Signature Explainer

Using the example above:

_Positional Params_
- **`routeName`** _String_: A fully-qualified name of this route, like `"people.index"`
- **`model`** _...Object|Array|Number|String_: Optionally pass an arbitrary amount of models to use for generation

_Named Params_
- **`models`** _Object|Array|Number|String_: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.
- **`queryParms`** _Object_: Optionally pass key value pairs that will be used to determine if the route is loading.

_Returns_
- _Boolean_: Determines if the route is loading or not.

### `{{is-transitioning-in}}` Helper

```hbs
{{is-transitioning-in 'people.index' model queryParams=(hash a=a)}}
```

Or

```hbs
{{is-transitioning-in 'people.index' models=model queryParams=(hash a=a)}}
```

The arguments to `{{is-transitioning-in}}` have the same semantics as all the other route state helpers, however `{{is-transitioning-in}}` only returns `true` when the route is going from an non-active to an active state. This should provide the same logic that determines whether to put an `ember-transition-in` class on a `{{link-to}}`.

#### Signature Explainer

Using the example above:

_Positional Params_
- **`routeName`** _String_: A fully-qualified name of this route, like `"people.index"`
- **`model`** _...Object|Array|Number|String_: Optionally pass an arbitrary amount of models to use for generation

_Named Params_
- **`models`** _Object|Array|Number|String_: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.
- **`queryParms`** _Object_:  Optionally pass key value pairs that will be used to determine if the route is transitioning in.

_Returns_
- _Boolean_: Determines if the route is transitioning in.

### `{{is-transitioning-out}}` Helper

```hbs
{{is-transitioning-out 'people.index' model queryParams=(hash a=a)}}
```

Or

```hbs
{{is-transitioning-out 'people.index' models=model queryParams=(hash a=a)}}
```

`{{is-transitioning-out}}` is just the inverse of `{{is-transitioning-in}}`.

#### Signature Explainer

Using the example above:

_Positional Params_
- **`routeName`** _String_: A fully-qualified name of this route, like `"people.index"`
- **`model`** _...Object|Array|Number|String_: Optionally pass an arbitrary amount of models to use for generation

_Named Params_
- **`models`** _Object|Array|Number|String_: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.
- **`queryParms`** _Object_:  Optionally pass key value pairs that will be used to determine if the route is transitioning out.

_Returns_
- _Boolean_: Determines if the route is transitioning out.

### Event Dispatcher

In the past, only `HTMLAnchorElement`s that were produced by `{{link-to}}`s would produce a transition when a user clicked on them. This RFC changes to the global `EventDispatcher` to allow for any `HTMLAnchorElement` with a valid root relative `href` to cause a transition. This will allow for us to not only allows us to support use cases like the ones described in the [motivation](#anchor-tags), it makes teaching easier since people who know HTML don't need know an Ember specific API to participate in routing transitions.

#### Route Globs And Route Blacklisting

While the vast majority of the time developers want root relative URLs to cause a transition there are cases where you want root relative urls to cause a normal HTTP navigation. In the router map you can define [wildcard / globbing](https://guides.emberjs.com/release/routing/defining-your-routes/#toc_wildcard--globbing-routes) that makes this problematic as any root relative url can be catched by a wildcard route. To solve this issue this RFC proposes expanding the route options to allow for a black list of urls that are allowed to cause a normal HTTP navigation.


```js
Router.map(function() {
  this.route('not-found', { path: '/*path', blacklist: ['/contact-us', '/order/:order_id'] });
});
```

When an event comes into the `EventDispatcher` we will cross check the blacklist to see if the event should be let through to the browser or if it should be handled internally.

### Transition Attribution

This RFC introduces the notion of an `attribution` to the `Transition`. The `TransitionAttribution` is a read-only object that has 2 fields `event` and `source`.

```ts
interface TransitionAttribution {
  readonly event: Maybe<Event>;
  readonly source: unknown
}

interface Transition {
  readonly attribution: TransitionAttribution;
}
```

On initial render `event` and `source` will be `null`. On subsequent transitions, the `event` will be the DOM event that caused the transition and `element` will be populated with `HTMLElement` that the user interacted with to cause the transition. See [Appendix A](#appendix-a) for example usage. In the event that the transition occurs programmatically through an API like `replaceWith` or `transitionTo` the `event` will be `null` but can be [populated by the caller](#programatic-attribution).

#### Programatic Attribution

In cases where you need to programatically transition with `transitionTo` or `replaceWith` we will allow for you to pass your own `TransitionAttribution`. See Appendix B for an example.

```ts
interface Options {
  queryParams?: Dict<string|number>,
  attribution?: TransitionAttribution;
}

interface Router /* Route, RouterService */ {
  //...
  transitionTo(routeName: string, models?: string|number|object, options?: Options): Transition;
  replaceWith(routeName: string, models?: string|number|object, options?: Options): Transition;
}
```

#### `Transition.attribution` Integrity

The `attribution` in a `Transition` is guaranteed to be carried through the completion of the route transition. This includes `abort`s, `redirect`s and `retry`s of the transition. The `attribution` field is readonlu and the `TransitionAttribution` is readonly and frozen.


## Migration Path

Since this RFC does not deprecate `{{link-to}}` you can continue to use it. That being said `{{link-to}}` has static semantics therefore we can write a codemod using [Ember Template Recast](https://github.com/ember-template-lint/ember-template-recast) to migrate the code. Below are numerous before and after examples of how the codemod would migrate. It's important to note that the behavior of the application [will change](#url-generation-helpers) if you are relying on the passing of the in-memory model. Because of this the codemod would need different levels of conversion.

### Basic `{{link-to}}`

**Before:**

```hbs
{{#link-to 'profile' class="profile"}}Profile{{/link-to}}
{{link-to 'About' 'about'}}
```

**After:**

```hbs
<a href={{url-for 'profile'}} class="profile">Profile</a>
<a href={{url-for 'about'}}>About</a>
```

### With Model `{{link-to}}`

**Before:**

```hbs
{{#link-to 'profile' this.profile class="profile"}}Profile{{/link-to}}
{{link-to 'About' 'about' this.contact}}
```

**After:**

```hbs
<a class="profile" href={{url-for 'profile' this.profile}}>Profile</a>
<a href={{url-for 'about' this.contact}}>About</a>
```

### With Query Params `{{link-to}}`

**Before:**

```hbs
{{#link-to 'post' this.post (query-params order="CHRON")}}{{this.post.name}}{{/link-to}}
```

**After:**

```hbs
<a href={{url-for 'post' this.post queryParms=(hash order="CHRON")}}>{{this.post.name}}</a>
```

One of the trickier parts about this migration is knowing how the autogenerated CSS classes are being used. Because of this, adding the route state helpers must explicitly be turned on in the codemod. For instance if you are making heavy use of the `.active` class, you will be suited best by turning pass the codemod the correct configuration to do a transform like the following:

**Before**

```hbs
{{#link-to 'profile'}}Profile{{/link-to}}
```

**After**

```hbs
<a href={{url-for 'profile'}} class={{if (is-active 'profile') 'active'}}>Profile</a>
```

#### Kitchen Sink

If you were to transform all `{{link-to}}`s verbatim in terms of functionality this would be the result.

**Before**

```hbs
{{#link-to 'profile' model (query-parmas foo=bar) replace=true}}Profile{{/link-to}}
```

**After**

```hbs
<a
  href={{url-for 'profile'
    model
    queryParams=(hash foo=bar)}}
  class="{{if (is-active 'profile' model queryParams=(hash foo=bar)) 'active'}} {{if (is-loading 'profile' model queryParams=(hash foo=bar)) 'loading'}} {{if (is-transitioning-in 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-in'}} {{if (is-transitioning-out 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-out'}}">Profile</a>
```

As the kitchen sink example shows, `{{link-to}}` is packed with functionality. While this convienent, it comes with a cost per `{{link-to}}` and is the reason why addons like [Ember-href-to](https://github.com/intercom/ember-href-to) were created. In reality the vast majority of applications only need a subset of this functionality and only in rare cases need things like the transition and loading states.

## How we teach this

In many ways this vastly simplifies Ember's approach to linking within the app. It removes the requirement for a proprietary API and instead embraces the power of URLs.

In the cases where you do need to do more complicated things like pass in memory models to a route, things should feel very similar to `{{link-to}}` as they have the exact same signature. In the case of query param serialization, I believe we are actually aligning a mental model as to how URL generation should work.

## Drawbacks

This RFC expands the surface area of the templating layer by exposing the primitives that make up `{{link-to}}`. This may cause confusion of choosing between using simple basic anchor tags, `{{url-for}}` and `{{link-to}}`, however I believe that each one of the these APIs are solving a real problem that we have in Ember today.

By proxy this may cause people to encapsulate all of these primitives into a single component and thus creating a user-land version of `{{link-to}}`. This could be seen as a framework misstep if the majority of applications end up depending on the addon.

## Alternatives

We could just start deprecating and removing functionality from `{{link-to}}` itself. That being said, it is hard to understand how much of the community is reliant on certain feature of `{{link-to}}`. This also doesn't help with usecases like the i18n and markdown use cases.

## Unresolved questions

TBD?


## Appendix A

```js
// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
```

```js
// app/components/track-link.js
import Component from '@ember/component';
import TRACKING_DATA from '../utils/tracking';

export default Component.extend({
  tagName: 'a',
  attributeBindings: ['href'],
  didInsertElement() {
    TRACKING_DATA.set(this.element, this.contextName);
  }
})
```

```js
// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition => {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
```

```hbs
<h1>Hello {{@name}}!</h1>
<TrackLink href="/profile" @contextName="profile.link">Profile</TrackLink>
<TrackLink href="/about" @contextName="about.link">About</TrackLink>
<TrackLink href="/contact" @contextName="contact.link">Contact</TrackLink>
```

## Appendix B

```js
// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
```

```js
// app/routes/profile.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  store: service('store'),
  actions: {
    changeName(name) {
      this.model.set('name', name);
    },

    changeAge(age) {
      this.model.set('age', age);
    },

    submit(e) {
      if (isValid(this.model)) {
        let attribution = {
          event: e,
          source: e.target,
        };

        TRACKING_DATA.set(e.target, 'profile.submit');

        this.model.save().then(() => {
          this.transitionTo('profile.success', { attribution });
        }, () => {
          alert('Issue saving... please try again.');
        });
      } else {
        alert('Data is not valid!');
      }
    }
  }
})
```

```hbs
<input onchange={{action 'changeName' value="target.value"}} />
<input onchange={{action 'changeAge' value="target.value"}} />
<button onclick={{action 'submit' this.model}}>Submit</button>
```

```js
// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition => {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
```



---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2018-10-23T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/392
project-link:
---

# Summary

This deprecates the string-based lookup API for associating a custom component manager with a corresponding base class.

```js
import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  //...
}))
```

Instead, you must pass a factory function that produces an instance of the custom manager:

```js
import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setComponentManager } from '@ember/modifier';

export default setComponentManager(createManager, EmberObject.extend({
  // ...
}));
```

Where `createManager` is:

```js
export function createManager(owner) {
  return new BasicManager(owner);
}
```

# Motivation

There are several motivators:

- A string-based API is not friendly when it comes to tree shaking. It would force us into creating a compiler to turn the string into a symbol that build tools like Rollup and Webpack could analyze.
- This API expands the namespacing problems associated with module unification. Specifically, an addon author would have to associate the package name with the string, similar to how [RFC#367](https://github.com/mixonic/rfcs/blob/mu-packages/text/0000-module-unification-packages.md#explicit-packages-for-service-injections) proposes changes to services.
- `setModifierManager` as introduced by [RFC#373](https://github.com/emberjs/rfcs/blob/89349d30ade24303a06448bc121b8fd810cbe58d/text/0373-Element-Modifier-Managers.md#determining-which-modifier-manager-to-use) uses a factory style API. This RFC intends to align these to function signatures.
- We want to make sure this API is compatible with the binary AoT compilation work we did in the Glimmer-VM.

# Transition Path

We can transition away by producing a factory function in the internals of `setupComponentManager`. The implementation would look something like:

```js
export function setComponentManager(stringOrFunction, obj: any) {
  let factory;
  if (typeof stringOrFunction === 'string') {
    deprecate(
      `Passing the name of the component manager to 'setupComponentManager' is deprecated. Please pass a function that produces an instance of the manager.`,
      {
        id: 'deprecate-string-based-component-manager',
        unil: '4.0.0'
      }
    );
    factory = function(owner: Owner) {
      return owner.lookup(`component-manager:${stringOrFunction}`);
    };
  } else {
    factory = stringOrFunction;
  }

  // ...
}

```

# How We Teach This

From our understanding this API has very limited usage as it is a low-level API. We should update that docs accordingly.

# Drawbacks

Historically, Ember has given developers base classes that the developer would extend from and Ember would create instances on your behalf. This allows the framework to know that the interface of the object is complete. With this approach we are relying more on the addon author to construct the object and ensure it conforms to the correct interface.

Generally speaking this a good practice of OOP but due to the fact that JavaScript does not have first-class interfaces, Ember has taken the concretion approach.

# Alternatives

Instead of passing a factory function we could pass the class itself. This option does have the issue of Ember needing to know how to construct the class and does not allow for the addon author to perform any dependency injections.

# Unresolved questions

TBD?


---

---
stage: recommended
start-date: 2018-10-31T00:00:00.000Z
release-date: 2019-06-28T00:00:00.000Z
release-versions:
  ember-data: v3.11.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/395
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/11
---

# Ember Data Packages

## Summary

This documents presents the proposed **public** import path changes for `ember-data`, and moving `ember-data`
  into the `@ember-data` namespace.

## Motivation

**Reduce Confusion & Bike Shedding**

Users of `ember-data` have often noted their confusion by the existence of both direct and "god object" (`DS.`) style
 imports for modules from `ember-data`. The documentation currently uses primarily the `DS.` style, and users have
 expressed interest and confusion over why the documentation has not been updated to reflect direct imports.

**Improve The TypeScript Experience**

Presence of multiple import locations confuses `Typescript`'s autocomplete, symbol resolution, and type hinting.

**Simplify The Mental Model**

Users of `ember-data` complain about the large API surface area; however, a large portion of this surface area is
 non-essential user-land APIs that the provided adapter and serializer implementations expose. This move to packages
 helps us simplify the mental model in three ways.

 First: it gives us a natural way of dividing the documentation and learning story such that key concepts
   and APIs are more discoverable.

 Second: it allows us specifically to isolate the API surface area explosion of the provided adapter and serializer
   implementations and make it clear that these are non-essential, replaceable APIs. E.G. it will help us to communicate
   that these adapters and serializers are _an implementation_, **not** _the required implementation_.

 Third: it clarifies the roles of several concepts within `ember-data` that are often misused today. Specifically:
   the `embedded-records-mixin` should *_only_* be used with the `RESTAdapter`, and `transforms` are *_only_* a
   serialization/deserialization concern and not a way of defining custom `attrs` or `types`. Furthermore, `transforms`
   are only applicable to the serializer implementations that `ember-data` provides, and not to `custom` (and sometimes
   not to `subclassed`) serializers.

**Improve the Contributor Experience**

Contributors to `ember-data` are faced with a large, complex project with poor code and test organization. This makes it
 unduly difficult to discover what tests exist, where to add tests, where associated code lives, and even what parts of
 the code base relate to the feature or bug that they are looking to address.

 This move to packages will help us restructure the project and associated tests in a manner that is more discoverable.

**Provide a Clear Subdivision of Packages**

Today, `ember-data` is a large single package (`~35KB gzipped` in production). `ember-data` is often one of the largest
 dependencies `emberjs` users have in their applications. However, not all users utilize all parts of `ember-data`, and
 some users use very little. Providing these packages helps to clearly show the cost of various features, and better
 allows us to enable end users to eliminate unneeded packages.

Users that implement their own adapter or serializers today must still carry the significant weight of the adapter and
 serializer implementations that `ember-data` ships regardless. This is a weight we should enable these users to eliminate.

With the landing of `RecordData` and the merging of the `modelFactoryFor` RFC, it is likely that many applications
 will soon require far less of `ember-data` than they do today. `ember-m3` is an example of a project that utilizes these
 APIs in a way that requires significantly less of the `ember-data` experience.

**Provide Infrastructure for Additional Changes**

`ember-data` is entering a period of extended evolution, of which `RecordData` and `modelFactoryFor` are only the early
  pieces. For example, current thinking includes the possibility of `ember-data` evolving to provide an `ember-m3`-like
  experience for `json-api` as the default out-of-the-box experience, and a rethinking of how we manage the request/response
  lifecycle when fulfilling a request for data.

 These experiences would live alongside the existing experience for a time prior to any deprecations of the current layer,
  and it is possible that sometimes the current experience would never be deprecated. Subdividing `ember-data` into these
  packages will enable us to provide a more seamless transition between these experiences without hoisting any package
  size costs onto users that do not use either the current or the new experience.

## Detailed design

This RFC proposes import paths following the guidelines established in [Ember Modules RFC #176](https://github.com/emberjs/rfcs/pull/176),
  with two addendums to account for scenarios that weren't faced by `ember`:
* `Error` sub-classes are named exports
* `Mixins` are named exports

This is done to allow for continued grouping by common usage and mental model, where otherwise users would be faced with multiple imports from length file paths.

The following modules would continue to live in a monorepo that (until further RFC) would continue to live at `github.com/ember/data`.

<table>
  <thead>
    <tr>
      <th colspan="2">Before</th>
      <th>After</th>
    </tr>
    <tr>
        <th>import DS from 'ember-data';</th>
        <th>Direct Import</th>
        <th>New Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="3"><h3>@ember-data/model</h3></td>
    </tr>
    <tr>
      <td>DS.Model</td>
      <td>import Model from 'ember-data/model';</td>
      <td>import Model from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.attr</td>
      <td>import attr from 'ember-data/attr';</td>
      <td>import { attr } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.belongsTo</td>
      <td>import { belongsTo } from 'ember-data/relationships';</td>
      <td>import { belongsTo } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.hasMany</td>
      <td>import { hasMany } from 'ember-data/relationships';</td>
      <td>import { hasMany } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/adapter</h3></td>
    </tr>
    <tr>
      <td>DS.Adapter</td>
      <td>import Adapter from 'ember-data/adapter';</td>
      <td>import Adapter from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.RESTAdapter</td>
      <td>import RESTAdapter from 'ember-data/adapters/rest';</td>
      <td>import RESTAdapter from '@ember-data/adapter/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPIAdapter</td>
      <td>import JSONAPIAdapter from 'ember-data/adapters/json-api';</td>
      <td>import JSONAPIAdapter from '@ember-data/adapter/json-api';</td>
    </tr>
    <tr>
      <td>DS.BuildURLMixin</td>
      <td>none</td>
      <td>import { BuildURLMixin } from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.AdapterError</td>
      <td>import { AdapterError } from 'ember-data/adapters/errors';</td>
      <td>import AdapterError from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.InvalidError</td>
      <td>import { InvalidError } from 'ember-data/adapters/errors';</td>
      <td>import { InvalidError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.TimeoutError</td>
      <td>import { TimeoutError } from 'ember-data/adapters/errors';</td>
      <td>import { TimeoutError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.AbortError</td>
      <td>import { AbortError } from 'ember-data/adapters/errors';</td>
      <td>import { AbortError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.UnauthorizedError</td>
      <td>import { UnauthorizedError } from 'ember-data/adapters/errors';</td>
      <td>import { UnauthorizedError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ForbiddenError</td>
      <td>import { ForbiddenError } from 'ember-data/adapters/errors';</td>
      <td>import { ForbiddenError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.NotFoundError</td>
      <td>import { NotFoundError } from 'ember-data/adapters/errors';</td>
      <td>import { NotFoundError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ConflictError</td>
      <td>import { ConflictError } from 'ember-data/adapters/errors';</td>
      <td>import { ConflictError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ServerError</td>
      <td>import { ServerError } from 'ember-data/adapters/errors';</td>
      <td>import { ServerError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.errorsHashToArray</td>
      <td>none</td>
      <td>import { errorsHashToArray } from '@ember-data/adapter/error';<br>
         <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td>DS.errorsArrayToHash</td>
      <td>none</td>
      <td>import { errorsArrayToHash } from '@ember-data/adapter/error';<br>
        <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/serializer</h3></td>
    </tr>
    <tr>
      <td>DS.Serializer</td>
      <td>import Serializer from 'ember-data/serializer';</td>
      <td>import Serializer from '@ember-data/serializer';</td>
    </tr>
    <tr>
      <td>DS.JSONSerializer</td>
      <td>import JSONSerializer from 'ember-data/serializers/json';</td>
      <td>import JSONSerializer from '@ember-data/serializer/json';</td>
    </tr>
    <tr>
      <td>DS.RESTSerializer</td>
      <td>import RESTSerializer from 'ember-data/serializers/rest';</td>
      <td>import RESTSerializer from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPISerializer</td>
      <td>import JSONAPISerializer from 'ember-data/serializers/json-api';</td>
      <td>import JSONAPISerializer from '@ember-data/serializer/json-api';</td>
    </tr>
    <tr>
      <td>DS.EmbeddedRecordsMixin</td>
      <td>import EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';</td>
      <td>import { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.Transform</td>
      <td>import Transform from 'ember-data/transform';</td>
      <td>import Transform from '@ember-data/serializer/transform';</td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/store</h3></td>
    </tr>
    <tr>
      <td>DS.Store</td>
      <td>import Store from 'ember-data/store';</td>
      <td>import Store from '@ember-data/store';</td>
    </tr>
    <tr>
      <td>DS.Snapshot</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseObject</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.AdapterPopulatedRecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordarrayManager</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.normalizeModelName</td>
      <td>none</td>
      <td>import { normalizeModelName } from '@ember-data/store';<br>
        <br>this public method should be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/record-data</h3></td>
    </tr>
    <tr>
      <td>none</td>
      <td>import { RecordData } from 'ember-data/-private';</td>
      <td>import RecordData from '@ember-data/record-data';</td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/relationship-layer</h3></td>
    </tr>
    <tr>
      <td>DS.Relationship</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td colspan="3"><h3>@ember-data/debug</h3></td>
    </tr>
    <tr>
      <td>DS.DebugAdapter</td>
      <td>none</td>
      <td>none</td>
    </tr>
  </tbody>
</table>

### Notes

#### `@ember-data/model`

  1) `InternalModel` and `RootState` are tightly coupled to the store and to our provided `Model`
    implementation. Over time we need to uncouple this, but given their coupling to `Model` and our
    desire to enable them to be eliminated from projects not using `Model`, these concepts belong in `@ember-data/model`, although they will not be given direct import paths.

  2) The following belong in `@ember-data/model` and not in `@ember-data/relationship-layer` with
    relationships.  While this presents a mild risk of confusion due to the presence of the
    `relationship-layer` package, the argument for their presence here is they are a ui-layer concern being coupled to the current `Model` presentation layer and not related to overall state management
     of relationships which could itself be used with alternative implementations.

  * `belongsTo`
  * `hasMany`

 3) The following have the same considerations as #2 but they will not be given direct import paths.

  * `PromiseManyArray`
  * `ManyArray`

#### `@ember-data/serializers`

  1) We should move automatic registration of transforms into a more traditional
    `app/` directory re-export for the package so that when the package is dropped they
    cleanly drop as well.

#### `@ember-data/relationship-layer`

This package seems thin but it's likely to hold quite a bit.
  Additional private things that would be moved here:

  * everything in `-private/system/relationships/state`
  * `BelongsToReference` and `HasManyReference`
  * relationship logic from `store` / `internal-model` that need to be isolated and extracted

#### `@ember-data/debug`

  Moving `DebugAdapter` here would allow dropping it if not desired. Additionally we should likely
  RFC dropping it for production builds where it adds persistent unnecessary overhead for a tool
  meant for devs. This exists to support the ember inspector.

### Documented Public APIs without public import paths

There are a few public classes that are not exposed at all via `export` today. Those classes will not be given
  public export paths, but the package containing their documentation and implementation is shown here:

  * `@ember-data/store`
    * `Reference`
    * `RecordReference`
    * `StoreWrapper`
  * `@ember-data/relationship-layer`
    * `BelongsToReference`
    * `HasManyReference`
  * `@ember-data/model`
      * `PromiseBelongsTo`
      * `PromiseRecord`

## Migration

Blueprints, guides, docs, and twiddle would be updated to use the new `@ember-data/` package imports.

A codemod would be provided to convert from the existing import locations to the new ones, as well as lint rules for encouraging their use.

The package `ember-data` would continue to exist, much like `ember-source`. Initially, this package would provide all of the subpackages
 as dependencies as well as the respective re-exports for supporting the existing import paths. After a time, the existing paths would
 be deprecated.

Users who have resolved the deprecations may choose to convert to consuming only the packages they still require directly,
 by dropping `ember-data` from their `package.json` and adding in the individual `@ember-data/` packages as necessary.

Ultimately, the default `ember-data` story in `ember-cli` would change to install select packages from `@ember-data` directly.

## How we teach this

This RFC should be seen as a continuation of the `javascript-modules` RFC that defined explicit import paths for `emberjs`.

Codemods and lint rules would be provided to convert existing imports to the new syntax. Existing import locations
 would continue to exist for a time but would at some point in the future be made to print build-time deprecations.

End users would need to run the codemod at some point, but no other changes will be required.

Ember documentation and guides would be updated to reflect these new import paths as well as to utilize the new package
 divisions to improve the teaching story.

## Drawbacks

* A Tiny amount of churn
* Sub-packages will require sprinkling significant numbers of excess package.json files throughout our repo.
* Our import paths may not align with the expected mental model for addon import paths going forward (no `/src/` in path)

## Alternatives

1) Divide into packages without exposing the new division publicly

  * _argument for:_ Don't expose churn to end users without a clear win, we aren't 100% sure what belongs in a vague
    "future ember-data", so wait until we are sure.
  * _rebuttal:_ The churn is minimal and mostly automated (codemod). There are clear wins here for many users. We
    should not hold up progress now on an uncertain future. Dividing into packages now gives us more options for how to
    manage future evolution. Regardless of when we become certain of what belongs in "future ember-data", these packages
    would need to exist alongside at least for a time.

2) Don't divide into packages until nebulous future RFCs have landed

  * _argument for:_ This argument is an extension of _alternative 1_ in which we wait for specific concepts to mature and
    materialize that we have discussed internally, including a significant rework of how we manage the `request/response`
    lifecycle. These new feature RFCs would come with corresponding deprecation RFCs for parts of the system they either
    fully replace or make vestigial.
  * _rebuttal:_ The argument here is a variation of the argument in _alternative 1_ and the rebuttal merely extends
    that rebuttal as well. These future deprecations would necessarily be long-tail, if we deprecate at all. There is
    the option to have both old and new experiences live side-by-side. Additionally, if we deprecate and then land
    `@ember-data/packages` there is both an equal amount of churn and fewer options for how to manage those deprecations.

3) Use the `@ember` namespace.

  * _argument for:_ `ember-data` is an official package and we wish to position it centrally within the `ember`
    ecosystem. This [argument has been presented](https://github.com/emberjs/rfcs/pull/238#issuecomment-318745236)
    by other core teams in response to previous attempts to move forward with a packages RFC for `ember-data`.
  * _rebuttal:_ `ember-cli` and `glimmer` are also official packages, but with their own namespaces. Additionally
    re-using the `@ember` namespace would only further confusion that many folks already have regarding:
      * where `ember` ends and `ember-data` begins.
      * whether `ember-data` is required or optional
      * whether other data layers are seen as "bad practices" (they are not)
      * what packages are provided by `ember-data` vs `ember`
    `ember-data`'s status as a team, in the guides and in release blog posts on `emberjs.com`, as well as presence in
     the default blueprint provided by `ember-cli` make clear it's status as an official offering. Using the `@ember`
     namespace is not required for this.

    This argument also necessarily foments an untrue presupposition: that `ember-data` is the right choice for every app.
    While we strive to make this the case, it would be very difficult to claim this today, and may never be true,
    as every app presents unique concerns and needs.

    Finally, using the `@ember` namespace would leave us in the unfortunate position of either always scoping all of our
    packages to `@ember/data/` or of fighting with `emberjs` for package names.

4) This RFC but with Adapters and Serializers broken out into the packages `@ember-data/json` `@ember-data/rest` `@ember-data/json-api`.

* _argument for:_ grouping the adapter / serializer "by API spec" feels more natural and would allow for users to drop only the versions of adapters / serializer they don't require.

* _rebuttal:_ Even without considering future changes to `ember-data`'s API surface, there are several issues with this approach.

  1) The implementations inherit each other:
     * `JSONAPISerializer extends RESTSerializer extends JSONSerializer extends Serializer`
     * `JSONAPIAdapter extends RESTAdapter extends Adapter`
  2) The adapter / serializer pairings aren't coupled
     * It is fairly common to use the `JSONAPIAdapter` with the `RESTSerializer` or
    with a custom serializer that extends the `RESTSerializer` and vice-verse.
     * Even when using a consistent spec (`json-api` or `rest`) it is common to need
    a fully custom serializer. The division of needs is at least equally between
    adapter/serializer as it is between specs.

  3) Transforms are an implementation detail for all the provided serializers

     * But they  are not required and likely not even used by custom serializers.

  4) Packages for automatically registered fallbacks would fit poorly.
     * Serializers: `"-default"` `"-rest"` `"-json-api"`
     * Adapters: `"-rest"` `"-json-api"`
  5) Today, we use multiple serializers for a single type based on entry-point
     * `Model.serialize` (per-type) / `Model.toJSON` (`"-json"`) / `Adapter.serialize` (per-adapter)

  That said, this organization is also one of the only-nods
  to future RFCs this RFC concedes. The existing provided implementations all follow roughly the same interface for their implementations, and that interface is something we strongly wish to change. For this reason, it seems advantageous to keep the existing implementations together such that the delineation between a new experience and this experience can be kept clear.


---

---
stage: recommended
start-date: 2018-11-02T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/398
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/10
---

# RouteInfo MetaData

## Summary

The RFC introduces the ability to associate application specific metadata with its corresponding `RouteInfo` object. This also adds a `metadata` field to `RouteInfo`, which will be the return value of `buildRouteInfoMetadata` for its corresponding `Route`.

```js
// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';

export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
```

```js
// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) => {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
```

## Motivation

While the `RouteInfo` object is sufficient in providing developers metadata about the `Route` itself, it is not sufficient in layering on application specific metadata about the `Route`. This metadata could be anything from a more domain-specific name for a `Route`, e.g. `profile_page` vs `profile.index`, all the way to providing contextual data when the `Route` was visited.

This metadata could be used for more pratical things like updating the `document.title`.
Currently, addons like [Ember CLI Head](https://github.com/ronco/ember-cli-head) and [Ember CLI Document Title](https://github.com/kimroen/ember-cli-document-title) require the user to supply special metadata fields on your `Route` that will be used to update the title. This API would be a formalized place to place that metadata.

See the [appendix](#appendix-a) for examples.

## Detailed design

### `buildRouteInfoMetadata`

This optional hook is intended to be used as a way of letting the routing system know about any metadata associated with the route.

#### `Route` Interface Extension

```ts
interface Route {
  // ... existing public API
  buildRouteInfoMetadata(): unknown
}
```

#### Runtime Semantics

- **Always** called before the `beforeModel` hook is called
- **Maybe** called more than once during a transition e.g. aborts, redirects.

### `RouteInfo.metadata`

The `metadata` optional field on `RouteInfo` will be populated with the return value of `buildRouteInfoMetadata`. If there is no metadata associated with the `Route`, the `metadata` field will be `null`.

```ts
interface RouteInfo {
  // ... existing public API
  metadata: Maybe<unknown>;
}
```

This field will also be added to `RouteInfoWithAttributes` as it is just a super-set of `RouteInfo`.


## How we teach this

We feel that this a low-level primitive that will allow existing tracking addons to encapsulate. That being said the concept here is pretty simple: What gets returned from `buildRouteInfoMetadata` becomes the value of `RouteInfo.metadata` for that `Route`.

The guides and tutorial should be updated to incorporate an example on how these APIs could integrate with services like Google Analytics.

## Drawbacks

This adds an additional hook that is called during route activation, expanding the surface area of the `Route` class.
While this is true, there is currently no good way to associate application-specific metadata with a route transition.

## Alternatives

There are numerous alternative to the proposal:

### `setRouteMetadata`

This API would be similar to `setComponentManager` and `setModifierManager`. For example:

```js
// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({

  init() {
    this._super(...arguments);
    setRouteMetadata(this, {
      trackingKey: 'page_profile',
      profile: {
        viewing: this.userId,
        locale: this.userLocale
      }
    });
  }
  // ...
});
```

You would then use the a `RouteInfo` to lookup the value:


```js
// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) => {
      let { to, from } = transition;
      let { trackingKey: fromKey } = getRouteMetadata(from);
      let { trackingKey: toKey } = getRouteMetadata(to);
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
```

This could work but there are two things that are confusing here:

1. What happens if you call `setRouteMetadata` mutliple times. Do you clobber the existing metadata? Do you merge it?
2. It is very odd that you would use a `RouteInfo` to access the metadata when you set it on the `Route`.

### `Route.metadata`

This would add a special field to the `Route` class that would be copied off on to the `RouteInfo`. For example:

```js
// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({
  metadata: {
    trackingKey: 'page_profile',
    profile: {
      viewing: this.userId,
      locale: this.userLocale
    }
  }
  // ...
});
```

The value would then be populated on `RouteInfo.metadata`.


```js
// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) => {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
```

This could work but there are two things that are problematic here:

1. What happens to the this data if you subclass it? Do you merge or clobber the field?
2. This is a generic property name and may conflict in existing applications

### Return Metadata From `activate`

Today `activate` does not get called when the dynamic segments of the `Route` change, making it not well fit for this use case.

## Unresolved questions

TBD?


### Apendix A

Tracking example

```js
// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
```

```js
// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) => {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
```


### Appendix B

Updating document.title

```js
// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      title: 'My Cool WebPage'
    }
  }
  // ...
});
```

```js
// app/router.js
import Router from '@ember/routing/router';

// ...
export default Router.extend({
  init() {
    this._super(...arguments);
    this.on('routeDidUpdate', (transition) => {
      let { title } = transition.metadata;
      document.title = title;
    });
  },
  // ...
});
```


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2018-11-25T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/403
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/31
---

# Ember Data | Identifiers

## Summary

`Identifiers` provides infrastructure for handling `identity` within `ember-data` to
 satisfy requirements around improved caching, serializability, replication, and handling
 of remote data.

This concept would parallel a similar structure proposed for `json-api` resource identifier
 `lid` property [drafted for version `1.2` of the `json-api` spec](https://github.com/json-api/json-api/pull/1244).

In doing so we provide a framework for future RFCs and/or addons to address many common
 feature requests.

----

## Motivation

This groundwork RFC represents the union of a diverse set of motivations, each of which
 is discussed below in no particular order of importance, outside of the first. **This
 RFC is not seeking to immediately address each of the motivations below, we are adding
 infrastructure to make future RFCs possible in these spaces**

### Unified concept of Identity

Identity is a core concept to managing a cache and guaranteeing [atomicity, consistency,
 isolation, and durability](https://en.wikipedia.org/wiki/ACID_(computer_science)).
 Currently, `ember-data` has no unified mechanism for Identity. This missing mechanism
 introduces errors in application code, makes `ember-data` internals needlessly complex,
 and complicates the method signatures of many public APIs.

Creating a unified `Identity` concept will allow `ember-data` to expose `identity` as a
first-class primitive to our users, improving the mental model, improving application
resiliance to errors, and providing a clear language of communication between `ember-data`'s
various primitives.

Today, we handle `identity` in a myriad of ad-hoc ways:

* `InternalModel` instances as keys for most internal methods and the relationship layer.
* `type+id` for serializing/deserializing a `record` or [`resource`](https://jsonapi.org/format/#document-resource-object-identification)
* `type+clientId` for caching newly created records on the client and communicating
   about them with `RecordData`.
* Various other non-serializable forms of identity for tracking requests, relationship
   membership and state.
* In some cases we have no concept at all where one is needed (for instance, caching
  queries)

We wish to simplify and codify our handling of identity.

### Simplify StoreWrapper and RecordData APIs

Today, to deal with the lack of a unified `identifier` concept, we overload many
 `StoreWrapper` and `RecordData` API method signatures with `modelName`, `id`, `clientId`
 as arguments. This leads to method signatures being long and needlessly unwieldy.

Note: We had initially intended to overload all of these classes method signatures in
this way, to ensure that `RecordData` implementations could be `singleton`s, but we failed
to correctly implement the `RecordData` RFC in this regard and a near future RFC will look
at rectifying this using the `Identity` APIs introduced here.

Moving to a unified concept of `identity` opens up a path to clean up these method
 signatures.

### Operations

Operations are a foundational concept for `acid` transactions. Without the ability to
 describe an operation and a clear mental model of what operations exist and achieve, it
 is difficult to understand how an action affects state. Granularity and clarity is key.

While `ember-data` does not yet have concepts of operations or transactions, mutations and
 updates are applied directly, there are many areas we could improve upon by introducing
them. As with data, operations upon data should be serializable so that local state can
be accurately cached on local clients.

### Nested Saves / API Transactions / Websocket Support

Many applications wish to create or update and save multiple records together. Achieving
 this in `ember-data` today is unweildy and has many difficult edge cases: one of which
 is correctly matching data received back from the API to the newly created records already
 on the client.

A similar edge case occurs when a newly created record is saved for the first time and
 prior to receiving the request response the same record is recieved via another means
(background polling, websocket subscription, etc.). We have no means of matching the record
returned by the alternative means to that of the request, leading to a second cache entry
being created and an error once the initial request completes.

One solution has been to generate and assign `id`s for records on the client, but this is
 not always desireable. These scenarios are a major motivation for `lid` in the `json-api`
spec. Users wishing to solve these cases would be able to serialize the `lid` of the
`Identifier` for a newly created record and reflect that `lid` back in any payloads send
from their API for the session to correctly match the payloads to the record.

### Better Cache Serialization & Improved Infra for Offline Support

In order to enable users to achieve full offline support, or to serialize the store
 or transport across the wire (for example as an advanced fastboot rehydration mode)
the entire state of the store needs to be serializable. This RFC introduces the
foundation for mechanisms through which this can be later achieved.

----

## Detailed design

```typescript
export interface Identifier {
  lid: string;
}

export interface RecordIdentifier extends Identifier {
  id?: string | null;
  type: string;
}
```

Note: the referential stability (object reference) of all identifiers created by the
`store` is guaranteed. E.g. any data that results in the lookup of an identifier
producing the same `lid` token will return the same `Identifier` instance. This is
useful for being able to use identifiers for either `Map` or `WeakMap` cache solutions.

### Buckets

In an ideal world, the `lid` of each `Identifier` would be a `v4` [uuid](https://en.wikipedia.org/wiki/Universally_unique_identifier),
 making it practically unique in all contexts. However, due to requirements around design
 flexibility and performance we are only requiring that `Identifiers` be unique _within
 their bucket_ for the data they are intended to reference.

Each underlying primitive will have its own bucket, as new primitives are formalized, new
 buckets will emerge. Initially we expect only a `record` bucket which aligns with today's
`IdentityMap` cache for `Record`s. Examples of future buckets may include a cache for
`queries`, `documents`, `transactions`, `operations`, `errors`, `meta` or any number of other
 concepts that represent state required to be serializable.

In our ideal world, the `lid` would then be a `uuid-v4` that is practically unique across
 buckets and not just within. While we  will ship a minimal `uuid-v4` generator to be used
 for generating identifiers when needed on the client, generating large quantities of `uuid`s
 is cost prohibitive.  An early performance analysis suggests that a few thousand identifiers
 would bring a cost in the tens of milliseconds on powerful machines. When generating
 identifiers for data returned by an API, this cost would impede optimizations around
 rendering.

This cost is primarily due to the need to generate large quantities of random bytes: a cost
 that is necessarily cpu intensive. Additionally, many forms of data (such as `json-api`
 resources) come with unique or nearly unique identifying information already (`type` + `id`,
`href` etc.).  Some APIs already make use of `v4` `uuid`s as IDs, and for these APIs it would
 make the most sense to implement a custom generation method to reuise these `id`s as `lid`s
 when present.

To balance performance with the requirements of `identity`, we are choosing what we feel is a
 *sensible default*.  Users for whom this default does not meet their requirements may override
the appropriate hooks to generate identifiers that do.

### Customizing Identifiers

For users wishing to provide increased guarantees around uniqueness and serializability
 of identifiers we provide the ability to configure how we generate and manage identifiers.

Given the guarantees around uniqueness and serializability that are required, this configuration
 applies to all `IdentifierCache` instances and meaning that it is shared across all buckets,
 store instances. Ideally the configuration does not change between application instances but
 for encapsulation purposes for fastboot and tests we allow and encourage repeated setup/teardown.
 Specifically, this recommendation is that in order to provide a strong guarantee of uniqueness
 and serializability, _identifiers generated by separate store or application instances but which
 represent the same data should result in the generation of the same `lid`_.

Indeed in this vein, we have not provided a mechanism for distinguishing what instance of a `store`
 has asked for an `Identifier` when multiple stores are present, but the `initializer` pattern
 recommended below does offer the ability to distinguish _per-application_. We do not recommend
 using this availability to affect your generation method.

Supplying custom `lid` generation can be done using `setIdentifierGenerationMethod`. Currently
 there is only one bucket (`record`) as discussed above, but we reserve the ability to add
 additional buckets in the future.

Users should do any identifier customization within an instance-initialize prior to making use
 of the store. Given the more universal nature of this customization, we recommend ensuring that
 you consider the mechanics of multiple applications in fastboot or test application instance
 scenarios when instantiating and populating any secondary lookup tables or caches for identifiers.
 Weakmapping these lookup tables and caches to the application instance will accomplish this.
 An example is provided below.

```typescript
/*
  A method which can expect to receive various data as its first argument
  and the name of a bucket as its second argument. Currently the second
  argument will always be `record` data should conform to a `json-api`
  `Resource` interface, but will be the normalized json data for a single
  resource that has been given to the store.

  The method must return a unique (to at-least the given bucket) string identifier
  for the given data as a string to be used as the `lid` of an `Identifier` token.

  This method will only be called by either `getOrCreateIdentifier` or
  `createIdentifierForNewRecord` when an identifier for the supplied data
  is not already known via `lid` or `type + id` combo and one needs to be
  generated or retrieved from a proprietary cache.

  `data` will be the same data argument provided to `getOrCreateIdentifier`
  and in the `createIdentifierForNewRecord` case will be an object with
  only `type` as a key.
*/
type GenerationMethod = (data: Object, bucket: string) => string;

/*
 A method which can expect to receive an existing `Identifier` alongside
 some new data to consider as a second argument. This is an opportunity
 for secondary lookup tables and caches associated with the identifier
 to be amended.

 This method is called everytime `updateRecordIdentifier` is called and
  with the same arguments. It provides the opportunity to update secondary
  lookup tables for existing identifiers.

 It will always be called after an identifier created with `createIdentifierForNewRecord`
  has been committed, or after an update to the `record` a `RecordIdentifier`
  is assigned to has been committed. Committed here meaning that the server
  has acknowledged the update (for instance after a call to `.save()`)

 If `id` has not previously existed, it will be assigned to the `Identifier`
  prior to this `UpdateMethod` being called; however, calls to the parent method
  `updateRecordIdentifier` that attempt to change the `id` or calling update
  without providing an `id` when one is missing will throw an error.
*/
type UpdateMethod = (identifier: StableIdentifier, newData: Object, bucket: string) => void;

/*
A method which can expect to receive an existing `Identifier` that should be eliminated
 from any secondary lookup tables or caches that the user has populated for it.
*/
type ForgetMethod = (identifier: StableIdentifier) => void;

/*
 A method which can expect to be called when the parent application is destroyed.

 If you have properly used a WeakMap to encapsulate the state of your customization
 to the application instance, you may not need to implement the `resetMethod`.
*/
type ResetMethod = () => void;

export function setIdentifierGenerationMethod(method: GenerationMethod): void {}

export function setIdentifierUpdateMethod(method: UpdateMethod): void {}

export function setIdentifierForgetMethod(method: ForgetMethod): void {}

export function setIdentifierResetMethod(method: ResetMethod): void {}
```

A simple custom generation method might be an increasing counter like below:

```typescript
import { setIdentifierGenerationMethod } form '@ember-data/store';

export function initialize(applicationInstance) {
  // note how `count` here is now scoped to the application instance
  // for our generation method by being inside the closure provided
  // by the initialize function
  let count = 0;

  setIdentifierGenerationMethod((resource: Resource) => {
    return resource.lid || `my-key-${count++}`;
  });
}

export default {
  name: 'configure-ember-data-identifiers',
  initialize
};
```

### Identifiers for Records

When discussing identifiers for records it is useful to be familiar with `json-api`
interfaces for [ResourceObjects](https://jsonapi.org/format/#document-resource-objects)
and [ResourceIdentifierObjects](https://jsonapi.org/format/#document-resource-identifier-objects).

Below, we expose a rough approximation of these interfaces as `Resource` including the
 potential presence of `lid`.

```typescript
import { Value as JSONValue } from 'json-typescript';

type JSONDict = { [k: string]: JSONValue };

export interface Resource {
  id: string;
  type: string;
  lid?: string;
  attributes?: JSONDict;
  relationships?: JSONDict;
  meta?: JSONDict;
}
```

We can access and generate identifiers for records using the following APIs available
 via the `identifierCache` on the `Store` and `StoreWrapper` classes.

```typescript
import Service from '@ember/service';

export interface Store {
  identifierCache: IdentifierCache
}

export interface StoreWrapper {
  identifierCache: IdentifierCache
}

export default class IdentifierCache extends Service {
  /*
   Returns the Identifier for the given Resource, creates one if it does not yet exist.

   Specifically this means that we:

   - validate the `id` `type` and `lid` combo against known identifiers
   - return an object with an `lid` that is stable (repeated calls with the same
    `id` + `type` or `lid` will return the same `lid` value)
   - this referential stability of the object itself is guaranteed
  */
  getOrCreateRecordIdentifier(resource: Resource): RecordIdentifier {}

  /*
   Returns a new Identifier for the supplied data. Call this method to generate
   an identifier when  a new resource is being created local to the client and
   potentially does not have an `id`.
  */
  createIdentifierForNewRecord({ type: string, id: string | null }): RecordIdentifier {}

  /*
   Provides the opportunity to update secondary lookup tables for existing identifiers

   Called with the attributes provided to createRecord after an identifier created with
   `createIdentifierForNewRecord` has been instantiated.

   Called again after an identifier created with `createIdentifierForNewRecord` has been
   committed, or a resource has received an update from the API.

   Assigns `id` to an `Identifier` if `id` has not previously existed; however,
   attempting to change the `id` or calling update without providing an `id` when
   one is missing will throw an error.
  */
  updateRecordIdentifier(identifier: RecordIdentifier, data: Resource): void;

  /*
   Provides the opportunity to eliminate an identifier from secondary lookup tables
   as well as eliminates it from ember-data's own lookup tables and book keeping.

   Useful when a record has been deleted and the deletion has been persisted and
   we do not care about the record anymore. Especially useful when an `id` of a
   deleted record might be reused later for a new record.
  */
  forgetRecordIdentifier(identifier: RecordIdentifier): void
}

// -- example uses

// ... for existing resources
let identifierA = identifierCache.getOrCreateRecordIdentifier({
  type: 'foo',
  id: '1'
}); // => { lid: 'some-unique-key-1324' }
let identifierB = identifierCache.getOrCreateRecordIdentifier({
  type: 'foo',
  id: '2',
  lid: '123a'
}); // => { lid: '123a' }
let identifierC = identifierCache.getOrCreateRecordIdentifier({
  type: 'foo',
  lid: '123b'
}); // => { lid: '123b' }
let identifierD = identifierCache.getOrCreateRecordIdentifier({
  lid: '123c'
}); // => { lid: '123c' }

// ... generating identifiers for newly created resources
// (this is something that likely only store.createRecord() should do)
let identifier1 = identifierCache.createIdentifierForNewRecord('foo'); // => { lid: 'some-random-unique-key-123a' }
let identifier2 = identifierCache.createIdentifierForNewRecord('foo'); // => { lid: 'some-random-unique-key-123b' }
let identifier3 = identifierCache.createIdentifierForNewRecord('bar'); // => { lid: 'some-random-unique-key-123c' }
```

### Updating new record Identifiers with more complete information

Called when an identifier has been generated for resource data prior to `id` being
 available for that resource and complete resource data is now available. `ember-data`
 will automatically call this with the resolved payload after save for any newly created
 records. An `identifier` can only be updated once, and only when transitioning the
 associated resource from a never-before-persisted to persisted state.

Udating provides the opportunity to update the primary and secondary lookup tables for the
 identifier. In the case of a RecordIdentifier that was created locally, it provides the
 ability to do a "one time only" upgrade of the identifier to assign an id.

```ts
IdentifierCache {
  updateRecordIdentifier(identifier: RecordIdentifier, data: Resource): void;
}
```

### Refreshing an `Identifier` When recycling an `id`

Occasionally some APIs re-use the same `id` for different `data`. Common scenarios for
 this include reusing the `id` of a previously deleted record for a new record, and less
 commonly a stable `id` to reference the "currently logged in user".

When this occurs, the existing `lid` needs the chance to be forgotten and a new `lid`
 generated. This method eliminates the identifier from our internal cache only. Caches
 associated with custom identifiier generation methods must be cleared by the implementors
 of those custom methods. Any data associated with the original `lid` should be purged from
 caches prior to calling this method. We leave it to follow up RFCs to provide
 infrastructure for safely and correctly eliminating records from caches.

```ts
IdentifierCache {
  forgetRecordIdentifier(identifier: RecordIdentifier): void
}
```

### Access from `record` instances

```typescript
export function recordIdentifierFor(record: object): RecordIdentifier {}
```

```ts
import { recordIdentifierFor } from '@ember-data/store';

// ...

// when you have a record instance
let identifier = recordIdentifierFor(record);

// from inside a record class after instantiation
class MyRecord {
  getIdentifier() {
    return recordIdentifierFor(this);
  }
}
```

Whether and how to access an identifier during instantiation of a record will be left
 for discussion as part of a different RFC for custom record classes.

### Polymorphism & "The Username Problem"

A common edge case that `Identifiers` enables end users to solve is when multiple pieces
 of identifying information should reference the same data.

For instance, when using single-table polymorphism (in which `ferrari` and `bmw` extend
 `car` and share a common `id` space) then `ferrari:1` and `bmw:2` are the same vehicles
  as `car:1` and `car:2`.

A similar problem presents for the scenario in which we know that we wish to reference a
`user` with a given `username`, but do not yet have access to the `id` for that user. In
 this case, `user:@jackson5` and `user:abc123` are the same user.

Today in these situations many users will encounter bugs resulting from there being two
 records present in the cache instead of one. This problem can be solved with a custom
 identifier generation method that is aware of an application's polymorphic associations
 or additional indexing requirements.

 For example, to solve the username problem we might do the following:

 ```typescript
import { setIdentifierGenerationMethod } from '@ember-data/store';

export const SECONDARY_IDENTIFIER_CACHE = new WeakMap();

export function initialize(applicationInstance) {
  let count = 0;
  const typeid_cache = {};
  const username_cache = {};

  /*
    Note: if you needed to share access to these caches elsewhere
    in the same applicationInstance, we could use a WeakMap to add
    them. Shown here for a more complete example.
  */
  SECONDARY_IDENTIFIER_CACHE.set(applicationInstance, {
    typeid: typeid_cache,
    username: username_cache
  });

  setIdentifierGenerationMethod((resource: Resource) => {
    let { type, id, lid } = resource;
    let username = (resource.type === 'user'
      && resource.attributes
      && resource.attributes.username);
    let cacheKey, altCacheKey;

    if (lid) {
      // probably ensure username and id cache are populated first IRL
      return lid;
    }

    // handle the case where we do know the ID and have set the `lid` previously
    if (id) {
      cacheKey = `${type}:${id}`;

      if (lid = typeid_cache[cacheKey]) {
        return lid;
      }
    }

    // handle the cases where we have a username but we didn't know the ID yet
    if (username) {
      lid = username_cache[username];

      if (!lid) {
        lid =  `my-key-${count++}`;
        username_cache[username] = lid;
      }

      if (id) {
        typeid_cache[cacheKey] = lid;
      }
      return lid;
    }

    // handle everything else
    lid =  `my-key-${count++}`;
    typeid_cache[cacheKey] = lid;

    return lid;
  });
}

export default {
  name: 'configure-ember-data-identifiers',
  initialize
};
 ```

#### Handling Updates to Alternative Cache Keys

 Note that in our above example we treat `username` a stable, immutable alternative
  primary-key. Some APIs allow users to change the value of such "unique keys" (`email`
  `phone` `username` being common examples).

 If your application enables such behavior, and these updates are not handled by the
  call to `updateRecordIdentifier` that occurs after a record is saved, in addition
  to manually calling `identifierCache.updateRecordIdentifier` with the desired patch
  you could also provide your own explicit method for doing so. An explicit method is
  great for ensuring the correct context for the granularity of this change. The timing
  of this update would be up to you (whether pre- or post- the mutation having been
  persisted to the server)

 Extending the example above:

 ```ts
 import { SECONDARY_IDENTIFIER_CACHE } from './initializers/configure-identifiers';

 export function updateUsernameForIdentifier(
   // application instance is the result of `getOwner`
   // on something like the `store` or a `component`
   owner: Owner,
   identifier: Identifier,
   oldUsername: string,
   newUsername: string
   ) {
    const caches = SECONDARY_IDENTIFIER_CACHE.get(applicationInstance);
    const typeid_cache = caches.typeid;
    const username_cache = caches.username;

    if (username_cache[oldUsername] !== identifier.lid) {
      throw new Error('invalid update');
    }

    // you might want to continue mapping both old an new username
    //  here we decided not to.
    delete username_cache[oldUsername];

    username_cache[newUsername] = identifier.lid;
  }
 ```

 ### Identifier Stability

Identifiers handed to public APIs by `ember-data` will **always** be _referentially stable_
 Public `ember-data` APIs that **expect** an `Identifier` will normalize the object they
 are given into the stable `Identifier` if it is not one already. This is done to allow
 for serialized identifiers and identifying information from the API to more easily be worked
 with without extra normalization effort.

Specifically, this means that as regards this RFC, `identifiers` that are structurally the same
 (meaning an object with the same `lid`) are treated as any other `identifier` regardless of
 whether the object is an identical reference to the object generated by the store previously.

Additionally, only the objects generated by the store will have additional debug information
 attached to them, as shown in the interfaces below.

```typescript
const IS_IDENTIFIER = Symbol('is-identifier');

// provided for additional debuggability
const DEBUG_CLIENT_ORIGINATED = Symbol('record-originated-on-client');
const DEBUG_IDENTIFIER_BUCKET = Symbol('identifier-bucket');

export interface StableIdentifier {
  lid: string;
  [IS_IDENTIFIER]: true;
  [DEBUG_IDENTIFIER_BUCKET]: string;
}

export interface StableRecordIdentifier extends StableIdentifier {
  id: string | null;
  type: string;
  [DEBUG_CLIENT_ORIGINATED]: boolean;
}
```

## How we teach this

Largely this is an internal feature, although one that power users will sometimes need
 access to. Additional guides should be created showing how identifiers may be used to
 solve common edge cases unique to given users. We have attempted to go into depth here
 with examples and documentation about the capabilities provided to make creating these
 additional resources as easy as possible.

Existing APIs that accept or provide `id` and `type` information will continue to do so
 unchanged.

## Drawbacks

- None, the performance characteristics of the setup here described may seem worse on
  allocation (object vs string identifier) but in reality they significantly improve our
  ability to reduce allocations, duplicate logic, and branching code paths throughout the
  library.

## Alternatives

A lengthy amount of discussion was had revolving around whether `Identifiers` shouldn't be
a simple `string` (e.g. just the `lid` portion).

The arguments for doing so revolve around `string` being referentially stable automatically,
and that we do not require an `object reference` for being able to use identifiers as keys in
`WeakMaps` both because `lid` is stable and because `ember-data` has need of controlling most
of the object lifecycle.

However, continuing to use an object wrapper, especially a stable object wrapper, comes with
a multitude of benefits, including:

* **debugging:** enhanced debugging by associating additional information with the
  identifier in development builds
* **debugging:** enhanced debugging by users being able to see type and id at a
  glance when inspecting state.
* **bug prevention:** enforcement of the use of the identifier generation process
  (to ensure lookup tables are properly populated)
* **debugging:** ability to tell at a glance that an identifier was properly processed
* **ergonomics:** closer alignment to `jsonapi` that makes it true that all `RecordIdentifiers`
  are also `ResourceIdentifierObjects`
* **ergonomics:** We can provide better `typescript` support for an object interface than a `string`
  given that any `string` would fit the `lid` interface but only correctly shaped objects (which includes
  the `Symbol` for `identifier`) would fit the correct object interface.


---

---
stage: recommended
start-date: 2018-10-20T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/408
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/7
---

# Decorators

## Summary

Native classes are now officially supported in Ember, but currently their usage
is very limited. Core Ember features such as computed properties, actions, and
service injections have no publicly supported APIs to be used with native class
syntax.

Decorators provide a way to abstract functionality and improve the developer
experience of working with native classes.  This RFC outlines the implementation
and rollout plan for bringing decorators to Ember's computed properties (and
other behavior) for use in native classes.

### A Note on Decorator Stability

[Decorators](https://github.com/tc39/proposal-decorators) are important to
adopting native class syntax. They are a formalization of the patterns we have
been using as a community for years, and it will not be possible to use native
classes ergonomically without them unless a number of major concepts (computed
properties, injections, actions) are rethought. That said, as of today (01/03/19)
decorators are still a [_stage 2_ proposal](https://tc39.github.io/process-document)
in TC39, which means that while they are fully defined as a spec, they are not
yet considered a candidate for inclusion in the language, and may have
incremental changes that could be breaking if/when moved to stage 3. As such,
merging support for them now would pose some risk. Additionally, [class
fields](https://github.com/tc39/proposal-class-fields) are also required for
effective use of decorators, and while they are stage 3 in the process, they
have not yet been fully accepted either.

Ember cannot guarantee that the spec won't change, and such changes cannot apply
to Ember's normal semver guarantees. But it can make the following guarantees:

1. If there are changes to the spec, and it ***is*** possible to avoid changing
   the public APIs of decorators, then Ember will make the changes necessary to
   avoid public API changes.

2. If there are changes to the spec, and it ***is not*** possible to avoid
   breaking changes, Ember will minimize the changes as much as possible, and
   will provide a codemod to convert from the previous version of the spec to
   the next.

3. If the spec is dropped from TC39 altogether, Ember would have to continue to
   provide support for decorators via babel transforms until they are deprecated
   following the standard RFC process, and removed according to SemVer. Reverse
   codemods which translate decorators and native class syntax back to classic
   class syntax _will_ be made, and alternatives for native class syntax will be
   explored.

4. Classic class syntax will continue to be supported _at least_ until these
   features have been stabilized in the JavaScript language, to allow us to
   revert these changes if necessary. They will most likely be supported for
   longer to allow a smooth transition for users who do not want to adopt native
   classes until they are completely stable.

This RFC is being made with the assumption that decorators will be moved to
stage 3 in the near future, _before_ this RFC is implemented in Ember,
dramatically reducing the risk of adopting decorators. If this RFC is accepted
and decorators are not advanced in a timely manner, a followup RFC should be
made to determine whether or not decorators should be adopted in stage 2, and
what the support for them would look like.

## Terminology

For the purposes of this RFC, we'll use the following terminology:

* The **Octane programming model** refers to the new programming model
  established by the Ember Octane edition. It includes _native classes_,
  _tracked properties_ and _Glimmer components_, and more generally refers to
  features that will be considered _core to Ember_ in the future.
* The **classic programming model** refers to the traditional programming model.
  It includes _classic classes_, _computed properties_, _event listeners_,
  _observers_, _property notifications_, and _classic components_, and more
  generally refers to features that will not be central to Ember Octane.
* **Native classes** are classes defined using the JavaScript `class` keyword
* **Classic classes** are classes defined by subclassing from `EmberObject`
  using the static `extend` method.

## Motivation

Native JavaScript class syntax has been evolving for the past three years, filling in
the cracks and providing better, more standardized ways to write classes for the
web. They will be a key part of the Octane programming model, and the ES Classes
RFC was the first step toward enabling Ember users to use native class syntax,
but there are still key features of Ember that are not usable with `class`
syntax today, including *computed properties*, *actions*, and *injections*.

These features cannot be used ergonomically with native classes as it stands.
The only options are to either use Ember's `defineProperty` function directly,
or to define these values in an anonymous class. Both of these options are hard
to read, and will be difficult to codemod in the future:

```js
// Using define property
import { computed, defineProperty } from '@ember/object';

class Person {
  constructor() {
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}

// define a computed property
defineProperty(
  Person.prototype,
  'fullName',
  computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
);

// Using intermediate extends
import EmberObject, { computed } from '@ember/object';

class Person extends EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
}) {
  constructor() {
    super(...arguments);
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}
```

Another method which was used for some time was to assign these values using
class field initializers. This practice is problematic however as it creates a
new instance of the computed property per _instance_ of the class, and does not
work with native getters either:

```ts
import EmberObject, { computed } from '@ember/object';

export default class Person extends EmberObject {
  firstName = 'Melanie';
  lastName = 'Sumner';

  fullName = computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
}

new Profile().fullName; // returns the CP instance, not 'Melanie Sumner'
```

The missing piece of functionality that we need here are _decorators_, and in
fact that is not a coincidence. The roots of the current TC39 decorator proposal
can be traced back to Ember (Yehuda having worked on the first few drafts of it)
specifically because computed properties, observers, and so on _are_ decorators.
We've been using them for years in Ember, just with a non-standard,
slightly-less-clean syntax.

```ts
import Component from '@ember/component';
import { computed } from '@ember/object';

export default class Profile extends Component {
  firstName = 'Melanie';
  lastName = 'Sumner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

Native decorators bring a more natural way of declaring computed properties to
native classes than the current computed macros.

## Prior Art

The [Ember Decorators](http://ember-decorators.github.io/ember-decorators/)
project has been experimenting with using decorators within Ember for some time
now, with the goal of reaching feature parity with the classic object model, and
the learnings from that project will be used to inform the API design in this
RFC.

## Detailed design

This RFC proposes that:

1. `Ember.computed`, the `inject` macros, and the computed property macros be
   updated to return a standard JavaScript decorator. Internally, the classic
   object model will be made aware of these decorators, and know how to apply
   them. This will allow the same exact imports to continue working as both
   native decorators and classic decorators. This decorator _will_ be compatible
   with classes that extend from `EmberObject` and classes which do not.
2. A new `@action` decorator be added to allow the definition of actions on
   classes. This decorator will _only_ be compatible with classes that are
   action handlers.

This does leave out some features from the classic programming model which are
currently provided by Ember Decorators. This is both to minimize decorators' API
surface area, and because they will not be a major part of Ember Octane's
programming model. Addressing them individually:

* **Observers and event listeners**, which have long been considered an
  antipattern.
* **Classic component** functionality such as `classNames`, `classNameBindings`,
  `attributeBindings`, etc. will be unnecessary with Glimmer components.
* **Ember Data** provides computed properties which had to be manually wrapped
  in decorators. With the changes proposed in this RFC, however, they should
  continue to work without any additional changes. In fact, all computed
  property macros will.

Users who want these features will still be able to rely on addons such as Ember
Decorators, which will provide decorator support for them for the forseeable
future. Moving forward, this RFC breaks down into _computed properties_ and
_actions_.

### Computed Properties

As mentioned before, computed properties essentially _are_ decorators. However,
they are not spec compliant. Currently, `computed()` returns an instance of the
`ComputedProperty` class, which contains all of the meta information about the
decorated property. Native decorators, by contrast, are functions which receive
a descriptor and modify it as necessary.

Unfortunately, there's no way for us to know _ahead of time_ when a computed
property is going to be used as a native decorator in a native class, and when
it is going to be used in a classic class. Consider the following:

```js
class Person {
  @alias('prefix') title;
}
```

Really, what's going on there is _not_ that we are invoking the `@alias`
decorator with parameters. We are invoking a function which _returns_ a
decorator, so it desugars to:

```js
const aliasForPrefix = alias('prefix');

class Person {
  @aliasForPrefix title;
}
```

Therefore, the `alias` function _must_ itself return a decorator function.
However, this conflicts with usage in the classic programming model:

```js
const Person = EmberObject.extend({
  title: alias('prefix')
})
```

We just established that `alias` must return a decorator function, but here it
is with the exact same arguments, and it needs to return a `ComputedProperty`
instance. There is nothing we can branch on here - in both cases, `alias` only
receives the string `'prefix'`, so it has no context for how it will be used.

The native class piece of this puzzle is completely inflexible. A decorator must
be a function, there is no choice about it. However, the _Ember_ piece is _very_
flexible. The classic object model just needs a way to get the meta information
for the property when the class is being finalized. We can either assign the
meta information to the decorator function directly, or we can associate it via
a [`WeakMap`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap).

The benefit of doing this is that the entire Ember ecosystem will get decorator
support with no extra work required. Because standard `computed` definitions
will work as decorators, existing macros will also work as decorators with no
changes to existing code.

All of Ember's built in computed macros in the `@ember/object/computed` module
will also become decorators with no extra work. However, the injection macros
will require slight updates as they use a subclass of the `ComputedProperty`
class. These updates should be relatively minor, and will follow the same
strategy as `computed()`.

#### Usage and API

The API for `computed` will remain mostly the same. The key differences will be:

1. The result of `computed` will be a decorator which can be applied directly to
   native _getters_, _setters_, and _class fields_.
2. The `ComputedPropertyConfig` (the getter/setter functions) argument provided
   to `computed` will now be optional when used as a decorator on a native
   getter or setter, and the native getter/setter will be used instead.

```ts
function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
```

The function signatures of all existing macros, including `inject` macros, would
change in the same way.

In general usage, these three definitions are equivalent:

```js
import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
});

class Person {
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  fullName;
}
```

That last example may seem confusing at first, but this is actually the same as
defining a computed property macro:

```js
import EmberObject, { computed } from '@ember/object';

function join(...dependentKeys) {
  return computed(...dependentKeys, {
    get() {
      return dependentKeys.map(key => this[key]).join(' ');
    }
  });
}

class Person {
  @join('firstName', 'lastName')
  fullName;
}
```

Notably, using `@computed` as a decorator _directly_, without parenthesis, will
not be supported. This is to prevent a parameter check on a critical path:

```js
class Person {
  @computed
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

The most common use case for this form in classic classes was to provide a new
instance of an object or array per instance of the class. This use case is
solved in native classes by class fields:

```js
const Person = EmberObject.extend({
  cache: computed(function() {
    return {};
  })
})

class Person {
  cache = {};
}
```

For other use cases, such as lazy evaluation and caching, it will still be
possible to call `@computed` with no arguments:

```js
class Person {
  @computed()
  get cache() {
    return {};
  };
}
```

#### Preventing Incoherent Usage

Making the `ComputedPropertyConfig` optional opens up lots of room for
accidents. A computed property without a getter or setter does not make sense,
nor does a computed propery with _two_ getters or setters. The new decorator
will assert at _decorator application_ time to ensure it is being used
correctly:

```js
import EmberObject, { computed } from '@ember/object';

// This will throw because the user attempted to define a CP without a getter
const Person = EmberObject.extend({
  fullName: computed()
});

// This will also throw because it is missing a getter
class Person {
  @computed('firstName', 'lastName')
  fullName;
}

// This will throw because a getter was already defined
class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

Effectively, if `computed` is passed a `ComputedPropertyConfig`, it returns a
class field decorator. Otherwise, it returns an accessor (getter/setter)
decorator.

#### Property Modifiers

Almost all computed property modifiers have been deprecated at this point, but
they are still in use today and will still be available until Ember v4. As such,
their syntax needs to remain available and unchanged:

```js
import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  }).readOnly().volatile().property('lastName') // a very strange combination
});
```

The decorator returned from `computed()` will need to have these chainable
methods available, and they will need to set the state of the decorator. This
should not be too difficult to accomplish.

Usage in native decorator syntax is a little bit trickier. In the current
proposal, only simple chaining is allowed in a decorator invocation. You may not
chain on the result of a function:

```js
import { computed } from '@ember/object';

const fullName = computed('firstName', 'lastName', function() {
  return `${this.firstName} ${this.lastName}`;
});

class Person {
  @computed('firstName', 'lastName').readOnly() // this is invalid JS decorator syntax
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @fullName.readOnly() // this is valid because it's a simple chain
  otherFullName;
}
```

Luckily, there is one other form of invocation which is available - wrapping the
entire decorator expression in parenthesis:

```js
import { computed } from '@ember/object';

class Person {
  @(computed('firstName', 'lastName').readOnly()) // this is valid
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

This is clearly _not_ ideal for commonly used features, and while `volatile()`
and `property()` are not very well known, `readOnly()` is generally considered
best practice, and is used all over the place. However, it _is_ deprecated, and
in the future computed properties will be read only by default. Rather than
attempt to write a different API for decorators, this RFC proposes that we
accept the current syntax, and focus instead on the implementation of Svelte.
This will allow users to enable default read only CPs much sooner, and prevent
the need to use `readOnly()` at all.

##### A Tale of Two `readOnly`s

You may be wondering why we can't add more decorators to Ember to take the place
of these modifiers. The crux of the issue is the `readOnly()` modifier, and the
`readOnly()` macro. These share a name, and when macros become decorators as
well they will collide. The only difference would be the import paths, and this
would result in awkward renaming which would likely _not_ be conventional:

```js
import { readOnly, computed } from '@ember/object';
import { readOnly as readOnlyAlias } from '@ember/object/computed';

class Person {
  @readOnly
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @readOnlyAlias('fullName')
  otherFullName;
}
```

Ember Decorators made the decision to attempt renaming the macros themselves,
since `reads`, `readOnly`, and `oneWay` were all poorly named (arguably, `reads`
should have been `readOnly` since it is the more common use case) but this is
not a possibility in Ember, since this would cause collisions and confusion
within the macros namespace.

All of this would be to support a deprecated feature, which can still be used
(albeit, with a less-than-ideal syntax). Accepting the current syntax would also
prevent us from polluting the decorator namespace - we may want to use
`@readOnly` or `@volatile` in the future with tracked properties instead.

### Actions

Actions are special in Ember because they are namespaced within a class on the
`actions` object, despite being able to reference the class directly using
`this` when called, and otherwise behaving like standard methods. The reason for
this stems from the early days of Ember, when users would accidentally name an
action something that conflicted with existing lifecycle and event hooks (e.g.
`destroy`, or `click`). The `actions` namespace was added as a convenience to
prevent these collisions, and to separate them from the rest of the class body
organizationally.

This namespace is problematic for native classes for a number of reasons:

1. The namespace cannot be defined using class field syntax, since that would
   assign a copy of the object to every instance of the class, and there is no
   other native way to easily assign it.
2. Actions must inherit from the parent, which means that the `actions` object
   must have its prototype set to the parent class's `actions` object.
3. It is not possible to use `super` within non-class methods, meaning an
   alternative would have to be developed specifically for the namespace.

With these constraints, a decorator would be necessary to maintain the current
namespacing functionality. The options for such a decorator are limited. It
could:

1. Decorate a class field, placing the value on the class prototype and setting
   up inheritance/super functionality. This would necessarily result in either
   some amount of repetition in the decorator name and field name, or a
   redundant field name:

    ```js
    class Foo {
      @actions actions = {
        onClick() { /* ... */ }
      }
    }
    ```

2. Decorate the class itself with the actions object as a parameter. This would
   be awkward, since actions would be removed from the class definition:

    ```js
    @actions({
      onClick() { /* ... */ }
    })
    class Foo {}
    ```

3. Decorate the class itself, with the expectation that the `actions` class
   field exists and is an object. This leads to a disconnect between the
   decoration and the definition that is easy to miss, and could be
   counterintuitive to newcomers:

    ```js
    @actionHandler
    class Foo {
      actions = {
        onClick() { /* ... */ }
      }
    }
    ```

None of these options is ergonomic in the least. Instead, it is much cleaner and
easier to decorate method definitions that are directly on the class body:

```js
class Foo {
  @action
  onClick() { /* ... */ }
}
```

This would be implemented by creating the class's `actions` object and assigning
the method to it, setting up inheritance and such in the process. The decorator
leaves the method definition on the class, where it can be called like a normal
method would, including `super` functionality. This maintains compatibility with
the classic object model, while making the `actions` namespace an
_implementation_ detail rather than something users need to know about.

This does mean that actions can once again collide with actual lifecycle and
event hooks on the class, since they are no longer namespaced. The decorator
_could_ remove the method from the class definition entirely, but this would be
confusing for users not familiar with the old `actions` namespace - why does
this method disappear from the class? It would also break `super` functionality,
so it would not be ideal to do this.

The `@action` decorator _could_ warn users when it collides with a lifecycle
hook. However, hooks may vary from class type to class type, which presents a
design challenge. We could either:

1. Allow classes to specify lifecycle hooks, and throw whenever `@action`
   collides with a specified hook.
2. Only throw on hooks that are shared across all classes, such as `init` and
   `destroy`.
3. Do nothing, and leave it to user's to know which lifecycle hooks exist.

Specifying hooks for each class would be time consuming and could fall out of
sync with the implementations. Throwing on "universal" hooks only is
inconsistent, and could lead users to think that they are safe when they are
not. This RFC suggests that we choose option 3 for this reason. When the actions
namespace was introduced, lifecycle hooks like `destroy` and `click` were less
commonly known and used (event listeners were not uncommon). Most Ember users
know they exist now, and will be aware that implementing an action with the same
name is not recommended. In addition, eslint rules can be added to hint against
these collisions.

### Method Binding

`@action` will also bind the function to the class instance, allowing it to be
used in templates and elsewhere without having to be bound:

```js
export default class ButtonComponent extends Component {
  @action
  onClick() {
    // handle click
  }
}
```
```hbs
<button onclick={{this.onClick}}>Click me!</button>
```

#### Usage and API

The API for this new decorator would be much simpler than the computed API,
since it is only used as a decorator without parameters.

```ts
// Technically `action` is a function, but we can't type it transparently that way
const action: MethodDecorator;
```

Attempting to pass any parameters to the decorator, or to apply the decorator to
anything other than a class method, will throw an error.

## How we teach this

Teaching decorators is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see native class syntax with
decorators as the _default_, and should not ever have to write a classic class
or see an example for one.

With this RFC, the majority of existing examples in the Ember guides will be
updatable to native class syntax. The exception would be examples of classic
components, which would be addressed separately by updating the guides to
Glimmer Components (proposed in a separate RFC). Otherwise, all examples in the
guides should be updated.

### Updating and Interop

For existing users, or users who have to interact with classic code from a modern
context, it'll be important to have a reference for the classic object model.
The current section on the object model in the guides can be moved to a classic
section, and a section on updating should be added. Links to relevant codemods,
such as the
[ember-es6-class-codemod](https://github.com/scalvert/ember-es6-class-codemod),
should be included. This section should remain updated and included in the main
guides for as long as `EmberObject` is a part of Ember's public API.

## Acceptance Commitments

> This section serves to capture the various commitments accepting this RFC
> would entail.

* Adds support for decorators and class fields to Ember's public API. Transforms
  would be included out of the box as well.
* Allows computed properties to work as a native decorators on native classes.
* Adds the `@action` decorator for defining actions on native classes.

## Drawbacks

* The `ComputedProperty` class has long been considered intimate API. Even with
  recent changes as part of the native getter RFC to make it more private, these
  changes could still cause breakage.
* The strategy for converting `computed` to decorators has one major drawback,
  which is that decorator macros cannot easily be customized and will require a
  bit of boilerplate in some cases. For instance, currently in Ember Decorators
  it is possible to apply the `map` and `reduce` macros directly to a _method_,
  which becomes the method to map or reduce by:

  ```js
  @map('array')
  mappedArray() {}

  @map('array', function() {}) mappedArray;
  ```

  With this method, only the second form would be usable. Likewise, by default
  addons like Ember Data would need to write thin decorator wrappers around
  macros that may be called _without_ parameters, or which require key
  reflection:

  ```js
  @attr name; // This would not work OOTB
  @attr('string') name; // This would

  @belongsTo user; // This would not work OOTB
  @belongsTo('user') user; // This would
  ```

## Alternatives

### No Decorators

We could not have official Ember support for any aspects of the classic
programming model. This essentially means computed properties, since `@action`
and the injection helpers are still needed for the Octane model. This would
leave many users in limbo, unable to update to native class syntax fully because
it would mean rewriting large amounts of classes and components, and would make
libraries like `@ember-decorators` essential.

### Namespaced Decorators

We could include decorators as a separate package, such as `@ember/decorators`.
This is not ideal as it would force users to remember more import paths, and it
would make eventual deprecation of the classic form much more difficult. It would
also mean that the wider ecosystem would have to do much more work to adopt
decorator syntax.

### Full Compatibility Decorators

We could include decorators for the remaining classic features: Observers, event
listeners, and classic components. These would add extra weight, and may
encourage users to continue using these features, which would not be ideal.

Instead, we can recommend that users wanting to update to native class syntax
use external packages that implement these features, such as
`@ember-decorators`. The native class codemod will detect and automatically
include these packages if they are necessary.

### Default Read Only Decorator

In this proposal, computeds used as decorators match the semantics of computeds
used in classic classes exactly. This is true even in the unfortunate case of
computed overridability:

```js
class Person {
  firstName = 'Stefan';
  lastName = 'Penner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let person = new Person;

person.fullName; // 'Tom Dale'

person.set('firstName', 'Kris');
person.set('lastName', 'Selden');

person.set('fullName', 'Melanie Sumner'); // overrides the setter

person.fullName; // 'Melanie Sumner'
```

We could, instead, make decorators apply computeds as _readOnly by default_,
since this is a new usage of them and not a breaking change. This would require
us to add a new `overridable()` modifier to opt-out of readOnly behavior by
default, for backwards compatibility, and would add a fair amount of complexity
to codemods. Either way, this behavior will be the default in Ember v4, and
deprecations will begin appearing when this happens soon.

### Allow `@action` to Rename Actions

If the namespace collisions caused by actions becoming standard methods are
difficult to refactor around or codemod, we can consider allowing the `@action`
helper to receive an alternative action name:

```js
export default class ButtonComponent extends GlimmerComponent {
  @action('destroy')
  destroyAction() {
    // handle click
  }
}
```
```hbs
<button {{action 'destroy'}}>Click me!</button>
```

This could be added later by a followup RFC, so it is not part of this proposal.
Ideally it won't be necessary.

## Unresolved questions

As stated in the introduction, this RFC is being made with the assumption that
decorators will be moved to stage 3 before this RFC is actually implemented. If
they are _not_ moved to stage 3, we will have to decide if decorators should be
supported in while they are in stage 2.

If they are supported while in stage 2, there are some additional questions:

* Should stage 2 transforms continue to be supported after decorators move to
  stage 3? Would removing stage 2 support require a major version bump?
* Should Typescript's stage 1-like decorators be supported, since Typescript
  will not implement new decorator transforms until they reach stage 3?

## Appendix A

This appendix contains the list of affected APIs and new APIs for quick reference.

| `@ember/controller` |
|---------------------|
| `inject`            |

| `@ember/object` |
|-----------------|
| `computed`      |
| _`action`_      |

| `@ember/object/computed` |
|--------------------------|
| `alias`                  |
| `and`                    |
| `bool`                   |
| `collect`                |
| `deprecatingAlias`       |
| `empty`                  |
| `equal`                  |
| `filter`                 |
| `filterBy`               |
| `gt`                     |
| `gte`                    |
| `intersect`              |
| `lt`                     |
| `lte`                    |
| `map`                    |
| `mapBy`                  |
| `match`                  |
| `max`                    |
| `min`                    |
| `none`                   |
| `not`                    |
| `notEmpty`               |
| `oneWay`                 |
| `or`                     |
| `readOnly`               |
| `reads`                  |
| `setDiff`                |
| `sort`                   |
| `sum`                    |
| `union`                  |
| `uniq`                   |
| `uniqBy`                 |

| `@ember/service` |
|------------------|
| `inject`         |

## Appendix B

This appendix contains a full list of changed APIs and their old and new signatures.

### **`@ember/controller`**

* `inject`
  ```ts
  // old
  function inject(): ComputedProperty<Controller>;
  function inject<K extends keyof ControllerRegistry>(
      name: K
  ): ComputedProperty<ControllerRegistry[K]>;

  // new
  function inject(): PropertyDecorator;
  function inject<K extends keyof ControllerRegistry>(
      name: K
  ): PropertyDecorator;
  ```

### **`@ember/object`**

* `computed`
  ```ts
  // old
  function computed(...args: (string | ComputedPropertyConfig<T>)[]): ComputedProperty<T>;

  // new
  function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
  ```

* `action`
  ```ts
  // old
  // N/A

  // new
  const action: MethodDecorator;
  ```

### **`@ember/object/computed`

* `alias`
  ```ts
  // old
  function alias(dependentKey: string): ComputedProperty<any>;

  // new
  function alias(dependentKey: string): PropertyDecorator;
  ```

* `and`
  ```ts
  // old
  function and(...dependentKeys: string[]): ComputedProperty<boolean>;

  // new
  function and(...dependentKeys: string[]): PropertyDecorator;
  ```

* `bool`
  ```ts
  // old
  function bool(dependentKey: string): ComputedProperty<boolean>;

  // new
  function bool(dependentKey: string): PropertyDecorator;
  ```

* `collect`
  ```ts
  // old
  function collect(...dependentKeys: string[]): ComputedProperty<any[]>;

  // new
  function collect(...dependentKeys: string[]): PropertyDecorator;
  ```

* `deprecatingAlias`
  ```ts
  // old
  function deprecatingAlias(
    dependentKey: string,
    options: { id: string; until: string }
  ): ComputedProperty<any>;

  // new
  function deprecatingAlias(
    dependentKey: string,
    options: { id: string; until: string }
  ): PropertyDecorator;
  ```

* `empty`
  ```ts
  // old
  function empty(dependentKey: string): ComputedProperty<boolean>;

  // new
  function empty(dependentKey: string): PropertyDecorator;
  ```

* `equal`
  ```ts
  // old
  function equal(dependentKey: string, value: any): ComputedProperty<boolean>;

  // new
  function equal(dependentKey: string, value: any): PropertyDecorator;
  ```

* `filter`
  ```ts
  // old
  function filter(
    dependentKey: string,
    callback: (value: any, index: number, array: any[]) => boolean
  ): ComputedProperty<any[]>;

  // new
  function filter(
    dependentKey: string,
    callback: (value: any, index: number, array: any[]) => boolean
  ): PropertyDecorator;
  ```

* `filterBy`
  ```ts
  // old
  function filterBy(
    dependentKey: string,
    propertyKey: string,
    value?: any
  ): ComputedProperty<any[]>;

  // new
  function filterBy(
    dependentKey: string,
    propertyKey: string,
    value?: any
  ): PropertyDecorator;
  ```

* `gt`
  ```ts
  // old
  function gt(dependentKey: string, value: number): ComputedProperty<boolean>;

  // new
  function gt(dependentKey: string, value: number): PropertyDecorator;
  ```

* `gte`
  ```ts
  // old
  function gte(dependentKey: string, value: number): ComputedProperty<boolean>;

  // new
  function gte(dependentKey: string, value: number): PropertyDecorator;
  ```

* `intersect`
  ```ts
  // old
  function intersect(...propertyKeys: string[]): ComputedProperty<any[]>;

  // new
  function intersect(...propertyKeys: string[]): PropertyDecorator;
  ```

* `lt`
  ```ts
  // old
  function lt(dependentKey: string, value: number): ComputedProperty<boolean>;

  // new
  function lt(dependentKey: string, value: number): PropertyDecorator;
  ```

* `lte`
  ```ts
  // old
  function lte(dependentKey: string, value: number): ComputedProperty<boolean>;

  // new
  function lte(dependentKey: string, value: number): PropertyDecorator;
  ```

* `map`
  ```ts
  // old
  function map<U>(
    dependentKey: string,
    callback: (value: any, index: number, array: any[]) => U
  ): ComputedProperty<U[]>;

  // new
  function map<U>(
    dependentKey: string,
    callback: (value: any, index: number, array: any[]) => U
  ): PropertyDecorator;
  ```

* `mapBy`
  ```ts
  // old
  function mapBy(dependentKey: string, propertyKey: string): ComputedProperty<any[]>;

  // new
  function mapBy(dependentKey: string, propertyKey: string): PropertyDecorator;
  ```

* `match`
  ```ts
  // old
  function match(dependentKey: string, regexp: RegExp): ComputedProperty<boolean>;

  // new
  function match(dependentKey: string, regexp: RegExp): PropertyDecorator;
  ```

* `max`
  ```ts
  // old
  function max(dependentKey: string): ComputedProperty<number>;

  // new
  function max(dependentKey: string): PropertyDecorator;
  ```

* `min`
  ```ts
  // old
  function min(dependentKey: string): ComputedProperty<number>;

  // new
  function min(dependentKey: string): PropertyDecorator;
  ```

* `none`
  ```ts
  // old
  function none(dependentKey: string): ComputedProperty<boolean>;

  // new
  function none(dependentKey: string): PropertyDecorator;
  ```

* `not`
  ```ts
  // old
  function not(dependentKey: string): ComputedProperty<boolean>;

  // new
  function not(dependentKey: string): PropertyDecorator;
  ```

* `notEmpty`
  ```ts
  // old
  function notEmpty(dependentKey: string): ComputedProperty<boolean>;

  // new
  function notEmpty(dependentKey: string): PropertyDecorator;
  ```

* `oneWay`
  ```ts
  // old
  function oneWay(dependentKey: string): ComputedProperty<any>;

  // new
  function oneWay(dependentKey: string): PropertyDecorator;
  ```

* `or`
  ```ts
  // old
  function or(...dependentKeys: string[]): ComputedProperty<boolean>;

  // new
  function or(...dependentKeys: string[]): PropertyDecorator;
  ```

* `readOnly`
  ```ts
  // old
  function readOnly(dependentKey: string): ComputedProperty<any>;

  // new
  function readOnly(dependentKey: string): PropertyDecorator;
  ```

* `reads`
  ```ts
  // old
  function reads(dependentKey: string): ComputedProperty<any>;

  // new
  function reads(dependentKey: string): PropertyDecorator;
  ```

* `setDiff`
  ```ts
  // old
  function setDiff(setAProperty: string, setBProperty: string): ComputedProperty<any[]>;

  // new
  function setDiff(setAProperty: string, setBProperty: string): PropertyDecorator;
  ```

* `sort`
  ```ts
  // old
  function sort(
    itemsKey: string,
    sortDefinition: string | ((itemA: any, itemB: any) => number)
  ): ComputedProperty<any[]>;

  // new
  function sort(
    itemsKey: string,
    sortDefinition: string | ((itemA: any, itemB: any) => number)
  ): PropertyDecorator;
  ```

* `sum`
  ```ts
  // old
  function sum(dependentKey: string): ComputedProperty<number>;

  // new
  function sum(dependentKey: string): PropertyDecorator;
  ```

* `union`
  ```ts
  // old
  function union(...propertyKeys: string[]): ComputedProperty<any[]>;

  // new
  function union(...propertyKeys: string[]): PropertyDecorator
  ```

* `uniq`
  ```ts
  // old
  function uniq(propertyKey: string): ComputedProperty<any[]>;

  // new
  function uniq(propertyKey: string): PropertyDecorator;
  ```

* `uniqBy`
  ```ts
  // old
  function uniqBy(dependentKey: string, propertyKey: string): ComputedProperty<any[]>;

  // new
  function uniqBy(dependentKey: string, propertyKey: string): PropertyDecorator;
  ```

### **`@ember/service`**

* `inject`
  ```ts
  // old
  function inject(): ComputedProperty<Service>;
  function inject<K extends keyof ServiceRegistry>(
      name: K
  ): ComputedProperty<ServiceRegistry[K]>;

  // new
  function inject(): PropertyDecorator;
  function inject<K extends keyof ServiceRegistry>(
      name: K
  ): PropertyDecorator;
  ```


---

---
stage: recommended
start-date: 2018-12-05T00:00:00.000Z
release-date: 2019-09-19T00:00:00.000Z
release-versions:
  ember-source: v3.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/410
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/4
  authors: Tom Dale, Chris Garrett, Chad Hietala, Yehuda Katz
---

# Tracked Properties

## Summary

Tracked properties introduce a simpler and more ergonomic system for tracking
state change in Ember applications. By taking advantage of new JavaScript
features, tracked properties allow Ember to reduce its API surface area while
producing code that is both more intuitive and less error-prone.

This simple example shows a `Person` class with three tracked properties:

```js
export default class Person {
  @tracked firstName = 'Chad';
  @tracked lastName = 'Hietala';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

### A Note on Decorator Support

This RFC proposes a decorator version of tracked properties, and uses this
decorator version in most examples, on the assumption that the [Decorators RFC]
(https://github.com/emberjs/rfcs/pull/408) will be accepted and implemented
before this RFC. If the Decorators RFC is _not_ accepted, or cannot be
implemented due to other criteria not being met (such as decorators remaining at
stage 2), then only the classic class syntax for tracked properties will be
implemented.

## Terminology

Because of the occasional overlap in terminology when discussing similar
features, this document uses the following language consistently:

- A **getter** is an ES5 JavaScript feature that executes a function to
  determine the value of a property. The function is executed every time the
  property is accessed.
- A **computed property** is a property on an Ember object whose value is lazily
  produced by executing a function. That value is nearly always cached until one
  of computed property's dependencies changes.
- A **tracked property** refers to any class field that has been instrumented
  with `@tracked`. Unlike computed properties, tracked properties are _never_
  getters or setters.
- The **classic programming model** refers to the traditional Ember programming
  model. It includes _classic classes_, _computed properties_, _event
  listeners_, _observers_, _property notifications_, and _classic components_,
  and more generally refers to features that will not be central to Ember
  Octane. Concepts like _routes_, _controllers_, and _services_ belong to both
  the Octane programming model and the classic programming model.
- **Native classes** are classes defined using the Javascript `class` keyword.
- **Classic classes** are classes defined by subclassing from `EmberObject`
  using the static `extend` method.

## Motivation

Tracked properties are designed to be simpler to learn, simpler to write, and
simpler to maintain than today's computed properties. In addition to clearer
code, tracked properties eliminate the most common sources of bugs and mental
model confusion in computed properties today, and reduce memory overhead by not
caching by default.

### Leverage Existing JavaScript Knowledge

Ember's computed properties provide functionality that overlaps with native
JavaScript getters and setters. Because native getters don't provide Ember with
the information it needs to track changes, it's not possible to use them
reliably in templates or in other computed properties.

New learners have to "unlearn" native getters, replacing them with Ember's
computed property system. Unfortunately, this knowledge is not portable to other
applications that don't use Ember that developers may work on in the future, and
while this problem may be lessened by adopting native classes and decorators, it
still requires users learn Ember's notification system and its quirks.

Tracked properties are as thin a layer as possible on top of native JavaScript.
Tracked properties look like normal properties because they _are_ normal
properties.

Because there is no special syntax for retrieving a tracked property, any
JavaScript syntax that feels like it should work does work:

```js
// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
```

Similarly, syntax for changing properties works just as well:

```js
// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
```

This compares favorably with APIs from other libraries, which becomes more
verbose than necessary when JavaScript syntax isn't available:

```js
this.setState({
  age: this.state.age + 1,
});
```

```js
this.setState({
  lastName: this.state.lastName + "Katz";
})
```

### Avoiding Dependency Hell

Currently, Ember requires developers to manually enumerate a computed property's
dependent keys: the list of _other_ properties that _this_ computed property
depends on. Whenever one of the listed properties changes, the computed
property's cache is cleared and any listeners are notified that the computed
property has changed.

In this example, `'firstName'` and `'lastName'` are the dependent keys of the
`fullName` computed property:

```js
import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});
```

While this system typically works well, it comes with its share of drawbacks.

First, it's extra work to have to type every property twice: once as a string as
a dependent key, and again as a property lookup inside the function. While
explicit APIs can often lead to clearer code, this verbosity has the potential
to complicate the implementation without improving developer intent at all.
People understand intuitively that they are typing out dependent keys to help
_Ember_, not other programmers.

It's also not clear what syntax goes inside the dependent key string. In this
simple example it's a property name, but nested dependencies become a property
path, like `'person.firstName'`. (Good luck writing a computed property that
depends on a property with a period in the name.)

You might form the mental model that a JavaScript expression goes inside the
string—until you encounter the `{firstName,lastName}` expansion syntax or the
magic `@each` syntax for array dependencies.

The truth is that dependent key strings are made up of an unintuitive,
unfamiliar microsyntax that you just have to memorize if you want to use Ember
well.

Lastly, it's easy for dependent keys to fall out of sync with the
implementation, leading to difficult-to-detect, difficult-to-troubleshoot bugs.

For example, imagine a new member on our team is assigned a bug where a user's
middle name is not appearing in their profile. Our intrepid developer finds the
problem, and updates `fullName` to include the middle name:

```js
import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }),
});
```

They test their change and it seems to work. Unfortunately, they've just
introduced a subtle bug. If the user's `middleName` were to change, `fullName`
wouldn't update! Maybe this will get caught in a code review, given how simple
the computed property is, but noticing missing dependencies is a challenge even
for experienced Ember developers when the computed property gets more
complicated.

Tracked properties have a feature called _autotrack_, where dependencies are
automatically detected as they are used. This means that as long as all
properties that are dependencies are marked as tracked, they will automatically
be detected:

```js
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

Note that getters and setters do _not_ need to be marked as tracked, only the
properties that they access need to. This also allows us to opt out of tracking
entirely, like if we know for instance that a given property is constant and
will never change. In general, the idea is that _mutable_, _watchable_
properties should be marked as tracked, and _immutable_ or _unwatched_
properties should not be.

### Reducing Memory Consumption

By default, computed properties cache their values. This is great when a
computed property has to perform expensive work to produce its value, and that
value gets used over and over again.

But checking, populating, and invalidating this cache comes with its own
overhead. Modern JavaScript VMs can produce highly optimized code, and in many
cases the overhead of caching is greater than the cost of simply recomputing the
value.

Worse, cached computed property values cannot be freed by the garbage collector
until the entire object is freed. Many computed properties are accessed only
once, but because they cache by default, they take up valuable space on the heap
for no benefit.

For example, imagine this component that checks whether the `files` property is
supported in input elements:

```js
import Component from '@ember/component';
import { computed } from '@ember/object';

export default Component.extend({
  inputElement: computed(function() {
    return document.createElement('input');
  }),

  supportsFiles: computed('inputElement', function() {
    return 'files' in this.inputElement;
  }),

  didInsertElement() {
    if (this.supportsFiles) {
      // do something
    } else {
      // do something else
    }
  },
});
```

This component would create and retain an `HTMLInputElement` DOM node for the
lifetime of the component, even though all we really want to cache is the
Boolean value of whether the browser supports the `files` attribute.

Particularly on inexpensive mobile devices, where RAM is limited and often slow, we should
be more conservative about our memory consumption. Tracked properties switch
from an opt-out caching model to opt-in, allowing developers to err on the side
of reduced memory usage, but easily enabling caching (a.k.a. memoization) if a
property shows up as a bottleneck during profiling.

## Prior Art

Tracked properties were first implemented in [Glimmer.js](https://glimmerjs.com/),
and were recently polyfilled with clever usage of `notifyPropertyChange` by
the [sparkles-components](https://github.com/rwjblue/sparkles-component/) addon.
These initial implementations inform the design in this RFC, but differ from it
in some key ways. For instance, both Sparkles's and early versions of Glimmer's
`@tracked` did not have an autotracking stack, and instead relied on explicit
dependency keys. After benchmarking showed that autotracking was a viable
strategy, the API for `@tracked` was updated to what is proposed here.

## Detailed Design

This RFC proposes adding the `tracked` decorator function, used to mark class
fields as tracked:

```ts
const tracked: PropertyDecorator;
```

This new function will be exported from `@glimmer/tracking`. Revisiting our
example from earlier, `@tracked` can be used on native class fields and
getters/setters:

```js
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

### Getting Tracked Properties

Tracked properties can be accessed using standard Javascript syntax. From the
user's point of view, there is nothing special about them. This should continue
to work in the future, even if new methods are added for accessing properties,
because tracked properties use native getters under the hood.

```js
let person = new Person();

// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
```

### Setting Tracked Properties

Tracked properties can be set using standard Javascript syntax. They use native
setters under the hood, meaning that there is no need for using a setter method
like `set`.

```js
let person = new Person();

// Simple assignment
person.firstName = 'Jen';
// Addition assignment (+=)
person.lastName += 'Weber';
// Increment operator
person.age++;
```

### Autotracking

Tracked properties do not need to specify their dependencies. Under the hood,
this works by utilizing an _autotrack stack_. This stack is a bit of global
state which tracked properties can access. As tracked properties are accessed,
they push themselves onto the stack, and once they have finished running, the
stack contains the full list of all the tracked properties that were accessed
while it was running.

In our first example, with the `Person` class, we can see this in action:

```js
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

When we create a new instance of `Person`, the tracking system has no knowledge
of the connection between `fullName`, `firstName`, and `lastName`. Now, let's
say we go to render this person's name in a component's template:

```hbs
{{this.person.fullName}}
```

When Glimmer accesses the `fullName` property on person, it creates an
_autotrack stack frame_. As we computed `fullName`, any values that are
decorated with `@tracked` push themselves into this stack frame. Because getters
and setters are pure functions, they will ultimately end up accessing some
tracked properties - in this case, the `fullName` getter accesses the
`firstName` and `lastName` properties, and they push themselves onto the stack
frame.

In this way, Glimmer will know about _all_ properties that were accessed when
calculating any bound value in templates.

> **NOTE:** This does _not_ invalidate a cache like in computed properties.
> Internally, Glimmer checks to see if a value has updated _before calling the
> getter_. If it hasn't, then Glimmer does not rerender the related section of
> the DOM. This is effectively an automatic `shouldComponentUpdate` (at least
> the most common usage) from React.

### Manual Invalidation

In user code, the idea that all mutable properties should be marked as tracked
and that all other properties are effectively immutable works well in isolation.
However, there are cases where users will want to work with code they do _not_
control, such as external library code.

Consider the following example. We have a `simple-timer` library that we've
imported from NPM, and we're trying to wrap it with a `TimerComponent` that
uses it to keep track of how much time has passed:

```js
// simple-timer/index.js
export default class Timer {
  seconds = 0;
  minutes = 0;
  hours = 0;

  listeners = [];

  constructor() {
    setInterval(() => {
      this.seconds++;
      this.minutes = Math.floor(this.seconds / 60);
      this.hours = Math.floor(this.minutes / 60);
      this.notifyTick();
    }, 1000);
  }

  notifyTick() {
    for (let listener of this.listeners) {
      listener(this.seconds);
    }
  }

  onTick(listener) {
    this.listeners.push(listener);
  }
}
```

```js
import Timer from 'simple-timer';
import Component, { tracked } from '@glimmer/tracking';

export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
```

Even though we've marked the `timer` property as tracked, the `timer.seconds`
property is untracked, and _it_ is the field that is updated. We can solve this
problem by using the timer library's `onTick` event handler to re-set the field,
invalidating it:

```js
export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  constructor() {
    this.timer.onTick(() => {
      // invalidate the timer field.
      this.timer = this.timer;
    });
  }

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
```

### Interop with the Classic Programming Model

Tracked properties represent a paradigm shift. They are a completely new system,
fully independent of the classic programming model and based on modern
Javascript features and design, and they will be the _default_ change tracking
system in Ember Octane.

However, existing apps, libraries, and addons will be using the classic
programming model for some time, and experience tells us that these sort of
transitions to new features take a while to settle in the community. To ease
this process and enable gradual adoption, tracked properties will be able to
interoperate with the most commonly used features of the classic model:

- Classic classes
- Computed properties
- `get`/`set` and property notifications
- Observers

#### Classic Classes

The `tracked` decorator function will be usable in classic classes, similar to
`computed`:

```js
import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';

const Person = EmberObject.extend({
  firstName: tracked({ value: 'Tom' }),
  lastName: tracked({ value: 'Dale' }),

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
});
```

This form will _not_ be allowed on native classes, and will hard error if it is
attempted. Additionally, default values will be defined on the _prototype_ to
maintain consistency with the classic object model.

This will allow existing libraries to transition incrementally, and add tracked
support minimally where necessary. This also brings the _benefits_ of tracked
to classic classes, including the ability to drop usage of `set`:

```js
// before
let person = Person.create();
person.set('firstName', 'Stefan');
person.set('lastName', 'Penner');

// after
let person = Person.create();
person.firstName = 'Stefan';
person.lastName = 'Penner';
```

Ember's `set` function is nowhere to be seen!

#### Computed Properties

Computed properties will interoperate with tracked properties in both
directions:

* Accessing a computed property from a tracked property will add the computed
  property to its list of depedencies. Whenever the computed property is
  invalidated (i.e. because it or one of its dependencies is updated), the
  tracked property will be invalidated as well.

  ```js
  import { tracked } from '@glimmer/tracking';
  import { set } from '@ember/object';
  import { alias } from '@ember/object/computed';

  class Person {
    @tracked firstName;
    @tracked lastName;

    @alias('title') prefix;

    get fullName() {
      return `${this.prefix} ${this.firstName} ${this.lastName}`;
    }
  }

  let person = new Person();

  person.firstName = 'Tom';
  person.lastName = 'Dale';

  set(person, 'title', 'Mr.');

  person.fullName; // 'Mr. Tom Dale'
  ```

* Accessing a tracked property from a computed property will _also_
  automatically add the tracked property to the list of its dependencies. In
  this way, users will be able to gradually add tracked properties and
  simultaneously reap the benefits of not having to use `set` with computeds,
  and not having to specify dependent keys.

  ```js
  import { computed } from '@ember/object';
  import { tracked } from '@glimmer/tracking';

  class Person {
    firstName;
    lastName;

    @tracked middleName;

    @computed('firstName', 'lastName')
    get fullName() {
      return `${this.firstName} ${this.middleName} ${this.lastName}`;
    }
  }

  let person = new Person();

  set(person, 'firstName', 'Tom');
  set(person, 'lastName', 'Dale');

  person.middleName = 'Tomster';

  person.fullName; // 'Tom Tomster Dale'
  ```

It will still be required to use `set` when updating computed properties and
their dependencies. In the future, this restriction could possibly be relaxed.

#### `get` and `set`

It is common in the classic model to set and consume plain object properties
which are not computed properties, or in any other way special. Ember's `get`
and `set` functions historically allowed this by giving us the ability to
intercept all property changes and watch for mutations.

This presents a problem for tracked properties, particularly because of the
recent change in Ember to enable native Javascript getters to replace `get`.
This change means that we have no way to intercept `get`, and consequently no
way for tracked properties to know whether or not a plain property will later
be updated with `set`.

To demonstrate this case, consider the following service and component:

```js
const Config = Service.extend({
  polling: {
    shouldPoll: false,
    pollInterval: -1,
  },

  init() {
    this._super(...arguments);

    fetch('config/api/url')
      .then(r => r.json())
      .then(polling => set(this, 'polling', polling));
  },
});
```
```js
class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let { shouldPoll, pollInterval } = this.config.polling;

    return shouldPoll ? pollInterval : -1;
  }
}
```
```hbs
{{this.pollInterval}}
```

Let's walk through the flow here:

1. The `SomeComponent` component is rendered for the first time, instantiating
   the `Config` service (assuming this the first time it has ever been
   accessed). The service's init hook kicks off an async request to get the
   configuration from a remote URl.
2. The `pollInterval` property first accesses the service injection when
   rendered, which is a computed property. The property is detected and added to
   the tracked stack.
3. We then access the plain, undecorated `polling` object. Because it is
   is not tracked and not a computed property, tracked does not know that it
   could update in the future.
4. Sometime later, the async request returns with the configuration object. We
   set it on the service, but because our tracked getter did not know this
   property would update, it does not invalidate.

In order to prevent this from happening, user's will have to use `get` when
accessing any values which may be set with `set`, and are not computed
properties.

```js
class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let shouldPoll = get(this, 'config.polling.shouldPoll');
    let pollInterval = get(this, 'config.polling.pollInterval');

    return shouldPoll ? pollInterval : -1;
  }
}
```

The reverse, however, is not true - computed properties will be able to add
tracked properties, and listen to dependencies explicitly. In some cases, this
may be preferable, though undecorated getters should be the conventional
standard with the long term goal of removing all explicit dependencies and
computed decorations.

#### Observers

While Ember's observer system has been minimized in recent years, it is still
supported in Ember 3 and used occasionally throughout the ecosystem. Observers
use a fundamentally different system for tracking changes than tracked
properties, but this does not mean that it is impossible for the two systems to
interoperate, and it theory it shouldn't require much effort to maintain such
interoperation or regress performance in any meaningful way.

As such, tracked properties will be made to interoperate with observers so that
whenever a tracked property is set using _any_ valid syntax, observers watching
that key will be fired:

```js
import { tracked } from '@glimmer/tracking';
import { addObserver } from '@ember/object/observers';

class Person {
  constructor() {
    addObserver('firstName', () => {
      console.log('firstName changed!');
    });
  }

  @tracked firstName;
}
```

If in the implementation of this RFC it becomes apparent that there _are_ major
caveats to supporting interop with observers, a followup RFC will be made to
address those caveats and make a decision on whether or not to support observers
with those additional constraints.

### Does this mean I still have to use `get` and `set`?

Yes. As mentioned above, interoperating with legacy code will require using
`get` and `set` to be fully safe. However, even in greenfield applications which
do not need to interoperate with legacy addons or code, there will still be use
cases which are _not_ covered by tracked properties. These use cases are roughly
the same as those that come with native [ES Getters][getters]:

1. Objects that implement `unknownProperty` and `setUnknownProperty`
2. [Ember proxies](https://emberjs.com/api/ember/release/classes/ObjectProxy),
   which use `unknownProperty` and `setUnknownProperty`
3. In general, cases where change tracking should be _dynamic_, where the keys
   that are being tracked are _not_ known in advance and cannot be declared
   using decorators.

`get` and `set` will continue to work (as defined in this RFC) and will be
necessary in many applications for the forseeable future. How long exactly is
an [open question addressed below in the unresolved questions section](#unresolved-questions).

[getters]: https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md#motivation


## How we teach this

There are three different aspects of tracked properties which need to be
considered for the learning story:

1. **General usage.** Which properties should I mark as tracked? How do I
   consume them? How do I trigger changes?
2. **Interop with classic systems.** How do I safely consume tracked properties
   from classic classes and computeds? How do I safely consume classic APIs from
   tracked properties?
3. **Interop with non-Ember systems.** How do I tell my app that something has
   changed in MobX objects, RxJS objects, Redux, etc.

### General Usage

The mental model with tracked properties is that anything _mutable_ that is
public should be tracked. If a value will ever change, and it will or could be
watched externally, it should have the `@tracked` decorator attached to it.

After that, usage should be "Just Javascript". You can safely access values
using any syntax you like, including desctructuring, and you can update values
using standard assignments.

```js
// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];

// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
```

#### Triggering Updates on Complex Objects

There may be cases where users want to update values in complex, untracked
objects such as arrays or POJOs. `@tracked` will only be usable with class
syntax at first, and while it may make sense to formalize these objects into
tracked classes in some cases, this will not always be the case.

To do this, users can re-set a tracked value directly after its inner values
have been updated.

```js
class SomeComponent extends Component {
  @tracked items = [];

  @action
  pushItem(item) {
    let { items } = this;

    items.push(item);

    this.items = items;
  }
}
```

This may seem a bit strange at first, but it allows users to mentally scope
off a tree of objects. They manipulate internals as they see fit, and the only
operation they need to do to update state is set the nearest tracked property.

### Interop with Classic Systems

There are two cases that we need to consider when teaching interoperability:

1. Accessing non-tracked properties and computeds from an autotrack context
2. Accessing tracked properties from a computed context

In the first case, the general rule of thumb is to use `get` if you want to be
100% safe. In cases where you are certain that the values you are accessing are
tracked, computeds, or immutable, you can safely use standard access syntax.

In the second case, no additional changes need to be made when using tracked
properties. They can be accessed as normal, and will be automatically added to
the computed's dependencies. There is no need to use `get`, and you can use
standard assignments when updating them.

### Interop with Non-Ember Systems

The strategy for trickier updates on complex objects by retriggering their
setters should cover most integration use cases. We should add a guide which
specifically demonstrates their usage by wrapping a common, simple external
library such as `moment.js`. This will demonstrate its usage concretely, and
establish best practices.

## Drawbacks

Like any technical design, tracked properties must make tradeoffs to balance
performance, simplicity, and usability. Tracked properties make a different set
of tradeoffs than today's computed properties.

This means tracked properties come with edge cases or "gotchas" that don't exist
in computed properties. When evaluating the following drawbacks, please consider
the two features in their totality, including computed property gotchas you have
learned to work around.

In particular, please try to compensate for [familiarity][familiarity] and
[loss aversion][loss-aversion] biases. Before you form a strong opinion, [give
it five minutes][5-minutes].

[familiarity]: https://en.wikipedia.org/wiki/Familiarity_heuristic
[loss-aversion]: https://en.wikipedia.org/wiki/Loss_aversion
[5-minutes]: https://signalvnoise.com/posts/3124-give-it-five-minutes

### Tracked Properties & Promises

Dependency autotracking requires that tracked getters access their dependencies
synchronously. Any access that happens asynchronously will not be detected as a
dependency.

This is most commonly encountered when trying to return a `Promise` from a
tracked getter. Here's an example that would "work" but would never update if
`firstName` or `lastName` change:

```js
class Person {
  @tracked firstName;
  @tracked lastName;

  get fullNameAsync() {
    return this.reloadUser().then(() => {
      return `${this.firstName} ${this.lastName}`;
    });
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }

  setFirstName(firstName) {
    // This should cause `fullNameAsync` to update, but doesn't, because
    // firstName was not detected as a dependency.
    this.firstName = firstName;
  }
}
```

One way you could address this is to ensure that any dependencies are consumed
synchronously:

```js
get fullNameAsync() {
  // Consume firstName and lastName so they are detected as dependencies.
  let { firstName, lastName } = this;

  return this.reloadUser().then(() => {
    // Fetch firstName and lastName again now that they may have been updated
    let { firstName, lastName } = this;
    return `${firstName} ${lastName}`;
  });
}
```

However, **modeling async behavior as tracked properties is an incoherent
approach and should be discouraged**. Tracked properties are intended to hold
simple state, or to derive state from data that is available synchronously.

But asynchrony is a fact of life in web applications, so how should we deal with
async data fetching?

**In keeping with Data Down, Actions Up, async behavior should be modeled as
methods that set tracked properties once the behavior is complete.**

Async behavior should be explicit, not a side-effect of property access. Today's
computed properties that rely on caching to only perform async behavior when a
dependency changes are effectively reintroducing observers into the programming
model via a side channel.

A better approach is to call a method to perform the async data fetching, then
set one or more tracked properties once the data has loaded. We can refactor the
above example back to a synchronous `fullName` tracked property:

```js
class Person {
  @tracked firstName;
  @tracked lastName;

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
```

Now, `reloadUser()` must be called explicitly, rather than being run implicitly
as a side-effect of consuming `fullName`.

### Accidental Untracked Properties

One of the design principles of tracked properties is that they are only
required for state that _changes over time_. Because tracked properties imply
some overhead over an untracked property (however small), we only want to pay
that cost for properties that actually change.

However, an obvious failure mode is that some property _does_ change over time,
but the user simply forgets to annotate that property as `@tracked`. This will
cause frustrating-to-diagnose bugs where the DOM doesn't update in response to
property changes.

Fortunately, we have a strategy for mitigating some of this frustration. It
involves the way most tracked properties will be consumed: via a component
template. In development mode, we can detect when an untracked property is used
in a template and install a setter that causes an exception to be thrown if it
is ever mutated. (This is similar to today's "mandatory setter" that causes an
exception to be thrown if a watched property is set without going through
`set()`.)

Unfortunately this strategy cannot be applied to values accessed by tracked
getters. The only way we could detect such access would be with native
[Proxies][proxy], but proxies are more focussed on security over flexibility
and recent discussion shows that [they may break entirely when used with
private fields](https://github.com/tc39/proposal-class-fields/issues/106). As
such, it would not be ideal for us to use them in this way.

## Alternatives

### Ship tracked properties in user-land

Instead of shipping `@tracked` today, we can focus on formalizing the primitives
which it uses under the hood in Glimmer VM (References and Validators) and make
these publicly consumable. This way, users will be able to implement tracked in
an addon and experiment with it before it becomes a core part of Ember.

This approach is similar to the approach taken with component managers in the
past year, which unblocked experimentation with `SparklesComponent`s as a way to
validate the design of `GlimmerComponent`s, and unlocked the ability for power
users to create their own component APIs. However, the reference and validator
system is a much more core part of the Glimmer VM, and it could take much longer
to figure out the best and safest way to do this without exposing too much of
the internals. It would certainly prevent `@tracked` from shipping with Ember
Octane.

### Keep the current system

We could keep the current computed property based system, and refactor it
internally to use references only and not rely on chains or the old property
notification system. This would be difficult, since CPs are very intertwined
with property events as are their dependencies. It would also mean we wouldn't
get the DX benefits of cleaner syntax, and the performance benefits of opt-in
change tracking and caching.

### We could keep `set`

Tracked properties were designed around wanting to use native setters to update
state. If we remove that constraint and keep `set`, it opens up some
possibilities. There is precedent for this in other frameworks, such as React's
`setState`.

However, keeping `set` likely wouldn't be able to restrict the requirement for
`@tracked` being applied to all mutable properties for the same reason `get`
must be used in interop - there's no way for a tracked property to know that a
plain, undecorated property could update in the future.

### Allow explicit dependencies

We could allow `@tracked` to receive explicit dependencies instead of forcing
`get` usage for interop. This would be very complex, if even possible, and is
ultimately not functionality `@tracked` should have in the long run, so it would
not make sense to add it now.

### We could wait on private fields and Proxy developments

Native [Proxies][proxy] represent a lot of possibilities for automatic change
tracking. Other frameworks such as Vue and Aurelia are looking into using
recursive proxy structures to wrap objects and intercept access, which would
allow them to track changes without _any_ decoration. We also considered using
recursive proxies in earlier drafts of this proposal, even though they aren't
part of our support matrix we believed they could be used during development to
assert when users attempted to update untracked properties which had been
consumed from tracked getters.

However, as mention above, TC39 has made it clear that this was [not an intended
use for Proxy](https://github.com/tc39/proposal-class-fields/issues/106), and
they will be _breaking_ this functionality with the inclusion of private fields.
They have also expressed that [they would like to solve this
use-case](https://github.com/tc39/proposal-class-fields/issues/162#issuecomment-441101578)
(observing object state changes in general) separately, and [a strawman proposal
was made](https://github.com/littledan/proposal-proxy-transparent) (though it
has not advanced and does not seem like it will). We could wait to see what the
future looks like here, and see if we can provide a more ergonomic tracked
properties RFC in the future.

## Unresolved questions

### When can I stop using `get` and `set`?

This is the biggest open question in this RFC, and with the direction that
tracked properties set. How do we get rid of `get` and `set` for good, if that
is the direction we want to go in?

The full answer to that question is out of scope for tracked properties, but it
would likely require at least two additional steps:

1. The underlying system for tracking changes, including the ability to create
   tags for fields and the ability to add to the current autotracking stack,
   will need to be made public for advanced users who need dynamic change
   tracking.

2. First class support for [native proxies][proxy] within Ember.
   `unknownProperty` and `setUnknownProperty` have no other analag in native
   Javascript, and without support for native proxies there will likely be use
   cases that cannot be supported in any other way.

   As mentioned above, native proxies _will_ (potentially) have more limitations
   than Ember proxies, but these limitations will most likely be possible to
   work around for advanced users who need this functionality in the first
   place. In other words, while they probably don't make sense as a basis for
   _all_ change tracking in Ember, they will probably be invaluable for specific
   use cases such as [Ember M3](https://www.npmjs.com/package/ember-m3) which
   require very dynamic change tracking.

[proxy]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy


---

---
stage: recommended
start-date: 2018-12-13T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/415
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/8
---

# Render Element Modifiers

## Summary

Element modifiers are a recently introduced concept in Ember that allow users to
run code that is tied to the lifecycle of an _element_ in a template, rather
than the component's lifecycle. They allow users to write self-contained logic
for manipulating the state of elements, and in many cases can be fully
independent of component code and state.

However, there are many cases where users wish to run some component code when
an element is setting up or tearing down. Today, this logic conventionally lives
in the `didInsertElement`, `didRender`, `didUpdate`, and  `willDestroyElement`
hooks in components, but there are cases where these hooks are not ideal.

This RFC proposes creating an official Ember addon which provides three new
generic element modifiers: `{{did-insert}}`, `{{did-update}}`, and
`{{will-destroy}}`. Users will be able to use these to run code during the most
common phases of any element's lifecycle.

## Motivation

The primary component hooks for interacting with the DOM today are:

* `didInsertElement`
* `didRender`
* `didUpdate`
* `willDestroyElement`

These render hooks cover many use cases. However, there are some cases which
they do not cover, such as setting up logic for conditional elements, or tagless
components. There also is no easy way to share element setup logic, aside from
mixins or pure functions (which require some amount of boilerplate).

### Conditionals

Render code for elements which exist conditionally is fairly tricky. Consider a
simple popover component:

```hbs
{{#if this.isOpen}}
  <div class="popover">
    {{yield}}
  </div>
{{/if}}
```

If the developer decides to use an external library like [Popper.js](https://popper.js.org)
to position the popover, they have to add a fair amount of boilerplate. On each
render, they need to check if the popover was added to the DOM or removed from
it, and setup or teardown accordingly.

```js
export default Component.extend({
  didRender() {
    if (this.isOpen && !this._popper) {
      let popoverElement = this.element.querySelector('.popover');

      this._popper = new Popper(document, popoverElement);
    } else if (this._popper) {
      this._popper.destroy();
    }
  },

  willDestroyElement() {
    if (this._popper) {
      this._popper.destroy();
    }
  }
});
```

At this level of complexity, most developers would reasonably choose to create
a second component to be used within the `{{if}}` block so they can use standard
lifecycle hooks. Sometimes this makes sense as it helps to separate concerns and
organize code, but other times it is clearly working around the limitations of
render hooks, and can feel like more components are being created than are
necessary.

With render modifiers, hooks are run whenever the _element_ they are applied to
is setup and torn down, which means we can focus on the setup and teardown code
without worrying about the overall lifecycle:

```hbs
{{#if this.isOpen}}
  <div
    {{did-insert (action this.setupPopper)}}
    {{will-destroy (action this.teardownPopper)}}

    class="popover"
  >
    {{yield}}
  </div>
{{/if}}
```
```js
export default Component.extend({
  setupPopper(element) {
    this._popper = new Popper(document, element);
  },

  teardownPopper() {
    this._popper.destroy();
  }
});
```

The element that the modifiers are applied to is also passed to the function, so
there is no longer a need to use `querySelector`. Overall the end result is a
fair amount simpler, without the need for an additional component.

These same issues are also present for collections items within an `{{each}}`
loop, and the render modifiers can be used to solve them as well:

```hbs
<ul>
  {{#each items as |item|}}
    <li
      {{did-insert (action this.registerElement)}}
      {{will-destroy (action this.unregisterElement)}}
    >
      ...
    </li>
  {{/each}}
</ul>
```

### Tagless Components

Additionally, render hooks do not provide great support for tagless components
(`tagName: ''`). While the hooks fire when the component is rendered, they have
no way to target any of the elements which are in the component's template,
meaning users must use `querySelector` and setup some unique id or class to
target the element by:

```js
export default Component.extend({
  tagName: '',

  listId: computed(function() {
    return generateId();
  }),

  didInsertElement() {
    let element = document.querySelector(`#${this.listId}`);

    // ...
  },

  willDestroyElement() {
    let element = document.querySelector(`#${this.listId}`);

// ...
  }
});
```
```hbs
<ul id={{listId}}>
  ...
</ul>

<div>
  ...
</div>
```

The render modifiers can be used to add hooks to the appropriate main element in
tagless components:

```js
export default Component.extend({
  tagName: '',

  didInsertList(element) {
    // ...
  },

  willDestroyList(element) {
    // ...
  }
});
```
```hbs
<ul
  {{did-insert (action this.didInsertList)}}
  {{will-destroy (action this.willDestroyList)}}
>
  ...
</ul>

<div>
  ...
</div>
```

### Reusable Helpers

Currently, the best ways to share element setup code are either via mixins,
which are somewhat opaque and can encourage problematic patterns, or standard JS
functions, which generally require some amount of boilerplate.

Developers will be able to define element modifiers in the future with modifier
managers provided by addons. However, the proposed modifier APIs are fairly
verbose (with good reason) and not stabilized.

However, the render modifiers can receive _any_ function as their first
parameter, allowing users to share and reuse common element setup code with
helpers. For instance, a simple `scrollTo` helper could be created to set the
scroll position of an element:

```js
// helpers/scroll-to.js
export default function scrollTo() {
  return (element, [scrollPosition]) => element.scrollTop = scrollPosition;
}
```
```hbs
<div
  {{did-insert (scroll-to) @scrollPosition}}
  {{did-update (scroll-to) @scrollPosition}}
  class="scroll-container"
>
  ...
</div>
```

### Official Addon

While these modifiers will be generally useful, modifiers are meant to be a more
generic API that can be used to create libraries for solving specific problems.
Unfortunately, the community hasn't had much time to experiment with modifiers,
since the public API for them hasn't been finalized.

The modifiers in this RFC will provide an basic stepping stone for users who
want to emulate lifecycle hooks and incrementally convert their applications to
modifiers while modifiers in general are being experimented with in the
community. In time, users should be able to pick and choose the modifiers that
suit their needs more directly and effectively, and they shouldn't have to
include these modifiers in the payload. These modifiers should also not be seen
as the "Ember way" - they are just another addon, a basic one supported by
the Ember core team, but one which may or may not be appropriate for a given
application.

## Detailed design

This RFC proposes adding three element modifiers:

* `{{did-insert}}`
* `{{did-update}}`
* `{{will-destroy}}`

Note that element modifiers do _not_ run in SSR mode - this code is only run on
clients. Each of these modifiers receives a callback as it's first positional
parameter:

```ts
type RenderModifierCallback = (element: Element, positionalArgs: [any], namedArgs: object): void;
```

The `element` argument is the element that the modifier is applied to,
`positionalArgs` contains any remaining positional arguments passed to the
modifier besides the callback, and `namedArgs` contains any named arguments
passed to the modifier. If the first positional argument is not a callable
function, the modifier will throw an error.

> Note: The timing semantics in the following section were mostly defined in the
> [element modifier manager RFC](https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md)
> and are repeated here for clarity and convenience.

### `{{did-insert}}`

This modifier is activated only when The element is inserted in the DOM.

It has the following timing semantics when activated:

* **Always**
  * called after DOM insertion
  * called _after_ any child element's `{{did-insert}}` modifiers
  * called _after_ the enclosing component's `willRender` hook
  * called _before_ the enclosing component's `didRender` hook
  * called in definition order in the template
* **May or May Not**
  * be called in the same tick as DOM insertion
  * have the sibling nodes fully initialized in DOM

Note that these statements do not refer to when the modifier is _activated_,
only to when it will be run relative to other hooks and modifiers _should it be
activated_. The modifier is only activated on insertion.

### `{{did-update}}`

This modifier is activated only on _updates_ to it's arguments (both positional
and named). It does _not_ run during or after initial render, or before
element destruction.

It has the following timing semantics when activated:

* **Always**
  * called after the arguments to the modifier have changed
  * called _after_ any child element's `{{did-update}}` modifiers
  * called _after_ the enclosing component's `willUpdate` hook
  * called _before_ the enclosing component's `didUpdate` hook
  * called in definition order in the template
* **Never**
  * called if the arguments to the modifier are constants

### `{{will-destroy}}`

This modifier is activated:

1. immediately before the element is removed from the DOM.

It has the following timing semantics when activated:

* **Always**
  * called _after_ any child element's `{{will-destroy}}` modifiers
  * called _before_ the enclosing component's `willDestroy` hook
  * called in definition order in the template
* **May or May Not**
  * be called in the same tick as DOM removal

### Function Binding

Functions which are passed to these element modifiers will _not_ be bound to any
context by default. Users can bind them using the `(action)` helper:

```hbs
<div {{did-insert (action this.setupElement)}}></div>
```

Or by using the `@action` decorator provided by the
[Decorators RFC](https://github.com/emberjs/rfcs/pull/408) to bind the function
in the class itself:

```js
export default class ExampleComponent extends Component {
  @action
  setupElement() {
    // ...
  }
}
```
```hbs
<div {{did-insert this.setupElement}}></div>
```

## How we teach this

Element modifiers will be new to everyone, so we're starting with a mostly blank
slate. The only modifier that exists in classic Ember is `{{action}}`, and while
most existing users will be familiar with it, that familiarity may not translate
to the more general idea of modifiers.

The first thing we should focus on is teaching _modifiers in general_. Modifiers
should be seen as the place for any logic which needs to act directly on an
element, or when an element is added to or removed from the DOM. Modifiers can
be fully independent (for instance, a `scroll-to` modifier that transparently
manages the scroll position of the element) or they can interact with the
component (like the `did-insert` and `will-destroy` modifiers). In all cases
though, they are _tied to the render lifecycle of the element_, and they
generally contain _side-effects_ (though these may be transparent and
declarative, as in the case of `{{action}}` or the theoretical `{{scroll-to}}`).

Second, we should teach the render modifiers specifically. We can do this by
illustrating common use cases which can currently be solved with render hooks,
and comparing them to using modifiers for the same solution. We should also
emphasize that these are an addon, not part of the core framework, and are
useful as solutions for _specific_ problems. As more modifiers become available,
we should create additional guides that focus on using the _best_ modifier for
the job, rather than these generic ones.

One thing we should definitely avoid teaching except in advanced cases is the
_ordering_ of element modifiers. Ideally, element modifiers should be
commutative, and order should not be something users have to think about. When
custom element modifiers become widely available, this should be considered best
practice.

### Example: Scrolling an element to a position

This sets the scroll position of an element, and updates it whenever the scroll
position changes.

Before:

```hbs
{{yield}}
```
```js
export default Component.extend({
  classNames: ['scroll-container'],

  didRender() {
    this.element.scrollTop = this.scrollPosition;
  }
});
```

After:

```hbs
<div
  {{did-insert this.setScrollPosition @scrollPosition}}
  {{did-update this.setScrollPosition @scrollPosition}}

  class="scroll-container"
>
  {{yield}}
</div>
```
```js
export default class Component.extend({
  setScrollPosition(element, scrollPosition) {
    element.scrollTop = scrollPosition;
  }
})
```

#### Example: Adding a class to an element after render for CSS animations

This adds a CSS class to an alert element in a conditional whenever it renders
to fade it in, which is a bit of an extra hoop. For CSS transitions to work, we
need to append the element _without_ the class, then add the class after it has
been appended.

Before:

```hbs
{{#if shouldShow}}
  <div class="alert">
    {{yield}}
  </div>
{{/if}}
```
```js
export default Component.extend({
  didRender() {
    let alert = this.element.querySelector('.alert');

    if (alert) {
      alert.classList.add('fade-in');
    }
  }
});
```

After:

```hbs
{{#if shouldShow}}
  <div {{did-insert this.fadeIn}} class="alert">
    {{yield}}
  </div>
{{/if}}
```
```js
export default Component.extend({
  fadeIn(element) {
    element.classList.add('fade-in');
  }
});
```

#### Example: Resizing text area

One key thing to know about `{{did-update}}` is it will not rerun whenever the
_contents_ or _attributes_ on the element change. For instance, `{{did-update}}`
will _not_ rerun when `@type` changes here:

```hbs
<div {{did-update this.setupType}} class="{{@type}}"></div>
```

If `{{did-update}}` should rerun whenever a value changes, the value should be
passed as a parameter to the modifier. For instance, a textarea which wants to
resize itself to fit text whenever the text is modified could be setup like
this:

```hbs
<textarea {{did-update this.resizeArea @text}}>
  {{@text}}
</textarea>
```
```js
export default Component.extend({
  resizeArea(element) {
    element.css.height = `${element.scrollHeight}px`;
  }
});
```

#### Example: `ember-composability-tools` style rendering

This is the type of rendering done by libraries like `ember-leaflet`, which use
components to control the _rendering_ of the library, but without any templates
themselves. The underlying library for this is [here](https://github.com/miguelcobain/ember-composability-tools).
This is a simplified example of how you could accomplish this with Glimmer
components and element modifiers.

Node component:

```js
// components/node.js
export default Component.extend({
  init() {
    super(...arguments);
    this.children = new Set();

    this.parent.registerChild(this);
  }

  willDestroy() {
    super(...arguments);

    this.parent.unregisterChild(this);
  }

  registerChild(child) {
    this.children.add(child);
  }

  unregisterChild(child) {
    this.children.delete(child);
  }

  didInsertNode(element) {
    // library setup code goes here

    this.children.forEach(c => c.didInsertNode(element));
  }

  willDestroyNode(element) {
    // library teardown code goes here

    this.children.forEach(c => c.willDestroyNode(element));
  }
}
```
```hbs
<!-- components/node.hbs -->
{{yield (component "node" parent=this)}}
```

Root component:

```js
// components/root.js
import NodeComponent from './node.js';

export default NodeComponent.extend();
```
```hbs
<!-- components/root.hbs -->
<div
  {{did-insert (action this.didInsertNode)}}
  {{will-destroy (action this.willDestroyNode)}}
>
  {{yield (component "node" parent=this)}}
</div>
```

Usage:

```hbs
<Root as |node|>
  <node as |node|>
    <node />
  </node>
</Root>
```

## Drawbacks

* Adding these modifiers means that there are more ways to accomplish similar
  goals, which may be confusing to developers. It may be less clear which is the
  conventional solution in a given situation.

* Relying on users binding via `action` is somewhat unintuitive, and may feel
  like it's getting in the way, especially considering sometimes methods will
  work without binding (if they never access `this`).

## Alternatives

* Stick with only lifecycle hooks for these situations, and don't add generic
  modifiers for them.




---

---
stage: recommended
start-date: 2018-12-13T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/416
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/2
---

# Glimmer Components

## Summary

Glimmer components are a simpler, more ergonomic, and more declarative approach
to building components. They represent the sum of multiple years of design and
feature work by the community, which stemmed from the original RFCs and
discussions surrounding "angle-bracket components".

This RFC proposes adding Glimmer components to Ember's public API, and making
them the default new app experience in Ember Octane.

## Attribution

The Glimmer components API presented in this RFC was designed in cooperation
between @tomdale, @rwjblue, @krisselden, @pzuraq, and others.

## First, a Bit of History

As components became the standard for Single Page Apps (SPAs) several years ago,
and the Ember community began adopting them in earnest and converting from Ember
1's primarily MVC oriented approach, there were many small and large issues that
cropped up with Ember's component API and usage: `{{curly-bracket}}` syntax felt
dated with the introduction of Web Components and other major frameworks; the
inability to specify or override HTML attributes led to explosions in API
complexity; the implicit wrapper element and customization fields (`tagName`,
`classNames`, et al.) felt burdensome and made templates difficult to read
compared to other frameworks; two way data-binding led to strange, hard to
predict data cycles within apps; and so on.

From this came the original [Angle Bracket component
RFC](https://github.com/emberjs/rfcs/blob/0b32059b3704836e52c906a0ead64ac186c844d8/active/0000-component-unification.md).
The idea was simple: switch to the superior `<angle-bracket>` syntax of web
components, and solve all the other problems! Seems easy enough, right?

As you can imagine, it was _not_ that easy. There was a flurry of discussion on
the original RFC, and many ideas were thrown around. This was seen as the _one_
chance Ember had to "fix" its component API, and the community did not want to
get it wrong and lock us into yet _another_ set of painful papercuts. After much
debate and lots of back and forth with the design, it was ultimately decided
that attempting to redesign components all at once, monolithically, was too
much. Instead, the individual ideas from that discussion could be broken out and
implemented in isolation, in a backwards compatible way, both incrementally
building a new, well thought out component API _and_ laying the groundwork in
the framework for future redesigns.

A lot of the foundational work that arose from these discussions and paves the
way for Glimmer components has already landed in Ember, including: Angle-bracket
invocation, named arguments, element modifiers, and component managers.

Glimmer components represent the final piece of that's required to enable the
"ember octane" programming model. They include the last of the major features
that were discussed during the original Angle Brackets RFC, and holistically, we
feel those features make a much simpler and more ergonomic component API. Taken
alone, they are an incremental change. Their individual features aren't _that_
much more than what we currently have in Ember today. But as a whole they
represent the culmination of multiple years of design work and discussion by the
Ember community, and the collective attention to detail and care of all of our
community members.

## Terminology

* The **Glimmer VM** is the underlying rendering engine which is used by
  _Ember.js_ and _Glimmer.js_.
* **Glimmer.js** is a thin wrapper on top of the _Glimmer VM_ which exposes a
  much simpler API compared to Ember. Historically it has been used to
  experiment with ideas and implementations before bringing them into Ember via
  RFC, and has been used to write applications which don't require the full
  feature set of Ember.
* **Glimmer components** are a newly proposed component API which draw from the
  experimental APIs provided in Glimmer.js, and Ember.js via
  [sparkles-component](https://github.com/rwjblue/sparkles-component).
* **Classic components** refer to the standard component API at the time of this
  RFC, which have been available in Ember in some form since v1.
* **Tracked properties** refer to a new method of change tracking which is being
  proposed in a separate RFC, parallel to this one.

## Motivation

`GlimmerComponent` is a simpler base component class that enables smaller class
definitions, stronger conventions for lifecycle hooks and properties, and
unidirectional data flow. We aim to design them to be easier understand in
isolation, and require less knowledge of the framework to use effectively.

This example shows a component written with the classic component API:

```hbs
<!-- templates/components/post.hbs -->
{{#if (eq type 'image'}}
  <img src={{post.imageUrl}} title={{post.imageTitle}}>
{{/if}}

{{post.text}}
```
```js
// components/post.js
export default Component.extend({
  tagName: 'section',
  classNames: ['post'],
  classNameBindings: ['type'],
  ariaRole: 'region',

  /* Arguments */
  post: null,

  type: readOnly('post.type'),

  didInsertElement() {
    this._super(...arguments);
    if (this.type === 'image') {
      setupImageOverlay(this.element.querySelector('img'));
    }
  }
});
```

And here is an equivalent component written with the Glimmer component API:

```hbs
<!-- templates/components/post.hbs -->
<section ...attributes role="region" type={{@post.type}} class="post {{@post.type}}">
  {{#if (eq @post.type 'image')}}
    <img
      {{did-insert this.didInsertImage}}
      src={{@post.imageUrl}}
      title={{@post.imageTitle}}
    />
  {{/if}}

  {{@post.text}}
</section>
```
```js
// components/post.js
export default class PostComponent extends GlimmerComponent {
  @action
  didInsertImage(element) {
    setupImageOverlay(element);
  }
}
```

Glimmer components eliminate many of the common paper cuts that cause confusion
with classic components, and align more closely with modern template syntax and
features.

### Outer HTML Semantics

The biggest change Glimmer components make is defaulting to outer HTML
semantics. In the classic component API, components had a implicit wrapper
element. Given this component template:

```hbs
Hello, world!
```

The output by _default_ would be something like:

```html
<!-- OUTPUT -->
<div id="ember-1234" class="ember-view">
  Hello, world!
</div>
```

But we can't know that for sure unless we look at the component definition. If
we do, we might see that the outer wrapping element is actually a `section`, and
it has a `.hello-world` class:

```js
export default Component.extend({
  tagName: 'section',
  classNames: ['hello-world']
});
```
```html
<!-- OUTPUT -->
<section id="ember-1234" class="hello-world ember-view">
  Hello, world!
</section>
```

This behavior means that the template for a component is missing crucial
information and context. Even for the simplest component, users must check the
class definition to know with certainty what the full template of the component
is. And unlike bindings, there is no hint to the user that there may be
something dynamic that they should check on - without advanced knowledge of
Ember's APIs, there is no way of knowing about this behavior.

By contrast, Glimmer components have no wrapping outer element - What you see in
the template is what you get in the output. There is no need to define class
names, class name bindings, attribute bindings, or any other DOM element values
_from the component class_; developers can achieve the equivalent result using
the same techniques they're familiar with from working with `Ember.Component`
templates. The template is the single source of truth for the output of a
component, and any dynamic values are explicitly stated in it.

```hbs
<!-- template.hbs -->
<section class="hello-world">
  Hello, world!
</section>
```

```html
<!-- OUTPUT -->
<section class="hello-world">
  Hello, world!
</section>
```

We can immediately see that this is a simple component with no bindings, no
dynamic values, and no meaningful state. Even if there was a component
definition, we know that it is not in any way affecting the output of this
template. Special element ids and classes are also not present, making the
output appear less magical.

This micro change makes a macro difference:

* Users can spend less time switching back and forth between reading template
  and class code, and can get a better idea of the structure of an app from its
  declarative templates.

* Component customization code becomes less imperative and more declarative,
  meaning users no longer need to keep the state of bindings, class names, and
  other class code in their heads.

* The gap between template-only components - which are analogous to React and
  other frameworks' functional components - and components with a backing class
  is reduced, making them a more viable pattern.

### Namespaced Arguments

In classic components, arguments are set as properties directly on the class
instance. This means that class methods and properties can be completely
overwritten by incoming arguments, which can have surprising and problematic
side effects. For example, let's say we have a component that has a `fullName`
computed property and expects `firstName` and `lastName` arguments:

```js
// components/person.js
export default Component.extend({
  firstName: null,
  lastName: null,

  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});
```

The public API of this component is _supposed_ to just be those two arguements.
However, a developer may realize that they can pass `fullName` directly to the
component, overriding the computed property:

```hbs
<Person @fullName={{this.fullNameWithMiddle}}>
```

This is clearly a bad pattern, but it shows that in effect that most details of
a component's implementation are not truly private, and any property or value
can be overriden from external contexts. In most common day-to-day scenarios
developers just have to be careful that they are following the intended public
API of a component, but this also has the potential for misuse and enables
antipatterns.

Glimmer components assign their arguments to the `args` property on their
instance, preventing namespace collisions from happening in the first place.
This allows component authors to define a clear public API for a component which
_cannot_ be circumvented.

### Immutable Arguments

In classic components argument values on the component are also _mutable_. This
can lead to some confusing behavior, because argument values in the _class_ can
change, but named arguments in _templates_ cannot. For instance, given this
component:

```js
// components/welcome.js
export default Component.extend({
  firstName: 'Jen',
  lastName: 'Weber'
});
```
```hbs
<!-- templates/components/welcome.hbs  -->
Hey there, {{@firstName}} {{@lastName}}!
```

And this invocation:

```hbs
<Welcome />
```

You might expect that the result would be:

```hbs
Hey there, Jen Weber!
```

However, `{{@firstName}}` and `{{@lastName}}` would actually be empty values.
They refer _directly_ to the arguments passed into the _invocation_ of the
component, and to get the results we wanted, we would have to invoke it like so:

```hbs
<Welcome @firstName="Jen" @lastName="Weber" />
```

The advantage in this is that named arguments are fully transparent. When seen
in a template, users can know without a doubt that the named argument was a
value passed in from the invocation. Likewise, when they see a standard binding
to a value like `{{this.firstName}}` or `{{firstName}}`, they know this is a
value defined on the component - it could a computed property, it could come
from a service, it could be a random value, but it is _not_ an argument.

Glimmer components align their argument access with named args by making
arguments available exclusively on a (shallow) frozen object, `this.args`.
Attempting to modify `this.args` will hard error, meaning that like templates,
users will always be able to refer to `this.args` as the canonical state of the
values passed to the component invocation.

Immutable arguments make reasoning about the state of a component simpler ("Was
that a user provided value or a default/mutated/computed value?" becomes "Was it
an argument or not?"), and encourages use of `{{@arg}}` syntax in templates
where appropriate. At scale, this makes reading templates even easier, since
more information is encoded in the template itself. One way data flow also
encourages the Data Down, Actions Up pattern, and normalizes the way that data
flows through apps, making reasoning about app state easier.

### Minimal Classes

Classic components are large classes, with lots of built up functionality and
debt from over the years. The total list of default properties and hooks
(including inherited ones) includes:

* **13** Standard lifecycle hooks, such as
  `didInsertElement`/`willDestroyElement` and `didUpdate`.
* **29** Event handlers, such as `click`, `mouseEnter`, and `dragStart`.
* **9** element/element customization properties, such as `element` and
  `tagName`.
* **21** standard framework functions, such as `get`/`set`,
  `addObserver`/`removeObserver` and `toggleProperty`.

Coming from a class hierarchy that is 4 levels deep (`Component` -> `CoreView`
-> `EmberObject` -> `CoreObject`, with about 19 mixins included along the way).

This is a large API surface to become acquainted with, and namespace
collisions are possible with new Ember users - collisions on `destroy`
were the original reason for adding the `actions` object to classes, and every
so often a user will pop in on `#help` wondering why their `click` or `submit`
methods trigger automagically, or why their component disappeared when they
added an `isVisible` property. Even putting aside the possibility of collisions,
the sheer amount of choice can sometimes be overwhelming: Do I put my
initialization logic in `init` or `didInsertElement`? Do I use an action or the
`click` handler? Which update method should I use - `didRender`, `didUpdate`,
`didReceiveAttrs`?

Glimmer components have a constructor, **2** lifecycle hooks, and **3**
properties. They only extend from the Glimmer Component base class -- a simple
ES6 class that does not extend from `EmberObject`. They don't have any
element/DOM based properties, hooks, event handler functions, whose
responsibilities have been passed on to element modifiers. This _dramatically_
simplifies what users need to learn in order to start using the bread-and-butter
class of Ember, and enforces a single conventional location for each of the
possible hooks in classic components, allowing users to focus on productivity
out of the box.

### Glimmer.js Compatibility

One of the goals for future versions of Ember, post Ember Octane, will be to
enable lighter-weight applications to be built using the framework. Breaking
Ember apart into smaller, fully independent and optional pieces is the core idea
behind the "install your way to Ember" goal, which will enable Ember to be used
in more constrained environments that smaller frameworks such as React, Preact,
Vue, and more excel in. It will also allow users who are size-conscious to adopt
Ember incrementally, adding functionality when it is _needed_ rather than having
all-or-nothing.

This will take time though. Progress has been made, but parts of Ember are still
monolithic. And while it isn't Ember, Glimmer.js is a lightweight wrapper of the
Glimmer VM that enables users to drop that weight and begin writing much more
minimal apps today.

Glimmer components aren't just based on the Glimmer.js component API - they are
one and the same. They will be a shared package, which will be importable and
usable by the users of both frameworks. Not only will users be able to write
better components in Ember, those components will also be cross-compatible with
Glimmer apps (assuming they don't use Ember specific functionality).

It is important to note that while Glimmer components will be versioned
independently from Glimmer and Ember ***they will abide by the Ember RFC process
for any and all changes to user APIs***. The implementations for their component
managers in Glimmer and Ember may change to keep them compatible, but they will
not make major changes without first getting community input, and will be
considered part of the public API of Ember.

## Prior Art

Part of the challenge in the original Angle Bracket components RFC was
attempting to design without implementation, testing, usage, and feedback.
Glimmer.js provided an early method to experiment, but because it was not widely
adopted there wasn't much feedback from larger-scale usage. This in part
motivated the [component manager
RFC](https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md),
which enabled experimentation in Ember directly, and set us up for having
multiple implementations of component APIs which were interchangeable.

As such, we now have two reference implementations which can be referred to:

* [Glimmer.js](https://glimmerjs.com/), the framework that this component API is
  based on, and will be cross-compatible with.
* [sparkles-component](https://github.com/rwjblue/sparkles-component), an an
  implementation of the Glimmer.js component API using Ember's component
  managers. It is usable in Ember today.

Both of these have minor differences from the API proposed in this RFC, mainly
because they were made before the [element modifier manager
RFC](https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md)
was accepted and opened up additional design possibilities. However, they serve
as valuable data points for the viability of a simpler component API, and inform
the design accordingly.

## Detailed design

Glimmer components have the following interface:

```ts
interface GlimmerComponent<T = object> {
  args: T;

  isDestroying: boolean;
  isDestroyed: boolean;

  constructor(owner: Opaque, args: T): void;
  willDestroy(): void;
}
```

This class will be importable from `@glimmer/component`;

```js
import Component from '@glimmer/component';
```

### Constructor

The constructor for Glimmer components receives two arguments: The owner
instance and the named arguments object. Both of these arguments should
conventionally be passed to `super` immediately, and then accessed through
decorated service properties, `getOwner`, and `this.args`:

```js
class PersonComponent extends GlimmerComponent {
  @service profile;

  constructor() {
    super(...arguments);

    let owner = getOwner(this);
    let profileService = this.profile;

    let firstName = this.args.firstName;
  }
}
```

These arguments are passed to the constructor so that they can be used for
initial setup of the component. Service injections and args being available in
this way also makes them available to class field initializers, which run
immediately _after_ the call to `super`:

```js
class PersonComponent extends GlimmerComponent {
  @service time;

  // Use the values of args in an initializer
  fullName = `${this.args.firstName} ${this.args.lastName}`;

  // Access a service in an initializer
  currentTime = this.time.now();
}
```

The `args` argument will be shallow-frozen (in development mode only) to prevent
users from modifying them.

#### Type Injections

Ember's dependency injection system allows defining injections across an entire
type via
[RegistryProxy#inject](https://www.emberjs.com/api/ember/3.5/classes/ApplicationInstance/methods/inject?anchor=inject) - for
instance, Ember Data's store, which is available by default as
`this.store` on all Routes and Controllers. These injections add a layer of
implicit state to objects, since users must know what the default injections are
ahead of time.

By contrast, service getters (decorated with `@service`) clearly and explicitly
state the dependencies of a class within its definition. The benefit of having
an explicit dependencies list within each class has proven to be invaluable in
practice since `inject.service()` was introduced.

Glimmer components will only receive the owner directly, and as such will _not_
support type injections. This cuts down on the implicit knowledge developers
must have when writing a component.

### Properties

Glimmer components have 3 properties: `args`, `isDestroying`, and `isDestroyed`.

#### `args`

As discussed in the motivation section, `args` is an object with the values of
the named arguments passed to the component. This property will be updated
whenever the arguments change. It will be shallow-frozen in development mode to
prevent users from setting values on it.

#### `isDestroying`

This property will be set to `true` when component teardown has been initiated,
_before_ the component's `willDestroy` hook is run, along with any other
components which are currently being torn down. This allows the entire component
tree to be marked before user code is run. It can be used by users to
conditionally prevent asynchronous code from running, and to check on the
teardown state of the component in general.

#### `isDestroyed`

This property will be set after any `willDestroy` hooks have run, and the
component has been fully torn down. It can be used by users to conditionally
prevent asynchronous code from running, and to check on the teardown state of
the component in general.

### Lifecycle Hooks

Classic components have 13 major lifecycle hooks that run during 3 major phases
of the component lifecycle, with some hooks running during multiple phases:

1. **Initialization and Initial Render:**
   * `init`
   * `willInsertElement`
   * `didInsertElement`,
   * `didReceiveAttrs`
   * `willRender`
   * `didRender`.

2. **Rerenders and Updates:**
   * `didReceiveAttrs`
   * `didUpdateAttrs`
   * `willUpdate`
   * `didUpdate`
   * `willRender`
   * `didRender`

3. **Destruction:**
   * `willDestroyElement`
   * `didDestroyElement`
   * `destroy`
   * `willDestroy`

Many of these hooks have overlapping or redundant functionality, and it's fairly
confusing when to use which and what the differences are. We can simplify this
cycle in a number of ways:

* Hooks that run during multiple phases such as `didRender` and
  `didRecieveAttrs` can be convenient at times, but also add mental overhead and
  redundancy. We can remove these in favor of clearly delineated hooks which
  only run during _one_ phase.

* "Bookend" methods (`did*` and `will*`) can be confusing, since they require
  some specific knowledge of what the "bookended" functionality is. For
  instance, users almost _always_ want to use `didInsertElement` and
  `willDestroyElement`, but the existence of their opposite bookends can make
  this confusing. Additionally, the fact that `didReceiveAttrs` and
  `didUpdateAttrs` do _not_ have opposing bookends is inconsistent with this
  pattern.

* Hooks that are used to update derived state, such as `didUpdate` and
  `didUpdateAttrs`, can be generally be replaced with tracked or computed
  properties that pull the required values as they are used, rather than eagerly
  as they are updated. This is more inline with Glimmer's pull-based change
  tracking system, and encourages better practices that are easier to optimize.

* Hooks which are used to manipulate elements or the DOM in general can be
  removed in favor of element modifiers, which are discussed in detail in the
  next section.

Based on these considerations, we can reduce these hooks to just a setup and
teardown method: `constructor` and `willDestroy`.

#### `constructor`

The native `constructor` method for the class can be used for initial setup of
the component. This effectively replaces `init`, and allows users to setup state
before _any_ renders occur. It has the following timing semantics:

* **Always**
  * called when a component is created
  * called _before_ any child components are created
  * called _before_ any element modifiers with install hooks in the component's
    template

In many cases, using the `constructor` directly will not be necessary due to
class fields, whose initializers run during instance construction.

```js
class Person {
  constructor() {
    this.name = 'Tomster';
  }
}
```

Is the same as:

```js
class Person {
  name = 'Tomster';
}
```

Class fields are assigned _after_ the call to `super` in the constructor, but
_before_ any of the user's code runs, allowing their values to be accessed by
users as well.

#### `willDestroy`

This hook runs when the component is being destroyed, and can be used for
cleanup code. It has the following timing semantics:

* **Always**
  * called when a component is removed
  * called _after_ any child component `willDestroy` hooks
  * called _after_ any element modifiers with destroy hooks in the component's
    template
  * called _after_ `isDestroying` has been set to `true`, and _before_
    `isDestroyed` has been set to `true`
  * called _after_ the DOM has been fully removed and is inaccessible
* **May or May Not**
  * be called in a stable order relative to sibling component `willDestroy`
    hooks

### Element Modifiers

DOM manipulation is a hard problem for component-oriented frameworks. We spend a
lot of time crafting elegant, functional, template oriented abstractions that
work very well, up until the point where we have to use an imperative native API
like `addEventListener` or `MutationObserver`. This is not a problem unique to
Ember - the recent introduction of the React Hooks API, and the [various flavors
of hooks that exist](https://nikgraf.github.io/react-hooks/), many of which
accomplish the same thing in slightly different ways, suggests that this is a
_fundamentally difficult problem_ no matter how you tackle it.

This is also evidenced by the sheer _number_ of hooks which have been added to
classic Ember components over time to handle various different use cases, and
the fact that there does not appear to be a general consensus on best practices
for using these hooks. In our audit, we observed the following:

1. `didInsertElement` was commonly used for setting up component state which had
   nothing to do with the element and could have been accomplished in `init`.
2. `didRender` was often used for setting up DOM state once on initial render
   only, instead of `didInsertElement`.
3. `didRender` and `didReceiveAttrs` (or `didUpdate` and `didUpdateAttrs`) were
   used interchangeably for setting up and updating DOM state based on incoming
   argument changes, without strong conventions on when to use one or the other,
   or consideration for which ones fire in SSR (`didReceiveAttrs` and
   `didUpdateAttrs`) and which do not.
4. Libraries like
   [ember-lifeline](https://github.com/ember-lifeline/ember-lifeline) were not
   uncommon for managing the extra state that using hooks inevitably creates,
   and imply that it is not always intuitive or well understood that you must
   clean up that state.
5. Guards for SSR appear sporadically throughout various hooks, since some
   (`didInsertElement`, `willDestroyElement`) do _not_ run in SSR, but others
   (`didReceiveAttrs`, `didUpdateAttrs`) do. This adds _another_ layer of state
   that developers must be aware of as they are using lifecycle hooks. Often
   times these guards occured even in hooks which _did not run_ in SSR, implying
   that it is difficult to remember which hooks are best to use in either
   situation.
6. Hooks such as `didRender` had many different potential use cases. It was used
   for reacting to changes to component arguments in some cases, but in others
   it was used as a more general purpose "bloom filter", allowing the component
   to react to _any_ changes to the DOM subtree. The variety of use cases seemed
   to add to the confusion about which hooks should be used in which
   circumstances.
7. Another disadvantage of the flexibility of these hooks was that often
   developers had to add additional validation steps for their specific use
   case. For instance, if a developer wanted to react to a change to a specific
   argument in `didRender` or `didReceiveAttrs`, they had to add cacheing and
   comparison logic manually to do so for each property.

In summary, lifecycle hooks attempted to provide on general solution to the
problem of DOM manipulation for _all_ use-cases, and in doing so provided a
solution that solves each individual problem and use-case in a mediocre way.
Rather than continue these patterns in Glimmer components, we believe that they
should lean instead on _Element Modifiers_.

Modifiers provide a single unified way to define multiple _different_ APIs for
interacting with the DOM. Individual modifiers can be targeted toward specific
use cases, such as adding an event listener or `MutationObserver`, triggering a
callback during certain lifecycle events, capturing element references for use
in components, and more. Importantly, modifiers are _easy to compose_ and
_self-contained_, meaning that it will be possible for general purpose addons to
be built for various use cases, and for them all to be used together without
difficulty.

#### Conversion and Path Forward

Modifiers may be the general purpose solution for writing DOM APIs, but average
Ember developers should not have to _write_ a modifier very often. This is a key
distinction - it means that beginner Ember developers will not need to learn the
ins and outs of modifiers as soon as they need to use DOM, and that they will be
able to instead rely on established patterns from established libraries, similar
to helpers. This combined with the fact that DOM manipulation was on average a
_rare_ occurence in our audits means they won't be overwhelming to learn.

However, while we have merged the [Modifier Manager
RFC](https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md),
the final API for modifiers themselves is still in RFC, and the community hasn't
had a chance to experiment with them and develop patterns yet. We also want to
be able to provide straightforward upgrade and migration guides for users who
want to convert from classic component lifecycle hooks to modifiers. In order to
cover this gap while the community is still absorbing the new APIs, the
modifiers proposed in the [Render Element Modifiers
RFC](https://github.com/emberjs/rfcs/pull/415) will be released as an official
Ember addon. These essentially expose the three hooks of modifiers to users
directly, allowing them to pass callbacks from their components:

```hbs
<div
  {{did-insert this.setupElement @arg1 @arg2}}
  {{did-update this.updateElement @arg1 @arg2}}
  {{will-destroy this.teardownElement}}
>
  ...
</div>
```

These modifiers should allow users to approximate most of the existing lifecycle
hooks, and in most cases should be pretty straightforward to update to. The
Ember guides will provide migration examples for a variety of use cases to
assist in converting to these modifiers. Over time, as addons and libraries are
released that target specific use cases, the guides should be updated to include
popular patterns and demonstrate the most effective and conventional ways to
solve _specific_ problems with DOM manipulation.

### Lifecycle Hook Audit

In the design process of this RFC, we wanted to provide the minimal set of
functionality that covered the previous use cases of classic components. The
final API of Glimmer components as proposed in this RFC is very small, cutting
out almost all existing hooks in favor of a handful of conventional hooks and
element modifiers.

In order to be sure that these hooks and modifiers would cover existing use
cases, we did an audit of a few popular addons: [Ember
Paper](https://miguelcobain.github.io/ember-paper/),
[ember-google-maps](https://github.com/sandydoo/ember-google-maps), and
[liquid-fire](https://github.com/ember-animation/liquid-fire). These libraries
were chosen because they represent a large mix of both common use cases and edge
cases, and give us a decent cross-section of what the hooks are used for today.

We also did a less formal audit of a variety of addons and open source apps,
including [ember-leaflet](https://github.com/miguelcobain/ember-leaflet),
[ember-power-select](https://github.com/cibernox/ember-power-select),
[ember-basic-dropdown](https://github.com/cibernox/ember-basic-dropdown),
[ember-table](https://github.com/Addepar/ember-table),
[vertical-collection](https://github.com/html-next/vertical-collection),
[ember-composablity-tools](https://github.com/miguelcobain/ember-composability-tools),
[Travis Web](https://github.com/travis-ci/travis-web), [the Ghost admin
app](https://github.com/TryGhost/Ghost-Admin), and [Hospital
Run](https://github.com/HospitalRun/hospitalrun-frontend), along with general
code searches through Ember Observer.

In all of these, the only use case we found that was _not_ covered was the
ability to run a hook whenever a render occurs in the subtree of a component
using `didRender` or `didUpdate`. The only instance we found of this was in
[ember-google-maps](https://github.com/sandydoo/ember-google-maps/blob/d901864e9198c1d4956d5ba9629147f64e4ae6b7/addon/templates/components/g-map/overlay.hbs#L6),
where it was used detect when an
[overlay](https://ember-google-maps.sandydoo.me/docs/overlays) component has
rendered and needs to be repositioned. For this rare case, we believe a
[MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
set to detect mutations to the DOM subtreemay be more appropriate.
Alternatively, a component can be defined with a custom component manager, which
still retains this ability.

The usages from the audit and their equivalent solution in Glimmer components
have been included in this RFC in an appendix.

### Actions

In classic components, actions are defined on the `actions` hash, and can be
referenced in templates using strings passed to the `{{action}}` helper:

```js
export default Component.extend({
  actions: {
    buttonPressed() {
      // ...
    }
  }
})
```
```hbs
<button onclick={{action 'buttonPressed'}}>Press Me!</button>
```

This form of action sending is based on the `ActionHandler` mixin and requires
that the component class have a `send` method. Glimmer components will _not_
implement this API, and as such will not support string based action helpers.
In development mode a special error will be thrown instead, informing users of
alternatives.

Instead, users should use helpers or decorators to bind functions to the
component instance. The `action` helper and modifier do this in templates, as
does the `bind` helper provided by the [ember-bind-helper](https://github.com/Serabe/ember-bind-helper) addon:

```js
export default class ButtonComponent extends Component {
  buttonPressed() {
    // ...
  }
}
```
```hbs
<button onclick={{action this.buttonPressed}}>Press Me!</button>
```

Alternatively, a decorator could be used to bind the helper to the instance,
such as the `@action` decorator proposed in the [Decorators RFC](https://github.com/emberjs/rfcs/pull/408).

```js
export default class ButtonComponent extends Component {
  @action
  buttonPressed() {
    // ...
  }
}
```
```hbs
<button onclick={{this.buttonPressed}}>Press Me!</button>
```

However, one method for binding methods which should be discouraged is assigning
an arrow function to class fields:

```js
export default class ButtonComponent extends Component {
  buttonPressed = () => {
    // ...
  }
}
```

This is messy for a few reasons:

* The method is no longer available on the prototype, making it difficult to
  mock
* It breaks `super` and inheritance, meaning subclasses have no way to override
  the arrow function
* Values such as `arguments` will not be set since it is an arrow function

For more details, see [this document explaining the rationale for decorators](https://github.com/tc39/proposal-decorators/blob/master/bound-decorator-rationale.md)
over class fields for binding.

## Dependencies

In it's current form this RFC is dependent on 2 of 3 open RFCs being accepted:

* The [Decorators RFC](https://github.com/emberjs/rfcs/pull/408) must be
  accepted, because Glimmer components cannot be defined using classic class
  syntax. If it is not accepted this RFC will have to be amended to add a way
  for users to define Glimmer components with classic classes.

* The [Render Element Modifiers RFC](https://github.com/emberjs/rfcs/pull/415)
  must be accepted, since Glimmer components currently do not have any render
  lifecycle hooks or ways to interact with the DOM.

  If it is not accepted, this RFC will have to explore some of the alternatives
  listed below (`{{capture-element}}`, `bounds`, and render hooks).

## How we teach this

Teaching Glimmer components is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see Glimmer components as the
_default_, and should not ever have to write a classic component or see one in
the main guides.

Classic components will of course be widely used for some time however, so a
classic section which includes conversion guides and relevant codemods should be
made available in the guides, and maintained for as long as classic components
are supported by Ember.

Breaking down the public API of Glimmer components, we need to cover:

* Native class syntax, including the `constructor` and class fields
* Arguments
* Lifecycle hooks and properties
* Element modifiers

### Native class syntax

One of the benefits of native class syntax is that it is used outside of Ember,
so as time goes on we will be able to assume there is more general knowledge of
it, and provide links to documentation for it for users who are not familiar.
During this transitionary period though we should add a more thorough primer of
the syntax to our guides, and explicitly call out the differences between
classic class syntax and native class syntax, including:

* Usage of `constructor` in classes which _do not_ extend from classic classes.
  Otherwise, always use `init`. This will be tricky, because even when using
  native classes to extend from classic classes, you should still use `init`.

* Nuances of class fields - they run _after_ `super`, and _before_ user code.

* Benefits of class field initializers, and how they can be used to do much of
  the work that would otherwise be done in the `constructor` or `init`

* Expense of class fields - new objects and functions are created for every
  instance, so users should also be careful with them.

* What ends up on the prototype and what's on the instance
* How do property initializers work
* What's the default behavior of a constructor, as it pertains to `super()` and passing arguments
* The risks of anonymous classes and class factories (i.e, you get poor stack traces)
* How to implement "default values" in ES6
* The risks of writing decorators in user-land code (until TC39 stage 4)
* Methods vs arrow function member values
* Getting ahold of prototypes if/when you need them

### Arguments

For arguments, namespacing makes sense in general as an API choice and is common
in other frameworks (`props` in React, etc.). We should be sure to cover this
thoroughly for users who are used to classic components, but it shouldn't
require too much explaining.

Immutability will be a bigger sticking point in general, in particular the
inability to provide default argument values. This is easy enough to work around
using an `{{or}}` helper in templates:

```hbs
Hello, {{or @firstName "friend"}}!
```

Or a defaulting alias getter in the class:

```hbs
Hello, {{this.firstName}}!
```
```js
export default class Greeting extends GlimmerComponent {
  @tracked
  get firstName() {
    return this.args.firstName || 'friend';
  }
}
```

But does add a bit of boilerplate to components. Users will also have to be
careful when attempting to override these "defaults" in subclasses, since it is
not as simple as overriding a class field or property. We can guide users to
use template-only components to "partially applied" components when trying to
provide defaults in subclasses instead, leveraging the outer HTML semantics of
Glimmer components:

```hbs
<!-- components/button.hbs -->
<button class="button {{@type}}">
  <i class="icon {{@type}}"></i>
  {{yield}}
</button>
```
```hbs
<!-- component/success-button.hbs -->
<Button @type="success">{{yield}}</Button>
```
```hbs
<!-- component/danger-button.hbs -->
<Button @type="danger">{{yield}}</Button>
```

Or to explore possibilities using decorators, such as those in the
[sparkles-decorators](https://github.com/gossi/sparkles-decorators) addon.

#### Lifecycle hooks and properties

For users without framework experience, and users of other frameworks, lifecycle
hooks will be very minimal and fairly easy to understand. The lack of render
hooks may be the more difficult part to understand, and we'll have to lean on
the documentation for element modifiers and make sure that is _really_ excellent
to get the concepts there across.

For existing users, who are used to having a variety of hooks to choose from
when coordinating lifecycle events, the hooks may be fairly confusing. The
bullet points here are:

* Tracked properties/computed properties are the primary place to react to
  argument changes for any values that can be computed directly via getters.
  Ideally, most logic for derived state is conventionally in tracked or computed
  properties.
* `willDestroy` is the correct place for all teardown code, like in classic
  components.
* `didReceiveAttrs`, `willRender`, and `didRender` code should be extracted into
  functions which are then passed to `{{did-insert}}` and `{{did-update}}`
* `willDestroyElement` code should be extracted into functions which are then
  passed to `{{will-destroy}}`

Additionally, we should make sure we cover `isDestroying` and `isDestroyed`
pretty thoroughly. Users should know that they can (and probably should) check
these flags if they are doing anything asynchronous that could happen after the
component has been torn down.

#### Element modifiers

The render element modifiers will be the most different part of Glimmer
components for users. The strategy for teaching these is [included in their
RFC](https://github.com/emberjs/rfcs/blob/b9f390cb98f560d9cf876e3b1d67226fe0e1613b/text/0000-render-element-modifiers.md#how-we-teach-this),
but the key points are:

1. Teaching modifiers as a concept first, so users understand that what they're
   looking at is a _general_ tool, and that the render modifiers are an official
   addon provided by Ember.

2. Providing _lots_ of examples for various use cases, especially for users
   transitioning from classic components.

### Template-Only Components

[Template-only components](https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md)
are not strictly speaking related to the `GlimmerComponent` class proposed in
this RFC. However, conceptually they will probably be much easier to teach in
relation to Glimmer components, and will be an important part of Octane that we
should be sure to cover in depth. Additionally, the name of the optional feature
flag, `template-only-glimmer-components`, would make teaching the differences
between Glimmer components and template-only components much more difficult and
confusing.

As such, when writing the documentation for Glimmer components, we should ensure
that we cover template-only components in some detail as well.

## Drawbacks

### Multiple component APIs

One major drawback to Glimmer components is that they add a separate API for
components, meaning that for the forseeable future Ember users will likely
need to learn how to use both interchangeably. This introduces a fair amount of
mental overhead for users, but the benefits of Glimmer components and their
simplicity should make this less problematic.

### Heavy reliance on element modifiers

Glimmer components as proposed in this RFC are heavily reliant on element
modifiers for element manipulation. Element modifiers are a relatively new
concept in Ember, and as such will likely be unfamiliar to users and require
more learning than normal to get used to. This also means that users will not
be able to rely on well established patterns, and will have to develop new ones
for dealing with element manipulation.

### Lack of positional parameter support

Glimmer components are meant to cover _most_ common use cases, but are also
meant to be as minimal as possible. As such, they do _not_ have support for
positional parameters. Positional parameters are already unusable with any
component invoked using angle bracket syntax, but Glimmer components will also
not support them even when using curly bracket invocation.

The use cases for positional parameters are very uncommon, so it doesn't make
sense to add them to the main component class as an option. Instead, we should
make alternative component classes which support positional parameters, perhaps
exclusively (e.g. asserting if positional parameters are _not_ defined).

## Alternatives

### Render lifecycle hooks

The ommission of `didRender`,  `didUpdate`, `didInsertElement`,
`willDestroyElement`, and other render oriented hooks could be confusing to
users. These were staples of classic components, are common in other frameworks,
and make it easy for users to orient themselves when looking at a component
class. They are part of the "standard lifecycle" that make up many component
rendering systems, and make components easier to teach. They also allow users to
place most of their element manipulation logic inside their components, which is
a benefit for users who prefer lighter templates with less logic in them.

Element modifiers, by contrast, are a very new concept in Ember and will require
users to learn a fair amount more just to get started. They force more logic
into the template, and mean users have to look at the template to know if a
method is an element lifecycle hook or an internal method.

Adding the standard element lifecycle hooks would allow users to follow the
patterns they are currently used to, and that are used in other frameworks. If
added without `{{capture-element}}` or `bounds` (see below), they could be used
with `{{did-insert}}` and `{{will-destroy}}` for registering elements:

```hbs
<div {{did-render this.registerElement}}></div>
```
```js
class ExampleComponent extends Component {
  @action
  registerElement(element) {
    this.element = element;
  }

  didRender() {
    setupElement(this.element);
  }
}
```

### Add a `{{capture-element}}` modifier

This alternative would go hand in hand with having render lifecycle hooks.
Rather than relying solely on element modifiers for DOM manipulation, we could
add a modifier that allows users to specify elements which they want to
reference in their component class:

```hbs
<div {{capture-element this}}></div>
```
```js
class ExampleComponent extends Component {
  didRender() {
    setupElement(this.elements.main);
  }
}
```

This would have to take into account multiple usages, and variations of usages.
For instance, how would using `capture-element` in an `if` or `each` work?

```hbs
<div {{capture-element this}}>
  {{#if someBool}}
    <div {{capture-element this 'conditionalElement'}}>
  {{/if}}

  {{#each items as |item|}}
    <div {{capture-element this 'itemElements'}}>
  {{/each}}
</div>
```
```js
class ExampleComponent extends Component {
  didRender() {
    this.elements.main; // the main outer div
    this.elements.conditionalElement; // the conditional element
    this.elements.itemElements; // An array of all the items that are rendered
  }
}
```

This would also mean a fair amount of additional code would need to be added for
reacting to changes in the DOM compared to `{{did-insert}}` and
`{{will-destroy}}`. For instance, if the case of conditionally captured element,
additional validation code will have to exist in `didRender`:

```js
class ExampleComponent extends Component {
  didRender() {
    let { conditionalElement } = this.elements;

    if (conditionalElement) {
      this._previousConditionalElement = conditionalElement;

      setupPlugin(conditionalElement);
    } else {
      teardownPlugin(this._previousConditionalElement);
    }
  }
}
```

This problem is compounded in collections, where any number of elements may be
added or removed.

### Add `element` or `bounds` on the component

We could attempt to add DOM references back to the component, instead of adding
the `{{did-insert}}` and `{{will-destroy}}` modifiers. This would require us to
handle a number of edge-cases (0 element, multi element), and would open up some
intimate details of the Glimmer VM to user code (`bounds` nodes). If in the
future the VM wanted to change these details, it could be problematic.

Element modifiers are less invasive, more declarative, and handle a lot of
boilerplate type code (checking to see if an element exists, for instance).
However, they are also very new to Ember users as a concept (aside from
`{{action}}`) and could be difficult to teach.

### `init` vs `constructor`

Recent changes to the way native classes extend from `EmberObject` made it so
users have to use `init` instead of the `constructor`. This is a pretty
universal caveat currently, so it's fairly teachable - there is a `constructor`,
but use `init` instead (see the [Native Class Constructor
RFC](https://github.com/emberjs/rfcs/blob/master/text/0337-native-class-constructor-update.md))

With the current design of Glimmer components, we are introducing the first base
class which doesn't extend from `EmberObject`, and requires users to use
`constructor` instead. This could be confusing, and will have to be _very_
clearly documented at the least.

We could alternatively include an `init` hook, or have both. This would allow
users to follow one rule for object initialization, but would also lock us into
the supporting the `init` hook for the forseeable future.

### No owner in constructor

Sparkles components do not provide access to the owner or injections in the
constructor, though it is a requested feature. Instead of passing the owner to
the constructor, we could add a `willCreate` or `init` hook which allows users
to setup the instance after the owner has been assigned.

Alternatively, the exact method by which the owner is passed to the constructor
can be changed (on an object vs directly) or all injections could be passed,
enabling typed injections.

## Appendix: Lifecycle Hook Audit

### [ember-paper](https://miguelcobain.github.io/ember-paper/)

#### `didUpdateAttrs`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-did-update-attrs-1]|Setup component state based on incoming arguments|Tracked properties|
|[link][ep-did-update-attrs-2]|Setup component state based on incoming arguments|Tracked properties|
|[link][ep-did-update-attrs-3]|Element setup/update code based on incoming arguments|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-update-attrs-4]|Element setup/update code based on incoming arguments|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-update-attrs-5]|Element setup/update code based on incoming arguments|`{{did-insert}}` and `{{did-update}}`|

[ep-did-update-attrs-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete-trigger.js#L37
[ep-did-update-attrs-2]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-tile.js#L41
[ep-did-update-attrs-3]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L69
[ep-did-update-attrs-4]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L75
[ep-did-update-attrs-5]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L65

#### `didReceiveAttrs`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-did-receive-attrs-1]|Setup component state based on incoming arguments|Tracked properties and `constructor`|
|[link][ep-did-receive-attrs-2]|Setup component state based on incoming arguments|Tracked properties and `constructor`|
|[link][ep-did-receive-attrs-3]|Setup component state based on incoming arguments, validate incoming arguments|Tracked properties and `constructor`|
|[link][ep-did-receive-attrs-4]|Animate based on incoming arguments|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-receive-attrs-5]|Trigger validations|Tracked properties and `constructor`|
|[link][ep-did-receive-attrs-6]|Element update code and sending an action|Tracked properties and `{{did-insert}}` with args|
|[link][ep-did-receive-attrs-7]|Updating logic and element update code|Tracked properties and `{{did-insert}}` with args|

[ep-did-receive-attrs-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete.js#L93
[ep-did-receive-attrs-2]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-card-actions.js#L17
[ep-did-receive-attrs-3]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L76
[ep-did-receive-attrs-4]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L126
[ep-did-receive-attrs-5]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select.js#L40
[ep-did-receive-attrs-6]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L55
[ep-did-receive-attrs-7]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L131

#### `willInsertElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-will-insert-element-1]|Container setup code on initialization|`{{did-insert}}`|

[ep-will-insert-element-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L91

#### `didInsertElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-did-insert-element-1]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-2]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-3]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-4]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-5]|Set focus after initial render|`{{did-insert}}`|
|[link][ep-did-insert-element-6]|Setup animation based on arguments|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-7]|Set focus after initial render|`{{did-insert}}`|
|[link][ep-did-insert-element-8]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-9]|Element setup code on initialization (partially based on args)|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-10]|Element setup code on initialization|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-11]|Element setup code on initialization|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-12]|Measure element on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-13]|Element setup code on initialization|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-14]|Element setup code on initialization|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-insert-element-15]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-16]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-17]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-18]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-19]|Measure element on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-20]|Element setup code on initialization|`{{did-insert}}`|
|[link][ep-did-insert-element-21]|Element animation on setup|`{{did-insert}}`|

[ep-did-insert-element-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L39
[ep-did-insert-element-2]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L64
[ep-did-insert-element-3]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L52
[ep-did-insert-element-4]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L89
[ep-did-insert-element-5]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-menu-content-inner.js#L26
[ep-did-insert-element-6]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L118
[ep-did-insert-element-7]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-menu-inner.js#L29
[ep-did-insert-element-8]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-options.js#L14
[ep-did-insert-element-9]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L48
[ep-did-insert-element-10]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L62
[ep-did-insert-element-11]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L56
[ep-did-insert-element-12]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L44
[ep-did-insert-element-13]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L71
[ep-did-insert-element-14]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L58
[ep-did-insert-element-15]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L96
[ep-did-insert-element-16]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip-inner.js#L24
[ep-did-insert-element-17]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L67
[ep-did-insert-element-18]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L8
[ep-did-insert-element-19]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L8
[ep-did-insert-element-20]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/ripple-mixin.js#L8
[ep-did-insert-element-21]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L8

#### `willDestroyElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-will-destroy-element-1]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-2]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-3]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-4]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-5]|Teardown animations on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-6]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-7]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-8]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-9]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-10]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-11]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-12]|Element teardown code on destruction|`{{will-destroy}}`|
|[link][ep-will-destroy-element-13]|Unregister child class from parent|`willDestroy`|
|[link][ep-will-destroy-element-14]|Teardown animations on destruction|`{{will-destroy}}`|

[ep-will-destroy-element-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L51
[ep-will-destroy-element-2]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L79
[ep-will-destroy-element-3]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L64
[ep-will-destroy-element-4]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L104
[ep-will-destroy-element-5]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L153
[ep-will-destroy-element-6]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L81
[ep-will-destroy-element-7]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L70
[ep-will-destroy-element-8]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L102
[ep-will-destroy-element-9]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L77
[ep-will-destroy-element-10]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L118
[ep-will-destroy-element-11]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L110
[ep-will-destroy-element-12]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L17
[ep-will-destroy-element-13]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/child-mixin.js#L30
[ep-will-destroy-element-14]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L30

#### `didUpdate`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-did-update-1]|Reapply styles based on changes to args|`{{did-insert}}` and `{{did-update}}`|

[ep-did-update-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L57

#### `didRender`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][ep-did-render-1]|Resize component based on changes to args|`{{did-insert}}` and `{{did-update}}`, or [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)|
|[link][ep-did-render-2]|Animate component based on changes to arguments|`{{did-insert}}` and `{{did-update}}`|
|[link][ep-did-render-3]|Set `elementDidRender` boolean on instance|`{{did-insert}}`|
|[link][ep-did-render-4]|Measure component on render|`{{did-insert}}` and `{{did-update}}`, or [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)|
|[link][ep-did-render-5]|Resize component based on changes to size|`{{did-insert}}` with args, or [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)|
|[link][ep-did-render-6]|Measure element sizes based on changes to args|`{{did-insert}}` with args|

[ep-did-render-1]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L97
[ep-did-render-2]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial-action-action.js#L34
[ep-did-render-3]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial.js#L32
[ep-did-render-4]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L52
[ep-did-render-5]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L96
[ep-did-render-6]: https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L156

### [ember-google-maps](https://github.com/sandydoo/ember-google-maps)

#### `didUpdateAttrs`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][egm-did-update-attrs-1]|Synchronize options with Google maps|Refactor to use actions to modify data, or use a modifier|
|[link][egm-did-update-attrs-2]|Update component based on changes to arguments|Refactor to use actions to modify data, or use a modifier|

[egm-did-update-attrs-1]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map.js#L103
[egm-did-update-attrs-2]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L54

#### `didReceiveAttrs`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][egm-did-receive-attrs-1]|Register component with parent|`constructor`|

[egm-did-receive-attrs-1]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L20

#### `didInsertElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][egm-did-insert-element-1]|Register component with parent and initialize|`constructor` and parent component `{{did-insert}}`|

[egm-did-insert-element-1]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L46

#### `willDestroyElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][egm-will-destroy-element-1]|Element teardown code on destruction (and potentially destruction of parent)|`willDestroy` and parent component `{{will-destroy}}`|
|[link][egm-will-destroy-element-2]|Unregister element from parent|`willDestroy` and parent component `{{will-destroy}}`|
|[link][egm-will-destroy-element-3]|Teardown class state|`willDestroy`|
|[link][egm-will-destroy-element-4]|Teardown class state|`willDestroy`|

[egm-will-destroy-element-1]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L60
[egm-will-destroy-element-2]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L26
[egm-will-destroy-element-3]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/process-options.js#L26
[egm-will-destroy-element-4]: https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/register-events.js#L26

#### `didRender`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][egm-did-render-1]|Detect changes to subtree and reposition overlay|[MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or custom component that can trigger actions on subtree rerenders|

[egm-did-render-1]: https://github.com/sandydoo/ember-google-maps/blob/master/addon/templates/components/g-map/overlay.hbs#L6

### [liquid-fire](https://github.com/ember-animation/liquid-fire)

#### `didReceiveAttrs`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][lf-did-receive-attrs-1]|Capture argument as component state|`constructor`|
|[link][lf-did-receive-attrs-2]|Capture argument as component state|`constructor`|
|[link][lf-did-receive-attrs-3]|Run update code for changing versions (and animating)|`constructor` and tracked properties or element modifiers|

[lf-did-receive-attrs-1]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/illiquid-model.js#L7
[lf-did-receive-attrs-2]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-outlet.js#L23
[lf-did-receive-attrs-3]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-versions.js#L15

#### `didInsertElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][lf-did-insert-element-1]|Trigger animation|`{{did-insert}}`|
|[link][lf-did-insert-element-2]|Set did render|`{{did-insert}}`|
|[link][lf-did-insert-element-3]|Element setup code on insertion|`{{did-insert}}`|
|[link][lf-did-insert-element-4]|Element setup code on insertion|`{{did-insert}}`|
|[link][lf-did-insert-element-5]|Pause animations on insertion (continue later via action)|`{{did-insert}}`|

[lf-did-insert-element-1]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-child.js#L12
[lf-did-insert-element-2]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-container.js#L44
[lf-did-insert-element-3]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L15
[lf-did-insert-element-4]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-spacer.js#L11
[lf-did-insert-element-5]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-sync.js#L8

#### `willDestroyElement`

|Usage|Use Case|Converts To|
|-----|--------|-----------|
|[link][lf-will-destroy-element-1]|Element teardown code on destruction|`{{will-destroy}}`|

[lf-will-destroy-element-1]: https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L37


---

---
stage: recommended
start-date: 2019-07-12T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/418
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/30
---

# Deprecate Route render APIs

## Summary

This RFC proposses the deprecation of [`Route#render`](https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=render), [`Route#renderTemplate`](https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=renderTemplate) and named `{{outlet}}` APIs. The following deprecation message will be emitted upon usage of `render` or `renderTemplate`:

```
The usage of `renderTemplate` is deprecated. Please see the following deprecation guide to migrate.
```
and

```
The usage of `render` is deprecated. Please see the following deprecation guide to migrate.
```

The following will be compile time deprecation for named outlets:

```
Please refactor `{{outlet <NAME>}}` to a component <SOURCE_INFO>.
```

## Motivation

These APIs are largely holdovers from a time where components where not as prominent in your typical Ember application. While they are still documented, these APIs created an interesting coupling between the `Route` and the template. These APIs are also prone to breaking conventional naming conventions, which can lead to confusion for developers. Another issue is that it is unclear how something like this works with route based tree shaking, as there are no strong conventions or direct imports as to what is actually being used.

## Transition Path

The migration plan here is going to be somewhat situational based on the UI that was being constructed. For cases where named outlets were being used it is likely that they should just be moved to components. For cases where you were escaping the existing DOM hierarchy to render a template somewhere else in the DOM, one should use the built-in [`{{in-element}}`](https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md) helper or an addon like [ember-elsewhere](https://github.com/ef4/ember-elsewhere). Below are some example of how a migration would look.

__Migrating Named Outlets__

Given:

```js
Ember.Route.extend({
  // ...

  renderTemplate() {
    this.render('cart', {
      into: 'checkout',
      outlet: 'cart',
      controller: 'cart'
    })
  }
})
```

```hbs
{{! checkout.hbs}}
<section id="items">
  {{outlet}}
</section>
<aside>
  {{outlet "cart"}}
</aside>
```

This would tell Ember to render `cart.hbs` into `checkout.hbs` at the `{{outlet "cart"}}` and use the `cart` controller to back the `cart.hbs` template. This is pretty confusing pattern and creates this implicit coupling that is spread between the `Route` and template.

Luckily, we can express this entire concept with components.

```hbs
{{! checkout.hbs}}
<section id="items">
  {{outlet}}
</section>
<aside>
  <Cart />
</aside>
```

In the event you were using `model` to derive what to render, you can us the `{{component}}` helper to dynamically render a component.

__Migrating Hiearchy Escaping__

Given:

```hbs
{{! app/templates/authenticated.hbs}}

<nav>
  <h1>ACME Corp.</h1>
  <section>
    {{outlet "account"}}
  </section>
</nav>

<section id="content">
  {{outlet}}
</section>
```

```hbs
{{! app/templates/account.hbs }}
{{#link-to 'account'}}
  <img src="{{this.img}}" alt="{{this.name}} />
{{/link-to}}
```

```js
// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  // ...
  user: service('user'),
  renderTemplate() {
    if (this.user.isLoggedIn) {
      this.render('account', {
        into: 'authenticated',
        outlet: 'account',
        controller: 'account'
      });
    } else {
      this.transitionTo('login')
    }
  }
});
```

One way this could be migrated is like the following:

```hbs
{{! app/templates/authenticated.hbs}}

<nav>
  <h1>ACME Corp.</h1>
  <section id="account-placeholder"></section>
</nav>

<section id="content">
  {{outlet}}
</section>
```

```hbs
{{! app/templates/authenticated/campaigns.hbs }}

{{outlet}}

{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    <img src="{{this.account.img}}" alt="{{this.account.name}} />
  {{/link-to}}
{{/in-element}}
```

```js
// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
```

```js
// app/controller/authenticated/campaigns.js
import Route from '@ember/route';
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { inject as controller } from '@ember/controller';

export default Controller.extend({
  //...
  account: controller('account')
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
```

If you want to do this with components you could do the same thing as the following:

```hbs
{{! app/templates/authenticated.hbs}}

<nav>
  <h1>ACME Corp.</h1>
  <section id="account-placeholder"></section>
</nav>

<section id="content">
  {{outlet}}
</section>
```

```hbs
{{! app/templates/authenticated/campaigns.hbs }}
{{outlet}}

<UserAccount />
```

```hbs
{{! app/templates/components/user-account.hbs }}
{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    <img src="{{this.account.img}}" alt="{{this.account.name}} />
  {{/link-to}}
{{/in-element}}
```

```js
// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
```

```js
// app/components/user-account.js
import Component from '@ember/route';
import { inject as controller } from '@ember/controller';

export default Component.extend({
  // ...
  account: controller('account'),
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
```

# How We Teach This

These APIs not been a mainline API for quite some time now. The guides briefly mention this functionality. In those cases we should mirgate the guides should link to the `{{in-element}}` documentation and the component documentation. The above "Transition Path" will serve as the deprecation guide.

# Role Out Plan

Prior to adding the deprecation we must first do the following items

* [ ] The `{{in-element}}` helper implementation remains incomplete. It should be completed.
  * [ ] The [small changes](https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md#small-proposed-changes) section of the `{{in-element}}` RFC needs to be implemented. Specifically the helper should "replace all the content of the destination".
  * [ ] The `{{in-element}}` helper should be documented in the [API docs](https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers).
  * [ ] Adding `{{in-element}}` usage to the guides can be considered.

## Drawbacks

The drawback of this is that it is churn for applications that are relying heavily of these imperative APIs to construct their UI. They will need to encapsulate and use the existing declarative APIs.

## Alternatives

No real alternatives as we want to move away from these style of imperative APIs in favor of declarative ones.

## Unresolved questions

Optional, but suggested for first drafts. What parts of the design are still
TBD?



---

---
stage: recommended
start-date: 2019-07-12T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/421
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/5
---

# Deprecate Application Controller Router Properties

## Summary

This RFC proposes the deprecation of `ApplicationController#currentPath` and `ApplicationController#currentRouteName`.

## Motivation

These APIs are no longer needed as the `RouterService` now has `RouterService#currentPath` and `RouterService#currentRouteName`.
These fields are only ever present on the application controller which is a weird special casing that we would like to remove.
Additionally, it's likely that there are very few if any consumers of this API as it is not documented.

## Transition Path

If you are reliant on `ApplicationController#currentPath` and `ApplicationController#currentRouteName` you can get the same functionality from the `RouterService` to migrate, inject the `RouterService` and read the `currentRouteName` or `currentPath` off of it.

Before:

```js
// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.currentRouteName
        })
      });
    }
  }
})
```

After:

```js
// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),
  router: service('router'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.router.currentRouteName
        })
      });
    }
  }
})
```

## How We Teach This

There is likely very few consumers of this functionality and migration path is covered by existing documentation.

## Drawbacks

This may introduce churn that we are not aware of.

## Alternatives

No real alternative other than keep setting the properties.

## Unresolved questions

Optional, but suggested for first drafts. What parts of the design are still
TBD?


---

---
stage: recommended
start-date: 2018-12-21T00:00:00.000Z
release-date: # FIXME
release-versions:
teams:
  - learning
  - steering
prs:
  accepted: https://github.com/emberjs/rfcs/pull/425
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/35
---

# Website Redesign

## Summary

The Ember homepage has been the same for a number of years, and while it's served us well in the past, it's been somewhat stale for a long time. For people who aren’t involved in the day-to-day of Ember development, it’s easy  to miss just how well the framework has kept up over the years. This redesign aims to modernize, update and improve all things website, so that the impression we give the general public matches reality.

Tremendous thank you to our friends at [EmberMap](http://www.embermap.com) for stepping up to fund and do the lion's share of the work, organizing and cat-herding on this one. The key folks involved in this throughout the lifecycle of our redesign efforts are @wycats, @tomdale, @wifelette, @samselikoff, @ryanto, @melsumner and @jenweber, with lots of other folks at intervals along the way.

## Motivation

Right now a developer visiting emberjs.com is presented with light information about the framework, but little about what it’s like to use modern Ember. The homepage is a very different experience from the programming model, the things we say and do in other RFCs, forward-looking conference talks and what it’s like to actively develop an Ember app in 2018. The design also hasn't changed significantly in years, so someone who comes back after two or three years away gets the impression nothing has changed, even if we've made slow and subtle updates to the copy, and dramatic improvements to Ember itself.

The primary goal of this redesign is to make our website match reality. Some of the secondary goals include reorganizing information on internal pages for generally better information architecture, improving accessibility, improving the discoverability of important project resources, and looking overall modern and current.


## Detailed design

A visual redesign is a bit different than most of the Code RFCs, so showing becomes more important than explaining. What follows is the proposed design  (comp) for the redesign of the primary homepage, and the intent is to approve the RFC with this, and then keep working on the dozens of internal pages in the general Ember project under this umbrella and using this design language.

Like any good design project, we expect changes along the way, but that these comps present the primary thrust and look/feel of the things that have not yet been designed.

![Comp 1](/images/website_1.png)

Much of the copy is placeholder, but much of it represents concrete thought. A lot of that content was gleaned from a survey of about 200 of our most active users, who told us that they most value *clear best practices* and *productivity*.

![Survey Results](/images/survey_results.png)

[A significantly detailed write up of the survey results can be found here](/images/survey_results_analysis.pdf). Various team members reviewed the results, and then worked together [to outline copy for the website based on the feedback](/images/EmberJS_Homepage_Outline.pdf). The goal was to reach consensus on what the homepage should communicate, disregarding design, aesthetic, and code.

The hierarchy of the first comp that resulted from that outline was deliberate—for example, the Social Proof section comes first right after the Hero, since it’s the next most important section. This hierarchy will continue to be apparent in the final design. The general instructions provided to the designer was that a tone of "friendly professional" was ideal, building on Ember's deliberately optimistic and friendly look and feel (and mascot!) up until now.

There are still missing pieces in the current mockup—the final code examples, images used in the Community section, and a few other graphics and copy odds and ends—but these ought be considered implementation details for now in the interest of involving the community earlier rather than later.

## Drawbacks

It's clear that most community members agree that the website is out of date and needs a refresh. That said, design is highly subjective and really easy to endlessly bikeshed over. The primary *risk* of this redesign is that we get too lost in the weeds (with comments or objections like "I don't like that color purple," *literal* bikeshedding). Visual design is particularly vulnerable to that trap.

Change is also just difficult in general, and there will be a brief period of potentially frustrating transition where people look for things in places they're accustomed to, but don't find them there (see: improved IA). We expect this to be a brief irritation though, and that the new overall experience will be improved for new and old users alike.

To mitigate, we should be very clear that comments ought be structural, actionable and detailed. "I just don't like that" or "I'd prefer a different color" are unlikely to be useful; the first proposed designs have already been through several rounds like that and the comp here represents a palette and structure that improves upon the existing broad strokes, without being too dramatic a shift. It's moderate, in a way that ought help this go smoothly.

Comments like "have you considered that X would be more accessible Y way" and "there's an inconsistency between these two things" could be *very* helpful and potentially point out things we've missed. Questions like "X used to be on the homepage but isn't anymore, can you explain the motivation and where will it go?" could be thought-provoking and clarifying.

## Alternatives

Redesigning the Ember website has been a goal for several years now, always with the intent to get to a solid homepage comp and then share with the community pre-implementation for input and buy-in. There have been several attempts like this one that have failed along the way for various reasons. This is the first redesign that has achieved both internal consent *and* which hasn't fizzled out and died along the way, and represents the learnings of the failed previous attempts.

The alternative would be to *not* update the site, but that's not really an alternative. The website is our most public face, and every day that it doesn't represent *reality* is a day we're likely losing potential new Ember developers and users. The older site also makes it difficult for our current users to promote their technology choice, and to get their team members on board. We aim to improve all of the above and more.

## Unresolved questions

Even once more designs are completed, the new site will need to be implemented piece by piece, in a transitional way. The recent updates made to the current site by the Ember Learning Team prove that we're capable of digging in together and doing the incremental work to get us to larger, sweeping changes. That recent work gives us the confidence that we can accomplish this in an open, community-way, with help from new and old users alike.

The exact *plan* for this will have to be developed next, hence, unresolved.

## Other

Some areas of the primary comp came with more detailed design views. Those can be seen here:

* [Header Dropdowns](/images/website_2_header_dropdown.png)
* [URL Examples](/images/website_3_url_examples.png)
* [Button UI](/images/website_4-button_ui.png)
* [Scrolled Nav, Concept 1](/images/website_5_scrolled_nav.png)
* [Scrolled Nav, Concept 2](/images/website_6_nav_alt.png)
* [Pointer](/images/website_7_pointer.png)


---

---
stage: recommended
start-date: 2018-01-13T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/431
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/29
---

# Restructuring the Guides Table of Contents

## Summary

As our favorite framework has grown and changed a lot over the past few years, so have our [Ember.js Guides](https://guides.emberjs.com)! This project aims to use the excellent work that has been done by hundreds of contributors and arrange it in a way that provides a natural learning flow for today’s Ember.js developers.

## Motivation

With Octane coming down the line, and an influx of fresh attention, it’s more important than ever to consider Ember's overall learning experience. It's time for a shift. The current structure and flow of the guides reflects the past, not the present experience for Ember. It’s time to fix that.

When the Guides were originally written, things like object-oriented programming in JavaScript, components, routing, and Single-Page Applications ([SPA](https://en.wikipedia.org/wiki/Single-page_application)) in general were new ideas. For example, they start by teaching the “Ember Objects” programming concept, necessary background information at the time. It would have been an unfamiliar pattern at the time. Now, the learning hierarchy needs have shifted from “learn these unique web development concepts” to “learn how familiar pieces fit together so you can build great apps quickly.”

## Detailed design

The focus of this RFC is not to write new content, but make better use of what is already there by presenting it in a different order. We aim to rearrange the table of contents without breaking any URLs, with refactors necessary to fix the transitions between topics, and with the minimal _new_ content needed to teach Octane. We take care to not make it look like there is “more to learn.”

The overall learning strategy is to establish a common core of sequential knowledge, and then later topics can be read standalone, skipping around. What this means is that if beginners read through to routes, they could skip around the topics lower down the chain successfully.

Finally, it is important to acknowlegde that the Guides are intended to represent the "Happy Path" of using Ember. It is not possible to have something that is a perfect fit for everyone's app needs, nor should they cover our entire API surface.

### Process and preparation

This Table of Contents plan was developed over the course of many months, meetings, and writing sessions. It includes input from many people in the community. Here are the sources of inspiration, information, and planning:

- Chris Garrett's ([@pzuraq](https://github.com/pzuraq)) 2018 Roadmap Blog Post, [Ember as a Component-Service Framework](https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1)
- My own Roadmap blog post reflections, [Be loud and be ready](https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8)
- Extensive discussion in Ember Learning Team Meetings, which are held weekly and open to the public
- The [2018 Roadmap RFC](https://github.com/emberjs/rfcs/blob/26c4d83fb66568e1087a05818fb39a307ebf8da8/text/0000-roadmap-2018.md) by [Tom Dale](https://github.com/tomdale)
- The Octane Strike Team meetings and followup conversations
- Hands-on writing of a mini guide for Octane
- Ember.js Framework Core Team meetings
- A [Twitter poll](https://twitter.com/jwwweber/status/1081352702083452928), "Name two things you think the guides should do well/better"
- Discussion on Discord of the initial Table of Contents draft with some key contributors and content creators
- [Dan Monroe](https://github.com/cah-danmonroe)'s trailblazing work to [convert the Guides to use Angle Brackets](https://github.com/ember-learn/guides-source/pull/357)
- Countless hours of Q&A on Stack Overflow and Discord
- Experience training new Ember developers in-house
- Public Ember 101 workshops run in Boston, Massachusetts, USA
- Studying the guides and tutorials of other JavaScript libraries
- The successful restructure and rewrite of the [Ember CLI Guides](https://cli.emberjs.com) (a far more drastic project than this RFC aims to be)
- Attempting to reorder the Guides in a branch, as an experiment

We are confident that this is possible thanks to the incredible response and effort shared by the community for the CLI Guides work.

### Audience

There are many different types of documentation within Ember, so it's important to identify a target audience for each, in order to guide decision making and provide a learning flow that grows with the reader.

There are 3 main audiences for our resources:

1. newcomers
2. upgraders
3. specific-answer-seekers

A huge challenge within the Guides is that they somewhat serve all three, and we'd like to have cleaner distinctions between sections and resources. For example, the Quickstart and Tutorials are distinct resources from the rest of the guides, and they clearly target new users. Upgraders could be served by adding 1 section to the guides as they are today. Specific-answer-seekers must lean on both the API docs and the Guides to find what they need.

We propose that the Guides should focus on the following audience - newcomers who have done the tutorial, and want to build real apps. It will show the "happy path" and how the parts of Ember interact to form good, useful patterns, in a way that would be out of scope for an API documentation block.

Along these lines, anything that can be offloaded to the API docs, should. For example, the Guides should show using a Computed Property/tracked property to solve a problem in a Component or Controller. They should not get into the depths of syntax option for one aspect of an API surface, but rather link to them.

We also have the current hypothesis to inform intro sections, as suggested by [Mike North](https://github.com/mike-north): "People want to get the smallest understandable atom that they can jump in on." This will help us refactor how we present different topics.

### Table of Contents

The following Table of Contents will be applied iteratively over the course of many months. It is not considered a blocker for the release of the Octane edition. The quick wins and urgent Octane refactors will be applied ASAP, and are described in the Implementation section of this RFC. Justification for the ordering is provided following the topics list.

**Core Concepts**

- What is Ember?
- Getting Started
- Anatomy of an app (future new content)

**Fundamentals**

- Templating
- Working with JavaScript
- Components
- Routing (includes Routes, Router, and Controllers)
- State management (aka computed properties)
- Services

**Leveling up**

- Data management (future new content that references separate Ember Data guides)
- Addons and dependencies
- Testing
- Configuration
- Deploying
- Upgrading (will contain links to upgrade resources, Editions, Deprecations)
- Developer Tools (currently named Ember Inspector)
- Reference
    - Accessibility
    - Syntax conversion guide

### Topic naming

As much as possible, we aim for the topics to be named after their general web development concepts, and not the Ember-specific implementation of them.

### Logic for ordering and grouping

In this section, we will cover why this order and grouping is being proposed.

#### Groupings

Groupings are added for the benefit of new learners. They break up the content visually and gives them a clue about which sections to pay the most attention to.

Just because something is included in "Leveling up" does not automatically make it an "advanced" topic. The main logic for the division between "Fundamentals" and "Leveling up" are the following tests: Can someone ignore this section and still use Ember effectively? Can it be learned in any order if someone knows the basics? If so, it goes in "Leveling up."

As we look at each topic, we also ask: Does someone need prior knowledge of another topic in order to understand this section? Whatever those "prior knowledge" topics are, we add them as Fundamentals.

#### Anatomy of an app

The most common points of confusion for new devs have become things like “how does everything fit together? Why can't I call a sibling component's actions directly?” The faster we can get the “Mental Model” of Ember across, the better. The Super Rentals tutorial covers the bases well for using the CLI and adding basic interactions. Anecdotally, thanks to the Tutorial, it seems that the missing pieces in the guides are mostly architectural. "Anatomy of an app" is the main area of new content, where we attempt to give an overview of the topics a web developer has to care about, the parts of Ember that address them, and the file structure. Current Ember developers will reference this section while learning new features.

#### Templates & Template helpers

Templates come before components, since it is possible for someone to not know JavaScript/Handlebars and still contribute to Ember apps. For example, designers could effectively work in only templates, using plain HTML. To make Templates work as the opening topic, additions are necessary in the introduction.

Template Syntax will cover Ember Handlebars basics and built-in features like `{{#each}}` and `{{#if}}`. It will take care to make it clear that Ember uses its own implementation of Handlebars. It will clearly differentiate between control structures (loops and conditionals), inline vs block styles, component invocation, and helpers.

Template helpers are split out and moved to "Leveling Up" because developers do not need to use them to write basic Ember apps (they are not a prerequisite). This section includes writing custom Helpers and using built-in helpers like `get`, `let`, and `array`. Although helpers themselves are not considered a difficult topic, they are used most often when developers understand their app's architecture and the flow of data. Also, template helpers have more in common with JavaScript functions than concerns relating to layout and data flow.

Lastly, another reason to split out Template syntax from Template Helpers is because the syntax section is expected to expand with the addition of Octane content.

An alternative to this split is to reduce the documentation of helpers themselves in the Guides, and lean on the API docs instead, however great care should be taken in removing documentation. Without a strong case for it, we lean towards leaving them in the Guides.

#### Working with JavaScript

A common concern of new learners is, what is JavaScript and what is special to Ember? The Working with JavaScript section incorporates the existing JavaScript Primer and new content that will help make the distinctions clearer. Ember.js has proactively adopted JavaScript APIs as they become available, such as Classes and Decorators, in some cases before the larger JavaScript community becomes familiar with them. Key people in the Ember Community are also involved in the development of JavaScript itself through TC39. To an extent, it is our responsibility to at least suggest to developers which JavaScript concepts they must learn in order to feel comfortable with Ember.

#### Components

Components will need the most refactor work and new content for Octane, so here’s the subtopic breakdown:

- Creating a component (includes Component Types post-Octane)
- Displaying data in a Template
- Adding actions
- Nesting components (includes suggestions of when to break things into components)
- Passing arguments
- Using computed properties (extremely basic example, link to the Computed Property section)
- Working with arrays of data
- Lifecycle hooks

#### State management

The State Management section is important because whether "computed properties" are available in their current state or as `@tracked` Decorators, the nuances must be within easy reach for existing Ember developers and future learners. We rename this topic in alignment with the Topic Naming convention mentioned above.

#### Routing

This RFC proposes grouping Routes, Routing, and Controllers under the same topic heading.

If that sounds like a lot, it's because it is. "Routing" is a responsibility that is divided into many pieces:

- the route declarations in `router.js`, including dynamic segments
- the Handlebars route template, the middleman for passing data from the controller to components
- the Route JavaScript file, which contains the model hook for fetching data and Transition rules in the form of hooks. The model hook receives the query params that are defined in the Controller
- Controllers, which hold the results of the model hook, actions and other attributes that need to be passed to child components, and query param definitions.

Common beginner mistakes are to define actions and attributes in a Route and try to pass them to components, plus attempts to access the result of the model hook in functions in the route JavaScript. Beginners think of Routes as "special components" and are surprised by their limitations. This becomes a long-lived pain point if developers hand off the controller's responsibilities to Components.

For better or for worse, there's a mental-model codependency between Routes and Controllers that is unlikely to change in the near term. Our Guides should reflect the best possible learning experience for today's constraints, rather than be a reflection of the codebase architecture. By grouping these topics together, we have an opportunity to heal confusion over Controllers and help new developers avoid unexpected pitfalls.

Based on initial feedback, this grouping is the most divisive part of the proposal. This grouping is informed by reflecting on how one might teach Controllers to a new developer, while working together in person. In order to reach consensus, any objections to the grouping should suggest solutions that include an explanation of how and where one would teach Routes, actions, routing with Query params, and passing arguments to the model hook.

#### Services

The Services documentation is currently sparse, but it is included in "Fundamentals" for two reasons. First, an understanding of Services is a prerequisite for understanding Ember Data's store service. Second, the Router service is not well known by new developers, as it is solely found in the API documentation, and it provides behavior that new developers expect to have. Third, the popularity of the mental model of Ember as a Components-Services framework is a signal that this may be an effective teaching strategy.

#### Ember Data

Ember Data will be gradually extracted into its own Guides. 2-3 years ago, there was a push to provide better official documentation of Ember Data, as a "first class citizen." It was intermingled with the rest of the Ember.js Guides as a result. We will continue to treat Ember Data as a first class citizen, yet with improved separation of concerns similar to the approach to Ember CLI Guides. Ultimately, the content in other Guides topics will be refactored to show both Ember Data and non-Ember Data approaches, in an effort to lower the perceived cognitive overhead of Ember.

This change reflects the overall drive of the JavaScript Ecosystem towards interchangeable, composable parts.

The Ember Data team is especially requested to review this shift and provide feedback.

#### Deploying and Upgrading

These sections have some existing content. They will aim to _not_ duplicate the contents of the CLI Guides, but rather reference content found there. They are included in the top-level Table of Contents for two readons, discoverability and to showcase Ember's strengths

#### Ember Inspector

Although the Ember.js Guides are versioned, the Inspector Guides do not need to follow the same versioning strategy. It would be reasonable to separate them out into their own, unversioned Guides. However the content is quite stable and therefore lower priority than other refactors.

The Ember Inspector team is requested to consider whether naming the section "Debugging" would improve discoverability of Ember Inspector for new developers, and whether the eventual unversioned separation aligns with expected technical development.

#### Unchanged topics

Configuration, Testing, and Addons & Dependencies remain unchanged in their approach. There are plans underway to make the Tutorial an unversioned, separate resource. That is outside the scope of this RFC, however this Table of Contents assumes that work comes to completion.

#### Removals

Notably missing is "Ember Object Model." This is on purpose. It will be pulled into other sections, in a “show, don’t tell” kind of approach. Also removed is "Application Concerns," which are separated into their appropriate alternate subtopics.

### Why doesn’t this RFC include rewriting content?

Individual pages have already been refactored over the past two years by many contributors. Examples include the Ember Objects page, Controllers, using third party libraries, and explanations of data management. Many of the pain points that current Ember devs remember from their early days have been fixed. For example, it’s clear that Ember Data/JSONAPI aren’t mandatory, that you *can* use things like fetch, that Computed Properties need to be consumed for them to fire… we’re in a pretty good place! Those improvements of individual topics may continue without the need for an RFC.

If we choose a good structure for the Table of Contents, it will make it much easier to write/rewrite individual sections.

It is also important to note here that that Ember does not have a foundation or funding arm, so although it would be great to have a dedicated writer tackle this from the ground up, we must choose an approach that would be realistic for a group of volunteers to achieve.

### Technical approach

Thanks to Chris Manson’s work ([@real_ate aka @mansona](https://github.com/mansona)) on the Guides app architecture, we can move content around while preserving existing links! The Table of Contents specified in the `pages.yml` file of guides-source can have any paths, and is not 100% dependent on the physical file structure to create URLs. It is very important that we don’t break existing blog articles, community tutorials, Stack Overflow answers, etc, both for user experience and SEO reasons.

All guides content is markdown. When we rearrange content, we’ll have to change some links and add redirects. However there are tests in place that check for bad links, so we can do this confidently.

## How we teach this

Community buy-in is important to reduce perception of churn and make “leveling up” our resources a team effort. Significant attention will be put towards informing the community of upcoming changes, and giving them the opportunity to participate.

We will also test major changes with beginner-level developers and developers who don’t know Ember. Although the rollout for the live site will take months, a rough cut, undeployed, could be completed in 1-2 weeks. It could serve as a North Star for the work to be done.

### Implementation plan

This work will need to be done incrementally over many months/the next year. It will be communicated in the form of Quest issues, with help requested via the Ember Times, Discord, Discuss, etc.

Community members will be asked to participate in PR reviews. A diversity of technical experience levels, language backgrounds, and use case perspectives will create a stronger output.

The intial steps will aim for the quick wins and the urgent changes that aid in Octane documentation.

Here's what we could expect a minimal first pass to look like:

- What is Ember?
- Getting Started
- Tutorial (already in progress of being split out)
- Templates
- Components
- Routing (includes Routes, Router, and Controllers)
- State management (aka computed properties)
- Services
- Ember Data (renamed from "Models")
- Addons and dependencies
- Testing
- Configuration
- Application Concerns
- Ember Inspector

The groupings like "Fundamentals" require architectural work on the guides app. They can be done in parallel depending on volunteer capacity and interest, or delayed until the end.

## Drawbacks

This refactor is biased towards new user experience, so existing Ember users could experience the most drawbacks.

1. They will need to discover where old content lives. This is mitigated by the site search, which is now stabilized
2. Experienced developers who haven’t looked at the Guides for a long time will all reference it during the Octane upgrade, and may be surprised to find a new layout. It’s another “new thing to learn.” This is mitigated by consolidating most of the new things to learn into the Components section
3. There will likely be some wrinkles to iron out with regards to content that should have been refactored during rearranging, but was overlooked. We are confident that the community will help identify these issues.

## Alternatives

The main architectural pattern choices were as follows:

1. On one extreme, make every section standalone
2. The middle ground, establish a “Common Core” to be read sequentially, and then have standalone sections that rely on knowledge of the core
3. The other extreme, make the entire guides sequential

We choose the middle ground, because it requires the least new writing, and if we chose to move towards one of the other extremes, it does not prevent that choice nor would we throw away work.

It’s also useful to study the learning flow of other front end libraries in order to determine possible alternatives. Let’s look at a few.

### React

React is known for having low learning overhead for someone who is making their first app. With its popularity, we can guess that new users may expect to find similar topics easily accessible in our guides. This list is most useful for considering what should be in our Components section.

1. Hello World
2. Introducing JSX
3. Rendering Elements
4. Components and Props
5. State and Lifecycle
6. Handling Events
7. Conditional Rendering
8. Lists and Keys
9. Forms
    1. Lifting State Up
    2. Composition vs Inheritance
    3. Thinking In React

The Overview section of the React Tutorial also helps show what we may be missing:

- What Is React?
- Inspecting the Starter Code
- Passing Data Through Props
- Making an Interactive Component
- Developer Tools

Nowhere on our current site do we have a highly visible explanation of what Ember is, beyond snippets. In light of this glaring omission, we have added a “What is Ember” section to the Guides Table of Contents above. It is not meant to replace the ongoing “Why Ember” and marketing-focused descriptions that are underway.

### Vue

As a fully-featured framework, Vue is an easier comparison for possible Table of Contents listings. Keep in mind that much of this type of content is present in our CLI docs instead, so this list will look longer than what we are aiming for.

- Introduction
- What is Vue.js?
- Getting Started
- Declarative Rendering
- Conditionals and Loops
- Handling User Input
- Composing with Components
- Relation to Custom Elements
- Ready for More?
- The Vue Instance
- Template Syntax
- Computed Properties and Watchers
- Class and Style Bindings
- Conditional Rendering
- List Rendering
- Event Handling
- Form Input Bindings
- Components Basics
- Components In-Depth
- Component Registration
- Props
- Custom Events
- Slots
- Dynamic & Async Components
- Handling Edge Cases
- Transitions & Animation
- Enter/Leave & List Transitions
- State Transitions
- Reusability & Composition
- Mixins
- Custom Directives
- Render Functions & JSX
- Plugins
- Filters
- Tooling
- Single File Components
- Unit Testing
- TypeScript Support
- Production Deployment
- Scaling Up
- Routing
- State Management
- Server-Side Rendering
- Internals
- Reactivity in Depth
- Migrating
- Migration from Vue 1.x
- Migration from Vue Router 0.7.x
- Migration from Vuex 0.6.x to 1.0
- Meta
- Comparison with Other Frameworks
- Join the Vue.js Community!
- Meet the Team

One possible lesson here is that we could split up Components like Vue did with Component Basics and Components In-Depth. Their dedicated section on Computed Properties inspired the inclusion in our new Table of Contents.

### Angular

Angular is also a full-featured framework that has a lot in common with Ember.

FUNDAMENTALS
- Architecture
    - Architecture Overview
    - Intro to Modules
    - Intro to Components
    - Intro to Services and DI
    - Next Steps
- Components & Templates
    - Displaying Data
    - Template Syntax
    - User Input
    - Lifecycle Hooks
    - Component Interaction
    - Component Styles
    - Angular Elements
    - Dynamic Components
    - Attribute Directives
    - Structural Directives
    - Pipes
- Forms
- Observables & RxJS
- Bootstrapping
- NgModules
- Dependency Injection
- HttpClient
- Routing & Navigation
- Animations

SETUP & DEPLOYMENT

- Project File Structure
- Workspace Configuration
- npm Dependencies
- TypeScript Configuration
- Ahead-of-Time Compilation
- Building & Serving
- Testing
- Deployment
- Browser Support
- Dev Tool Integration

Angular is the closest match to our current guides structure. Notably, they work Styles in as part of their Components section.

### Trends

All three of the libraries above cover forms in their own dedicated section. They also cover styles and animation, which we do not cover at all. These are all good candidates for future guides.

## Unresolved questions

- What does the community think of this structure? How can it be improved?
- Is it good for new learners? Is it good for existing users?
- What possible pain points does the community see?
- Are there any areas missing from the Table of Contents?
- What do people think of removing the “Ember Object Model” section?
- Are the goals of the Ember Data and Ember Inspector teams supported by this new layout?

### One last note

The Guides are one of those things where everyone has an opinion, and that's ok! However, as a reminder, please be kind and constructive in your comments. The Guides and the tools they cover are the work of many dedicated community members. They are authored and maintained through donated effort, both by unpaid individuals and companies who encourage their teams to contribute. Although we always know there is room for improvement, we are proud of where we came from and excited for where we're going next!


---

---
stage: released
start-date: 2018-12-17T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/432
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/6
---

# Contextual Helpers and Modifiers (a.k.a. "first-class helpers/modifiers")

## Summary

We propose to extend the semantics of Handlebars helpers and modifiers such
that they can be passed around as first-class values in templates.

For example:

```hbs
{{join-words "foo" "bar" "baz" separator=","}}

{{!-- ...is functionally equivalent to... --}}

{{#let (helper "join-words" separator=",") as |join|}}
  {{#let (helper join "foo") as |foo|}}
    {{#let (helper foo "bar") as |foo-bar|}}
      {{foo-bar "baz"}}
    {{/let}}
  {{/let}}
{{/let}}
```

```hbs
<Submit {{on
  click=(action "submit")
  mouseenter=(action "highlight")
  mouseleave=(action "unhighlight")
}} />

{{!-- ...is functionally equivalent to... --}}

{{#let (modifier "on") as |on|}}
  {{#let (modifier on click=(action "submit")) as |on-click|}}
    {{#let (modifier on-click mouseenter=(action "highlight")) as |on-click-enter|}}
      {{#let (modifier on-click-enter mouseleave=(action "unhighlight")) as |on-click-enter-leave|}}
        <Submit {{on-click-enter-leave}} />
      {{/let}}
    {{/let}}
  {{/let}}
{{/let}}
```

## Motivation

[RFC #64](https://github.com/emberjs/rfcs/pull/64) introduced a feature known
as "contextual components", which allowed components to be passed around as
first-class values. While this is a somewhat advanced feature, it allowed addon
authors to encapsulate internal state and logic, which in turns, allowed them
to create easy-to-use and easy-to-understand DSL-like APIs that could benefit
users of all level.

For example, the original RFC used form controls as a motivating example.
Without contextual components, an addon that provides form-building components
might have to expose an API like this:

```hbs
<SuperForm @model={{this.post}} as |f|>
  <SuperInput @model={{this.post}} @name="title" />
  <SuperTextarea @model={{this.post}} @name="body" />
  <SuperSubmit @form={{f}} />
</SuperForm>
```

As you can see, this is far from ideal for several reasons. First, to avoid
collision, the addon author had to prefix all the components. Second, the
`@model` argument has to be passed to all the controls that needs it. Finally,
in cases where the components need to communicate with each other (the form and
the submit button in the example), they would have to expose some internal state
(the `|f|` block param) that the user would have to manually thread through. Not
only does this make the API very verbose, it also breaks encapsulation.

Instead, the contextual components feature allows the addon author to expose an
API like this:

```hbs
<SuperForm @model={{this.post}} as |f|>
  <f.Input @name="title" />
  <f.Textarea @name="body" />
  <f.Submit />
</SuperForm>
```

Behind the scene, the `<SuperForm>` component's template would look something
like this:

```hbs
<form ...>
  {{yield (hash
    Input=(component "super-input" form=this model=this.model)
    Textarea=(component "super-textarea" form=this model=this.model)
    Submit=(component "super-submit" form=this model=this.model)
  )}}
</form>
```

Here, the `component` helper looked up the components by name (first argument)
and packaged up ("curried") any additional arguments (`form=this`) into an
internal object (known as a "component definition" in the Glimmer VM). This
object can then be passed around like any other values and invoked at a later
time.

(Typically, a number of them are passed to the `hash` helper to "bundle" them
into a single object, but this is not required.)

While this is indeed a pretty advanced feature, the users of `SuperForm` do not
need to be aware of these implementation details in order to use the addon.
This had proved to be a very useful and powerful feature and enabled a number
of popular addons, such as
[ember-cli-addon-docs](https://ember-learn.github.io/ember-cli-addon-docs/),
[ember-bootstrap](https://www.ember-bootstrap.com),
[ember-table](https://opensource.addepar.com/ember-table/),
[ember-paper](https://miguelcobain.github.io/ember-paper/),
[ember-power-calendar](https://ember-power-calendar.com),
[ember-accordion](http://khorus.github.io/ember-accordion/),
[emberx-select](https://emberx-select.netlify.com/),
[ember-light-table](https://offirgolan.github.io/ember-light-table/).

The original RFC left an important question unanswered – [should this feature
be available for helpers, too?](https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#unresolved-questions)

In this RFC, we argue – yes, this feature will be just as useful for helpers as
well as modifiers.

For example, the `SuperForm` addon API can be expanded to include some extra
helpers and modifiers, like so:

```hbs
<SuperForm @model={{this.post}} as |f|>
  <f.Input @name="title" />

  {{!-- f.is-valid and f.error-for are contextual helpers --}}
  {{#unless (f.is-valid "title")}}
    <div class="error">This field {{f.error-for "title"}}</div>
  {{/unless}}

  {{!-- f.auto-resize is a contextual modifier --}}
  <f.Textarea @name="body" {{f.auto-resize maxHeight="500"}} />

  <f.Submit />
</SuperForm>
```

For reference, the `<SuperForm>` component's template would look something like
this:

```hbs
<form ...>
  {{yield (hash
    is-valid=(helper "super-is-valid" form=this model=this.model)
    error-for=(helper "super-error-for" form=this model=this.model)
    auto-resize=(modifier "super-auto-resize")
    ...
  )}}
</form>
```

This RFC proposes a complete design for enabling this capability.

## Detailed design

### The `helper` and `modifier` helpers

This RFC introduces two new helpers named `helper` and `modifier`, which work
similarly to the `component` helper:

* When passed a string (e.g. `(helper "foo")`) as the first argument, it will
  produce an opaque, internal "helper definition" or "modifier definition"
  object that can be passed around and invoked elsewhere.

* Any additional positional and/or named arguments (a.k.a. params and hash)
  will be stored ("curried") inside the definition object, such that, when
  invoked, these arguments will be passed along to the referenced helper or
  modifier.

Some additional details:

* When the first argument passed to the `helper` or `modifier` helper is
  `null`, `undefined` or an empty string, it will produce a no-op definition
  object. In the case of the `helper` helper, this will produce `undefined`
  when invoked, regardless of the arguments that are passed to the invocation.
  In the case of the `modifier` helper, it will not perform any operations on
  the target element.

* When the first argument passed to the `helper` or `modifier` helper is a
  string, it will be used to resolve a helper or modifier (respectively) with
  the same name. If the resolution failed, it will result in a runtime error.
  However, the timing of this lookup is unspecified. `(helper "not-a-helper")`
  may result in an immediate error, or it may happen when it is later passed
  into the `helper` helper a second time, or it may happen when it is invoked.
  If it is never invoked, the error may not be reported at all. This timing may
  change between releases and should not be relied upon.

* Some built-in helpers or modifiers may not be resolvable with the `helper`
  and `modifier` helpers. For example, `(helper "debugger")` and
  `(helper "yield")` will not work, as they are considered _keywords_. For
  implementation simplicity, we propose to forbid resolving built-in helpers,
  components and modifiers this way across the board (i.e. a runtime error).
  We acknowledge that there are good use cases for this feature such as
  currying the `array` and `hash` helpers, and will consider enabling them in
  the future on a case-by-case basis.

* Similarly, contextual helpers cannot be named after certain keywords. For
  example, `{{#let ... as |yield|}} {{yield}} {{/let}}` will not work. We
  propose to turn these cases into syntax errors.

* A contextual helper or modifier can be further "curried" by passing them back
  into the `helper` or `modifier` helper again, as shown in the example in the
  [summary](#Summary) section. This will produce a new definition object.

* When the first argument passed to the `helper` or `modifier` helper is a
  bound value, a new definition object will be produced whenever the value
  changes. This will _invalidate_ all downstream invocations. If the previous
  value is a [simple helper](https://emberjs.com/api/ember/3.7/functions/@ember%2Fcomponent%2Fhelper/helper),
  this has no observable effect and Ember will simply invoke the new helper
  value. If the previous value is a [class-based helper](https://emberjs.com/api/ember/3.7/classes/Helper),
  or a modifier, the existing instance will be destroyed before the new value
  is invoked. On the other hand, if only the curried arguments has changed, the
  helper or modifier instances (if any) will remain.

* An important implication of the teardown semantics is that it is possible for
  a modifier to be destroyed while its target element lives on for much longer.
  Therefore, it is important to actually teardown any event listeners and
  cleanup any associated states in the `destroyModifier` hook.

* Positional arguments are "curried" the same way as the `component` helper.
  This matches the behavior of `Function.prototype.bind`.

  ```hbs
  {{#let (helper "join-words" separator=",") as |join|}}
    {{join "foo" "bar" "baz"}} {{!-- "foo,bar,baz" --}}

    {{#let (helper join "foo") as |foo|}}
      {{foo "bar" "baz"}} {{!-- "foo,bar,baz" --}}

      {{#let (helper foo "bar") as |foo-bar|}}
        {{foo-bar "baz"}} {{!-- "foo,bar,baz" --}}
      {{/let}}

    {{/let}}

  {{/let}}
  ```

* Named arguments are curried the same way as the `component` helper.
  This matches the "last-write-wins" behavior of `Object.assign`.

  ```hbs
  {{#let (helper "join-words" "foo" "bar" "baz") as |join|}}
    {{join separator=","}} {{!-- foo,bar,baz --}}

    {{#let (helper join separator=",") as |comma|}}
      {{comma separator=" "}} {{!-- foo bar baz --}}

      {{#let (helper comma separator=" ") as |space|}}
        {{space separator="-"}} {{!-- foo-bar-baz --}}
      {{/let}}

    {{/let}}

  {{/let}}
  ```

* When a definition object is passed into JavaScipt (e.g. as an argument to a
  JavaScript helper), the resulting value is unspecified (hence "opaque"). In
  particular, for helpers, it is _not_ guarenteed that it will be an invokable
  JavaScript function. The only guarentee provided is that, when passed back
  into Handlebars it will be an invokable value. Hanging onto a definition
  object in JavaScript may result in unexpected memory leaks, as these objects
  may close over arbitrary template states.

### Invoking contextual helpers

Invoking a contextual helper is no different from invoking any other helpers:

```hbs
{{#let (helper "join-words" "foo" "bar" separator=" ") as |foo-bar|}}

  {{!-- content position --}}

  {{foo-bar}}

  {{foo-bar "baz"}}

  {{foo-bar separator=","}}

  {{!-- not necessary, but works --}}

  {{helper foo-bar}}

  {{helper foo-bar "baz"}}

  {{helper foo-bar separator=","}}

  {{!-- attribute position --}}

  <div class={{foo-bar}}>...</div>

  <div class={{foo-bar "baz"}}>...</div>

  <div class={{foo-bar separator=","}}>...</div>

  {{!-- not necessary, but works --}}

  <div class={{helper foo-bar}}>...</div>

  <div class={{helper foo-bar "baz"}}>...</div>

  <div class={{helper foo-bar separator=","}}>...</div>

  {{!-- curly invocation, argument position --}}

  {{my-component value=(foo-bar)}}

  {{my-component value=(foo-bar "baz")}}

  {{my-component value=(foo-bar separator=",")}}

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  {{my-component helper=foo-bar}}

  {{my-component helper=(helper foo-bar)}}

  {{my-component helper=(helper foo-bar "baz")}}

  {{my-component helper=(helper foo-bar separator=",")}}

  {{!-- angle bracket invokation, argument position --}}

  <MyComponent @value={{(foo-bar)}} />

  <MyComponent @value={{foo-bar "baz"}} />

  <MyComponent @value={{foo-bar separator=","}} />

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  <MyComponent @helper={{foo-bar}} />

  <MyComponent @helper={{helper foo-bar}} />

  <MyComponent @helper={{helper foo-bar "baz"}} />

  <MyComponent @value={{helper foo-bar separator=","}} />

  {{!-- sub-expression positions --}}

  {{yield (foo-bar)}}

  {{yield (foo-bar "baz")}}

  {{yield (foo-bar separator=",")}}

  {{!-- these will yield the helper itself ("contextual helper"), instead of invoking it now --}}

  {{yield foo-bar}}

  {{yield (helper foo-bar)}}

  {{yield (helper foo-bar "baz")}}

  {{yield (helper foo-bar separator=",")}}

  {{!-- deeply nested sub-expression --}}

  {{#if (eq (concat ">>> " (foo-bar "baz") " <<<") ">>> foo bar baz <<<")}}
    This is true.
  {{/if}}

  {{!-- runtime error: not a component --}}
  <foo-bar />

  {{!-- runtime error: not a modifier --}}
  <div {{foo-bar}}>
{{/let}}
```

### Invoking contextual modifiers

Invoking a contextual helper is no different from invoking any other modifiers:

```hbs
{{#let (modifier "on" click=(action "submit")) as |on-click|}}

  {{!-- HTML elements --}}

  <button {{on-click}}>Click Me!!</button>

  <button {{on-click "extra" "args"}}>Click Me!!</button>

  <button {{on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}}>
    Click Me!!
  </button>

  {{!-- not necessary, but works --}}

  <button {{modifier on-click}}>Click Me!!</button>

  <button {{modifier on-click "extra" "args"}}>Click Me!!</button>

  <button {{modifier on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}}>
    Click Me!!
  </button>

  {{!-- components --}}

  <MyComponent {{on-click}} />

  <MyComponent {{on-click "extra" "args"}} />

  <MyComponent {{on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}} />

  {{!-- not necessary, but works --}}

  <MyComponent {{modifier on-click}} />

  <MyComponent {{modifier on-click "extra" "args"}} />

  <MyComponent {{modifier on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}} />

  {{!-- these will pass the modifier itself into the component, instead of invoking it now --}}

  <MyComponent @modifier={{on-click}} />

  <MyComponent @modifier={{modifier on-click}} />

  <MyComponent @modifier={{modifier on-click "extra" "args"}} />

  <MyComponent @modifier={{modifier on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}} />

  {{my-component modifier=on-click}}

  {{my-component modifier=(modifier on-click)}}

  {{my-component modifier=(modifier on-click "extra" "args")}}

  {{my-component modifier=(modifier on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight"))}}

  {{!-- these will yield the modifier itself ("contextual modifier"), instead of invoking it now --}}

  {{yield on-click}}

  {{yield (modifier on-click)}}

  {{yield (modifier on-click "extra" "args")}}

  {{yield (modifier on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight"))}}

  {{!-- runtime error: cannot invoke a modifier as a helper --}}

  {{yield (on-click)}}

  {{yield (on-click "extra" "args")}}

  {{yield (on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight"))}}

  {{!-- runtime error: cannot append a modifier --}}

  {{on-click}}

  {{on-click "extra" "args"}}

  {{on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}}

  {{!-- runtime error: cannot set an attribute to a modifier --}}

  <div class={{on-click}} />

  <div class={{on-click "extra" "args"}} />

  <div class={{on-click mouseenter=(action "highlight") mouseleave=(action "unhighlight")}} />

  {{!-- runtime error: not a component --}}
  <on-click />
{{/let}}
```

### Relationship with globals

Today, Ember apps rely heavily on the global namespace as the main mechanism of
making components, helpers and modifiers available. Ideally, in a world where
"everything is a value", the global and local namespace should behave the same
way. Global components, helpers and modifiers should just be global variables
that are implicitly defined around every templates in the app.

In other words, it is as if every template has the following hidden "prelude"
around its content:

```hbs
{{!-- prelude --}}
{{#let (component "input") as |input|}}
  {{#let (helper "concat") as |concat|}}
    {{#let (modifier "action") as |action|}}
      {{!-- ...other global components, helpers and modifiers omitted... --}}

      {{!-- begin template content --}}
      Your name:
      {{concat this.firstName " " this.lastName}}

      Change it:
      {{input value=this.firstName}}
      {{input value=this.lastName}}

      <button {{action "submit"}}></button>
      {{!-- end tempalte content ---}}
    {{/let}}
  {{/let}}
{{/let}}
```

While this largely matches how things work today, there are a few notable
differences where globals behave "unexpectedly" in this world.

First of all, it is not possible to reference a component, helper or modifier
in templates without invoking them today:

```hbs
{{!-- if `join-words` is a global helper, this works as expected --}}
{{!-- this invokes the helper and yield the result --}}

{{yield (join-words "foo" "bar" separator=",")}}
         ~~~~~~~~~~

{{!-- however, in this position, Ember does not "see" the helper --}}
{{!-- this falls back to looking up the `join-words` property on `this` --}}

{{yield join-words}}
        ~~~~~~~~~~

{{!-- as opposed to a "true" variable/value binding... --}}
{{!-- this yields the helper as a value, as expected --}}

{{#let (helper "join-words") as |join-words|}}
  {{yield join-words}}
          ~~~~~~~~~~
{{/let}}
```

In the long term, we propose to unify the semantics such that globals will
behave exactly like local bindings (i.e. we should make this second case work).

However, is not possible in the short term. This is due to the ambiguity
between referencing a global variable and the
[property lookup fallback](https://github.com/emberjs/rfcs/blob/master/text/0308-deprecate-property-lookup-fallback.md)
feature. We propose we simply wait until the property lookup fallback is fully
deprecated and removed, at which point we can reclaim the syntax.

In the mean time, globals can be referenced explicitly using the `component`,
`helper`, and `modifier` helpers.

Another difference is how global helpers can be invoked without arguments in
named arguments position for angle bracket invocations:

```hbs
{{!-- if `pi` is a global helper that returns the value of the constant 𝛑 --}}
{{!-- this invokes the helper and passes the value 3.1415... --}}
<MyComponent @value={{pi}} />
                      ~~

{{!-- as opposed to a "true" variable/value binding... --}}

{{#let (helper "pi") as |pi|}}
  {{!-- this passes the helper into the component --}}
  <MyComponent @value={{pi}} />
                        ~~

  {{!-- this invokes the helper and passes the value 3.1415... --}}
  <MyComponent @value={{(pi)}} />
                        ~~~~
{{/let}}
```

Notably, this problem only exists in the named arguments position and only in
angle bracket invocations. For content and attribute positions, it would not
make sense to pass a helper "by value", so the ambiguity does not exist (so it
always invokes). For sub-expression positions (which includes argument
positions for curly invocations), the parentheses are already mandatory
(otherwise it invokes the property fallback).

We propose to deprecate auto-invoking global helpers with no arguments in named
argument positions for angle bracket invocations and require the parentheses
instead. This will make room for unifying the global semantics in the future.

It is also worth pointing out that, since helpers tend to be pure, helpers
that take no arguments are exceedingly rare.

Finally, the last challenge to the unification is it is entirely possible to
have any combinations of components, helpers and modifiers all with the same
name today. This works, as they currently live in different "namespaces", and
each lookup is contextually scoped to their respective "namespace" depending on
the position where it is invoked:

```hbs
{{!-- foo-bar, the modifier here --}}
<div {{foo-bar}} />
       ~~~~~~~

{{!-- foo-bar, the helper here --}}
<div class={{foo-bar}} />
             ~~~~~~~

{{!-- foo-bar, the helper here --}}
{{#let (foo-bar) as |result|}}
        ~~~~~~~
{{/let}}

{{!-- foo-bar, the component here --}}
{{#foo-bar}}...{{/foo-bar}}
   ~~~~~~~        ~~~~~~~

{{!-- prefers foo-bar, the component here --}}
{{!-- if not found, then foo-bar, the helper --}}
{{foo-bar}}
  ~~~~~~~
```

Since this could get pretty confusing, most developers already avoid giving
these unrelated the same names. However, it is certainly possible that they
may happen by accident and go unnoticed (e.g. an addon introducing a global
helper that "conflicts" with a component in the app).

These kind of naming conflicts would not make sense in the value-based world.
Imagine if this is how JavaScript works:

```js
class FooBar {}

function FooBar() {}

const FooBar = 1;

class FooBarBaz extends FooBar {}
//                      ~~~~~~ FooBar, the class here

console.log(FooBar());
//          ~~~~~~ FooBar, the function here

console.log(FooBar + 1);
//          ~~~~~~ FooBar, the constant here

someObj.FooBar = FooBar;
//               ~~~~~~ well, which one is this?
```

Clearly, this would be unacceptable and is similar to the situation we find
ourselves in here.

We propose to issue deprecation warnings whenever we detect these conflicts,
both at build time and at invocation time, while maintaining the same lookup
precedence for the time being. For example, when invoking a component in the
content position, if we see that there is also a helper with the same name, it
should result in a deprecation asking the developer to remain one or the other.

Notably, there is such a conflict in Ember today where `action` is both a
helper and a modifier. Instead of deprecating one of them, we propose to use an
internal mechanism to produce a single special value such that it will be
invokable as either a modifier or a helper context. This is different than
"namespace" semantics in that there is only one context-independent value in this
special case, i.e. `(helper "action") === (modifier "action")`.

We also acknowledge that, so long as there are _implicit_ globals, we may never
be able to truly unify global bindings with local ones, as implicit global
bindings have a high risk of conflicting with HTML elements. Consider the
built-in `input` helper, or an in-app `main` helper. If these were implicitly
turned into global identifiers, they would conflict with the HTML elements with
the same name:

```hbs
<input type="text">
 ~~~~~ now refers to the global `input` identifier?

<main>...</main>
 ~~~~ now refers to the global `main` identifier?
```

While the problem exists for local bindings also, it was already addressed in
[RFC #311](https://github.com/emberjs/rfcs/pull/311). With local bindings, this
problem is fairly noticible and understandable since the conflict is introduced
nearby. The solution is also fairly simple – just rename the local variable to
avoid the conflict. With proper linting, this could be quite easily avoided
altogether.

With _implicit_ global bindings, this problem is much more difficult to spot
and reason about. There is also no quick way out, other than to rename the
global component, helper or modifer which could be difficult or not an option
at all for addon authors trying to maintain compatibility. To truly resolve
this conflict, we would have to eliminate implicit globals, which is out of
scope for this RFC. This also wouldn't be a problem until all the proposed
deprecations are implemented and removed, which would be quite some time.

We _speculate_ that when all the of that is said and done, we would have an
alternative resolution mechanism ("template imports") that does not have this
problem. Alternatively, we could exclude the angle bracket invocation position
from being able to "see" implicit global identifiers.

### Local helpers and modifiers

A nice fallout of this plan is that developers will be able to define helpers
and modifiers specific to a component locally in the same JavaScript file:

```js
// app/components/date-picker.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';

export default Component.extend({
  date: null, // passed in

  'format-date': helper(function(params, hash) {
    /* ... */
  })
});
```

```hbs
{{!-- app/templates/components/date-picker.hbs --}}
{{this.format-date this.date}}
```

In additional to encapsulation and namespacing, this will also enable even more
advanced use cases that uses the component's state:

```js
// app/components/filtered-each.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';
import { computed } from '@ember/object';

export default Component.extend({
  list: null, // passed in
  callback: null, // passed in

  filter: computed('callback', function() {
    return helper(params => this.callback(params[0]));
  });
});
```

```hbs
{{!-- app/templates/components/filtered-each.hbs --}}

{{#each this.list as |item|}}
  {{#if (this.filter item)}}
    {{yield item}}
  {{/if}}
{{/each}}
```

This feature would work with element modifiers as well.

Ideally, this should also work with components. However, currently there are
two pieces to a component – a template and a JavaScript class, either could be
optional. This poses a challenge to invoking components this way – without
going through the component helper, there is no easy way to import or package
a component into a single value. This is a solvable problem, but to design a
solution for that would be out of scope for this RFC. For the time being, the
only way to get a handle of a "component defition value" would be through the
component helper. Attempting to "invoke" just the component template or class
this way will result in a runtime error.

## How we teach this

There are two sides to this feature – the consumption side and the authoring
side.

The consumption side refers to learning how the contextual helper and modifier
values can be used (invoked). We expect developers to enounter this mainly
through addons that others have written. So long as there is adequate
documentation from the addon authors, we expect that this group of users can be
immediately productive by simply treating these APIs as DSLs, similar to the
Router DSL.

In other words, while this group of developer may not immediately understand
how to _author_ these kind of APIs, or what is involved under-the-hood to make
it work, the design goal is that it should feel straightforward to _consume_
this style of API.

The authoring side refers to using the `helper` and `modifier` helpers, and
more importantly, the advanced composition patterns that motivated their
existence in the first place As with the `component` helper and other
"higher-order functions" in JavaScript, this is a somewhat advanced topic that
is mainly targeted at addon authors and advanced developers.

For this group of users, we expect this feature to complement and complete the
"contextual components" feature. Developers who are already familiar with that
feature should feel right at home. We expect to be able to introduce this new
feature at the point where we currently teach contextual components today.

In the long term, the unifications proposed in this RFC should make these
concepts easier to teach for this group of developers, as components, helpers
and modifiers, whether global or contextual, will all behave uniformly. The
value-based semantics also better matches JavaScript which they are probably
already familiar with.

The official documentations should be updated to include this feature:

* The new `helper` and `modifier` helpers need be be added to the API docs.
  We should consider cross-linking between the `helper`, `modifier` and
  `component` helpers since they solve a similar problem.

* The guide should be updated to teach this feature as well. We recommend
  teaching the two sides of the feature separately, and prioritize the
  consumption side, as that is what beginners are likely to encounter first.

  For example, when teaching component invocations, there can be a section that
  mentions:

  > Sometimes, components may be yielded to you as a block param. These are
  called contextual components, and they can be invoked just like any other
  components you have encountered so far.
  >
  > ...examples...
  >
  > To learn how to do this yourself, skip ahead to the "Composition Patterns"
  > section (link).

* For the authoring side, we recommend teaching the helper, modifier and
  component version of the feature in a single place (such as a "Composition
  Patterns" section), cross-linked from their respective sections, rather than
  repeating it three times.

## Drawbacks

This RFC introduces another feature that developers may encounter and have to
learn when consuming addons. However, on the whole, we think this will simplify
things more than adding to the concepts – as it ultimiately try to unify the
behavior of components, helpers and modifiers (and in the future, globals).
This should make things feel more consistent and allow developers to apply
their knowledge consistently across the board.

In the short term, this feature may amplify some of the mismatches and causes
confusions where the legacy semantics does not perfectly match the new world we
are building. This could be mitigated with helpful deprecation messages.

## Alternatives

[RFC #208](https://github.com/emberjs/rfcs/pull/208) has previously explored
the same design space. It solves the same fundamental problems, but proposes
two seperate helpers resolution/currying and invocation. This is largely due to
limitations and ambiguities in Handlebars. This RFC attempts to remove the need
of a separate invocation helper by resolving the ambiguities and integrating
more tightly with Handlebars. If accepted, this RFC will supersede the design
proposed in RFC #208.

As proposed, this RFC relies heavily on context-dependent syntatic positions to
disambiguate between component, helper and modifier invocations. For example,
while they may look similar, the following syntax does not produce the same
result:

```hbs
{{foo-bar baz="bat"}}

{{(foo-bar baz="bar")}}
```

If `foo-bar` is a helper, either would work. However, if `foo-bar` is a
component, only the first form would work and the second form would result in
a runtime error (trying to invoke a component as helper).

A different design has been considered where the first form is just strictly a
syntactic sugar for the latter and `(...)` invocation is one true primitive
that ties everything together.

Specifically, when "invoked" with `(...)`, a component or modifier simply
produces a value, which is a definition object with the curried arguments, i.e.
`(...)` is a syntatic surgar for currying using the `helper` and `modifier`
helpers. The `{{...}}` syntax then simply "append" the curried definition
object by first invoking it.

This design turned out to add more complexities and confusions than the
unification has brought to the table, and so that design was abandoned in favor
of what is proposed here.

Another alternative is to keep the global namespace separate from the local
namespace, thus avoiding the need for most deprecations. In practice, we
believe this would result in much more confusion when things do not behave the
way you would expect, but only in some niche corner cases.

## Unresolved questions

None


---

---
stage: recommended
start-date: 2019-01-18T00:00:00.000Z
release-date: 2019-06-24T00:00:00.000Z
release-versions:
  ember-source: v3.11.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/435
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/9
---

# Forwarding Element Modifiers with "Splattributes"

## Summary

This is a small amendment to
[RFC #311 "Angle Bracket Invocation"](https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html)
and [RFC #373 "Element Modifier Manager"](https://emberjs.github.io/rfcs/0373-Element-Modifier-Managers.html)
to clarify how the "splattributes" feature interact with element modifiers.

## Motivation

RFC #311 introduced the angle bracket component invocation feature. Aside from
the syntatic differences, the angle bracket invocation syntax enabled passing
HTML attributes to components, which can then be applied the underlying HTML
element(s) in the component's layout using the `...attributes` "splattributes"
syntax.

For example, given the following invocation:

```hbs
<FooBar class="foo-bar" />
```

...and the following layout for the `FooBar` component:


```hbs
<div ...attributes>foo bar!</div>
```

Ember will render the following HTML content:

```html
<div class="foo-bar">foo bar!</div>
```

See the [HTML Attributes section](https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#html-attributes)
of RFC #311 for more information on this feature.

On the other hand, RFC #373 introduced the element modifier manager feature.
This enabled Ember developers to define custom element modifiers, similar to
the built-in `{{action}}` modifier that ships with Ember.

This feature can be quite useful for encapsulating, among other things, DOM
event handling and accessibility concerns. For example:

```hbs
<a {{on click=(action this.onClick)}} {{act-as "button"}}>Click Me!</a>
```

While these features are both very useful on their own, they can be combined
to enable powerful abstraction and composition patterns. Unfortunately, the
two RFCs did not explicitly describe how these features would interact with
each other. This RFC proposes three admenments to clarify their relationship:

1. It is legal to apply modifiers to angle bracket component invocations, i.e.

   ```hbs
   {{!-- this is legal --}}
   <MyButton {{action this.onClick}}>Click Me!</MyButton>
   ```

2. Element modifiers can be applied to the underlying HTML element(s), along
   with any HTML attributes, using the splattributes syntax.

   ```hbs
   {{!-- this apply any modifiers in addition to HTML attributes --}}
   <a ...attributes>{{yield}}</a>
   ```

3. In addition, the splattributes syntax can be used to forward HTML attributes
   and element modifiers to subsequent angle bracket component invocations.

   ```hbs
   {{!-- this is also legal, does the same as the above --}}
   <InternalButton ...attributes>{{yield}}</InternalButton>
   ```

This allows the end-users to retain some control over DOM event handling and
other HTML concerns (such as CSS and ARIA roles/accessibility concerns) when
invoking components.

Fundamentally, element modifiers simply enable more fine-grained customization
of an HTML element, on top of what one could accomplish with HTML attributes.
If it is possible to configure the `class` and `aria-role` attributes of a
component's HTML element, it should also be possible to extract them into a
custom element modifier.

It is also adventageous to allow modifiers like `action` to work consistently,
whether the invocation happens to be an HTML element or a component. This allow
features like the [element helper](https://github.com/emberjs/rfcs/pull/389) to
compose better.

For these reasons, we believe it is important and consistent to allow these
interactions.

## Detailed design

From Glimmer VM's perspective, the foundation for these features are already
in-place. Specifically, when applied on an angle bracket invocation, HTML
attributes and element modifiers are collected into an internal block, and the
splattributes syntax simply yields back to that block. Similarly, when applying
the splattributes to another angle bracket invocation, it simply fowards the
block recurrsively. This feature is only currently gated by a precautionary
"compile time error" which can be easily removed once this RFC is accepted.

As laid out in the [modifier manager RFC](https://github.com/emberjs/rfcs/pull/373),
the `createModifier` hook is called in the order they appear in the template.
This means that given the following invocation:

```hbs
<MyComponent {{bar}} />
```

And the following template for `MyComponent`:

```hbs
<div {{foo}} ...attributes {{baz}} />
```

The creation order will be `{{foo}}`, `{{bar}}`, `{{baz}}`. However, the RFC
only provide relative timing guarentees for `createModifier`, and notably _not_
for `installModifier` and `updateModifier` where most of the interesting work
happen (`createModifier` does not receive the element). Therefore, in practice,
it is both not very useful to rely on this timing guarentee, nor is it a good
idea.

## How we teach this

This should be taught in the guides:

1. When teaching angle bracket invocations, we should mention that HTML
   attributes and modifiers, in addition to named arguments, can be passed to
   components. Some examples would be passing `class`, `aria-role` and the
   built-in `action` modifier.

2. When teaching how to author component layouts, we should introduce the
   splattributes syntax and explain why it is a good practice to include it on
   the primary element(s) in the layout, in order to allow custom styling and
   accessibility management by the end-user.

3. When teaching advanced component composition patterns, we can introduce the
   concept of "components that invokes other components". This would be a good
   place to explain how the splattributes can be used to forward both HTML
   attributes as well as modifiers to child components.

4. When teaching element modifiers, we can give use cases of refactoring common
   set of HTML attributes (e.g. classes that goes together with aria-roles)
   into named element modifiers (e.g. `{{act-as "button"}}`).

With the changes proposed in this RFC, it becomes more important to emphasize
that element modifier is a "sharp tool". As with lifecycle hooks in the classic
`Ember.Component`, element modifier is an escape valve from the declarative,
pure and functional world of Handlebars templates, into the messy world of
imperative code, shared states and mutability. While they are very flexible,
that flexibility comes at a cost. When used incorrectly, they can easily leak
state, stomp over each other and causes problems in the app.

Therefore, when authoring element modifiers, it is important to be a "good
citizen", keeping in mind that the underlying HTML element is "shared" among
any bound attributes in the template and other element modifiers. For example,
it is probably a bad idea to prevent event propagation from within an element
modifier, as it may break other modifiers that are listening to the same DOM
event.

This problem is not new, as it is already possible to have multiple element
modifiers attached to the same HTML element. However, when intermediate
components are involved, this could become very difficult to notice.

Therefore, it is even more important to teach and encourage users to author
element modifiers that play well with each other to allow the kind of
composition proposed in this RFC to work at scale.

On the flip side, installing element modifiers on extenal components (i.e.
those that came from outside the app, such as those provided by addons) is also
a somewhat fragile act as it pierces through an encapsulation boundries. Very
generic modifiers like `{{action}}` and `{{on}}` are unlikely to cause problems,
but more special-purpose ones may not be appropiate, unless they are sanctioned
by the component authors.

This is already a risk with splattributes in general, as there are plenty of
context-specific HTML attributes. However, allowing element modifiers here is
going to increase the risk as the operations they perform are hidden further
away.

## Drawbacks

The main drawback is the added risk of breaking encapsulation boundries of
components. Specifically, because the element modifiers have access to the raw
underlying HTML element, they may inadvertently depend upon details about the
element (it is of a particular type, has certain attributes or properties set,
etc), beyond what was intended by the component author as a public API. If this
turned out to be a wide-spread problem, it can be mitigated by adding linting
rules to the template linter.

Separately, as proposed, this API does not allow the element modifiers to "see"
any intermediate components, only the final HTML element. If this turned out to
be useful, we can consider introducing it as an optional capability in future
extensions.

## Alternatives

We can disallow using element modifiers on components, as well as using
splattributes to forward HTML attributes on child component invocations.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2019-02-06T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/440
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/41
---

# Decorator Support

## Summary

Move forward with the Decorators RFC via stage 1 decorators, and await a stable
future decorators proposal.

## Motivation

The recently merged [Decorators
RFC](https://github.com/emberjs/rfcs/blob/master/text/0408-decorators.md)
contained an explicit condition: That it was premised on decorators moving from
stage 2 in the TC39 process to stage 3. If this were to not happen, the original
RFC stipulates that a followup (this RFC) should be created to clarify whether
or not we should move forward with decorators while they remain in stage 2, and
how we would do so.

This RFC proposes that we do so. As discussed in the original, the decorator
pattern has been in use in Ember since the beginning, and there is no easy path
forward to native class syntax without a native equivalent to "classic"
decorators.

[Stage 2 in TC39](https://tc39.github.io/process-document/) signals that the
committee expects this feature to be included in the language in the future, and
is working out the details and semantics. The fact that decorators _remain_ in
stage 2, and have not been rejected, signals that they still expect this to be
the case. However, it is clear based on the initial work following the January
TC39 meeting that [the proposal could change
significantly](https://github.com/tc39/proposal-decorators/pull/250) between now
and stage 3.

Parts of the proposal, such as how decorators are invoked, seem solid based on
the feedback we received at the January TC39 meeting, and based on the draft of
the new spec. The definition of decorators is the most likely thing to change.
As such, user code should be minimally affected by any changes, and most changes
should be codemod-able. This reduces the risk of adopting decorators now, since
code _written_ with decorators shouldn't need to change that much.

[The current recommendation from the authors of the
spec](https://github.com/tc39/proposal-decorators/tree/static#how-should-i-use-decorators-in-transpilers-today)
is to use the stage 1 decorators proposal until the next iteration is ready.
Stage 1 decorators are very stable, and used by a large community of developers
outside of Ember. By standardizing on this version of the spec, we'll be able to
gain the benefits of using a shared solution with the wider ecosystem while we
wait for the next iteration.

## Detailed design

### Classic Classes

The first thing to note is that Ember.js will continue to work with classic
classes and classic class syntax for the forseeable future, as a way for users
to opt-out if they don't want to take the risk of using native classes. This
includes:

- Classic Classes
- Classic Components
- Mixins
- Computed Properties
- Observers
- Tracked Properties
- Injections
- All existing classes defined with classic class syntax

Notably, `GlimmerComponent` will _not_ support classic class syntax, due to its
constraint of having to support both Ember.js _and_ Glimmer.js, where the
classic class model is not available. However, creating an API compatible
classic class version using Ember's component manager API should be possible if
users want to write Glimmer-like components with classic syntax.

### Decorator Semantics

Ember will support Babel's stage 1 decorator transforms. Since Babel and
TypeScript's decorators overlap so much, most TypeScript decorators should also
work in Ember apps. However, due to subtle differences in the way Babel and
TypeScript's decorators work, we can't support them both in _all_ cases. In
cases where there are nuanced differences, Babel's transforms will be considered
the canonical source of truth. For `ember-cli-typescript` users this shouldn't
be an issue, since they can use Babel's transforms in the latest versions of
`ember-cli-typescript`.

#### Class Field Assigment Order

Ember also does _not_ guarantee a particular ordering for the assignment of
decorated fields in order to support users who want to use _native_ class fields
when they are available. All that Ember guarantees is that by the time the
`constructor`'s `super` method completes (or the constructor code begins, if the
class is not extending), all class fields will be assigned.

Assigning class fields based on the values of other class fields is somewhat of
an anti-pattern as is, so this would reinforce discouraging problematic
patterns. To be clear:

```js
class MyComponent extends Component {
  // This is ok, because the component instance exists
  // for all class fields.
  stateManager = new StateManager(this);

  @service time;

  // This is ok, because the `time` is an injection,
  // and always available for all class fields.
  createdAt = this.time.now();

  // This is problematic in general, not just with decorators, because
  // it relies on the order of class field assignment within this class.
  // It is a refactoring hazard, and should likely be done in the
  // constructor instead.
  registry = new Registry();
  container = new Container(this.registry);
}
```

Ember will attempt to provide a lint rule which can handle this level of nuance
and prevent frustration when users copy and paste code around the class body.

#### Class Field Assignment Semantics

Currently, the Babel stage 1 transforms require `loose` mode for class fields
which causes them to be assigned directly rather than using
`Object.defineProperty`, which is not inline with the class fields spec. The
biggest difference in behavior is when a child class attempts to override a
getter/setter on the parent class:

```js
class Foo {
  get baz() {
    return this._baz;
  }

  set baz(value) {
    this._baz = value;
  }
}

class Bar extends Foo {
  baz = 123;
}
```

In strict mode, `baz` in the child class would completely override the
getter/setter, and they would not exist/be usable on an instance of `Bar`
(except through calls to `super`). In loose mode, `baz` in the child class would
go through the getter/setter, and be assigned to `_baz` on the instance.

In order to mitigate this, Ember will provide an assertion in development builds
via a babel transform for fields that are assigned in a non-spec compliant way
that throws in this scenario. This will prevent users from accidentally writing
code that will be hard to migrate forward to class fields in the future.

### Decorator Support Timeframe

Stage 1 decorators will be considered a first class Ember API. They will be
supported until:

1. A new RFC has been made to introduce a new decorator API as a parallel API to
   the stage 1 decorators.
2. A deprecation RFC has been created for Stage 1 decorators.

They will follow the same deprecation flow, and same SemVer requirements, as any
other Ember feature.

## How we teach this

There are a few different important aspects of this that should be taught:

1. **Class Field and Decorator semantics**, specifically around the ordering of
   class fields. While any step to change a user's class field ordering would
   likely be based on their target browsers and configuration, and would be
   unlikely to change in a patch or minor version release, users writing code
   that could be difficult to upgrade or dependent on a particular version of
   the class field/decorator transforms is a failure case we want to avoid.
2. **Support timeframe and alternatives.** Users should be aware that this will
   be a feature that will _likely_ change in the future, if only subtly. We
   should highlight that there _is_ an alternative, classic class syntax, and
   that it will still be fully supported. Ultimately, this point is about
   setting expectations - that a year or so from now, when decorators are truly
   final, there will be another shift.
3. **Custom Decorators.** We should document how users can write their own
   decorators, but also caution against behaviors that will be difficult to
   replicate in Stage 3 decorators when they are ready. This will _necessarily_
   be a moving target, since stage 3 decorators are not yet finished, but we can
   try our best to recommend against usages that could be problematic.

   We should also warn that decorator definition code will almost definitely
   have to be rewritten for stage 3. This should be very clear, so that users
   understand that adopting custom decorators in their apps means taking on more
   tech debt than just using official Ember decorators, and decorators provided
   by addons.

## Drawbacks

- The fact that decorators did not move to stage 3 signals that there may be
  additional changes to the spec in the near future. Adopting them now could
  cause more churn than it's worth.

- By adopting decorators now, we are essentially taking on some amount of debt
  that we know will have to be repaid in the future as a community. This is less
  than ideal, since we know that standardization is coming, it's just a matter
  of when. This is also the situation we've been in for quite some time already,
  and with the latest turn of events, it seems unlikely that decorators will be
  fully standardized within the year.

  We can continue to wait, but there is no deadline on the design process, and
  we could be stuck here indefinitely. This move is pragmatic in that it
  unblocks us for now, and moves us toward using modern syntax that will be
  compatible with stage 3 decorators - it allows us to begin unwinding other
  layers of technical debt. It also represents minimal risk and debt to _users_
  of decorators, since the invocation style will likely be the same.

## Alternatives

- We could continue to rely on unofficial addons such as `ember-decorators`,
  which allow users to opt-in to using decorators. However, these libaries have
  limitations that first class decorators will not have, and they don't allow us
  to update the official guides to use them.

- We could create an official decorators addon. However, this means that
  decorators would be available at a different import path, meaning that any
  code which seeks to work with _both_ classic classes and native classes would
  have to be written twice. This would be very difficult for applications that
  are mid-transition, and even more difficult throughout the ecosystem for addon
  authors.


---

---
stage: recommended
start-date: 2019-02-13T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/445
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/40
---

# Deprecate `{{with}}`

## Summary

The `{{with}}` helper has always had slightly confusing conditional semantics, this was one of the motivators for [introducing](https://github.com/emberjs/rfcs/blob/master/text/0286-block-let-template-helper.md) the easier to understand `{{let}}` helper. Now that `{{let}}` exists, the remaining use case for using `{{with}}` is for its unique conditional semantics. These conditional semantics can be cleanly represented with a combination of `{{let}}` and `{{if}}` statements so we should deprecate `{{with}}`.

## Motivation

The difference between `{{let}}` and `{{with}}` is with how they handle conditional arguments. The `{{let}}` helper's block content is always rendered, regardless of its parameters. In contrast, `{{with}}` only renders its main block when the first position parameter is truthy. For example:

```hbs
{{#with "Alex" as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
```

Will render "[Alex] is truthy".

```hbs
{{#with false as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
```

Will render "The first positional param was falsy".

The conditional arguments behavior of `{{with}}` can easily be replicated using a combination of `{{let}}` and `{{if}}` in a way that's easily readable:

```hbs
{{#let "Alex" as |value|}}
  {{#if value}}
    {{value}} is truthy
  {{else}}
    The first positional param was falsy
  {{/if}}
{{/let}}
```

## Detailed design

We'll create an AST transform in [`packages/ember-template-compiler`](https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler) which will emit a deprecation warning for all uses of `{{with}}`. The deprecation warning will be:

```
Using `{{with}}` is deprecated, please use `{{let}}` instead.
```

This message will link to the following deprecation details which aim to give clear guidance on how to migrate to using `{{let}}`, `{{if}}` and `{{else}}` in different combinations:

----

The use of `{{with}}` has been deprecated, you should replace it with either `{{let}}` or a combination of `{{let}}`, `{{if}}` and `{{else}}`:

**If you always want the block to render, replace `{{with}}` with `{{let}}` directly:**

Before:

```hbs
{{#with (hash name="Ben" age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/with}}
```

After:

```hbs
{{#let (hash name="Ben" age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/let}}
```

**If you want to render a block conditionally, use a combination of `{{let}}` and `{{if}}`:**

Before:

```hbs
{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{/with}}
```

After:

```hbs
{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{/if}}
{{/let}}
```

**If you want to render a block conditionally, and otherwise render an alternative block, use a combination of `{{let}}`, `{{if}}` and `{{else}}`:**

Before:

```hbs
{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{else}}
  There are no blog posts
{{/with}}
```

After:

```hbs
{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{else}}
    There are no blog posts
  {{/if}}
{{/let}}
```

---

For people on older versions of Ember that support `{{let}}`, we'll create an `ember-template-lint` rule that they can use to prevent the use of `{{with}}`.

We'll also create a codemod which will assist people when migrating from `{{with}}` to `{{let}}`.

## How we teach this

We'll mentiton the deprecation in an Ember point release blog post.

As mentioned above, the deprecation message will contain a link to clear guidelines on how to migrate to using `{{let}}`.

There is nothing to remove from the Ember.js Guides since we already teach only the use of `{{let}}`.
## Drawbacks

This adds a little churn to Ember's API.

## Alternatives

We could leave `{{with}}` as is. I don't believe that this is a good option as the name `{{with}}` is confusing.

We could deprecate `{{with}}` and introduce `{{if-let}}` in Ember core. This RFC originally made that exact proposal, I was strongly persuaded of the [lack of need for `{{if-let}}` by @tcjr](https://github.com/emberjs/rfcs/pull/445#issuecomment-463594185).

We could deprecate `{{with}}` and introduce `{{if-let}}` in an addon instead of Ember core.

## Unresolved questions

(none)


---

---
stage: recommended
start-date: 2019-02-14T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/446
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/39
---

# Contribution Guides

## Summary

This RFC proposes the creation of an official **Contribution Guide** that aims to improve the discoverability of Ember-related projects that require help by the community and outlines the general contribution workflow for these projects.


## Motivation

In the past year alone, [43](https://github.com/emberjs/ember.js/graphs/contributors?from=2018-01-01&to=2019-01-01&type=c), [34](https://github.com/ember-cli/ember-cli/graphs/contributors?from=2018-01-01&to=2019-01-01&type=c), [29](https://github.com/emberjs/data/graphs/contributors?from=2018-01-01&to=2019-01-01&type=c), [81](https://github.com/ember-learn/guides-source/graphs/contributors?from=2018-01-01&to=2019-01-01&type=c) and [31](https://github.com/emberjs/website/graphs/contributors?from=2018-01-01&to=2019-01-01&type=c) people made contributions to the [core framework library](https://github.com/emberjs/ember.js), the [Ember CLI](https://github.com/ember-cli/ember-cli), Ember’s [Data library](https://github.com/emberjs/data), the source for [the official framework Guides](https://github.com/ember-learn/guides-source), and the [project website](https://github.com/emberjs/website), respectively. An already impressive amount of developers decided to dedicate their time and effort to contribute to Ember - a project, that has been actively supported, maintained and developed by a strong open-source community for over seven years. Besides the code contributions to the main project repositories, the community can also look back on years of immense effort that has been put into the development of community-maintained packages which resulted in the vast Ember addon ecosystem as we know it today, as well as independent documentation and learning resources.

We are confident that there is an even greater potential for the community to contribute and that this can be unlocked by facilitating the contribution process - especially in regards to the on-boarding process for first-time contributors to Ember. Today, new community members oftentimes need to spend some time and effort to find a suitable project that allows them to apply a) their skills efficiently and b) is in their eyes worthwhile.

This RFC proposes to create and release a Contribution Guide - a new website as part of the `emberjs.com` domain. This new site should allow contributors to find Ember-related projects to work on easily and should provide more information on the workflow for their potentially (but not necessarily) first open-source contribution.

## Detailed design

The new Contribution Guides should be as **beginner-friendly** as possible to accommodate the needs of those who might make their very first code contribution to an open-source project.

 The list of topics covered should therefore include:

- **A summary of the motivation of open-source and its meaning for Ember as an OSS project.** This aims to provide more context to those new to Ember and open-source in general about the purpose of the project and how Ember values a collaborative approach in the development of the framework.

- **A How-To for code contributions with a real-world example.** This can include tips on how to find and claim a suitable issue, an introduction to Git and how to send a pull request, tips for the review process about finding a reviewer, communicating effectively and submitting changes and easy-to-review chunks of contribution work.

- **A How-To for filing a new issue on an Ember project**

- **An issue finder functionality inspired by the [What Can I Do for Mozilla landing page](https://whatcanidoformozilla.org/#!/progornoprog/teach)**. This should lead users to a) a list of relevant issues on the [Ember Help Wanted App](https://help-wanted.emberjs.com/), b) a related strike team channel on the Ember Discord chat, c) a link to the description of an on-going initiative on the [Status Board](https://emberjs.com/statusboard/).

Any subjects covered in the Guides should be presented as text instruction at least, but each topic can be enhanced with relevant code examples and multi-media content (e.g. slides of a relevant community talk, video content among others).

To help with the integration of the issue finder on the Contribution Guides with the Ember Help Wanted app, this proposes to extend the Ember Help Wanted App with a search filter for the main programming language used in the project. To make the Contribution Guides easy to discover from Ember projects, each project's specific contribution guidelines (e.g. [Ember CLI's `CONTRIBUTING.md`](https://github.com/ember-cli/ember-cli/blob/master/CONTRIBUTING.md)) should cross link back to the new Contribution Guides site for reference.

To improve discoverability of the Contribution Guides via search engines, it is also proposed to host the Guides on their own Ember sub domain: **contribute.emberjs.com**


## Alternatives

An alternative would be to not create a dedicated Contribution Guide and instead refer those that want to contribute to [the related section in the Ember Guides](https://guides.emberjs.com/release/contributing/adding-new-features/). It would also be possible to expand this section of the Ember Guides further with more content we'd like to share with contributors.

Also, the Ember Help Wanted App already works in favour of one of the goals of this proposal which is increasing the discoverability of issues that require contribution help. Instead of creating a new, dedicated website for the Contribution Guides, it would also make sense to progressively enhance the Help Wanted App with relevant content on contribution, e.g. with a short tutorial on the contribution workflow or How-Tos on other kinds of contribution work.

## Unresolved questions

Although this RFC already answers questions about the kind of content we’d like to see with an Contribution Guide for Ember, it is not clear yet, how the infrastructure for this guide looks like. Some of related questions are:

- Should the Guide be another Ember app, e.g another dedicated Guides app, in a similar to the official Ember and [Ember CLI Guides](https://github.com/ember-learn/cli-guides)? Making it an Ember app might in return help community members to contribute to it since they’re most likely already familiar with Ember. Choosing a similar format as the one of the Ember CLI Guides comes with the additional benefit of making it particularly easy to contribute to the Guide’s content since this only requires an understanding of Markdown, lowering the entry hurdle for a first-time contribution

- If we decide to not create another Guides app for the Contribution Guides, how should the design for the new website look like?

- This RFC only considered content related to code contributions relevant for the Contribution Guides. This excludes other types of important contribution work to Ember and the community, as event organisation, blogging, release management and many other topics. Should the Guides be expanded by relevant information about other types of contribution work as we iterate on it? This could include How-Tos for organising meetups, a collection of workshop materials for reuse, an introduction to the RFC process and other pieces of information


---

---
stage: recommended
start-date: 2019-02-17T00:00:00.000Z
release-date: 2019-12-09T00:00:00.000Z
release-versions:
  ember-source: v3.15.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/449
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/38
---

# Deprecate `{{partial}}`

## Summary

Partials are an old Ember construct that have no benefits and many downsides when compared to modern Ember components. We should deprecate them in favor of components.

## Motivation

Partials have a number of downsides when compared with components:

 - They are hard to reason about as they inherit the scope of the calling template
 - They perform poorly in comparison to components

Partials should have no place in modern Ember applications, components should always be preferred.

Once removed, Ember's API will become smaller and more consistent.

## Detailed design

We'll create an AST transform in [`packages/ember-template-compiler`](https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler) which will emit a deprecation warning for all uses of `{{partial}}`. The deprecation warning will be:

```
Using `{{partial}}` is deprecated, please use a component instead.
```

This message will link to the following deprecation details which aim to give clear guidance on how to migrate to component:

---

The use of `{{partial}}` has been deprecated, you should replace the partial with a component as follows:

Let's consider a simple example of a `partials/quick-tip` partial being invoked from the `application.hbs` template:

`app/templates/application.hbs`

```hbs
{{#let (hash title="Don't use partials" body="Components are always better") as |tip|}}
  {{partial "partials/quick-tip"}}
{{/let}}
```

`app/templates/partials/quick-tip.hbs`

```hbs
<h1>Tip: {{tip.title}}</h1>
<p>{{tip.body}}</p>
<button {{action 'dismissTip'}}>OK</button>
```

Here's the same template code after migrating the `partials/quick-tip` partial to be a component.

`app/templates/application.hbs`

```hbs
{{#let (hash title="Don't use partials" body="Components are always better") as |tip|}}
  <QuickTip @tip={{tip}} @onDismiss={{action 'dismissTip'}} />
{{/let}}
```

`app/templates/components/quick-tip.hbs`

```hbs
<h1>Tip: {{@tip.title}}</h1>
<p>{{@tip.body}}</p>
<button {{action @onDismiss}}>OK</button>
```

---

A codemod, while not necessary for this RFC to land, would greatly simplify the migration of partials to components. We should endeavor to create this codemod as part of efforts to implement this RFC. The codemod might work as follows:

 * Examine each partial template to recognize which properties originate from the caller scope
 * Generate a component to replace each partial
 * Replace each `{{partial "foo-bar"}}` invocation with a component invocation, passing arguments as required
 * Delete the partial handlebars files

 If we do implement a codemod, we should mention it in the deprecation details above.

## How we teach this

We'll mentiton the deprecation in an Ember point release blog post.

The deprecation message will contain a link to clear guidelines on how to migrate from a `{{partial}}` to a component. See the section above beginning with "The use of `{{partial}}` has been deprecated..." for the content.

There are no changes to make to the Ember.js guides, since mentions of `{{partial}}` were removed in 2.x guides.

## Drawbacks

This adds a little churn to Ember's API.

## Alternatives

We could do nothing and leave things as is.

## Unresolved questions

None


---

---
stage: recommended
start-date: 2019-02-19T00:00:00.000Z
release-date: 2019-06-24T00:00:00.000Z
release-versions:
  ember-source: v3.11.0

teams:
  - framework
  - data
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/451
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/34
---

# Injection Parameter Normalization

## Summary

Normalize on passing the `owner` as the first parameter to the constructor for
the following built in framework classes:

- `GlimmerComponent`
- `EmberComponent`
- `Service`
- `Route`
- `Controller`
- `Helper`

Along with the following Ember Data classes:

- `Model`
- `Adapter`
- `Serializer`
- `Transform`

## Terminology

- _Explicit injections_ are injections which are defined in the class body using
  the `inject` APIs:

  ```js
  import Component from '@ember/component';
  import { inject as service } from '@ember/service';

  export default Component.extend({
    store: service(),
  });
  ```

  The are _explicit_ because they don't require any knowledge of the system to
  outside of the class itself to know they exist.

- _Implicit injections_ are injections which are defined using the container
  APIs directly, often in initializers:

  ```js
  import Application from '@ember/application';

  Application.initializer({
    name: 'inject-session',

    initialize() {
      // Inject the session service onto all factories of the type 'controller'
      // with the name 'session'
      App.inject('controller', 'session', 'service:session');
    },
  });
  ```

  They are implicit because they require knowledge of the context
  of the class to know whether or not they exist, simply looking at the class
  body (without looking at method logic) will not hint at their existence. The
  canonical example here is the Ember Data `store`, which is implicitly injected
  into all routes and controllers.

## Motivation

The introduction of native class syntax in Ember has recently exposed some of
the inner-workings and expectations of Ember's Dependency Injection (DI) system.
Specifically, it is now possible to write code that can run _before_
dependencies are injected in some base classes, such as Services and
Controllers. Currently, users must use the `init` hook in these classes if they
wish to run setup code that accesses injections, but this is somewhat confusing
since `init` has historically been taught as the same as the `constructor` in
native classes.

Glimmer components made the decision to break from this pattern, and instead
pass the DI Owner as the first parameter to the constructor. They then set it
using `setOwner` in the base class, making explicit injections available during the
constructor, and to class field initializers.

So far this has worked pretty well in practice:

- Glimmer components have just 2 lifecycle hooks, which makes them simpler to
  understand and learn about.
- We don't have to teach the differences between `constructor` and `init`, when
  to use one or the other, and debugging issues when the two have mixed usage
  throughout the class hierarchy
- We don't have to worry about explaining the timings/lifecycle of the container
  and the way it constructs classes in order to explain why these are separate.

This RFC seeks to normalize this contract for all _Ember base classes_ - that
is, framework classes that are provided by Ember:

- `GlimmerComponent`
- `EmberComponent`
- `Service`
- `Route`
- `Controller`
- `Helper`

Along with framework clases provided by Ember Data:

- `Model`
- `Adapter`
- `Serializer`
- `Transform`

This RFC does **_not_** aim to provide a single contract for _all_ classes
registered on the container, in perpetuity. This would lock us into a tight
coupling between the container and constructors for objects that are registered,
and wouldn't provide much flexibility in the future.

Instead, we believe we should continue exploring APIs for generalizing the way
DI is configured for a given base class. It could be done via custom managers,
or via decoration, like the [Injection Hook Normalization
RFC](https://github.com/emberjs/rfcs/pull/467). When these APIs are fully
rationalized and accepted, we'll update Ember's base classes to use them to
specify the owner injection like any other user class could.

## Detailed design

This RFC has 2 major parts:

1. The contract that we'll uphold for dependency injection in _Ember base
   classes_.
2. The implementation of that contract for existing base classes (the tunnel).

### Dependency Injection Contract

For all Ember base classes created by the container, such as `GlimmerComponent`,
`Service`, `Controller`, etc. we will:

1. Pass the owner as the first parameter when constructing the class.
2. Set the owner with `setOwner` in the base class constructor.

This will make explicit injections available during the `constructor` method of
the class, and for access by class field initializers.

This contract _only_ applies to Ember base classes and framework objects, and
classes that extend `EmberObject`. It does _not_ apply to arbitrary
classes that are created and registered in the container.

### Implementation

The "tunnel" itself is fairly simple. As described in the Constructor Update
RFC, this is how the `create` method on framework classes works currently:

```js
class Service extends EmberObject {
  constructor() {
    super();
    // ..class setup things
  }

  static create(args) {
    let instance = new this();

    Object.assign(instance, args);
    instance.init();

    return instance;
  }
}
```

We would update this to the following:

```js
class Service extends EmberObject {
  constructor(owner) {
    super();
    setOwner(this, owner);
    // ..class setup things
  }

  static create(args) {
    let owner = args ? getOwner(args) : undefined;
    let instance = new this(owner);

    Object.assign(instance, args);
    instance.init();

    return instance;
  }
}
```

Now, when any subclass's constructor code is run it will have the owner
available, which in turn makes all _explicit_ injections work (they use
`getOwner` under the hood).

However, _implicit_ injections will still only be available during `init`,
because they are passed in and assigned as `args`. This RFC proposes that rather
than attempting to fix implicit injections, we create development-mode
assertions for them which throw if a user attempts to use them during the
`constructor`, before they are assigned. This will give a helpful error message
that instructs them to add the injection explicitly (ideally), or to use `init`.

### Backwards Compatibility

This change is backwards compatible, so existing applications will not be
affected. These changes will also be backported to at least:

- lts-3.8
- lts-3.4

via the `ember-native-class-polyfill`, which currently supports polyfilling to
Ember@3.4. If possible, that range will be extended to the last v2 LTS versions.

## How we teach this

This change would take some burden off of the guides for _new_ Ember users,
post-Octane, since it would simplify them. New documentation should only refer
to `constructor` when talking about native class syntax, and should guide users
toward using `constructor` over `init`.

For existing apps and upgrade documentation, the distinction needs to be made
clear about the two types of classes that _should_ still use `init`:

- Classic Components
- Utility Classes (e.g. user defined classes that extend `EmberObject`)

These two require `init` if users need access to component args or create args,
respectively.

The main guides will recommend that users refactor these classes entirely rather
than convert them to native classes. Classic components should become Glimmer
components, and utility classes should be refactor _away_ from extending
`EmberObject`.

The [`@classic`](https://github.com/emberjs/rfcs/pull/468) decorator will also
provide a way to guide users toward the correct usage, based on whether they are
in "classic" mode or "octane" mode. We will be able to provide linting and
warnings/assertions to prevent users from accidentally using `init` when they
should have used `constructor`, and vice-versa.

## Drawbacks

- More churn in the ecosystem, early adopters of classes already switched from
  `constructor` -> `init`, switching back would be painful.
- Where to use `init` and where to use `constructor` may be a bit less clear
  after. This was already a concern with `GlimmerComponent`, but it may be more
  problematic if there are more exceptions.

## Alternatives

- Add an `init` hook to `GlimmerComponent` to unify it with the classic classes.
  This could be confusing to users of `GlimmerComponent` (why do injections
  work in GC but not any other class constructor? Why does GC have `init` _and_
  `constructor`?)
- Keep using `init` for classic classes for the indefinite future, and teach
  around it.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-02-20T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/452
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/50
---

# **Summary**

This RFC sets the plan for Ember Data's medium term development, on the path towards modularizing the library. We expect the following immediate design and implementation work to take between one and two quarters. The main goals are:

- Increase approachability of the library for both the users and contributors
- Increase iteration speed and stability
- Enable shedding of legacy layers
- Increase flexibility and lay the foundation for future improvements

# Background and Motivation

Ember Data needs to continue to evolve with Ember and the wider Javascript ecosystem and provide a modern first class data handling support. Moreover, we want to reach the future in which using ED is a much more modular and composable experience. In order to do this, we need to create a foundation for future development while making sure we are honoring our stability guarantees and helping the ecosystem evolve together with us. The two main motivations for this RFC are:

- Enabling future improvements
- Increasing velocity and stability


## Enabling future improvements

In order to provide Ember users with a future proof data stack, ED has to mold and adapt. A sample of requirements for a modern data library for Ember include:

- Not depending on Ember's object model
- Support for complex persistence strategies
- Flexible query expressions and mutations, allowing optional GraphQL support
- Out of the box high level of performance without compromises

Ember Data should incrementally evolve to support all of the above with full backwards compatibility. However, evolving a complex codebase over time while maintaining compatibility has always been a tricky endeavor abound with tradeoffs. In the 3.x cycle there have been several angles of attack towards exploring the future of ED.

---

- Orbit.js has been driving experimentation with a multi source transformation driven approach
- An experimental spike of Ember Data frontend backed by Orbit.js (https://github.com/igorT/data-orbit)
- Single model class Ember Data Addon with dynamic schemas and no normalization (https://github.com/hjdivad/ember-m3)
- Public interface in Ember Data that allows for above efforts to be stable and exposes the internals for more experimentation (https://github.com/emberjs/rfcs/pull/293)

While some of these efforts are experimental spikes and others have seen production use, we want to bring their ideas and improvements back into ED proper. The first motivation for this RFC is to design our internal architecture so that we can iteratively move the library in that direction. We have already done the first part of this work, refactoring the bulk of in memory data storage into a pluggable RecordData interface and now need to spread that approach to the rest of the library.

However, we will not succeed in delivering this future vision in a timely manner and bringing it's benefits to our existing body of users if we do not improve our velocity and stability.

# Increasing velocity and stability

Ember Data has continuously evolved over seven years and over time acquired several layers of cruft along with a intimately connected internal architecture. The current state of the library is not particularly hospitable to new contributors while at the same time being hard to iterate on in a stable manner. Lots of Ember Data's public apis have been designed with stability and extensibility in mind, but the internal layers of the library have not benefited from the same amount of design work. The unspecified internal layers together with a host of implicit dependencies make it hard to expose parts of Ember Data to addon developers as well as prevent ED contributors from being able to easily do experimental iterative work.

The three main problems this internal structure causes us is:

- It is hard for developers to grok the codebase and become prolific contributors due to the complexity
- Testing ideas in addons is usually a great way to move faster and derisk ideas. However due to the internal structure of ED, such addons use a large surface area of internal apis, negating most of the benefits
- Due to the structure of the code base and the inherent complex nature of data retrieval and storage, it is hard to make changes to ED with confidence. While we have an extensive acceptance level test suite, testing of the internal apis and data structures is lacking at best

We have already begun some efforts to address these problems: incremental conversion to Typescript and the RecordData refactor stand out as biggest value adds.

A great example of how these issues impact us are the problems one runs into when trying to remove ED's dependency on DS.Model and Ember's object model. In a perfect world, if we wanted to ship ED that used ES6 classes instead of DS.Models, we would adopt an incremental approach:

- A small refactor of ED to make base record class pluggable
- Develop an addon that uses ES6 classes as a base record class and experiment with it
- After a period of experimentation, merge the addon into ED core with a compatibility layer for legacy users

However, this is currently very hard to do in the ED codebase, because the whole system is littered with both explicit and implicit assumptions about record's intimate apis and it's class structure. The implicit assumptions throughout the codebase of how a record behaves are especially challenging to reason about and test.

# Goals

Success criteria for this plan is shipping an Ember data release which:

- Does not break SemVer and has no user facing changes
- Consists of several independently tested packages with clearly defined boundaries and interfaces
- (mostly) In Typescript
- Enables a path for users to not have model classes dependent on the old Ember object model and DS.Model
- And allows addons like ModelFragments and ember-m3 to not use any private apis

# Non Goals

While the internal apis and interfaces will be designed with an eye towards the future public and addon use, in this phase of the work we will not be exposing all of them to apps and addons as fully stable public apis, or we will do so for addon author with an explicit plan to deprecate and replace.

Moreover, as part of the RFC we will not be deciding on, or baking in the future app level public apis.

# High Level plan

The high level plan is to refactor the ED internals so that:

- DS.Model and code relying on it is isolated from the rest of the system allowing us to swap it out in the future
- InternalModel is removed in favor of moving the functionality to specced out APIs
- We introduce a concept of RecordIdentity, a string or POJO which can be used to uniquely identify a record throughout the system
- Boundaries between parts of the system are hardened, specced out and implemented in typescript

In a typical Ember app, Ember Data sits as a layer between the application code which issues queries for data, reads and manipulates the results and the browser fetch or websocket interface.  You could model a typical use of ED at a high level as :

App Query —>   In memory cache —>  Request sent → Data normalized → Result object returned

However Ember Data's architecture currently is quite a bit more complex:

![](https://i.imgur.com/98oiXCx.png)

While the overall shape of the architecture looks as you might expect, our current implementation suffers from several critical problems:

- A large part of critical model behavior is handled by the internal model abstraction
- Entire library implicitly relies on DS.Model classes, Ember's object model
- The division of responsibilities between internalModel, RecordData, Store are not clear

This medium size ball of mud should be refactored to the following high level pieces: (add diagram here):

![](https://i.imgur.com/C3tNcH2.png)

*this is a high level design, each of these would correspond to an RFC*

- User facing record objects, and a corresponding interface which the rest of the system uses to interact with records. This currently corresponds to DS.Model, DS.RecordArray, ObjectProxy and ArrayProxy. These classes will be swappable, and give us a path to change ED's object model
- RecordIdentity - a system wide way to uniquely identify records
- In memory store, RecordData++, taking what RecordData does today(in memory storage of record and relationship information) and adding record state management, error handling and capability to have a singleton Record Data instead of having to have a Record Data instance per Record
- Schema Service - a service for providing attribute and relationship info to the rest of the system, the initial implementation would just provide a wrapper for DS.Model, but allows us a path forward to dropping DS.Models
- Identity Map, which is keyed of record identity objects instead of holding references to internal models
- User facing Store - class that most resembles todays Store which exposes finder methods to the user
- Query builder - a service which takes user queries such as `findRecord` and turns them into Orbit.js like query objects that can be passed around
- Fetching service - layer that takes user queries, relationship queries and save requests and decides whether they need fulfillment, and if so delegates to adapter/serialzier. Currently done by a mix of store and internal model.

Adapter, Serializer and Snapshots would not have major changes at this time, other than those needed to make use of the schema service and public apis for accessing records.

It is important to note that none of the existing public user apis would change, and that the bulk of this work is taking existing code structures and making the specified and isolated.

# Tactical plan

- Continue the Typescript conversion
- Implement packages RFC
- Cleanup Record Data

Write RFCs for:

- RecordIdentity
- Custom Record Classes
- Record Data incremental improvements for:
    - Internal Error storage
    - Record State RFC
- Schema Service
- Query builder

# Open questions

What level of future support should we commit ourselves to with the new apis?

# Downsides

- Exposing more intimate apis


---

---
stage: recommended
start-date: 2019-03-05T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/457
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/37
---

# Nested Invocations in Angle Bracket Syntax

## Summary

Create a syntax for invoking components nested inside of directories in angle-bracket syntax. The invocation `<AppIcons::Warning>` refers to the component `app/components/app-icons/warning.js` when using the default resolver, and looks up `component:app-icons/warning` in the container.

## Motivation

Today's angle-bracket syntax conversion guide says this:

![existing documentation](/images/457-when-to-use-curlies.jpg)

This has been an acceptable interim step as we have worked on completing the work of revamping the component model, but it's a source of incoherence (and a reported adoption blocker for some apps) in the Ember design, and we need to eliminate this source of incoherence in order to recommend angle bracket components in the Octane edition.

For positional arguments, we recommend that add-on authors migrate to named arguments. There is one exception to this rule: addons that are mimicking control-flow syntax (like `liquid-if`). These addons should clearly document that they are meant to be used with curly syntax.

For components nested inside of directories, this RFC proposes a new syntax to allow users to migrate directly to angle bracket invocation.

## Detailed design

> Note: This RFC uses curly syntax without blocks for illustrative purposes. In all cases, adding a block doesn't change the normalization or lookup rules described here.

When using curly syntax, component invocation looks like this:

```hbs
{{some-component some=parameters}}
```

If `some-component` is not a local variable in scope, the semantics of this invocation are:

1. look up `component:some-component` in the container
2. look up `template:components/some-component` in the container
3. invoke the component with its template (using the relevant component manager semantics)

When using angle-bracket syntax, the equivalent invocation looks like this:

```hbs
<SomeComponent @some={{parameters}}>
```

The syntax means the same thing, with one additional step:

1. **normalize `SomeComponent` into `some-component` using the dasherization rule specified in [RFC #311][angle-bracket-dasherize]**
2. look up `component:some-component` in the container
3. look up `template:components/some-component` in the container
4. invoke the component with its template (using the relevant component manager semantics)

[angle-bracket-dasherize]: https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#tag-name

Curly bracket syntax also allows the user to invoke a component nested inside of a directory. This syntax:

```hbs
{{app-icons/warning color="yellow"}}
```

has these semantics:

1. look up `component:app-icons/warning` in the container
2. look up `template:components/app-icons/warning` in the container
3. invoke the component with its template (using the relevant component manager semantics)

However, RFC #311 didn't specify an angle-bracket equivalent syntax for the same semantics.

This RFC proposes that the `::` separator serve the same purpose, with the same semantics, in angle-bracket notation:

```hbs
<AppIcons::Warning @color="yellow" />
```

---

This RFC is an extension to the **normalization** rules that already occur in angle bracket notation.

RFC #311 specified the normalization rules as:

> The tag name will be normalized using the dasherize function, which is the same rules used by existing use cases, such as service injections

This RFC amends the normalization rule by first replacing any occurrences of `::` in the tag name with a `/`, but otherwise doesn't change the semantics of RFC #311.

[RFC #143][module-unification], Module Unification, uses `::` as a package separator, but because of problems with scoped packages in npm, we no longer intend to use the `::` syntax in that way. Instead, we intend to allow templates to import components from other packages using import syntax, and the `::` syntax is therefore available for this purpose.

[module-unification]: https://emberjs.github.io/rfcs/0143-module-unification.html

## How we teach this

We currently don't cover directory nesting in the guides, and directory nesting is not an extremely early-stage Ember feature. That said, most Ember developers encounter a need or desire to group components together relatively quickly, and it does make sense to cover it.

RFC #311 introduced a normalization rule for angle bracket invocation, and the guides mention that `<NavBar>` invokes a component that appears in the file system as `nav-bar`.

![rental-listing in the docs](/images/457-dasherization.jpg)

After this RFC, the documentation should add a "Zoey says" sidebar that describes the rule in more detail, and mentions that you can refer to components nested in a directory with the `::` separator.

Finally, the goal of this RFC is to make it possible to recommend that users always use angle-bracket invocation for components other than control flow (`if`, `each`).

This means that we should update the syntax conversion guide to no longer say that `{{` syntax is sometimes required, and avoid recommending it.

We should also recommend that component authors who are using positional parameters (other than control flow components like `liquid-if`) should stabilize, document and recommend named argument for their parameters so that their users can uniformly use angle bracket invocation syntax.

## Drawbacks and Alternatives

This RFC introduces another normalization rule--Ember developers will need to understand that `::` refers to nested directories in the file system. It also introduces another divergence from the `{{` syntax, which already uses `/` for the same purpose.

Alternatively, we could use `/` as the separator for the same purpose. This would have the benefit of matching the idiomatic way that people describe file system nesting as well as matching the existing `{{` syntax.

On the other hand, it has poor syntax highlighting in virtually all existing highlighters:

```hbs
<AppIcons::Warning></AppIcons::Warning>
<AppIcons/Warning></AppIcons/Warning>
```

Additionally, some autocomplete systems assume that `<AppIcons/` is the beginning of a self-closing tag.

![an example of an IDE confusing this syntax as a self-closing tag](/images/457-autocomplete-problem.gif)

Another drawback of this proposal is that it uses `::` syntax for today's templates, and we don't expect that syntax to be relevant to templates using template imports. It's possible that we would want to use this syntax, which might be considered valuable, in templates using template imports. That said, there is no specific proposal for what we might want to use this syntax for, and we could compatibly reclaim it in the context of template imports, at the cost of some mental churn.

Another alternative is to recommend that people use `#let` with `(component)` in situations where nesting is required.

```hbs
{{#let (component 'app-icons/warning') as |Warning|}}
  <Warning></Warning>
{{/let}}
```

The primary drawback of this approach is that the need to group components together in directories comes up earlier in the typical Ember developer's experience than learning the ins and outs of `let` and the `component` helper. It seems likely that developers could encounter a desire to group components in directories even before they have a full understanding of `let` and block parameters.

Secondarily, this is a fairly verbose syntax that introduces a significant cliff from top-level components to grouped components.

Another alternative is to introduce a new non-block syntax for bringing components into scope, such as:

```hbs
{{resolve-component 'app-icons/warning' as Warning}}

<Warning></Warning>
```

This avoids introducing rightward drift, but it is still relatively verbose. It also creates a question that we would need to provide guidance on whether people should use this feature for all components or just nested ones (both sides have plausible arguments).

I also comes at the cost of creating a brand new way to bring variables into scope in Glimmer templates. Up to this point, we have carefully maintained the constraint that variables come into scope using nesting and `as |name|` syntax. While we might be willing to introduce new variable binding forms in the future, adding such a form to this proposal would significantly increase its design scope, and maintaining a small scope is a key goal of this RFC.

Another alternative is to avoid introducing a solution to this problem, and wait for the expected longer-term solution, template imports. While this is indeed expected to serve our longer-term goals, it would mean that Ember users couldn't use angle-bracket invocation, with all the benefits they bring, with nested components, or choose not to nest components at all.

On balance, it seems better to introduce an interim syntax that restores feature parity with curly invocation.


---

---
stage: recommended
start-date: 2019-03-05T00:00:00.000Z
release-date: 2019-05-13T00:00:00.000Z
release-versions:
  ember-source: v3.10.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/459
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/36
---

# Angle Bracket Invocations For Built-in Components

## Summary

[RFC #311](./0311-angle-bracket-invocation.md) introduced the angle bracket
component invocation syntax. Many developers in the Ember community have since
adopted this feature with very positive feedback. This style of component
invocation will become the default style in the Octane edition and become the
primary way component invocations are taught.

However, Ember ships with three built-in components – `{{link-to}}`, `{{input}}`
and `{{textarea}}`. To date, it is not possible to invoke them with the angle
bracket syntax due to various API mismatches and implementation details.

This RFC proposes some small amendments to these APIs and their implementations
to allow them to be invoked with the angle bracket syntax, i.e. `<LinkTo>`,
`<Input>` and `<Textarea>`.

## Motivation

As mentioned above, this will allow Ember developers to invoke components with
a consistent syntax, which should make it easier to teach.

This RFC _does not_ aim to "fix" issues or quirks with the existing APIs – it
merely attempts to provide a way to do the equivalent invocation in angle
bracket syntax.

## Detailed design

### `<LinkTo>`

There are two main problem with `{{link-to}}`:

* It uses positional arguments as the main API.
* It supports an "inline" form (i.e. without a block).

In the new world, components are expected to work with named arguments. This is
both to improve clarity and to match the HTML tags model (which angle bracket
invocations are loosely modelled after). Positional arguments are reserved for
"control-flow-like" components (e.g. `liquid-if`) and to be paired with the
curly bracket invocation style. Since links are not that, it is not appropiate
for this component to use positional params.

When invoked with a block, the first argument is the route to navigate to. We
propose to name this argument explicitly, with `@route`:

```hbs
{{#link-to "about"}}About Us{{/link-to}}

...becomes...

<LinkTo @route="about">About Us</LinkTo>
```

The second argument can be used to provide a model to the route. We propose to
name this argument explicitly, with `@model`:

```hbs
{{#let this.model.posts.firstObject as |post|}}

  {{#link-to "post" post}}Read {{post.title}}...{{/link-to}}

  ...becomes...

  <LinkTo @route="post" @model={{post}}>Read {{post.title}}...</LinkTo>

{{/let}}
```

In fact, it is possible to pass multiple models to deeply nested routes with
additional positional arguments. For this use case, we propose the `@models`
named argument which accepts an array:

```hbs
{{#let this.model.posts.firstObject as |post|}}
  {{#each post.comments as |comment|}}

    {{#link-to "post.comment" post comment}}
      Comment by {{comment.author.name}} on {{comment.date}}
    {{/link-to}}

    ...becomes...

    <LinkTo @route="post.comment" @models={{array post comment}}>
      Comment by {{comment.author.name}} on {{comment.date}}
    </LinkTo>

  {{/each}}
{{/let}}
```

The singular `@model` argument is a special case of `@models`, provided as a
convenience for the common case. Passing both `@model` and `@models` will be an
error. Passing insufficient amount of models for the given route, will continue
to be an error.

It is also possible to pass query params to the `{{link-to}}` component with
the somewhat awkward `(query-params)` API. We propose to replace it with a
`@query` named argument that simply take a regular hash (or POJO):

```hbs
{{#link-to "posts" (query-params direction="desc" showArchived=false)}}
  Recent Posts
{{/link-to}}

...becomes...

<LinkTo @route="posts" @query={{hash direction="desc" showArchived=false}}>
  Recent Posts
</LinkTo>
```

Finally, as mentioned above, `{{link-to}}` supports an "inline" form without a
block. This form doesn't bring much value and causes confusion around
the ordering of the arguments. We propose to simply not support this for the
angle bracket invocation style:

```hbs
{{link-to "About Us" "about"}}

...becomes...

<LinkTo @route="about">About Us</LinkTo>
```

Other APIs of this compoment are already based on named arguments.

#### Migration Path

We would provide a codemod to convert the old invocation style into the new
style.

#### Template Lints

Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, `{{link-to}}` would still work and
invoke the same component.

We propose to add template lint rules to using this component with the curly
invocation style.

### `<Input>`

Today, the `{{input}}` component is internally implemented as several internal
components that are selected based on the `type` argument. This is intended as
an internal implementation detail, but as a result, it is not possible to invoke
the component with `<Input>` since it does not exist as a "real" component.

We propose to change this internal implementation strategy to make it possible
to invoke it with angle brackets just like any other components.

For example:

```hbs
{{input type="text" value=this.model.name}}

...becomes...

<Input @type="text" @value={{this.model.name}} />
```

Another example:

```hbs
{{input type="checkbox" name="email-opt-in" checked=this.model.emailPreference}}

...becomes...

<Input @type="checkbox" @name="email-opt-in" @checked={{this.model.emailPreference}} />
```

#### Migration Path

We would provide a codemod to convert the old invocation style into the new
style.

#### Template Lints

Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, `{{input}}` would still work and
invoke the same component.

We propose to add template lint rules to using this component with the curly
invocation style.

### `<Textarea>`

Due to a similar implementation issue, it is also not possible to invoke the
`{{textarea}}` component with angle bracket invocation style.

We propose to change this internal implementation strategy to make it possible
to invoke this with angle brackets just like any other components.

For example:

```hbs
{{textarea value=this.model.body}}

...becomes...

<Textarea @value={{this.model.body}} />
```

#### Migration Path

We would provide a codemod to convert the old invocation style into the new
style.

[RFC #176](./0176-javascript-module-api.md) picked `text-area`/`TextArea` for
this component. To prevent confusion, we will add a helpful hint to the error
message ("did you mean `<Textarea>`?") when a user mistakenly typed
`{{text-area}}` or `<TextArea>` in development mode.

#### Template Lints

Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, `{{textarea}}` would still work and
invoke the same component.

We propose to add template lint rules to using this component with the curly
invocation style.

## How we teach this

Going forward, we will focus on teaching the angle bracket invocation style as
the main (only?) way of invoking components. In that world, there wouldn't be
anything extra to teach, as the invocation style proposed in this RFC is not
different from any other components, which is the purpose of this proposal. Of
course, the APIs of these components will still need to be taught, but that is
not a new change.

The only caveat is that, since the advanced `<LinkTo>` APIs require passing
arrays and hashes, the `{{array}}` and `{{hash}}` helper would have to be
taught before those advanced features can be introduced. However, since the
basic usage (linking to top-level routes) does not require either of those
helpers, it doesn't really affect things from a getting started perspective.

It should also be mentioned that, other built-ins, such as `{{yield}}`,
`{{outlet}}`, `{{mount}}`, etc are considered "keywords" not components, they
are also "control-flow-like", so it wouldn't be appropiate to invoke them with
angle brackets.

The technical implementation of this RFC will need to be accompanied by changes to the API docs for the built-in template helpers, [link-to](https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/link-to?anchor=link-to) and [input](https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/input?anchor=input). In keeping with past decisions for Angle Brackets, the API docs should show both curly and Angle Bracket invocations of these helpers. The API docs are expected to show the full supported API surface of Ember.

`link-to` and `input` are used liberally throughout the Ember.js Guides, Tutorial, and `super-rentals` [sample app](https://github.com/ember-learn/super-rentals), so those examples will need to be updated. In the Guides, we want to show solely Angle Brackets invocation. The [syntax conversion guide](https://guides.emberjs.com/release/reference/syntax-conversion-guide/) should be revised to include these helpers.
## Drawbacks

None.

## Alternatives

* `<LinkTo>` could only support `@models` without special casing `@model` as a
  convenience.

* `<LinkTo>` could support a `@text` argument for inline usage.

* `<Textarea>` could be named `<TextArea>`.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2019-03-06T00:00:00.000Z
release-date: 2021-02-08T00:00:00.000Z
release-versions:
  ember-source: v3.25.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/460
project-link:
---

# Yieldable Named Blocks

## Summary

This RFC amends [#226 (named blocks)][named-blocks] to finalize the syntax of named blocks and reduce the scope of the feature.

[named-blocks]: https://emberjs.github.io/rfcs/0226-named-blocks.html

## Motivation

The original named blocks RFC (#226) defined a mechanism for passing multiple blocks to a component, as well as semantics for capturing the block in JavaScript.

Since #226, RFC [#311 (angle bracket invocation)][angle-bracket] repurposed the original syntax for invocation.

```hbs
<Tab>
  <@header></@header>
</Tab>
```

In #226, the above syntax passed a named block called `@header` to the `Tab` component. RFC #311 repurposed that syntax to mean "invoke the component located at `@header` in the default block of `Tab`".

Curly bracket components already support two blocks (the default block and the `else` block), while angle bracket components, as implemented today in Ember, only support a single default block.

While RFC #226 predates a formal RFC about angle bracket components, it speculates significantly about usage in angle bracket components, and is heavily motivated by the desire to support more than a single block in that context.

That said, #226 included significant additional scope beyond allowing angle bracket invocations to pass more than one block, including:

- using `<@name>` as a syntax for passing named blocks to curly components
- passing named blocks as `@name` variables, accessible in the receiving component as `@blockName`
- capturing named blocks in JavaScript using `this.blockName`, as well as capturing named blocks in JavaScript by forwarding them into JavaScript as a parameter to a helper or another named argument.

While versions of those features are all desirable, the RFC, in total, had a fairly large scope and also speculated a lot about the future of angle bracket components which would not be approved until RFC #311.

This RFC proposes a version of named blocks with a smaller scope, with a plan to reintroduce the other goals of the original named blocks RFC in a subsequent RFC.

> Note: The version of named blocks described in this RFC has already been implemented in Glimmer VM.

[angle-bracket]: https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html

## Detailed design

> The detailed design of this RFC assumes a starting point without RFC #226, and describes the functionality in terms of RFC #311.

When invoking a component with angle bracket syntax, the content between the starting tag and the ending tag is passed as a block to the receiving component.

This means that the receiving component can invoke the block using `{{yield}}`. The block is not exposed to JavaScript at all, and it may only be invoked in the body of the receiving component's template.

On their own, blocks provide useful functionality. For example, consider an `Article` component that takes a `@body` argument:

```hbs
<Article @body={{this.body}} />
```

The `Article` component could be implemented this way:

```hbs
<article>
  <section>{{@body}}</section>
</article>
```

This works, but what if you want to include HTML functionality or use helpers. In that case, you could use a block:

```hbs
<Article>
  <div class='byline'>{{byline this.author}}</div>
  <div class='body'>{{this.body}}</div>
</Article>
```

The `Article` component could then be implemented by using `{{yield}}` to invoke the block:

```hbs
<article>
  <section>{{yield}}</section>
</article>
```

But what if we also want the ability to pass a title to the component. We could use a `@title` argument:

```hbs
<Article @title={{this.title}}>
  <div class='byline'>{{byline this.author}}</div>
  <div class='body'>{{this.body}}</div>
</Article>
```

Implemented this way:

```hbs
<article>
  <header>{{@title}}</header>
  <section>{{yield}}</section>
</article>
```

Again, that works, but if you want to use any of the block features, such as the ability to use HTML, you can't pass a second block.

This RFC introduces the ability to pass any number of blocks to a component. With that capability, you could call `Article` this way:

```hbs
<Article>
  <:title>
    <h1>{{this.title}}</h1>
  </:title>
  <:body>
    <div class='byline'>{{byline this.author}}</div>
    <div class='body'>{{this.body}}</div>
  </:body>
</Article>
```

And implement it this way:

```hbs
<article>
  <header>{{yield to='title'}}</header>
  <section>{{yield to='body'}}</section>
</article>
```

### Block Parameters

Just like normal blocks, named blocks can take block parameter, which are passed via `yield`.

```hbs
<Article @article={{this.article}}>
  <:header as |title|>
    <h1>{{title}}</h1>
  </:header>
  <:body as |body|>
    <div>{{body}}</div>
  </:body>
</Article>
```

```hbs
<article>
  <header>{{yield @article.title to='header'}}</header>
  <section>{{yield @article.body to='body'}}</section>
</article>
```

To summarize, today's Ember allows all components to pass a default block, and curly components to pass a default block and an `inverse` block. Component templates can invoke default templates by using `{{yield}}` and `else` templates by using `{{yield to='inverse'}}`.

This RFC introduces a new syntax for passing arbitrary blocks to angle bracket components that can be invoked by the receiving component using the same `yield` syntax.

### Syntax

This RFC proposes an extension to the angle bracket invocation syntax.

From:

```
AngleBracketInvocation :
  | AngleBracketWithBlock
  | AngleBracketWithoutBlock

AngleBracketWithBlock :
  "<" ComponentTag ComponentArgs? BlockParams? ">"
  Block
  "</" ComponentTag ">"

AngleBracketWithoutBlock :
  "<" ComponentTag ComponentArgs? "/>"
```

To:

```
AngleBracketInvocation :
  | AngleBracketWithBlocks
  | AngleBracketWithBlock
  | AngleBracketWithoutBlock

AngleBracketWithBlock :
  "<" ComponentTag ComponentArgs? BlockParams? ">"
  BlockBody
  "</" ComponentTag ">"

AngleBracketWithBlocks :
  "<" ComponentTag ComponentArgs? ">"
  NamedBlock+
  "</" ComponentTag ">"

NamedBlock :
  | "<:" Identifier "/>"
  | "<:" Identifier BlockParams? ">" BlockBody "</:" Identifier ">"

AngleBracketWithoutBlock :
  "<" ComponentTag ComponentArgs? "/>"

ComponentTag :
  | Identifier ; when ident is in scope variable
  | Path
  | AtName
```

A component invocation has named blocks if the first non-whitespace token after the invocation's closing `">"` is `"<:"`. In that case, the whitespace around the named blocks is ignored. Otherwise, the contents between `">"` and `"</"` are the default block.

This RFC does not propose an extension to curly syntax, although a future extension to curly syntax is expected.

### Semantics

A named block in angle bracket invocation has identical semantics to the `inverse` block created by `{{else}}`. It is invoked in the receiving component by `{{yield to='<Identifier>'}}`. Block parameters may appear after `<:identifier` as `<:identifier as |block params|>`, and they are passed by the receiving component through positional parameters to `{{yield}}`.

In all observable ways, named blocks passed by angle bracket components behave like the `inverse` block passed by curly components.

This includes `has-block` and `has-block-params`, which take the name of the block as a parameter.

This RFC intentionally does not reify the block as an argument, either as an `@name` or into JavaScript. A future RFC is expected to specify and describe this kind of capturing semantics.

[glimmer-component]: https://emberjs.github.io/rfcs/0416-glimmer-components.html

## How we teach this

This feature could be taught by example, using a situation where multiple blocks are relevant.

For example, the guides could describe an accordion widget, with two named blocks:

```hbs
<Article>
  <:title>This article is awesome!</:title>

  <:body>
    My blog has very awesome content, and everyone should
    read it.
  </:body>
</Article>
```

It should be taught after `yield`, so that describing how to implement a component that uses named blocks can lean on the existing knowledge of `yield`.

```hbs
<div class="accordion">
  <h1>{{yield to='title'}}</h1>
  <div class="body">{{yield to='body'}}</div>
</div>
```

## Drawbacks

This feature introduces the concept of arbitrary named blocks, which adds cognitive overhead to the component model. On the other hand, it leans on the existing concept of blocks, including the existing well-trod syntax for block parameters and yielding.

Unlike the original #226, this RFC chooses not to provide a counterpart to this feature in curly components. RFC #226 used angle-bracket syntax inside of curly components for specifying named blocks:

```hbs
{{#await this.article}}
  <@loaded as |article|>
    <article>
      <header><h1>{{article.title}}</h1></header>
      <section>{{article.body}}</section>
    </article>
  </@loaded>
  <@error as |reason|>
    <p class='error'>Couldn't load article: {{reason}}</p>
  </@error>
  <@loading>
    <img src="/assets/loading.gif">
  </@loading>
{{/await}}
```

This was always a strange syntax, and this RFC prefers to consider alternatives once named blocks in angle bracket syntax has been absorbed.

Additionally, it might make sense to support named blocks together with `else`, and defining the semantics for that behavior requires additional design.

One possible design contemplated by the authors of this RFC would look something like:

```hbs
{{#await this.article}}
{{when :loaded}}
  <article>
    <header><h1>{{article.title}}</h1></header>
    <section>{{article.body}}</section>
  </article>
{{when :error}}
  <p class='error'>Couldn't load article: {{reason}}</p>
{{else}}
  <img src="/assets/loading.gif">
{{/await}}
```

In this design, the `else` block would be rendered if none of the other named blocks were rendered, which is similar to the semantics of `{{#each}}`, which invokes the `else` block if the block passed to `#each` is never invoked (because the iterator had no values).

This design could make sense if curly invocation ends up being useful in the long-term for control flow (equivalent to `if`, `let` and `each`). The idea would be that in curly invocation, only one of the cases is expected to be invoked at a time, and if none of the cases are invoked, the `else` block is invoked.

This is just one possible design for curlies, but it is a possible design that the RFC authors believe should be explored separately.

## Alternatives

This RFC chooses not to specify "block capturing", which is useful for features like `ember-elsewhere`. It's a genuinely useful feature that we expect to be specified in the future. However, that design is orthogonal to the use-cases anticipated by yieldable named blocks.

We could wait for a complete design on either (a) named blocks in curly components or (b) capturable named blocks. However, we believe that there's enough standalone value in this RFC to justify shipping it before finalizing either of those two designs.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-03-06T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/461
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/51
---

# Singleton Record Data

## Summary

Ensures that `RecordData` can be implemented as a singleton, eliminates several redundant APIs
that creeped into the original implementation, and simplifies the method signatures of
RecordData APIs by using [`Identifiers`](https://github.com/emberjs/rfcs/pull/403).

## Motivation

`RecordData` is the data-cache primitive for information given to `ember-data`, and while
a cache-per-entity setup is sometimes desired, a singleton cache offers opportunities for
performance optimization and improved feature sets. Current default `RecordData`, and
`InternalModel` which it replaced are examples of cache-per-entity strategies.

Our original intent [when discussing `RecordData`](https://github.com/emberjs/rfcs/pull/293)
was for it to be possible to be implemented as a singleton; however, this intent was not
captured well in that RFC and while the APIs presented there would have enabled it, the
actual implementation differed in ways that prevent `singleton` implementations.

The introduction of `Identifiers` presents us with a good opportunity to refactor the API
surface of our cache-primitive, simplifying and streamlining how it works while solidifying
and codifying its ability to be a `singleton`.

### Reduce Overloading

Previously, to deal with the lack of a unified identifier concept, we overloaded many
`StoreWrapper` and `RecordData` method signatures with `modelName, id, clientId` as
`arguments`. The original intent was to overload **all** of their method signatures
in this way to ensure `singleton` implementations could be built, but we failed to
correctly implement the original `RecordData RFC` in this regard.

The introduction of `Identifiers` provides us a cleaner interface for communicating identity
in these APIs. For uniformity, methods will always take an `identifier` as their **first
argument**.

## Detailed design

Because `RecordData` is a public userland interface we
must rely on capabilities reporting to handle the
deprecations for it introduced by this RFC.

We will use this opportunity to improve the encapsulation
of `RecordData` via introduction of a sandbox.

This sandbox will be responsible for handling interop,
deprecations and other book-keeping tasks we require as needed
while ensuring that `RecordData` implementations are properly
encapsulated (e.g. implementations can only talk to other
implementations via public API).

RecordData implementations must now specify a `version`.
The implicit version when unspecified is `"1"` (the version
which this RFC supplants and deprecates). Implementations
without a version or with a version equal to `"1"` will
receive a deprecation notice the first time an instance of
a previously unseen `RecordData` class is encountered.

In keeping with the support policy of `Ember.js`, future
releases of `ember-data` will support the versions of `RecordData`
current at the time of the last two `ember-data` `LTS` releases.

The APIs proposed by this RFC constitute version `"2"`
and will be used by `ember-data` when the following is
`true`.

```js
recordData.version === "2";
```

It is possible that once this upgrade to `identifiers` has occurred that we never need to
increment this `version` again. If so, a future RFC may choose to deprecate the `version`
property altogether once "version 1" is no longer supported.

### Sandboxing

The sandbox implementation would guarantee the following

Beginning with this RFC, `StoreWrapper.recordDataFor` will no longer directly return the `RecordData`
instance provided by the `createRecordDataFor` hook, instead returning a delegate.

This encapsulates the `RecordData` feature ensuring that communication is via public API
and provides us the ability to manage the three concerns listed above and described below.

**Managing Deprecations**

When a `RecordData` method or method signature is deprecated, we will detect calls to deprecated
methods or calls using deprecated method signatures and print the appropriate deprecation messages.

**Version Interop**

When a `RecordData` method or method signature is deprecated the instance provided by `createRecordDataFor`
may not have implemented the deprecated method or signature. Using the supplied version, calling context,
and other information available we will transform calls to deprecated methods or signatures
into their supported equivalent.

**Updates to Store Methods**

<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td width="50%" valign="top">

```ts
class Store {
  createRecordDataFor(
    modelName: string,
    id: string,
    clientId: string | null,
    storeWrapper
  ): RecordData;
  createRecordDataFor(
    modelName: string,
    id: null,
    clientId: string,
    storeWrapper
  ): RecordData {}
}
```

</td>
<td valign="top">

```ts
class Store {
  createRecordDataFor(identifier: RecordIdentifier, storeWrapper): RecordData {}
}
```

</td>
</tr>
</tbody>
</table>

**Updates to StoreWrapper Methods**

<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">

```ts
class RecordDataStoreWrapper {
  recordDataFor(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): RecordData {}

  notifyPropertyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  notifyHasManyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  notifyBelongsToChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  attributesDefinitionFor(modelName: string): AttributesSchema {}

  relationshipsDefinitionFor(modelName: string): RelationshipsSchema {}

  setRecordId(modelName: string, id: string, clientId: string): void {}

  disconnectRecord(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): void {}

  @deprecated // Use hasRecord
  isRecordInUse(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): boolean {}

  inverseForRelationship(modelName: string, key: string): string {}
  inverseIsAsyncForRelationship(modelName: string, key: string): boolean {}
}
```

</td>
<td valign="top">

```ts
class RecordDataStoreWrapper {
  recordDataFor(identifier: RecordIdentifier): RecordData {}

  @deprecated // use notifyChange instead
  notifyPropertyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  @deprecated // not in the original RFC, use notifyChange instead
  notifyHasManyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  @deprecated // not in the original RFC, use notifyChange instead
  notifyBelongsToChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  // replaces notifyErrorsChange introduced by RecordData Errors RFC
  notifyChange(
    identifier: RecordIdentifier,
    namespace: "errors" | "relationships" | "attributes" | "meta" | "state"
  ): void {}

  attributesDefinitionFor(identifier: RecordIdentifier): AttributesSchema {}

  relationshipsDefinitionFor(
    identifier: RecordIdentifier
  ): RelationshipsSchema {}

  setRecordId(identifier: RecordIdentifier, id: string): void {}

  disconnectRecord(identifier: RecordIdentifier): void {}

  @deprecated // Use hasRecord
  isRecordInUse(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): boolean {}

  hasRecord(identifier: RecordIdentifier): boolean {}

  inverseForRelationship(identifier: RecordIdentifier, key: string): string {}
  inverseIsAsyncForRelationship(
    identifier: RecordIdentifier,
    key: string
  ): boolean {}
}
```

</td>
</tr>

</tbody>
</table>

**Updates to RecordData Methods**

<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">

```ts
interface LegacyResourceIdentifierObject {
  type: string;
  id: string | null;
  clientId: string | null;
}

interface RecordDataV1 {
  unloadRecord(): void;

  @deprecated // This RFC deprecates this method without replacement. It was not in
  // the original RecordData RFC and after investigation is unneeded once the singleton
  // and identifiers refactoring are completed.
  isRecordInUse(): boolean;
  isEmpty(): boolean;
  isNew(): boolean;

  getAttr(propertyName: string): any;
  isAttrDirty(propertyName: string): boolean;
  changedAttributes(): AttributesChanges;
  hasChangedAttributes(): boolean;
  rollbackAttributes(): void;

  @deprecated // this RFC deprecates this method entirely
  getBelongsTo(propertyName: string): { data: LegacyResourceIdentifierObject };
  @deprecated // this RFC deprecates this method entirely
  getHasMany(propertyName: string): { data: LegacyResourceIdentifierObject[] };

  willCommit(): void;
  didCommit(data: any): void;

  @deprecated // this RFC deprecates this method entirely
  _initRecordCreateOptions(options: object): object;
  clientDidCreate(): void;

  @deprecated // this RFC deprecates this method entirely and without replacement
  getResourceIdentifier(): LegacyResourceIdentifierObject;

  // original RecordData RFC specified setBelongsTo
  // with the 2nd arg being LegacyResourceIdentifierObject
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyBelongsTo(propertyName: string, value: RecordData | null): void;

  // original RecordData RFC specified setAttribute
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyAttribute(propertyName: string, value: any): void;

  // original RecordData RFC specified setHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyHasMany(propertyName: string, value: RecordData[]): void;

  // original RecordData RFC specified addToHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  addToHasMany(propertyName: string, values: RecordData[], startIndex?: number): void;

  // original RecordData RFC specified removeFromHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  removeFromHasMany(propertyName: string, values: RecordData[]): void;

  @deprecated // this RFC deprecates this method entirely and without replacement
  removeFromInverseRelationships(isNew: boolean): void;
}
```

</td>
<td valign="top">

```ts
interface RecordDataV2 {
  version: "2";
  unloadRecord(identifier: Identifier);
  isEmpty(identifier: Identifier): boolean;
  isNew(identifier: Identifier): boolean;

  getAttr(identifier: Identifier, propertyName: string): any;
  isAttrDirty(identifier: Identifier, propertyName: string): boolean;
  changedAttrs(identifier: Identifier): AttributesChanges;
  hasChangedAttrs(identifier: Identifier): boolean;
  rollbackAttrs(identifier: Identifier): void;

  getRelationship(
    identifier: Identifier,
    propertyName: string
  ): { data: Identifier | Identifier[] };

  willCommit(identifier: Identifier): void;
  didCommit(identifier: Identifier, data: any);

  clientDidCreate(identifier: Identifier, options: object): void;

  setBelongsTo(
    identifier: Identifier,
    propertyName: string,
    value: Identifier | null
  ): void;

  setAttr(identifier: Identifier, propertyName: string, value: any): void;

  setHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[]
  ): void;

  addToHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[],
    startIndex?: number
  ): void;

  removeFromHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[]
  ): void;
}
```

</td>
</tr>

</tbody>
</table>

## How we teach this

`RecordData` is primarily an API meant for power-user addon-authors,
and not something we expect everyday users of `ember-data` to be intimately
familiar with. It is unlikely that we produce a `guide` for using `RecordData`, but
a public `typescript` interface for `RecordData` should be introduced with
API Documentation for the available APIs and their roles.

## Drawbacks

It introduces churn in APIs we only recently introduced (in the past 6 months); however we have
strong reason to believe that very few implementations exist and that those which do have their
migration path covered by the sandboxed RecordData implementation.

## Alternatives

- keep the status quo: large number of arguments to methods, no support for singleton RecordData,
  renders `Identifier` RFC largely useless and makes future iteration on RecordData similarly difficult.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-03-13T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/463
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/47
---

# Record State on Record Data RFC


## Summary

This RFC is a follow-up RFC for #293 RecordData.

Add `isNew` , `isDeleted` and `isDeletionPersisted` methods on Record Data that expose information about newly created and deleted states on the record

## Motivation

RecordData handles managing local and server state for records. While the current API surface of RecordData handles most data wrangling needs, as we have used RD internally in ED and in addons we have repeatedly run into the need of knowing whether a record is in a new or a deleted state.  The initial version of Record Data made the choice to not expose state information in order to limit the scope of the RFC and to give us time to come up with a design.

## Detailed design

Add the following methods on the RecordData interface:

```ts
interface RecordData {

  // To be added in this RFC
  isNew(identifier: RecordIdentifier): boolean

  isDeleted(identifier: RecordIdentifier): boolean

  isDeletionCommitted(identifier: RecordIdentifier): boolean

  setIsDeleted(identifier: RecordIdentifier, boolean: isDeleted): void
}
```

`isNew` should return true if and only if the record with the given identifier was created on the client side (via clientDidCreate) and not successfully committed on the server, otherwise false.

`isDeleted` should return true if and only if the record has been marked for deletion on the client side, otherwise false

`isDeletionPersisted` should return true if and only if the record had been marked for deletion and that deletion has been successfully persisted, otherwise false.

The TS interface for the all of Record Data with the new methods can be be found [here](https://github.com/emberjs/data/blob/igor/record-data-state-interface/packages/store/addon/-private/ts-interfaces/record-data.ts#L13).

In order to notify changes to the state flags we would also add a notification method to the store wrapper which is passed to RecordData:

```ts
interface RecordDataStoreWrapper {
  notifyStateChange(identifier: RecordIdentifier, key: 'isNew' | 'isDeleted' | 'isDeletionPersisted');
}
```

Which would bring Record Data Store Wrapper to look like:

```ts
export interface RecordDataStoreWrapper {
  // This rfc
  notifyStateChange(identifier: RecordIdentifier, key: 'isNew' | 'isDeleted' | 'isDeletionPersisted');

  // Existing
  notifyAttributeChange(identifier: RecordIdentifier, key: string);
  notifyRelationshipChange(identifier: RecordIdentifier, key: string);
  notifyErrorsChange(identifier: RecordIdentifier, key: string);

  relationshipsDefinitionFor(identifier: RecordIdentifier): RelationshipsSchema
  attributesDefinitionFor(identifier: RecordIdentifier): AttributesSchema
  setRecordId(identifier: RecordIdentifier, id: string);
  disconnectRecord(identifier: RecordIdentifier);
  isRecordInUse(identifier: RecordIdentifier): boolean;
}
```

Currently calling `rollbackAttributes` rolls back `isDeleted` to a non deleted state. This logic would be the responsibility of Record Data to implement.

## How we teach this
We currently do not have a comprehensive way to teach RecordData api. This RFC will be tought alongisde the rest of upcoming Record Data docs.


## Alternatives

Instead of separate methods, have a single methods, somehting like `getState` that returns a POJO with keys like

    { isDeleted: true, isNew: false }


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-03-13T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/465
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/46
---

# Record Data Errors RFC

## Summary

This RFC is a follow-up RFC for #293 RecordData.

Exposes the content of Invalid Errors returned by the adapter on Record Data.

## Motivation

Currently Record Data manages and exposes all of the attributes and relationships for a record. However, the initial version of Record Data made the choice to not expose error information in order to limit the scope of the RFC and to give us time to come up with a design. This RFC, together with the Request State RFC, addresses this capability gap.

When a user sends a record save request, it can fail in two different ways:

- It can fail as a generic Adapter Error, and put the record in an `isError` state. This corresponds to any failure, including those such as the network being down, server returning 500s or the auth layer returning a 401. Because these errors are not tied to the Record or it's data, they do not belong in the Record Data layer and will be exposed separately as part of the Request State RFC
- However, the request can also fail with a more specific `InvalidError` This currently puts the record in the `invalid` state. `InvalidError` corresponds to a specific validation failure of the request being made. Currently, the default adapter implementation creates an `InvalidError` if the server returns a `422` . `InvalidError` payload follows the JSON API error object spec, and if the error payload contains pointers those get mapped to attributes on a record. Because an Invalid Error maps to the data on a record, it should be managed by Record Data together with the attributes and relationships.

## Detailed design

Currently on a failed save, Record Data receives a call to

`commitWasRejected(recordIdentifier: RecordIdentifier): void;`

This RFC proposes passing an optional errors object that would follow a subset of the JSON api errors spec, only in case an invalid error has been returned. We would also expose a getter for the errors.

```ts
interface RecordValidationError {
  title: string;
  detail: string;
  source: {
    pointer: string;  <relative to record>
  }
}

interface RecordData {
  commitWasRejected(recordIdentifier: RecordIdentifier, errors?: RecordValidationError[]): void;
  getErrors(recordIdentifier: RecordIdentifier): RecordValidationError[]
}
```

`RecordValidationError` follows the subset of the JSON api errors spec. For example, if the record being saved was rejected because the attribute `password` was empty, the `RecordValidationError` could look like:

```ts
{
  title: 'Field cant be empty',
  detail: 'Field must be at least 8 characters long',
  source: {
    pointer: 'attributes/password'
  }
}
```

The source pointer is a JSON pointer relative to the Resource Object.

We would also add a method on the `RecordDataStoreWrapper` to enable Record Data to notify the store that the errors properties have changed.
```ts
class RecordDataStoreWrapper {
  notifyErrorsChange(recordIdentifier: RecordIdentifier)
}
```

There would be no api for changing the errors from the client side, they would be read only from the perspective of the `DS.Model`  Currently `DS.Model`  exposes an `Errors` object, which has the behavior of removing errors if an attribute has been modified. This behavior would not be the responsibility of the `RecordData` layer which is tasked only with exposing the errors it received from the server and would remain an implementation detail of `DS.Model`

## How we teach this

We currently do not have a comprehensive way to teach the RecordData api. This RFC will be taught alongisde the rest of upcoming Record Data docs.

## Alternatives

We could add a method to `RecordData` to make the errors setable from the model, something like `setErrors`. However, conceptually, because updated errors don't get sent back to the server they shouldn't be managed by the data cache layer. Removing or updating Error values should be the responsibility of the Model or UI layer.



---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-03-09T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/466
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/52
---

# Request State Service


## Summary

Currently, Ember Data internally uses a complicated state machine abstraction to help records keep track of what state they are in and expose state flags. A lot of those flags try to expose request state. Instead of relying on a complicated inflexible state machine, this RFC proposes exposing a Request State service which would expose inflight and completed requests.

# Motivation

Currently DS.Model has several flags that expose information about either inflight requests or completed requests. `isReloading` and `isSaving` expose inflight request state, while `isLoaded`, `isValid`, `isError`, expose state about the last completed request. While these flags are very convenient, the have several drawbacks:

- They rely on Ember Data's internal state machine which is not app controllable and is very inflexible
- They assume a single source, and as we try to support more advanced use cases will prove insufficient. For example, if you are saving records both in IndexDB and on the backend, `isSaving` as a flag is insufficient.

This RFC proposes creating a RequestState service which would allow us to rewrite the current flags as helper methods and move us away from the internal state machine implementations. It would also allow users to handle cases not covered by the rigid model flags, and give us a place to experiment with a multi source approach. Moreover, such a service would also allow for a better debugging experience and could be easily exposed in the Ember Inspector, allowing for a much nicer debugging experience compared to the existing Promises tab.

## Detailed design

This RFC exposes the minimal necessary set of APIs needed to reimplement the existing flags on DS.Models. In particular, it only covers requests pertaining to `findRecord` , `reload`

and `save` methods. Those are also easier to design and implement because they match up to a single record and don't require a more complex `Query` interface. We would expect RequestState Services scope of responsibility to grow in the future to where it would handle all of requests.

Design of the RequestState service:

```ts
// no id yet
interface Request {
  data: RequestOperation[];
}

interface RequestOperation {
  op: string
}

interface FindRecordRequestOp extends RequestOperation {
  op: 'findRecord'
  recordIdentifier: RecordIdentifier
  options: : { [k: string]: any }
}

interface SaveRecordRequestOp extends RequestOperation {
  op: 'saveRecord'
  recordIdentifier: RecordIdentifier
  options: : { [k: string]: any }
}

interface RequestState {
  state: 'pending' | 'fulfilled' | 'rejected'
  type: 'query' | 'mutation'
  request: Request;
  response?: Response;
}

interface Response {
  rawData: unknown;
  data: unknown;
}


// exported from '@ember-data/store';
function unsubscribe(token: UnsubscribeToken): void

interface NotificationCallback {
  (request: RequestState): void;
}

class RequestStateService {
  getPendingRequestsForRecord(recordIdentifier: RecordIdentifier): RequestState[]
  getLastRequestForRecord(recordIdentifier: RecordIdentifier): RequestState | null
  subscribeForRecord(recordIdentifier: RecordIdentifier, callback: NotificationCallback): UnsubscribeToken
  unsubcribe(token: UnsubscribeToken): void
}
```

The subscription methods are needed in order the model to learn about changes to network states. Once tracked properties exposes a public way for manipulating Tags, we will likely be able to move away from the subscription mechanism to a nicer notification mechanism.

Expose a service on the store

```ts
class Store {
  getRequestStateService(): RequestStateService
}
```

Using these  we can reimplement the current `isSaving` method on `DS.Model`

The subscription mechanism is deliberately somewhat klunky in anticipation of replacing it with an automatic tracked properties solution.

```ts
DS.Model.extend({

  isSaving: computed(function () {
    let requests = this.store.getRequestStateService().getPending(this);
    return !!requests.find((req) => req.data.op === 'saveRecord');
  })

});
```

```ts
DS.Model.extend({
  isSaving: computed(function () {
    let requests = this.store.getRequestStateService().getPending(this);
    return !!requests.find((req) => req.data.op === 'saveRecord');
  })

});
```

## How we teach this

Initially we would write up the API docs for the request. Once several followup RFCs which made the design ergonomic and added other use cases,
we would write up a guide entry showing common ways to handle request based use cases with the request state service.

## Drawbacks

We are exposing more internal state as public api.

The subscription mechanism is not extremely ergonomic.

Exposing the raw results in request objects might lead to apps using the raw payloads and punching wholes through our existing api boundaries


---

---
stage: recommended
start-date: 2019-03-14T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
  - data
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/468
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/55
---

# `@classic` Decorator

## Summary

Add a set of warnings for users who adopt native class syntax with
`EmberObject` base classes, and a `@classic` decorator which can be used to
disable these warnings on a per-class basis.

## Motivation

As we've added native class support to Ember and moved forward with Ember
Octane, it's become increasingly clear that there are still a number of strange
behaviors, edge-cases, and other issues with adopting native class syntax and
extending from `EmberObject`. These issues include:

- The timings of `init` and `constructor`, and how the two can interact through
  a class hierachy in a way that causes confusing failures.
- The differences between class fields and properties, and how class fields can
  override properties even in a subclass.
- The use of Mixins, which lack a native class alternative, and can force users
  to interop and have even more failure cases.

Despite these edge cases, the community has made progress using native class
syntax, and it is absolutely necessary for some users (`ember-cli-typescript`
users in particular). The ability to transition progressively to a new syntax is
also very valuable, and allowing users to adopt native class syntax _without_
completely rewriting their classes means that they can upgrade one step at a
time.

However, as we begin to move into a world where more and more classes _don't_
extend from `EmberObject` (starting with `GlimmerComponent`), these edge cases
will become more common and confusing. It won't be enough to rely on simple
rules of thumb like "always use `init`" because in some cases, there won't _be_
an `init` method. It'll also become a question of "which class am I extending?
`GlimmerComponent`? `EmberComponent`?

This RFC proposes adding a `@classic` decorator which can be used on classes
that still use `EmberObject` APIs:

```js
import classic from 'ember-classic-decorator';

@classic
export default class ApplicationController extends Controller {
  init() {
    super.init(...arguments);
    // setup the controller class
  }
}
```

This decorator will:

1. Provide a visual hint to users that they class they are working on uses
   `EmberObject` specific functionality, and to be aware that they are not
   working with "just" native classes.
2. Provide a hint to _linters_ so that they can use a different set of rules for
   "classic" classes, such as always use `init`, etc. and native classes, such
   as to never use `.extend()` or mixins.
3. Disable a number of warnings that will alert users when they have encountered
   an edge case, such as using `init` in a parent class and `constructor` in a
   child class.

This should allow users who wish to adopt native class syntax to do so
incrementally, one change at a time, with as much safety as possible.

## Detailed design

There are roughly two categories of base classes in Ember:

1. Base classes which do not have alternatives, _and_ use a very minimal amount
   of `EmberObject` APIs
   - `Route`
   - `Controller`
   - `Service`
   - `Helper`
2. Base classes which have modern alternatives, _and_ use a much larger amount
   of `EmberObject` APIs:
   - `Component`, which can be converted to `GlimmerComponent`
   - Utility classes, which can be converted plain native classes that do not
     extend `EmberObject`

`@classic` will work slightly differently for these two categories. We'll call
them _transitionable_ and _non-transitionable_ respectively.

### Transitionable Base Classes

Transitionable base classes can be converted to native classes safely _without_
using any `EmberObject` APIs. Once converted, we can safely lint against using
any `EmberObject` APIs, preventing any future confusion. As such, it will only
be necessary to apply the `@classic` decorator for as long as any of the user's
own classes use `EmberObject` APIs. These include:

- `extend`
- `reopen` and `reopenClass`
- `init`
- `destroy`
- `proto`
- `detect`
- `get`/`set`

Along with any other extra methods or APIs that exist on `CoreObject` and
`EmberObject`. Methods and APIs that exist on the class itself, such as
`transitionTo` on Routes, or `send` and `sendAction` on Controllers, are _not_
considered `EmberObject` APIs, since they could be implemented purely in native
classes, and aren't tied to the way `EmberObject` does inheritance.

If a class, or any of its parent classes, uses one of these methods _without_
being decorated with `@classic`, a lint rule will log a warning to let users
know that they are using classic object APIs, and they should either refactor
away from using those APIs, or use the `@classic` decorator to opt-out of
warnings.

The `@classic` decorator itself will brand the class it is applied to, disabling
warnings on that instance of the class.

### Non-transitionable Base Classes

Non-transitionable base classes _cannot_ be converted to native classes without
relying on behaviors that are specific to `EmberObject`. Classic components, for
instance, rely deeply on the way that `EmberObject.create` sets up its instance,
and any utility class that extends from `EmberObject` _must_ use `create` to
create instances. While this is also true of `Route`s and `Service`s, the
important distinction is that _users_ don't have to ever use `create` in their
own code, or are not passed any arguments other than injections, so for those
classes the usage of `create` is an implementation detail.

These classes will _always_ warn users if they are not decorated with
`@classic`. In order to transition away the decorator, they must be converted
into newer base classes, such as `GlimmerComponent`, or away from base classes
entirely.

### Implementation

The decorator and the warnings would be added by an official Ember addon,
`ember-classic-decorator`. This would allow us to keep the implementation
details separate from the main Ember codebase, especially specifics like babel
transforms for stripping out the `@classic` decorator in production builds.

The `@classic` decorator should only be applied in DEBUG mode, and should be
stripped entirely from production builds. Other than that, the details of the
exact implementation is left up to the champions, though it should likely use
symbols to brand classes marked with the decorator.

## How we teach this

In the Working with JavaScript section of the guides, when we discuss both
native class syntax and classic class syntax, we should also provide a breakdown
of using native classes with objects that implement or use classic class APIs.
We can explain the usage of the `@classic` decorator here, along with clear
examples for how it should be applied, and what will warnings without it.

The warnings themselve should also link to this guide page, with a clear
explanation for _why_ the warning was triggered, and a link to a section on the
page that covers the specific API, and how to convert that API to use native
class syntax. In the case of Glimmer components and utility classes, the
sections should point to the more detailed Octane Edition guide, which covers
the various differences between classic and Glimmer components and classic and
native classes, and how to convert the two.

## Drawbacks

Adding the `@classic` decorator could encourage more usage of native classes
with `EmberObject`, which in turn could lead to even more confusion as users
attempt to navigate the edge cases in differences between native and classic
syntax. If the warnings provided by `@classic` are not strong enough, it could
result in a frustrating developer experience when the differences between the
two cause problems and failures.

## Alternatives

This RFC is taking the stance that:

1. Adopting native class syntax with `EmberObject` is valuable enough to a
   significant number of users that we should support it, and recommend it in
   some cases (such as for transitionable classes)
2. There are enough caveats with doing this that we must warn users of them in
   order to support it.

We could alternatively _not_ recommend using native class syntax with any class
that extends `EmberObject`, even Route/Controller/Service and other
transitionable classes, and wait until we have a pure native alternative to
transition to.

We could also not warn, if we believe the caveats are actually not that
problematic, and that users can figure out the details on their own without any
hinting.

### Built-in Instead of Addon

This RFC currently proposes adding `@classic` as a default addon, which will
allow us to keep its implementation separate from the main Ember codebase. This
could lead to users dropping it or not adding it to existing codebases, which
would in turn lead to users encountering failures without any warnings.


---

---
stage: recommended
start-date: 2019-03-20T00:00:00.000Z
release-date: 2019-06-24T00:00:00.000Z
release-versions:
  ember-source: v3.11.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/470
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/33
---

# `{{fn}}` Helper

## Summary

This RFC introduces a new helper, `{{fn}}`, to allow clear argument passing for functions in templates.

## Motivation

The current `action` helper has a lot of implicit and confusing behavior that is different than the Octane and post Octane programming model.

To understand the complexity of `action` there are many complex behaviors including:

1. Argument partial application (currying)
2. `this` context binding
3. `send` checks for Component and Controllers

At build time the `action` helper currently is passed through an AST transform to explicitly bind the `this` to be deterministic at runtime. This is a private API where the outputted Glimmer is not a 1-1 to the template. Also, the `action` helper is confused and has overlap with the `action` modifier which has similar but slightly different behavior.

Instead of this confusing and overloaded behavior, a new `fn` helper would be introduced to do partial application (with no need for build time private APIs), and context binding will be done instead using the `@action` decorator in classes.

## Detailed design

The `fn` helper will take in a function and then the set of arguments that will be partially applied to the function.

Here are some examples of the `fn` helper and the equivalent JS:

### Simple Case On Argument Curry

```hbs
{{fn this.log 1}}
```

```js
return function() {
  this.log.call(this, 1);
}
```

### Multiple Argument Partial Application

```hbs
{{fn this.add 1 2}}
```

```js
return function() {
  this.add.call(this, 1, 2);
}
```

The use of `function` application like so allows us to preserve/pass through the `this` context of the calling site accurately, so creating a function `fn` is equivalent to the same function _without_ args.

### Comparison to Action Helper/Modifier

```hbs
{{!-- Actions --}}
<button {{action "increment" 5}}>Click</button>
<button {{action this.increment 5}}>Click</button>
<button onclick={{action "increment" 5}}>Click</button>
<button onclick={{action this.increment 5}}>Click</button>
<button {{action (action "increment" 5)}}>Click</button>
<button {{action (action this.increment 5)}}>Click</button>

<button onclick={{fn this.increment 5}}>Click</button>
<button {{on "click" (fn this.increment 5)}}>Click</button>
```

### With `mut`

```hbs
{{!-- Actions --}}
<button {{action (mut showModal) true}}>Click</button>
<button onclick={{action (mut showModal) true}}>Click</button>
<button {{action (action (mut showModal) true)}}>Click</button>

<button onclick={{fn (mut showModal) true}}>Click</button>
<button {{on "click" (fn (mut showModal) true)}}>Click</button>
```

## How we teach this

For guides we would switch to recommending the `fn` helper to pass functions into components args and modifiers. We'll teach the helper as similar to the `hash` and `arr` helpers - `fn` returns a function with some arguments being passed to it.

In guides we would no longer recommend using the `action` helper based on the reasons listed in motivations.

## Drawbacks

* `fn` is not the clearest name, and could be difficult for users to understand.

## Alternatives

One alternative would be to continue using the `action` helper despite confusion and overloading behavior.

There are also a number of potential alternatives for names:

* `args` - A shorter, simpler name with similar properties. This is somewhat less self-explanatory (on its own, without context, one might think it refers to component args, or does something with them), but may make up for this by being short and simple.
* `bind` - The original name this RFC suggested. `bind` is fairly _imperative_, it describes the action that we do to the function rather than what is returned. It also does not exactly match the JS method API, and as noted in the RFC feedback this could be confusing. Finally, it requires stopping to teach the concept of binding and how that works, which is a lot of overhead for a helper that will be used early and often.
* `call` - This reads nicely in templates, but is _very_ imperative and has already been confusing to folks when discussed. It differs significantly from the JS method API, teaching around this would be difficult, though possible. It also is not clear that it is _not required_ unless args are being passed, so we may see users attempting to use it for plain functions.
* `with-args` - Descriptive, but fairly verbose

Names that have been considered, but passed over:

* `apply` - Same downsides as `call`, but less nice to read.
* `applyArgs` - Similar enough to `fn`, but uses more obscure computer-science-y terminology without many benefits.
* `partial` - From LISP and other languages. `partial` there means "Partial Application". This is a computer-science-y term that isn't super explanatory, plus `partial` is already a (deprecated) feature in Ember templates.
* `papply` - From R. Generally unaesthetically pleasing, and same issues as `partial`
* `action` - We considered trying to reclaim the "action" term, but it still has the same problems of overlap with the modifier and decorator, and there isn't an easy transition path to deprecating the automatic `this` binding.
* `callback` - Considered, but it conflicts with the `@action` decorator's naming - the method is an action, until we pass it to callback, at which point it's a callback? This felt too confusing, and we believe it makes most sense if the helper is an "adjective" that modifies whatever its input is.


---

---
stage: recommended
start-date: 2019-03-21T00:00:00.000Z
release-date: 2019-06-24T00:00:00.000Z
release-versions:
  ember-source: v3.11.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/471
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/32
---

# `{{on}}` Modifier

## Summary

Add an `{{on}}` modifier for adding event listeners to elements.

## Motivation

Currently, there are two ways to bind event listeners to elements in Ember
templates with built-in, official Ember APIs:

1. Use the `{{action}}` element modifier
2. Use the `on*=` property bindings

Both of these solutions are problematic for a number of reasons.

The `{{action}}` modifier:

- Uses a non-standard AST transform to pass `this` in order to bind the context
  of the template (the component) to the function (typically a component
  method). This is problematic behavior, not just because of the transform, but
  because of the implicit state that is being passed to the modifier in the
  first place, and the fact that the modifier is "magical" in the sense that it
  can do things that no other modifier or helper can do.
- Binds to the `click` event by default, which requires a bit of knowledge to
  understand on first glance, and requires a bit of extra knowledge to figure
  out how to bind to other events. Compared to `onclick=`, this is less
  explicit, and requires more knowledge of the framework out of the box.
- Is confusing when used with the `@action` decorator to bind the function, and
  the `{{action}}` helper. The term "action" is highly overloaded here, and it
  is unclear what it concretely means without context.

The `on*` properties, by contrast, may seem to be a better approach overall to
the problem, but they have their own issues:

- The require the ability to bind to element _properties_. Properties are _not_
  attributes, and the distinction is subtle, but important. Most importantly,
  props are _not_ rendered, and thus are _not_ SSR/rehydration friendly, since
  it is difficult to assign during rehydration. By constrast, modifiers are
  specifically designed around SSR. They do not trigger at all during server
  side render, and then are run specifically during rehydration.
- Not all events are bindable via `on*` properties, and some events such as
  `focus` have different behavior than when assigned with `addEventListener`
  directly. This behavior has been a pain point in other frontend frameworks,
  and requires workarounds in most cases.
- They do not work on certain elements at all, such as `<svg>`.
- They are not compatible at all with standard web components. Web components
  don't send events in the same way as standard elements for properties, and
  instead rely on event listeners added via `addEventListener`. While web
  components are not currently used in the Ember ecosystem, they are advancing
  and may eventually be useful for smaller, self-contained components,
  especially for users that want to share code between framework ecosystems.

Neither of these solutions is perfect for solving the problem of adding event
listeners. This RFC proposes adding a new modifier to Ember: the `{{on}}`
modifier. This modifier will explicitly add event listeners using the
`addEventListener` API.

## Credits

The design of this modifier is based on [ember-on-modifier](https://github.com/buschtoens/ember-on-modifier)
by Jan Buschtöns, which is an excellent addon that has allowed us to test this
design in real apps and get feedback about the design.

## Detailed design

The `{{on}}` modifier will recieve:

1. The event name as a string as the first positional parameter
2. The event listener function as the second positional parameter
3. Named parameters as options

The following usages are equivalent:

```hbs
<div {{on "click" this.handleClick passive=true}}></div>
```

```js
element.addEventListener('click', this.handleClick, { passive: true });
```

Multiple event listeners can be added to an element by adding the modifier more
than once:

```hbs
<div
  {{on "click" this.handleClick}}
  {{on "mouseenter" this.handleMouseEnter}}
>
</div>
```

Extra positional parameters will be ignored. In order to pass values to a
function, users should use a helper such as the [fn helper](https://github.com/emberjs/rfcs/pull/470):

```hbs
<div {{on "click" (fn this.addNumber 123)}}></div>
```

The event will also be passed as a parameter to the function, so it can be used
directly.

`{{on}}` does _not_ bind context. Context binding must be handled via a helper,
or in the component definition via the `@action` decorator, which will be the
recommended path:

```js
class ClickComponent extends Component {
  @action
  handleClick() {
    // ...
  }
}
```

### Named Parameters

The following named parameters will be accepted as options to `{{on}}`:

- `capture`
- `once`
- `passive`

These will be passed forward to `addEventListener` as options in modern
browsers, and will be polyfilled in older browsers. Other options will be
ignored.

## How we teach this

`{{on}}` itself can be taught in conjuction with event listeners. We can give
users an overview of event listeners and the `addEventListener` API, and then
relate the modifier directly to it. We should provide lots of examples of usage
throughout the guides for how users can use it, including some examples of how
to apply multiple event listeners to an element.

`{{on}}` also does not bind context, and we should make it clear that the
`@action` decorator is the recommended way to bind methods to their components.

Other than that, most examples in the guides can be translated directly from
the `{{action}}` modifier to the `{{on}}` modifier.
Documentation work would include:

- revising [Handling Events](https://guides.emberjs.com/release/components/handling-events/#toc_event-names) or the corresponding Octane article in entirety
- revising [Triggering Changes with Actions](https://guides.emberjs.com/release/components/triggering-changes-with-actions/) or the corresponding Octane article
- Updating 50+ uses of `{{action}}` in the guides
- Adding `{{on}}` as a new API docs entry
- Update examples within the API docs to show all uses of actions that are supported in the API docs - `{{on}}`, `{{action}}`, `onclick={{action}}`

`{{action}}` is used 130+ times in the API docs. Not all examples would need to be updated, however an audit would be needed to figure out which need to be added to/changed.

## Drawbacks

- This API is somewhat more verbose than the `{{action}}` modifier since it
  requires a helper for passing additional values to the function. However, this
  explicitness makes it much more clear what the separation of concerns is, and
  allows users to fine tune their event handling.
- The `{{on}}` modifier requires another helper to pass values. Currently, the
  ideal companion helper is the `{{fn}}` helper, which is still in RFC.
- The `onclick=` style at first looks like a native browser API, and is
  sometimes easier to teach because of this. However, it is _not_ the same as
  the `onclick` attribute, which only receives strings, and the differences are
  often confusing. In addition, the fact that there are many use cases that
  aren't covered by these properties, and the fact that they are hostile to SSR,
  makes them less than ideal.

## Alternatives

One option would be to allow the `{{on}}` modifier to receive event listeners
as named parameters instead:

```hbs
<div
  {{on
    click=this.handleClick
    mouseenter=this.handleMouseEnter
  }}
>
</div>
```

One downside of this style of API is that there is no clear way to pass
additional options to the individual event listeners. We could pass them as a
positional parameter, but they would apply to _all_ listeners, which would
require multiple invocations.

We could also allow the `{{on}}` modifier to bind context. This opens up a
question: Should helpers and modifiers by able to use the context of the
template implicitly? Since helpers are analogous to functions in JavaScript,
this would be an equivalent API choice in JS:

```js
function foo() {
  this.bar = 123;
}

class Foo {
  doSomething() {
    foo();
  }
}

let foo = new Foo();

foo.doSomething();
console.log(foo.bar); // 123
```

Arbitrary functions being able to access `this` when used within a class like so
seems problematic from a language design standpoint, and we believe an API like
this in Ember's templates would be very problematic, and easy to misuse.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-04-17T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/477
project-link:
---

# Syncing Blueprints

## Summary

I want to use [ember-cli-update](https://github.com/ember-cli/ember-cli-update) to keep any blueprint up-to-date. Since ember-cli-update can not possibly contain knowledge of all blueprints, some state must be stored in a project.

## Motivation

Projects like [libkit](https://github.com/tildeio/libkit), [@glimmer/blueprint](https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/blueprint), [@ember/octane-app-blueprint](https://github.com/ember-cli/ember-octane-blueprint), and other app replacement blueprints become out-of-date instantly after generation. Tweaks to the blueprints are only beneficial to newly generated apps.

## Detailed design

**State storage schema**

Up until now, ember-cli-update could update apps without any configuration, but in order to handle all blueprints and their options, some state has to be stored in the project.

The code is already completed but opt-in. I wanted to publish this RFC before releasing it into the wild. I want to make sure the format of these files are agreed upon, because if this is successful, it will probably propagate throughout the ecosystem.

```json
// config/ember-cli-update.json
{
  "packages": [
    {
      "name": "my-custom-blueprint",
      "version": "0.0.1",
      "blueprints": [
        {
          "name": "my-custom-blueprint"
        }
      ]
    }
  ]
}
```

`ember-cli-update.json` will be rewritten by the tool, which is why JSON is preferred over JS.

How should the state be structured?

```ts
/**
  This lives at config/ember-cli-update.json by default.
*/
interface BlueprintConfig {
  /**
    Keep track of incompatible schema changes.
  */
  schemaVersion: number;

  /**
    A package is a collection of blueprints from a single source.
  */
  packages: {
    /**
      The name of the package.
    */
    name: string;

    /**
      Target a blueprint on your local filesystem, monorepo or otherwise.
    */
    location?: string;

    /**
      The version of the package used for blueprint diffing.
    */
    version: string;

    /**
      The blueprints in the package. Can be a default blueprint having
      the same name as the package, or a named blueprint like component
      generators.
    */
    blueprints: {
      /**
        A base blueprint is the blueprint you started your project with.
        This could be the ember app blueprint, or a custom blueprint like libkit.
        If this is missing or false, it is a partial blueprint, like the changes
        you get when installing an ember addon like ember-cli-mirage.
        There must be one base blueprint at all times.
      */
      isBaseBlueprint?: boolean;

      /**
        The name of the blueprint to be run.
      */
      name: string;

      /**
        The path inside your project to run in. Think deeply nested
        component generators. Missing means project root.
      */
      cwd?: string;

      /**
        The location of a codemods manifest if there are codemods
        associated with this blueprint.
      */
      codemodsUrl?: string;

      /**
        All options should be normalized to match any codemod requirements.
        The work to normalise them might not be done at first, so users
        writing the CLI commands are expected to do it. For example,
        `--no-welcome` should be expanded to `--welcome=false` so that
        a codemod with a requirement of `[ "--welcome=false" ]` can match it.
      */
      options?: string[];
    }[]
  }[]
}
```

**Commands**

***bootstrap***

```
ember-cli-update bootstrap
```

This starts an `ember-cli-update.json` file for you with the detected ember-cli blueprint version. It uses the same logic we currently have for detecting the ember-cli blueprint version, but now since the state is stored, we don't have to run the detection logic anymore.

***init***

```
ember-cli-update init
ember-cli-update init -b libkit
ember-cli-update init -b my-custom-blueprint --custom-option-1 --custom-option-2 foo
```

This is similar to `ember init` or `ember-cli-update --reset`, but also stores the blueprint information in `ember-cli-update.json`. It also stores any options used to create future update diffs.

***install***

```
ember-cli-update install ember-cli-mirage
```

This is the same as `ember install ember-cli-mirage` except that it stores the blueprint state for later updating.

***save***

```
ember-cli-update save libkit --from 0.5.18
ember-cli-update save ember-cli-mirage --from 0.4.0
```

This is a helper for saving the state of an old blueprint's run without ember-cli-update. The usefulness of this is questionable, because you have to remember something you did in the past. Its only usefulness is getting a project set up without having to know the `ember-cli-update.json` schema.

**Methods of delivery**

The goal is for when you type `ember-cli-update` in your project, you will get a prompt like

```
$ ember-cli-update
Multiple blueprint updates found, which would you like to update?
 * ember-cli
 * ember-cli-mirage
 * ember-ci
```

The reason this is so powerful is any org could create their own _partial_ project blueprint (public or private). This blueprint can make any slight (or massive) tweaks to the official blueprints, and ember-cli-update can keep any project in sync with both the official blueprint and your org's blueprints, at the same time.

**Preserving options**

I'm not sure if anyone does it now, but it could be possible to handle options when generating a new project via a custom blueprints.

```
ember new my-app -b my-blueprint --option1 --option2=foo
```

```json
// my-app/config/ember-cli-update.json
{
  "packages": [
    {
      "name": "my-blueprint",
      "version": "0.0.1",
      "blueprints": [
        {
          "name": "my-blueprint",
          "options": [
            "option1=true",
            "option2=\"foo\""
          ]
        }
      ]
    }
  ]
}
```

The updater can now generate a project with the correct options.

**Codemods**

There is no reason why you couldn't provide your own codemods with this system. This would be especially useful for project replacement blueprints. We would use the existing codemod system with version detection, option detection, etc.

```json
{
  "packages": [
    {
      "name": "my-blueprint",
      "version": "0.0.1",
      "blueprints": [
        {
          "name": "my-blueprint",
          "codemodsUrl": "some-server.com/my-blueprint-codemods-manifest.json"
        }
      ]
    }
  ]
}
```

## How we teach this

I’m not sure. It could be a section in the ember-cli-update README, or leave it up to the blueprints that want to support this to document. If this feature takes off in the ecosystem, then it might warrant a guides section on keeping your blueprints up-to-date.

## Drawbacks

A drawback could be that blueprints start writing this state, but the consumer doesn’t want to use ember-cli-update to keep it in sync. In that case, it’s another file the user has to delete.

## Unresolved questions

The options need to be normalized somehow to be used in the codemods system.

`--custom-option foo` vs `--custom-option=foo` vs `--custom-option="foo"`

```js
// This would probably be bad as `foo` would be treated as an option
"options": [
  "--custom-option",
  "foo"
]
// This is better
"options": [
  "--custom-option=\"foo\""
]
// or maybe this?
"options": [
  "customOption=\"foo\""
]
```

For now, we should leave it up to the end-user to normalize the options to match any codemod manifest. This is too hard a problem to nail down on the first iteration.


---

---
stage: recommended
start-date: 2019-04-12T00:00:00.000Z
release-date: 2019-09-19T00:00:00.000Z
release-versions:
  ember-source: v3.13.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/478
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/45
---

# Tracked Properties Updates

## Summary

During the Ember Octane preview period we encountered some issues with the
current design for Tracked Properties that was proposed and accepted in
[RFC 410](https://github.com/emberjs/rfcs/blob/master/text/0410-tracked-properties.md).
The primary issues were specifically around interop between tracked properties,
computed properties, and autotracking, with a few extra issues and
inconsistencies surrounding these. This RFC seeks to fix these issues and
provide a new interop path.

## Motivation

During the preview for Octane, we've encountered a few issues with tracked
properties:

1. Computed property autotracking interop was too aggresive, and resulted in
   breaking changes in existing applications.
2. When users need to use `get()` and `set()` is still fairly confusing, and we
   don't have enough warnings to help guide users down the happy path.
3. Users were confused by the fact that `set()` was still required when updating
   computed properties, especially CP macros like `DS.attr()`.

### Autotracking Interop

The core of the autotracking issue was that autotracking _inside_ computed
properties resulted in more values being consumed and watched than before,
fundamentally changing the dynamic of the CP. For instance, consider this code
example:

```js
const Person = EmberObject.extend({
  init(...args) {
    this._super(...args);

    let fullName = `${this.get('firstName')} ${this.get('lastName')}`;

    this.set('fullName', fullName);
  },
});

const Profile = EmberObject.create({
  person: computed('firstName', 'lastName', function() {
    return Person.create({
      firstName: this.get('firstName'),
      lastName: this.get('lastName'),
    });
  }),
});
```

The `Profile#person` computed would currently only invalidate if
`Profile#firstName` or `Profile#lastName` was updated, and it would be possible
to update the person like so:

```js
// without autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // true
```

However, because `get` now autotracks, the fact that the `Person` class uses
`this.get()` in its own constructor causes `Profile#person.firstName` to
autotrack. When we go to update the object later on, it invalidates the
underlying computed property.

```js
// with autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // false
```

It's arguable that computed properties that are relying on these caching
semantics are problematic in general. After all, it's strange to setup state
like this _during_ construction, usually you would use a CP instead, and if CPs
_are_ trying to use a value, it generally means that value _should_ be a
dependency. However, based on our experiences with attempting to upgrade
existing applications to enable autotracking, we believe it likely would result
in enough breakage that it would be a breaking change.

### When to Use `get` and `set`

While the original tracked properties RFC laid the groundwork for getting rid of
`get` and `set` in the browser, there are still cases where users need to use
it. Specifically, users must use `get` and `set` when:

- Getting and setting values on POJOs
- Using Ember Proxies
- Setting Computed Properties

Ember proxies already throw errors if users don't use `get` and `set`, so users
can generally get the feedback they need for them, and setting computed
properties is addressed in the next section. For POJOs, however, the feedback
can be lacking. Users could access a POJO from a tracked context like so:

```js
class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }
}
```

And later on, try to update `featureFlags.someValueEnabled`, and be confused
when it doesn't work and they don't have any actionable feedback:

```js
class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }

  @action
  updateFlag() {
    this.featureFlags.someValueEnabled = true;
  }
}
```

Adding an assertion to values that are accessed like this which requires `set`
will help to prevent confusion from occuring.

### Computed Property Setters

As we move toward removing `get` and `set` entirely, computed properties stick
out somewhat as a sore thumb. They generally look and feel like standard getters
and setters with some caching, but while modern Ember users can use native
getters to _get_ the computed, they must use `set()` to update them. This is
particularly annoying when dealing with macros, like aliases and Ember Data
attributes such as `DS.attr`.

Installing a native setter for computed properties will smooth over these
inconistencies, and give us a clear learning boundary for `get` and `set` - you
only need to use them for plain, undecorated properties on POJOs, and for Ember
proxies.

## Detailed design

### Autotracking Interop

Not all of the interop in the original RFC was problematic, and as such, the
following parts will remain the same:

- `get` - will still autotrack any value that is accessed
- `set`/`notifyPropertyChange` - will still invalidate any value that was
  accessed with `get`
- Computed properties - will still autotrack _if accessed in an autotracking
  context_.

What will change is that computed properties will no longer autotrack as they
are being evaluated. Instead, they will follow the same rules as they do
currently, listing explicit dependencies and only invalidating when one of those
dependencies changes. Any autotracking that may have occured during the
computation of the computed will instead no-op, making the computed a _black
box_.

Since computed properties no longer autotrack, they will need a different
interop story for tracked properties and autotracking. Autotracking is a very
general tool - as we saw in the motivation, it's possible to track through
_function calls_, something that wasn't possible before.

However, we don't need to enable interop with _all_ of autotracking. All we
really need is the ability to depend on the autotracking equivalents of what
computed properties already are capable of depending on, so that users can
convert existing code to autotracking incrementally. Computed properties can
already depend on:

- Properties
- Other Computed Properties

The equivalents to these in autotracking are:

- Tracked Properties
- Native Getters

#### Depending on Tracked Properties

Tracked properties are already instrumented under the hood. They have a native
setter that calls `notifyPropertyChange`, and this will automatically invalidate
any computeds that specify the property as a dependency. There is no need to do
any further work.

#### Depending on Native Getters

Native getters are just that - native. They don't have any special autotracking
behavior, which was part of the benefits of tracked properties. However, this
means there is nothing to notify computed properties of changes.

To solve this problem, we propose the `@dependentKeyCompat` decorator. This decorator
would instrument a native getter with its own autotracking frame, which would
allow it to track any events in its evaluation. It would coalesce these into its
own tag, which computed properties (and observers) would be able to depend on:

```js
import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

const Profile = EmberObject.extend({
  // provided on create
  person: null,

  username: alias('person.fullName'),
});
```

`@dependentKeyCompat` would be imported from `@ember/object/compat`, since it is used
specifically in Ember apps for interop with Ember object model abstractions.
Like other Ember decorators, it would be usable in both classic and native
classes. When used in classic classes, it will be able to define its underlying
getter and setter using the same API as computed properties. However, it will
throw an error if it is used to define more than one getter/setter - dependentKeyCompat
macros should be avoided and discouraged.

Observers and computed properties will throw an error if they attempt to watch
a getter which is not marked as dependentKeyCompat.

#### Debugging Assertions

Consuming a value using `get()` inside of a tracked context will both autotrack
the value, and in _development_ builds install the mandatory setter assertion.
This assertion already exists and is currently installed on values that are
watched by computeds, observers, and templates, but not for values accessed
using `get()`. Extending it to these values should not be too difficult.

### Computed Property Setters

Computed properties will no longer install the mandatory setter assertion like
they have for much of Ember's existence. Instead, they will install a native
setter that proxies to the one defined for the computed property. This will
allow users to use native setters instead of `set()`.

## How we teach this

There are two major points of consideration here:

- How do we teach classic/autotrack interop and `@dependentKeyCompat`
- How do we teach `get`/`set` and when they are necessary to use

### Classic/Autotrack Interop

Many of the points from the original tracked property RFC remain valid, but we
will have to update the way that we teach computed properties. In some ways the
overall mental model is simplified - computed properties will only update
whenever a dependent property is updated, as they always have. The following
table describes what types of values can be depended on, and how they can
trigger updates:

| Type                          | Updates By                         |
| ----------------------------- | ---------------------------------- |
| Plain, undecorator property   | `set()`                            |
| Tracked property              | Native setter                      |
| Computed property             | `set()`, or upstream invalidations |
| Dependency compatible getters | Tracked value changes              |

We should cover each of these in some detail in the main guides.

#### `@dependentKeyCompat` API Docs

`@dependentKeyCompat` is decorator that can be used on _native getters_ that use tracked
properties. It exposes the getter to Ember's classic computed property and
observer systems, so they can watch it for changes. It can be used in both
native and classic classes.

Native Example:

```js
import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import { computed, set } from '@ember/object';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Profile {
  constructor(person) {
    set(this, 'person', person);
  }

  @computed('person.fullName')
  get helloMessage() {
    return `Hello, ${this.person.fullName}!`;
  }
}
```

Classic Example:

```js
import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import EmberObject, { computed, observer, set } from '@ember/object';

const Person = EmberObject.extend({
  firstName: tracked(),
  lastName: tracked(),

  fullName: dependentKeyCompat(function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});

const Profile = EmberObject.extend({
  person: null,

  helloMessage: computed('person.fullName', function() {
    return `Hello, ${this.person.fullName}!`;
  }),

  onNameUpdated: observer('person.fullName', function() {
    console.log('person name updated!');
  }),
});
```

`dependentKeyCompat()` can receive a getter function or an object containing `get`/`set`
methods when used in classic classes, like computed properties.

In general, only properties which you _expect_ to be watched by older, untracked
clases should be marked as dependency compatible. The decorator is meant as an interop layer
for parts of Ember's older classic APIs, and should not be applied to every
possible getter/setter in classes. The number of dependency compatible getters should be
_minimized_ wherever possible. New application code should not need to use
`@dependentKeyCompat`, since it is only for interoperation with older code.

### Computed Properties

Computed properties are a pre-Octane concept in Ember. They serve the same
purpose as tracked properties and native getters, allowing users to respond to
changes, derive state, and ultimately update the DOM. They also have built-in
caching to prevent having to perform expensive calculations more than once.

While computed properties are no longer the recommended default, it's likely
that you may encounter them in code that hasn't been updated to tracked
properties just yet, either in existing applications or in the wider Ember
ecosystem, so this guide exists both to describe how they work and can be used,
and how they interoperate with tracked properties.

#### Computed Property Usage

You can create a computed property by using the `@computed` decorator to
decorate standard computed property getters and setters:

```javascript
import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // "Tony Stark"
```

This computed property works just like a normal getter/setter, with two key
differences:

1. It will cache its value by default, and it will only update that value if its
   _dependencies_, in this case the `firstName` and `lastName` properties,
   change.

   ```javascript
   class Counter {
     _count = 0;

     @computed
     get count() {
       console.log('counted!');
       return this._count;
     }
   }

   let counter = new Counter();

   counter.count; // logs 'counted!'
   counter.count; // logs nothing, the values was cached and hasn't updated
   ```

2. It will notify other "watchers", such as other computed properties and
   templates, if any of its dependencies has updated and it needs to be
   recalculated.

##### Specifying Dependencies

So far we've seen computed properties with dependencies on properties that are
_local_ to the object, but you can specify a few other types of dependencies:

- **Chain dependencies.** If you need to specify a dependency on an _object_,
  you can use dot notation to do so:

  ```js
  class Profile {
    constructor(user) {
      set(this, 'user', user);
    }

    @computed('user.firstName', 'user.lastName')
    get userName() {
      return `${this.user.firstName} ${this.user.lastName}`;
    }
  }
  ```

  When doing this for more than one value on the object, you can also use a
  special truncated syntax as shorthand:

  ```js
  class Profile {
    constructor(user) {
      set(this, 'user', user);
    }

    @computed('user.{firstName,lastName}')
    get userName() {
      return `${this.user.firstName} ${this.user.lastName}`;
    }
  }
  ```

  Note that no spaces are allowed in this truncated syntax, Ember will assert if
  you place any inside of it.

- **Array dependencies.** It's possible to depend on an array, and the items in
  the array, by watching the `[]` property on the array:

  ```js
  class Person {
    constructor(friends = []) {
      set(this, 'friends', friends);
    }

    @computed('friends.[]')
    get friendNames() {
      return this.friends.map(friend => friend.name);
    }
  }
  ```

  You can also depend directly on a _property_ of each item in the array using
  `@each` syntax:

  ```js
  class Person {
    constructor(friends = []) {
      set(this, 'friends', friends);
    }

    @computed('friends.@each.name')
    get friendNames() {
      return this.friends.map(friend => friend.name);
    }
  }
  ```

  However, you cannot _chain_ on these properties, as it is a performance
  pitfall. You can only do 1 level of `@each` watching.

##### Defining Setters

If you define a setter for your computed property, it'll work just like a normal
setter:

```javascript
import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }
}

let hero = new Person('Tony', 'Stark');

hero.fullName; // 'Tony Stark'

hero.fullName = 'Hope Pym';
hero.firstName; // 'Hope'
```

It's worth noting that we do _not_ need to use `set` to update the computed
property. It wraps the native setter transparently, so there is no need for the
set function. The properties it _depends_ on, however, _do_ need to be updated
with `set`, since they are not marked as `@tracked` and we don't have another
way of knowing they were updated. We will dive into this a bit more below.

The setter will also immediately call the getter for the computed in order to
recalculate the cached value. You can also return the value, as an optimization:

```js
class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  }
}
```

##### Computed Property Macros

It's possible to define _macros_ using computed properties. This works because
the `@computed` decorator can receive getter and setter functions, and be
applied to a normal class field instead of a getter/setter:

```js
class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  // Just a getter function
  @computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
  fullName;

  // With setter and getter
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  })
  fullNameWithSetter;
}
```

You can then extract this decorator to create a new decorator definition:

```js
const fullNameMacro = computed('firstName', 'lastName', {
  get() {
    return `${this.firstName} ${this.lastName}`;
  },

  set(key, value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  },
});

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName;
}
```

And we can abstract this further to create a function that generates the
decorator dynamically, which allows us to reuse the macro:

```js
function fullNameMacro(firstNameKey, lastNameKey) {
  return computed(firstNameKey, lastNameKey, {
    get() {
      return `${this[firstNameKey]} ${this[lastNameKey]}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, firstNameKey, firstName);
      set(this, lastNameKey, lastName);

      return value;
    },
  });
}

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName('firstName', 'lastName');
  @otherFullNameMacro fullName('first', 'last');
}
```

When you provide a getter and setter like this to `@computed`, the getter and
setter receive the `key` of the property they are decorating as the first value,
and the setter receives the actual value second. The setter also **must** return
the value to be cached - the getter will not be rerun if it does not, and the
value will be `undefined`.

##### Computed Properties in Classic Classes

Computed properties can be used in classic class syntax as well. This works by
passing the getter and setter to the `computed()` decorator just like we would
for a macro:

```js
const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  }),
});
```

#### Computed Property Dependency Types

You may have noticed that in the previous section, our computed properties were
depending on normal, undecorated properties. This is possible in classic Ember
if we always update those properties using Ember's `set` method, which is why
all of the examples use it. Computed properties can depend on other types of
values as well though. Altogether, the types of values are:

- Plain, undecorated object properties
- `@tracked` properties
- `@computed` properties
- `@dependentKeyCompat` getters
- Arrays

We'll talk about each of these individually, and discuss how they are watched
and updated.

##### Plain Properties

In all the examples above, we demonstrated computed properties that depended on
plain object properties which hadn't been otherwise decorated. This was the
default in classic Ember, before tracked properties were introduced, and it
still works today - however, to trigger updates on a plain property dependency,
you _must_ use `set`:

```js
import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // "Tony Stark"
ironMan.firstName = 'Anthony'; // This will throw an error
set(ironMan, 'firstName', 'Anthony'); // This will work, and update `fullName`
```

In general Ember will try to throw an error if you should use `set` to update a
value, but you didn't.

##### Tracked Properties

Computed properties can also depend directly on tracked properties, and tracked
properties do _not_ need to be updated with `set`. Updating them with normal
JavaScript update syntax will invalidate them:

```js
import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // "Tony Stark"
ironMan.firstName = 'Anthony'; // Now this will work, because 'firstName' is tracked!
```

##### Computed Properties

Computed properties can depend on other computed properties. If you depend on a
computed property, it will only trigger updates if _its_ dependencies update, or
if you set it directly:

```js
import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}

let hero = new Person('Tony', 'Stark');

hero.legalName; // 'Tony Stark'

hero.fullName = 'Hope Pym'; // Invalidates `legalName`
hero.legalName; // 'Hope Pym'

hero.firstName = 'Hank'; // Invalidates `fullName` _and_ `legalName`
hero.fullName; // 'Hank Pym'
hero.legalName; // 'Hank Pym'
```

##### Dependency Compatible Getters

In modern, fully tracked classes, computed properties aren't recommended
anymore. However, if you are working in a legacy codebase and converting to
tracked properties and native getters, there may be a point in time where you
try to convert a computed property that is being depended on by _other_ computed
properties. Native getters normally _cannot_ be depended on, and this will
trigger an error in development mode.

However, this doesn't mean that you need to convert an entire tree of computed
properties every time you try to update a class! Instead, you can mark native
getters that need to be depended on by computed properties with the `@dependentKeyCompat`
decorator:

```js
import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}
```

This decorator exposes the getter to computed properties, but otherwise leaves
it untouched - it'll operate just like a normal native getter with tracked
properties. When you have removed all computed properties that are depending on the
getter, you can remove the `@dependentKeyCompat` decorator.

In general, you should try to remove `@dependentKeyCompat` decorators as you convert your
app. Making getters compatible with the explicit dependency system means that more computeds can be written to watch
those getters, and the situation can get _worse_ instead of better over time. If
you need to write a service or class that needs to interop with modern and
classic code for some time, try to _minimize_ the number of `@dependentKeyCompat` getters
to just the ones that are the "public API" of the class - the values that are
expected to be depended on from the outside by other classes.

##### Arrays

As we mentioned above, computed properties can specify dependencies on arrays.
They can watch for changes in the items of the array by watching the `[]` key of
the array, and they can watch for changes on properties of the items using the
`@each` syntax.

In order to be properly notified of changes to an array, you either use KVO
compliant methods of Ember arrays such as `pushObject` or `popObject`, or `set`
the entire array:

```js
import { computed, set } from '@ember/object';
import { A as emberA } from '@ember/array';

class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend => friend.name);
  }
}

let joey = new Person(
  emberA([
    { name: 'Phoebe' },
    { name: 'Monica' },
    { name: 'Chandler' },
    { name: 'Ross' },
  ])
);

// Using pushObject will cause `friendNames` to update
joey.friends.pushObject({ name: 'Rachel' });

// Alternatively, we can update the whole array:
set(joey, 'friends', [...joey.friends, { name: 'Rachel' }]);
```

If the property is tracked, then `set` is not necessary, and the field can be
updated directly as you would with normal tracked properties:

```js
import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracking friends;

  constructor(friends = []) {
    this.friends = friends;
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend => friend.name);
  }
}

let joey = new Person([
  { name: 'Phoebe' },
  { name: 'Monica' },
  { name: 'Chandler' },
  { name: 'Ross' },
]);

joey.friends = [...joey.friends, { name: 'Rachel' }];
```

#### Computed Properties and Tracking

Computed properties will autotrack when they are accessed from templates or
through other getters, like tracked properties:

```js
import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  // legalName will update whenever `fullName` updates
  get legalName() {
    return this.fullName;
  }
}
```

### When to Use `get` and `set`

Ember's classic change tracking system used two methods to ensure that all data
was accessed properly and updated correctly: `get` and `set`.

```js
import { get, set } from '@ember/object';

let person = {};

set(person, 'firstName', 'Amy');
set(person, 'lastName', 'Lam');

get(person, 'firstName'); // 'Amy'
get(person, 'lastName'); // 'Lam'
```

In classic Ember, all property access had to go through these two methods. Over
time, these rules have become less strict, and now they have been minimized to
just a few cases. In general, in a modern Ember app, you shouldn't need to use
them all that much. As long as you are marking your properties as `@tracked`,
autotracking should automatically figure out what needs to change, and when.

However, there still are two cases where you _will_ need to use them:

- When accessing and updating plain, undecorated properties on objects
- When using Ember's `ObjectProxy` class, or a class that implements the
  `unknownProperty` function (which allows objects to intercept `get` calls)

Additionally, you will have to continue using _accessor_ functions for arrays if
you want arrays to update as expected. These functions are covered in more
detail in the guide on arrays (LINK TO ARRAY GUIDES HERE).

Importantly, you do _not_ have to use `get` or `set` when reading or updating
computed properties, as was noted in the computed property section.

#### Plain Properties

In general, if a value in your application could update, and that update should
trigger rerenders, then you should mark that value as `@tracked`. This
oftentimes may mean taking a POJO and turning it into a class, but this is
usually better because it forces us to _rationalize_ the object - think about
what its API is, what values it has, what data it represents, and define that in
a single place.

However, there are times when data is _too_ dynamic. As noted below, proxies are
often used for this type of data, but usually they're overkill. Most of the
time, all we want is a POJO.

In those cases, you can still use `get` and `set` to read and update state from
POJOs within your getters, and these will track automatically and trigger
updates.

```js
class Profile {
  person = {
    firstName: 'Chris',
    lastName: 'Thoburn',
  };

  get profileName() {
    return `${get(this.person, 'firstName')} ${get(this.person, 'lastName')}`;
  }
}

let profile = new Profile();

// render the page...

set(profile.person, 'firstName', 'Christopher'); // triggers an update
```

This is also useful for interoperating with older Ember code which has not yet
been updated to tracked properties. If you're unsure, you can use `get` and
`set` to be safe.

#### `ObjectProxy`

Ember has and continues to support an implementation of a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy),
which is a type of object that can _wrap around_ other objects and _intercept_
all of your gets and sets to them. Native JavaScript proxies allow you to do
this without any special methods or syntax, but unfortunately they are not
available in IE11. Since many Ember users must still support IE11, Ember's
`ObjectProxy` class allows us to accomplish something similar.

The use cases for proxies are generally cases where some data is very dynamic,
and its not possible to know ahead of time how to create a class that is
decorated. For instance, [ember-m3](https://github.com/hjdivad/ember-m3) is an
addon that allows Ember Data to work with dynamically generated models instead
of models defined using `@attr`, `@hasMany`, and `@belongsTo`. This cuts back on
code shipped to the browser, but it means that the models have to _dynamically_
watch and update values. A proxy allows all accesses and updates to be
intercepted, so M3 can do what it needs to do without predefined classes.

Most `ObjectProxy` classes have their own `get` and `set` method on them, like
`EmberObject` classes. This means you can use them directly on the class
instance:

```js
proxy.get('firstName');
proxy.set('firstName', 'Amy');
```

If you're unsure whether or not a given object will be a proxy or not, you can
still use Ember's `get` and `set` functions:

```js
get(maybeProxy, 'firstName');
set(maybeProxy, 'firstName', 'Amy');
```

## Drawbacks

- The interop story here may a bit confusing for users at first. `@dependentKeyCompat`
  should only be used in some cases, and it could unclear when it should be
  used. Documentation should help alleviate this, along with clear examples.
- We're introducing a decorator that will eventually be deprecated and removed
  as part of this process, which is essentially some tech debt we're taking on.
  However, we know that this has a timeline for removal, and it is purely a
  temporary measure for interop, so it's not a significant amount of debt to
  take on in the meantime.

## Alternatives

- We could not provide `@dependentKeyCompat` instead. This would mean there isn't really
  an interop path for users who want to depend on native getters from CPs and
  observers, leaving a large gap that could prevent users from updating
  altogether.


---

---
stage: recommended
start-date: 2019-04-12T00:00:00.000Z
release-date: 2019-09-19T00:00:00.000Z
release-versions:
  ember-source: v3.13.0

teams:
  - framework
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/481
project-link:
---

# Component Templates Co-location

## Summary

We propose to place a component's JavaScript file (the class) and its template
in the same directory on the file system.

Today:

```
app
├── components
│   ├── just-class.js
│   ├── my-widget.js
│   ├── nested
│   │   └── another-widget.js
│   └── ...
├── models
│   └── ...
├── routes
│   └── ...
├── services
│   └── ...
├── templates
│   ├── components
│   │   ├── just-template.hbs
│   │   ├── my-widget.hbs
│   │   ├── nested
│   │   │   └── another-widget.hbs
│   │   └── ...
│   ├── some-route.hbs
│   └── ...
└── ...
```

Proposed:

```
app
├── components
│   ├── just-class.js
│   ├── just-template.hbs
│   ├── my-widget.hbs
│   ├── my-widget.js
│   ├── nested
│   │   ├── another-widget.hbs
│   │   └── another-widget.js
│   └── ...
├── models
│   └── ...
├── routes
│   └── ...
├── services
│   └── ...
├── templates
│   ├── some-route.hbs
│   └── ...
└── ...
```

## Motivation

Today, a component's JavaScript file is located in the `app/components`
directory. On the other hand, its template is located in the
`app/templates/components` directory.

This design decision is a relic of Ember's pre-1.0 days. In those early days,
before components were even conceived, "views" were the primary building blocks
in Ember's UI programming model. Like components, they consist of a view class
located in `app/views/$NAME.js` (subclassing `Ember.View`), and/or a template
located in `app/templates/$NAME.hbs`. In other words, every template in Ember
could optionally have an associated view class, and vice versa.

Similar to components, they can be "invoked" in other templates using either
the `{{view "$NAME"}}` or `{{#view "$NAME"}}...{{/view}}` syntax. At the time,
this was how Ember developers create reusable pieces of UI in their app.

Unlike components, when a view is "invoked", the view instance does not become
the `this` context of its template. Instead, the `this` from the calling side
will persist (similar to partials), while properties on the view instance are
accessible from within the template with `{{view.someProperty}}` syntax.

Over time, this programming model has gone through several iterations of
refinements (remember the short-lived "controls"? 😀), eventually evolved into
the component-based programming model as we know it today.

When components were introduced, it was decided that they would live in a
separate "namespace" than views: their JavaScript files are located in
`app/components` instead of `app/views`, and it uses the now-familiar curly
invocation syntax instead of the `view` keyword.

This decision causes two problems. First, given a template file, such as
`app/templates/foo-bar.hbs`, how do we know if it belongs to a component or a
view? Furthermore, since they live in different namespaces, it is totally legal
to have unrelated components and views with the same names, which could result
in naming collisions if their templates were both located in `app/templates`.
To solve this problem, component templates were also given a separate namespace
`app/templates/components`, as opposed to sharing `app/templates` with views.

Over the course of the Ember 1.x release series, components have taken over as
the primary UI programming primitive. Views were eventually deprecated and
removed from Ember's API entirely in Ember 2.0. Despite that, the ramifications
of that era are still around us.

We argue that the current file system layout for component files is one such
example. Given how much Ember has evolved since its early days, most of the
design constraints we had at the time no longer apply. On the other hand, new
features in the framework – such as the introduction of Ember CLI and the addon
ecosystem – has brought new capabilities and constraints to the table. As a
result, this design has caused a lot of "ergonomics papercuts", which we have
enumerated below. While each of these may feel inconsequential on their own,
together they cause a lot of unnecessary friction and feel out-of-place in the
modern Ember experience.

### 1. Component class/template coupling

The JavaScript class and template of a component are not just _related_ but
fundamentally _coupled_. Together, they provide the whole implementation of
the component. It is impossible to understand one of them without the other.
When one file is changed, the other likely need to be updated as well. Placing
these files physically far apart on the file system fails to communicate this
tight coupling, in addition to causing a lot of inconveniences when navigating
a project.

### 2. No single enumeration of components

Given the importance of components in modern Ember apps, when navigating a
large-scale or otherwise unfamiliar project, some of the most common task for
Ember developers is to enumerate all components from the given app or to
determine whether there exists a component with a specific name. The former is
useful for getting a general sense of the scope, scale and coding style, and
the latter is sometimes necessary to disambiguate components from helpers or
to determine whether a component is part of the app or provided by an addon.

Unfortunately, under the current filesystem layout, neither `app/components` or
`app/templates/components` provide a complete view for those purposes. With
template-only components, it is possible to define a component without a class,
therefore a casual scan of `app/components` will not discover those components.
With the release of Octane, we expect template-only components to become more
common. Likewise, albeit less common, it is also possible to define a component
with _only_ a class, making `app/templates/components` potentially incomplete
also.

Therefore, the "correct" way to explore the components in an app is to mentally
merge the contents of both folders, which is difficult and counterproductive.

### 3. Deviation from route template conventions

In the view-centric days of Ember, `app/templates` was a "kitchen-sink" folder
without much internal structure – it mixes route templates with reusable view
templates, as well as component templates, each of which could be grouped into
their own deeper nesting structure.

With Ember 2.0 removing views, and therefore view templates, `app/templates`
now has a clear purpose and internal structure: each template file corresponds
to a route, and each folder corresponding to a nested route. For example,
`app/templates/post.hbs` is the template for the top-level `post` route, and
`app/templates/admin/authors/new.hbs` is the template for `admin.authors.new`.

Of course, there is one prominent exception to this: `app/templates/components`
breaks the otherwise clear convention. Unlike other folders in `app/templates`,
`app/templates/components` does not represent a nested route. Furthermore, its
internal structure (if any) also differs from its siblings: folders represent
arbitrary logical/domain groupings, rather than sub-routes.

Since `app/templates/components` did not start with a special character (e.g.
`app/templates/-components`), it shows up in the middle between its routes
siblings in most apps, due to lexicographical sorting of the filenames.

This inconsistency causes confusion and prevents us from teaching the otherwise
clear convention crisply.

### 4. Lack of single import

Even though the JavaScript class and template of a component are fundamentally
coupled and inseparable pieces, this relationship is only very loosely encoded
in Ember today. In fact – the only thing that ties them together is their name:
when Ember tries to render a component, it will separately lookup the class and
template by name through the resolver. These elements can both be present at
the same time, or in the cases of template-only or class-only components, one
of the resolutions will return a negative result. Only when both elements are
missing would Ember declare the component missing and raise an error.

This setup falls short when designing components meant for subclassing. For
example:

```js
// app/components/foo-bar.js

import MyParentComponent from "./my-parent";

export default class FooBarComponent extends MyParentComponent {
  // ...
}
```

As far as Ember can tell, this file defines a class-only component by the name
of `foo-bar`. The fact that it inherits from `my-parent` is an irrelevant and
unobservable detail. While the developer may expect this to also inherit the
parent component's template (`app/templates/components/my-parent.hbs`), Ember
has no way to know that the two are related.

Because of this problem, addons typically use the `layout` property from the
classic component API to get around this problem. When generating a component
in an addon, this is the default output from the blueprint:

```js
// addon/components/foo-bar.js

import Component from "@ember/component";
import layout from "../templates/components/foo-bar";

export default Component.extend({
  layout
});
```

```hbs
{{!-- addon/templates/components/foo-bar.hbs --}}

{{yield}}
```

```js
// app/components/foo-bar.js

export { default } from "my-addon/components/foo-bar";
```

First, within the `addon` folder, there is the component class and template.
Having these files in the `addon` folder allow them to be imported from
JavaScript (e.g. `import FooBar from 'my-addon/components/foo-bar';`) for
subclassing. However, as mentioned above, this does not also bring along the
component's template.

To avoid developers having to also import the template, the addon component
blueprint sets the `layout` property on the component's class. At runtime,
when Ember fail to find a template associated with the component, it will
then fall back to this property.

Finally, it re-exports the component in the `app` folder, which is merged with
the app's `app` folder, allowing the component to be resolved by the resolver
and invoked from Handlebars.

This workaround gets the job done, but has several major drawbacks.

First, it adds a significant amount of boilerplate to addon components, which
could be puzzling even to seasoned addon developers. In fact, the problem it
solves is unique to addons – there is nothing wrong with using inheritance in
apps – we just didn't think we could justify adding this amount of boilerplate
to every app and putting them in Ember's "happy path".

Second, the `layout` property in classic component uses a feature in Glimmer VM
called "late-bound layout", in which we must assume a different template for
each _instance_ of the component (the `layout` property can be set in `init`).
This is fundamentally more difficult to optimize and excludes the component
from key optimizations (and opportunities for future optimizations).

Most importantly, Glimmer components do not have the equivalent of the `layout`
property, meaning that addons (or components designed for inheritance in mind)
cannot be written using Glimmer components today.

To solve these problems once and for all, we need to change things such that
component templates are automatically associated with their JavaScript class at
build time, and importing the JavaScript class should result in a value that
has this metadata associated with it, which needs to survive subclassing as
well. Solving this problem is also essential for unblocking template imports.

We believe the technical design for allowing co-location will solve this
problem nicely.

## Detailed design

### High-level design

We propose to allow placing a component's template adjacent to its JavaScript
file in `app/components`. For example, for a component named `foo-bar`, it will
be `app/components/foo-bar.js` and `app/components/foo-bar.hbs`.

In addition, per the node resolution convention, we propose to allow `index`
files inside a directory to have the equivalent semantics. In the example
above, it could also be structured as `app/components/foo-bar/index.js` and
`app/components/foo-bar/index.hbs`. This allows additional files related to the
component (such as a `README.md` file) to be co-located on the filesystem.

For template-only components, they can be either `app/components/foo-bar.hbs`
or `app/components/foo-bar/index.hbs` without a corresponding JavaScript file.

Similarly, for addons, templates can be placed inside `addon/components` with
the same rules laid out above.

In all of these case, if a template file is present in `app/components` or
`addon/components`, it will take precedence over any corresponding template
files in `app/templates`, the `layout` property on classic components, or a
template with the same name that is made available with the resolver API.
Instead of being resolved at runtime, a template in `app/components` will be
associated with the component's JavaScript class at build time.

### Low-level primitives

We propose to introduce the following low-level APIs:

- The `setComponentTemplate` function takes two arguments, the first being the
  pre-compiled (wire-format) template, the second being the component class. It
  transparently associates the given template with the component class in a way
  can be retrieved later with the `getComponentTemplate` function described
  below. For convenience, `setComponentTemplate` will return the component
  class (the second argument).

- The `getComponentTemplate` function takes a component class and returns the
  template associated with the given component class, if any, or one of its
  superclasses, if any, or `undefined` if no template association was found.

This is one possible way to implement these functions:

```js
function setComponentTemplate(template, componentClass) {
  Object.defineProperty(componentClass, "__template__", {
    configurable: true,
    enumerable: false,
    writable: false,
    value: template
  });

  return componentClass;
}

function getComponentTemplate(componentClass) {
  return componentClass.__template__;
}

class Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

class Bat {}

// USAGE

setComponentTemplate(template("foo template"), Foo);
setComponentTemplate(template("baz template"), Baz);

getComponentTemplate(Foo); // => foo template
getComponentTemplate(Bar); // => foo template (inherited)
getComponentTemplate(Baz); // => baz template (overridden)

getComponentTemplate(Bat); // => undefined
```

In an actual implementation, we would probably want to avoid polluting the
component class with a string key (`__template__` in this example) and use a
`Symbol` or `WeakMap` based strategery.

For performance reason, changing the template is not allowed once set. It is
also illegal to call `setComponentTemplate` on a component class that has
already been rendered, or once `getComponentTemplate` has been called on it.
Together, these rules ensure the results from calling `getComponentTemplate`
can be reliably cached, either by the internals of `getComponentTemplate`
itself or by one of its callers.

While the default export of a component's JavaScript file is usually a class,
it is not a strict requirement with custom component managers. To accommodate
this, `setComponentTemplate` can be passed any JavaScript `Object`.

### Build-time transformations

The low-level `setComponentTemplate` and `getComponentTemplate` APIs are not
intended to be called by end-users directly, even though they will be public
and part of our semver stability guarantee. Instead, they are meant to be used
primarily in the output emitted by build tools. At build time, any template
files found in `{app,addon}/components` will be inlined into the component's
JavaScript file and removed from the build output. For example, given these
files on disk:

```js
// app/components/foo-bar.js

import Component from "@ember/component";

export default Component.extend({
  // ...
});
```

```hbs
{{!-- app/components/foo-bar.hbs --}}

foo bar!
```

The build output will be something to the effect of this JavaScript file:

```js
// app/components/foo-bar.js

import Component, { setComponentTemplate } from "@ember/component";

// output of compiling "foo bar!" with ember-cli-htmlbars
const TEMPLATE = Ember.HTMLBars.template({
  id: "...",
  block: "...",
  meta: { moduleName: "app/components/foo-bar" }
});

const CLASS = Component.extend({
  // ...
});

export default setComponentTemplate(TEMPLATE, CLASS);
```

The variables are named here for clarity, but the actual build output would
be careful to avoid introducing hygiene issues and other observable semantic
changes to the JavaScript file.

One caveat here is that each component JavaScript file should export a value
that is unique to that file. For example, this should be **avoided**:

```js
// app/components/foo-bar.js

import MyParentComponent from "./my-parent";

// BAD: don't do this!
export default MyParentComponent;
```

This is problematic because `setComponentTemplate` will be called on
`MyParentComponent` directly, affecting the parent component and all of its
descendants. This can be avoided by subclassing, even when no customization is
required:

```js
// app/components/foo-bar.js

import MyParentComponent from "./my-parent";

// GOOD: do this instead!
export default class extends MyParentComponent {}
```

Most cases of this problem can be linted against easily.

### Template-only components

For template-only components, we propose to introduce the following low-level
API:

- The `templateOnlyComponent` function takes no arguments and produces a unique
  value that can be used to represent a template-only component.

Again, this function, though public, is not intended to be called by users
directly. It is primarily used in the output emitted by build tools. When a
template is found in `{app,addon}/components` but without a corresponding
JavaScript file, the build output will be something similar to the following:

```js
// app/components/foo-bar.js

import Component, { setComponentTemplate } from "@ember/component";
import templateOnlyComponent from "@ember/component/template-only";

// output of compiling "foo bar!" with ember-cli-htmlbars
const TEMPLATE = Ember.HTMLBars.template({
  id: "...",
  block: "...",
  meta: { moduleName: "app/components/foo-bar" }
});

const CLASS = templateOnlyComponent();

export default setComponentTemplate(TEMPLATE, CLASS);
```

In addition to build tooling, addon authors may also find this function
useful. Currently, the only way to create a "true" template-only component
is by enabling an optional feature in the app. Since addons cannot assume the
value of that flag in the consuming app, they currently cannot take advantage
of the feature. By providing this function, addon authors can work around this
problem by explicitly defining a JavaScript file with `templateOnlyComponent()`
as the default export.

On the other hand, app developers, should _not_ have any reason to use this
function directly in their app, since they could just as easily enable the
optional feature across the board.

### Codemod

A codemod will be provided to seamlessly migrate component templates.

Such a "codemod" will essentially just merges `app/templates/components` into
`app/components`. For a quick "taste test" of what the resulting tree will look
like in your app, the following commands give a close approximation:

```bash
$ rsync --archive --remove-source-files app/templates/components/ app/components/
$ rm -rf app/templates/components/
```

Of course, the resulting output won't "work", but it can be useful for getting
a sense of what it's like to work with the new layout on editors, Github, etc.

### Generator

We propose to make some updates to the components generator to accompany this
change.

1. It should accept a `--component-class` option. This controls which base
   class is used for that component and whether native classes are used. The
   legal values for this option are `@glimmer/component` (aliased as `-gc`),
   `@ember/component` (aliased as `-cc`), `@ember/component/template-only`
   (aliased as `-tc`) or an empty string (aliased as `--no-component-class` and
   `-nc`).

   The latter two differ in that `@ember/component/template-only` would
   generate an explicit JavaScript file with `templateOnlyComponent()` as the
   default export, which is useful for addons, whereas `--no-component-class`
   would skip generating a JavaScript file altogether.

   This option may be extended in the future to allow other custom components
   to provide their own blueprints, but for now, passing anything other than
   the allowed values will result in an error.

2. It should accept a `--component-structure` option.

   When this option is set to `flat` (aliased as `-fs`), the component's JavaScript and template files will both be generated at the root of
   `{app,addon}/components`.

   When this option is set to `nested` (aliased as `-ns`), a folder will be
   generated for the component in `{app,addon}/components`, and the component's
   JavaScript and template files will be generated as `index.{js,hbs}` inside
   the folder.

   When this option is set to `classic` (aliased as `-cs`), the component's
   template file will be generated in `{app,addon}/templates/components`. For
   addons, when used with `--component-class=@ember/component`, this will also
   emit the `layout` property workaround.

   When this option is set to `pods` (aliased as `--pods`), it will generate
   `{app,addon}/components/$name/{component.js,template.hbs}`.

3. Thses options will default to `--component-class=@ember/component` and
   `--component-structure=classic` for backwards compatibility.

   However, the default values can be overridden in `.ember-cli` as usual, and
   teams are encouraged to do so as they see fit. Due to a limitation in how
   the system works, the names for these options are chosen such that they are
   unlikely to conflict with options on other `ember` commands, which is why
   they are a bit verbose.

   For Octane apps, the default app blueprint will include a `.ember-cli` file
   that defaults to `--no-component-class` and `--component-structure=flat`.
   The guides and documentation will assume these settings going forward.

## How we teach this

As mentioned above, we will update the learning resources to assume the "flat"
co-located layout. Throughout the Ember Guides, the Tutorials, and the CLI
Addon Tutorial, we would update the file paths in all component examples. Since
we assume the classic layout today, in most cases only the template paths would
need to be updated. The prose describing the location of files would also need
to change.

The API documentation will describe the full set of file layout options
supported in the major version of Ember. A section should also be added to the
CLI guides, which describes how to properly import components from addons that
have a mix of layout types. We will not cover blending file layouts in the
Ember Guides, since they represent the happy path for an app, but we could link
to the CLI Guides explanation.

With this layout, it should be much easier for new users to form a mental model
around components. We can start by teaching that the most basic component is
just a reusable piece of markup (template-only components), but can "upgraded"
to have dynamic content by taking arguments using the `@name` syntax, and
further "upgraded" to keep internal states by creating a JavaScript file next
to the template and finally add interactivity with element modifiers.

Because template-only component is such a light-weight concept, it is arguably
not necessary to separate out the topic of "templates" from "components" in the
guides, but this can be addressed in a future revision of the guides.

We will teach that the `templates` folder is used for route templates. This can
be introduced in the Guides at the same time as the `routes` and `controllers`
folders/topics, which come later in the Table of Contents.

## Drawbacks

Another drawback is that it only address the co-location issue for components,
not other related types like [[route, controller, route template]] and [[model,
adapter, serializer]], or even co-location of tests. However, we believe the
situation with components is unique enough (see the motivation section) that
they are not merely _related_, but _coupled_. That, along with the fact that
components are much more common, sets them apart from the rest and justifies
solving the problem first.

There is a small risk that we will subject the community to another migration
when we finalize the replacement of Module Unification (the "New File Layout").
However, we feel pretty confident that regardless of where the collection of
components will end up on disk (e.g. `src/ui/components`), the internal
structure of that collection will closely match what is proposed in this RFC.
Ultimately, we expect there to be automatic migrators for these kinds of
changes anyway, so the cost of the possible churn is contained.


---

---
stage: recommended
start-date: 2019-04-28T00:00:00.000Z
release-date: 2019-09-19T00:00:00.000Z
release-versions:
  ember-source: v3.13.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/486
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/54
---

# Deprecate support for mouseEnter/Leave/Move Ember events

## Summary

Deprecate support for `mouseenter`, `mouseleave` and `mousemove` events in Ember's EventDispatcher. This affects
the corresponding event handler methods (`mouseEnter() {}`) in Ember components and
`{{action "some" on="mouseenter"}}`.

## Motivation

Ember's EventDispatcher handles "Ember events" by attaching listeners to the app's root element
and relying on the events bubbling up to that element (aka event delegation). There they
are processed and invoke any matching `Ember.Component` event handler method with
the same (camel-cased) method as the event type. Same for element-space `{{action}}`
modifiers.

> Note: for a "Deep Dive on Ember Events" and how they differ from "native events" I refer to
Marie Chatfield's excellent
[blog post](https://medium.com/square-corner-blog/deep-dive-on-ember-events-cf684fd3b808)
or [EmberConf talk](https://youtu.be/G9hXjjHFJVs)

This works fine in general, but `mouseenter`/`mouseleave` events are special as they do
not bubble. In the past it still worked nevertheless as jQuery transparently handled this
for us, as it had special support for event delegation for these events, essentially by using
(bubbling) `mouseover` events to replicate the semantics of `mouseenter`/`mouseleave` events.

When support for jQuery-less apps was introduced, this [left a hole](https://github.com/emberjs/ember.js/issues/16591)
in the jQuery-less EventDispatcher implementation. But as support for those events was and
still is part of Ember's pubic API, we had no chance other than to [implement support
for jQuery-less apps](https://github.com/emberjs/ember.js/pull/16603) using the same
`mouseover` based approach.

This however comes with a cost: besides an [unresolved issue](https://github.com/emberjs/ember.js/issues/17228)
the implementation has some performance drawbacks, as it has to process every `mouseover` event on
*any* element, create fake `mouseenter`/`mouseleave` events and try to dispatch them, even when
not a single component/action needs them.

Deprecating support for `mousemove` is also proposed, which is a (bubbling) event that does not have the higher
implementation cost as `mouseenter`/`mouseleave`, but nevertheless requires the EventDispatcher to optimistically handle
these extremely high-volume events.

While efforts to make this more "pay as you go" are [possible](https://github.com/emberjs/ember.js/pull/17911),
the trade-off of keeping support around still seems unfavorable, as these events fire so
frequently, while they are (most certainly) very rarely used.

This is even more so given that Glimmer Components with their outerHTML semantics do not
work with event handler methods, and `{{action}}` will eventually fade away in favor of
`{{on}}` using native `addListener()`.

## Transition Path

#### Ember.Component

When a component with a `mouseEnter`, `mouseLeave` or `mouseMove` method is created, a deprecation warning will be issued.

The linked migration guide will cover these examples:

Before:

```js
import Component from '@ember/component';

export default class MyComponent extends Component {
  mouseEnter(e) {
    // do something
  }
}
```

After:

```js
import Component from '@ember/component';
import { action } from '@ember/object';

export default class MyComponent extends Component {
  @action
  handleMouseEnter(e) {
    // do something
  }

  didInsertElement() {
    super.didInsertElement(...arguments);
    this.element.addEventListener('mouseenter', this.handleMouseEnter);
  }

  willDestroyElement() {
    super.willDestroyElement(...arguments);
    this.element.removeEventListener('mouseenter', this.handleMouseEnter);
  }
}
```

An alternative to attaching the event listener in the component class is to opt into outer HTML semantics by making the
component tag-less and using the `{{on}}` modifier in the template:

```js
import Component from '@ember/component';
import { action } from '@ember/object';

export default class MyComponent extends Component {
  tagName = '';

  @action
  handleMouseEnter(e) {
    // do something
  }
}
```

```hbs
<div {{on "mouseenter" this.handleMouseEnter}}>
  ...
</div>
```

#### `{{action}}` modifier

Similarily a deprecation warning will be shown when an instance of `{{action}}` is rendered in a template that listens
to one of the deprecated events, and will link to a deprecation guide with the following migration example:

Before:

```hbs
<button {{action "handleMouseEnter" on="mouseEnter"}}>Hover</button>
```

After (based on [RFC471](https://github.com/emberjs/rfcs/blob/master/text/0471-on-modifier.md)):

```hbs
<button {{on "mouseenter" this.handleMouseEnter}}>Hover</button>
```

## How We Teach This

The deprecation guide should explain the transition path as shown above.

The references to `mouseenter`, `mouseleave` and `mousemove` should be removed from the Guide's
[Handling Events](https://guides.emberjs.com/release/components/handling-events/#toc_event-names) section and the API
docs for [Components events](https://api.emberjs.com/ember/release/classes/Component).

Other than that, no changes are required, as the replacement APIs are all available and
well established, and this RFC does not introduce anything new. Also having certain event
types not be supported by the EventDispatcher is not something new, as other high-volume
events like `mouseover` or `scroll` are also not supported (by default).

## Drawbacks

It requires refactoring existing code that relies on support for these events. But given that
these events are (presumably) rarely used, and the alternatives are easy to implement, this
should not be a major issue.

## Alternatives

We could keep support in place, and eventually work on optimizations that minimize the
performance impact.

## Unresolved questions

None at this point.


---

---
stage: released # FIXME: This may be recommended
start-date: 2019-05-09T00:00:00.000Z
release-date: 2021-08-20T00:00:00.000Z
release-versions:
  ember-data: v3.28.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/487
project-link:
meta:
  tracking: https://github.com/emberjs/rfc-tracking/issues/53
---

# Custom Model Class RFC

## Summary

This RFC is a follow-up RFC for #293 RecordData and replaces [https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor](https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor)

Create a way for addons and user to define their own implementation of a model class. Adds an `instantiateRecord` method to `Store` which would allow addons and ED itself to offer a clean replacement the default DS.Model with a custom Model class.

## Motivation

- Allowing Addons to experiment with replacing the default DS.Model implementation ([https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor](https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor))
- Currently Ember Data conflates schema information and record implementation together as part of properties defined on `DS.Model`.
DS.Model both defines the schema, that is the attributes and relationships present on a type, and the model implementation, that is the
actual class which is exposed to the app containing those properties. This has several disadvantages:
- it makes it hard to optimize the schema information, and ties to a definition of a JS class
- it makes it hard to statically analyze the schema
- it requires a 1-1 correspondence between the number of backing types in the system and the number of model classes, resulting
in an app sometimes having to ship a much higher number of models than it otherwise would have.

This RFC represents the first step in separating the record implementation from schema information.

## Detailed design

After the work in [Record Data Errors RFC](https://github.com/emberjs/rfcs/pull/465),  [Record Data State RFC](https://github.com/emberjs/rfcs/pull/463), and [Request State Service RFC](https://github.com/emberjs/rfcs/pull/466) we have enough coverage in public apis that we can implement the entire DS.Model class with just a few changes to Store APIs.

We will need five separate changes:

- A way to instantiate custom Records and for them to be able to access underlying record data
- A way for those records to be notified of changes in Record Data
- A way to access schema information from the store and not from the DS.Model static properties
- Replacement of a few store methods that take DS.Models
- Deprecate passing DS.Model classes to adapter/serializers/exposing them on Snapshots

## Instantiating and destroying custom Records

We need to make the following changes:

* expose a method on the store for instantiating a record
* add a hook to be notified when a record is being destroyed for potential cleanup
* a way for the record to get notified when RecordData values change

The following interface shows the interface of these methods:

```ts
interface RecordDataWrapper { // proxies a subset of RD methods and hides the rest
  getAttr(identifier: RecordIdentifier, key: string)
  isAttrDirty(identifier: RecordIdentifier, key)

  changedAttributes(identifier: RecordIdentifier)
  hasChangedAttributes(identifier: RecordIdentifier)
  rollbackAttributes(identifier: RecordIdentifier)

  getRelationship(identifier: RecordIdentifier, key: string)

  setRecordId(identifier: RecordIdentifier, id: string): void;

  getErrors(identifier: RecordIdentifier)
  getMeta(identifier: RecordIdentifier)

  isNew(identifier: RecordIdentifier): boolean;
  isDeleted(identifier: RecordIdentifier): boolean;

  setDirtyAttribute(identifier, key: string, value: any): void;

  addToHasMany(key: string, identifiers: Identifier[], idx?: number): void;
  removeFromHasMany(key: string, identifiers: Identifier[]): void;
  setDirtyHasMany(key: string, identifiers: Identifier[]): void;

  setDirtyBelongsTo(name: string, identifier: Identifier | null): void;
}

interface RecordDataFor {
  (identifier: RecordIdentifier): RecordDataWrapper
}

class Store {
  instantiateRecord(
    identifier: RecordIdentifier,
    createRecordArgs: { [key: string]: any }, // args passed in to store.createRecord() and processed by recordData to be set on creation
    recordDataFor: RecordDataFor,
    notificationManager: NotificationManager): unknown

  teardownRecord(record): void
}
```

Instead of passing the entire RecordData Class to `instantiateRecord`, we pass in a lookup method that returns a record data wrapper which exposes only the local facing methods and hide the server/adapter facing methods that the Model should not have access to.

We also expose `teardownRecord`, which will get called whenever a record is getting unloaded, or otherwise disposed of (if we add future ways of destroying records that are uncoupled from unloading) from the identity map, thus giving addons an opportunity to perform cleanup.

## Change Notification

In order for the record class to learn about changes to the underlying data, it will be passed a `NotificationManager` as a constructor argument, which will allow it to
subscribe and unsubscribe to notifications of underlying changes to the data. Once `RecordData` calls one of the notification methods, the notification manager will call
any registered callback for the given identifier, and pass in the type of the notification, allowing the record the opportunity to repull the data if needed. There are no guarantees around the timing of the notification callback being called after `RecordData` informs the store of changes. We expect that in a modern Ember app with tracked properties, this wouldn't be the common path for tracking changes.

```ts
function unsubscribe(token: UnsubscribeToken)

interface NotificationCallback {
  (identifier: Identifier, notificationType: 'attributes' | 'relationships' | 'errors'  | 'meta'  | 'unload'): void;
}

interface NotificationManager {
  subscribe(identifier, NotificationCallback): UnsubscribeToken
 }
```

## Exposing schema information

We currently keep schema information on `DS.Model` class. In order to allow for custom Model implementations we need to allow lookup of schema info from the store. We already have specified a schema api that RecordData consumes: `attributesDefinitionFor` and `relationshipDefinitionFor`. We would define on a schema interface that the store would expose and addons could use. **The schema methods are not ergonomic on purpose.** They match the current Record Data apis and are designed as a stepping stone on the way of having a better, user facing schema APIs. Addons could provide their own `SchemaDefinitionService` by calling `registerSchemaDefinitionService`. We would initially not allow calling `registerSchemaDefinitionService` more than once, but this constraint could potentially be relaxed in the future. The schema info is currently primarily geared towards being used by the internal relationship handling layer, the serializer/adapter layers and the DebugAdapter. Schema methods support both static and dynamic schema computation. For static schemas, the method can always respond with a schema definition based on the type passed, and for dynamic changing schemas, it can look up the underlying data by the identifer which is passed in. We would also add a method called `doesTypeExist`, which would return `true` if ED knew that a given string is a model type and `false` otherwise.


```ts
export interface RelationshipDefinition {
  kind: 'hasMany'| 'belongsTo';
  type: string;
  options: { [key: string]: any } ;
  name: string;
}

interface RelationshipsDefinition {
  [key: string]: RelationshipDefinition
}

interface AttributeDefinition {
  name: string;
  options: { [key: string]: any };
  type: string;
}

interface AttributesDefinition {
  [key: string]: AttributeDefinition
}

interface SchemaDefinitionService {
  // Following the existing RD implementation
  attributesDefinitonFor(identifier: RecordIdentifier | type: string): AttributesDefiniton

  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | type: string): RelationshipsDefinition

  doesTypeExist(type: string): boolean
}

class Store {
  registerSchemaDefinitionService(schema: SchemaDefinitionService): void

  getSchemaDefinitionService(): SchemaDefinitionService
}
```

## Adding store methods for manipulating records

Currently there exist methods on DS.Model that call into `internalModel` for it's functionality. In order for a parallel implementation
to be possible, we need to expose that functionality through public methods on the store.

```ts
class Store {
  saveRecord(record): Promise // equivalent of currently doing record.save()
  serializeRecord(record): any // equivalent of currently doing record.serialize()
  relationshipReferenceFor(identifier: RecordIdentifier, key: string): RelationshipReference
}
```

this would allow you to have a custom model class like this:

```ts
class CustomModel {
  save() {
    return this._store.saveRecord(this);
  }
}
```

### Record Arrays

Currently Ember Data manages live Record Arrays which are returned as a response to query methods such as `findAll` or `queryRecords`. Because ED can track records which are returned from `instantiateRecord`, it will be able to seamlessly manage custom models which are part of Ember Data record arrays and clean them up correctly.

If an addon implements it's own record array like structures, it will be able to manage membership of Ember Data default records by subclassing `teardownRecord`, which gives it a convinient place to listen for a record being destroyed.


## Deprecating DS.Model being passed to serializers and adapters and store.modelFor

Currently some adapter/serializer methods get the underlying class passed in. For example:

```ts
// Adapter
createRecord(store, type, snapshot)
findRecord(store, type, id, snapshot)

// Serializer
normalizeResponse(store, primaryModelClass, payload, id, requestType)

// Store
modelFor(modelName)
```

### Serializing

When serializing we already have a `Snapshot` passed in as an argument which has all of the information that a `ModelClass` provides. We would deprecate the class argument being passed in, and instruct the user to refactor towards using the `Snapshot`.

For example:
```ts
createRecord(store, type, snapshot) {
  let url = `/api/${type.modelName}`;
}
```

would become

```ts
createRecord(store, type, snapshot) {
  let url = `/api/${snapshot.modelName}`;
}
```

 For backwards compatibility, we would still lookup the class from the registry, and if we found a class we would return it but would no longer error if null was returned. If we did not find the class, we would create a shim class that exposed a deprecated `modelName`. We would deprecate accessing the properties on the class when passed to serializer/adapter by wrapping it in a proxy in dev mode. Currently Snapshots contain all of the data that is available on the Model class which would be needed for serializing/normalizing.

### Normalizing

While `Snapshot` roughly corresponds to a `Request` like object to be used while serializing, and we intend to in the future refactor it to be a request object, we don't have a similar construct when normalizing. In the future, normalizing will have a corresponding `Response` like object exposed, but for the time being we can still deprecate using the `primaryModelClass` argument for anything other than `modelName`, `eachAttribute`, `eachRelationship`. If a user accesses any other property on the `primaryModelClass` they will receive a deprecation.

If there was a custom model instance provided, and we had no corresponding class to pass in to `normalizeResponse` we would pass in a shim class that only exposed the `modelName` property, and `eachAttribute` and `eachRelationship` methods which would proxy to the underlying schema methods, thus allowing the normalization layers to continue working with custom model classes.

```ts
interface ClassSchemaShim {
  modelName: string;
  eachAttribute( (name: string, attr: AttributeDefinition): void ): void;
  eachRelationship( (name: string, attr: AttributeDefinition): void ): void;
}
```


## How we teach this

This is a very addon/very power user specific api, and would be inappropriate for the default guides. We would document it in the Api docs and potentially if there was a guide for Ember Data addon developers.



---

---
stage: recommended
start-date: 2019-05-20T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/491
project-link:
---

# Deprecate `disconnectOutlet`

## Summary

This RFC deprecates `Route#disconnectOutlet` because it has no use case given [#418](https://github.com/emberjs/rfcs/pull/418).

## Motivation

`Route#disconnectOutlet` is intended to be used in conjunction with `Route#render`. When we wrote [#418](https://github.com/emberjs/rfcs/pull/418) we should have also deprecated `Route#disconnectOutlet` because it is primarily used to teardown named outlets setup by `Route#render`. For all intensive this is just an addendum to #418.

## Transition Path

The transition path is the same to the one outlined in [#418](https://github.com/emberjs/rfcs/blob/master/text/0418-deprecate-route-render-methods.md#transition-path). Since the migration path for the named outlets is to use components, a developer would need to wrap the component in a conditional if they want to control the destruction.

Given:

```js
// app/routes/checkout.js

class CheckoutRoute extends Route {
  // ...

  @action
  showModal() {
    this.render('modal', {
      outlet: 'modal',
      into: 'application'
    });
  }

  @action
  hideModal() {
    this.disconnectOutlet('modal');
  }
}
```

```hbs
{{! app/templates/checkout.hbs}}

<button {{action 'showModal'}}>Show Modal</button>
<button {{action 'closeModal'}}>Close Modal</button>
```

```hbs
{{! app/templates/application.hbs}}
{{outlet "modal"}}

<main>
  {{outlet}}
</main>
```

This can transitioned to:

```js
// app/controller/checkout.js

class CheckoutController extends Controller {
  // ...
  @tracked isModalOpen = false;

  init() {
    super.init();
    this.modalElement = document.getElementById('modal');
  }

  @action
  showModal() {
    this.isModalOpen = true;
  }

  @action
  closeModal() {
    this.isModalOpen = false;
  }
}
```

```hbs
{{! app/templates/checkout.hbs}}

<button {{action 'showModal'}}>Show Modal</button>
<button {{action 'closeModal'}}>Close Modal</button>

{{#if this.isModalOpen}}
  {{#in-element this.modalElement}}
    <Modal />
  {{/in-element}}
{{/if}}
```

```hbs
{{! app/templates/application.hbs}}
<div id="modal"></div>

<main>
  {{outlet}}
</main>
```

The above example will conditionally append the modal component into `div#modal` whenever the user toggles the modal.

## How We Teach This

Once deprecated, developers will be presented with the following deprecation warning:

```
"disconnectOutlet" has been deprecated for disconnecting outlets.
```

This deprecation message will also link to the transition guide. The transition guide will cover how to migrate named outlets to components. In addition, the guides should be updated to remove any usage of these APIs.

## Drawbacks

N/A. This addendum to [#418](https://github.com/emberjs/rfcs/pull/418).

## Alternatives

N/A. This addendum to [#418](https://github.com/emberjs/rfcs/pull/418).

## Unresolved questions

> Optional, but suggested for first drafts. What parts of the design are still
TBD?


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-05-30T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/494
project-link:
---

# Async Observers

## Summary

Add a way to specify whether or not observers should fire synchronously -
that is, immediately after the property they are observing has changed - or
asynchronously during the next runloop, along with an optional feature to
specify whether observers should default to sync or async.

## Motivation

Observers have been run synchronously in Ember since before v1.0 was released,
and for about as long it has been an intention of the core team to eventually
make them asynchronous. There are a two main reasons for why triggering
observers asynchronously would be better overall:

- They promote better programming practices. Synchronous observers can be used
  in a lot of ways to interact with the code they are observing, which puts more
  code on the "hot-path" and is prone to create a mess of intertangled, loosely
  related code filled with [spooky action at a distance](<https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)>).
- It would allow us to clean up a significant chunk of code within Ember
  itself. There is non-trivial amount of code dedicated to sending change
  signals synchronously, and that code has been slowly replaced by an
  alternative system that is lazy. Asynchronous observers would allow us to
  remove legacy code and tech debt.

We implemented this change behind a feature flag, and several community members
tested it out in their applications. In testing, we found that this was
unfortunately too much of a breaking change to do all at once - like it or not,
the timing semantics of observers are public API.

The proposed solution now is to provide a method for users to specify whether an
observer should be sync or async. In existing apps, observers can be converted
incrementally to be async, giving them a path forward. In addition, an optional
feature will be made which sets observers to be async by default, allowing users
to set the default once their whole app has been converted, and allowing new
apps to prevent/discourage sync observers in the first place. In the long run,
synchronous observers will be deprecated and removed.

## Detailed design

### New APIs

A new `sync` boolean argument will be added to both `addObserver` and
`removeObserver`:

```ts
export function addObserver(
  obj: any,
  path: string,
  target: object | Function | null,
  method?: string | Function,
  sync = SYNC_DEFAULT
): void;

export function removeObserver(
  obj: any,
  path: string,
  target: object | Function | null,
  method?: string | Function,
  sync = SYNC_DEFAULT
): void;
```

The argument needs to be added to both because sync and async observers are
tracked separately, so we need to know where to look for the observer when
removing it. Attempting to add both a sync and async observer will throw an
error.

In addition, a new overloaded form of `observer` will allow users to specify
whether or not the observer should be sync or async:

```ts
type ObserverDefinition = {
  dependentKeys: string[];
  fn: Function;
  sync: boolean;
};

export function observer(...args: (string | Function)[]): Function;
export function observer(definition: ObserverDefinition): Function;
```

Users will have to provide a full `ObserverDefinition` to set `sync`, which will
prevent us from having to do any more argument munging to figure out what the
user wants.

### Synchronous Observer Implementation

Since chains are removed, the only way to check if observers should fire is to
cycle through all of them. This means that on every `notifyPropertyChange`, we
will cycle through _all_ active synchronous observers and fire any that have
dirtied.

In apps that are observer heavy, this could lead to performance impacts.
Unfortunately, there isn't much we can do about this. We will try to minimize
the impact as much as possible, but in the end it will be up to individual
applications to migrate away from synchronous observers over time.

### Tracked Properties and `@dependentKeyCompat`

Tracked properties and `@dependentKeyCompat` marked getters/setters will _not_
fire observers synchronously, since they do not use `notifyPropertyChange` or
the old change tracking system at all. In this way, they will encourage users to
convert to async observers, or away from observers entirely.

### Optional Feature

The name of the feature will be `default-async-observers`. Enabling it will
default all observers to be async, but still allow users to set observers to be
synchronous manually. This flag will be enabled by default in Ember Octane.

## How we teach this

### API Docs

(To be added at the [end of the current API docs](https://github.com/emberjs/ember.js/blob/4a98e1610b795edb544513f10a8870af1375141d/packages/%40ember/-internals/runtime/lib/mixins/observable.js#L359))

#### `sync`

By default in new Ember applications, observers are asynchronous. They can be
marked as _synchronous_ instead by using the `sync` option. Synchronous
observers will run immediately when the property they are observing changes,
instead of being scheduled to run later.

Each synchronous observer has a performance impact for every property change, so
you should generally avoid using synchronous observers.

In older applications, observers are synchronous by default. You can use the
`sync` option to make them asynchronous instead and convert them over time. You
can also enable the `default-async-observers` optional feature to make them
asynchronous by default, once you are sure that they will continue to function
if they are asynchronous.

### Guides

Observers are not discussed in the post-Octane guides, since we don't want to
encourage their use. It may make sense to include a section on them in the
upgrade guide instead.

### Upgrade Guides

We should make a note in the Octane upgrade guides that sync observers are
discouraged and probably not very performant. We should be up front that this
will likely be a performance hit, but that we decided it was worth the benefits
of the change.

## Drawbacks

The biggest potential drawback is in performance. While we haven't been able to
do any testing on apps that have observers, its possible that these changes will
have an impact on them, especially apps that have many observers.

In theory, this shouldn't impact the majority of Ember apps since observers have
been discouraged so heavily for such a long time. The impact should also
decrease in time, as users transition away from observers entirely and toward
tracked properties.

## Alternatives

- We could release Ember v4, and ship asynchronous observers as a breaking
  change. We currently believe this would be a breaking change that would
  prevent many users from adopting Octane or transitioning forward to tracked
  properties, which would be problematic and could divide the community.

## Unresolved questions

What is the exact performance impact? Can we test it out in an application that
represents a typical Ember app that uses observers?


---

---
stage: recommended
start-date: 2019-02-14T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/496'
  recommended: 'https://github.com/emberjs/rfcs/pull/1024'
project-link:
---

# Handlebars Strict Mode

## Summary

In this RFC, we propose a set of changes to Ember's variant of Handlebars that
are aimed at codifying best practices, improving clarity and simplifying the
language. Together, these changes are bundled into a "strict mode" that Ember
developers can opt-into. In contrast, the non-strict mode (i.e. what developers
are using today) will be referred to as "non-strict mode" in this RFC.

This RFC aims to introduce and define the semantics of the Handlebars strict
mode, as well as the low-level primitive APIs to enable it. However, it does
not introduce any new user-facing syntax or conveniences for opting into this
mode.

The intention is to unlock experimentation of features such as template
imports and single-file components, but those features will require further
design and iterations before they can be proposed and recommended to Ember
users.

## Motivation

Ember has been using Handlebars since it was released 7 years ago (!). Over
time, we have evolved, adapted and in some case repurposed the Handlebars
language significantly (remember "context-shifting" `{{#each}}`?). This RFC
proposes to provide a "strict mode" opt-in to remedy some of Handlebars' design
decisions that we have come to regret over the years, or are otherwise not a
good fit for Ember. We believe this will make the Handlbars language easier to
learn, understand and implement, as well as enable better tooling to support
common development workflows for Ember developers.

We propose the following changes:

1. No implicit globals
2. No implicit `this` fallback
3. No implicit invocation of argument-less helpers
4. No dynamic resolution
5. No evals (no partials)

### 1. No implicit globals

Today, Ember implicitly introduces a set of implicit globals into a template's
scope, such as built-in helpers, components, modifiers. Apps and addons also
have the ability to introduce additional implicit globals by placing files into
the `app` folder or broccoli tree. It is also possible to further influence
this behavior by using the intimate resolver API (such as the alternative
"pods" layout).

This adds a fair amount of dynamism, ambiguity and confusion when reading
templates. When an identifier is encountered, it's not always clear where this
value comes from or what kind of value it may be. This problem is especially
acute for the "ambigious content" position, i.e. `<div>{{foo-bar}}</div>`,
which could be a local variable `foo-bar`, a global component or a helper named
`foo-bar` provided by the app or an addon, or `{{this.foo-bar}}` (see the next
section). This problem is even worse when there is a custom resolver involved,
as the resolver may return a component or helper not found in the "expected"
location at runtime.

Not only is this confusing for the human reader, it also makes it difficult for
the Glimmer VM implementation as well as other ecosystem tooling. For example,
if the developer made a typo, `{{food-bar}}`, it would be impossible to issue
a static error (build time error, inline error in IDEs) because the value may
be resolvable at runtime. It is also difficult, and in some cases impossible,
to implement IDE features such as "Jump to definition" without running code.

[RFC #432](https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals)
described some additional issues with the current implicit globals semantics.

We propose to remove support for implicit globals in strict mode. All values
must be explicitly brought into scope, either through block params or defined
in the "ambient scope" (see [Detailed design](#detailed-design) section).

### 2. No implicit `this` fallback

Today, when Ember sees a path like `{{foo}}` in the template, after exhausting
the possibilities of implicit globals, it falls back to `{{this.foo}}`. This
adds to the same confusion outlined above. More details about the motivation
can be found in the accepted [RFC #308](https://github.com/emberjs/rfcs/pull/308).

We propose to remove support for implicit `this` fallback in strict mode. The
explicit form `{{this.foo}}` must be used to refer to instance state, otherwise
it will trigger the same errors mentioned in the previous section.

It is worth mentioning that [RFC #432](https://github.com/emberjs/rfcs/pull/432)
laid out a transition path towards a world where "everything is a value".
Between this and the previous restriction, we essentially have completed that
transition. To recap, here is a list of the
[outstanding issues](https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals):

1. Not possible to reference globals outside of invocation positions
2. Invocation of global helpers in angle bracket named arguments positions
3. Naming collisions between global components, helpers and element modifiers

All of these problems are all related to implicit globals and/or implicit
`this` fallback. Since neither of these features are supported in strict mode,
they are no longer a concern for us.

### 3. No implicit invocation of argument-less helpers

In the contextual helpers RFC, we discussed [an issue](https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals)
regarding the invocation of arguments-less helpers in invocation argument
positions.

In today's semantics, if there is a global helper named `pi`, the following
template will result it the helper being invoked, and the result of the helper
invocation will be passed into the component.

```hbs
<MyComponent @value={{pi}} />
```

This is not desirable behavior in the value-based semantics proposed in that
RFC, because it makes it impossible to pass helpers around as values, just as
it is possible to pass around contextual components today.

The contextual helper RFC proposed to deprecate this behavior and require
mandatory parentheses to invoke the helper.


```hbs
{{!-- passing the helper pi to the component --}}
<MyComponent @value={{pi}} />

{{!-- passing the result of invoking the helper pi to the component --}}
<MyComponent @value={{(pi)}} />
```

In strict mode, the current, soon-to-be-deprecated behavior will be removed,
and the parentheses syntax will be mandatory.

Note that this only affects arguments-less helpers, which are exceedingly rare,
as most helpers perform self-contained computations based on the provided
arguments. It also only affect argument positions. In content and attribute
positions, the intent is clear as it does not make sense to "pass a helper into
the DOM". The parentheses-less form will continue to work in those positions,
although the explicit parentheses are also permitted.

### 4. No dynamic resolution

Today, Ember supports passing strings to the `component` helper (as well as the
`helper` and `modifier` helpers proposed in [RFC #432](https://github.com/emberjs/rfcs/pull/432)).
This can either be passed as a literal `{{component "foo-bar"}}` or passed as a
runtime value `{{component this.someString}}`. In either case, Ember will
attempt to _resolve_ the string as a component.

It shares some of the same problems with implicit globals (where did this come
from?), but the dynamic form makes the problem more acute, as it is difficult
or impossible to tell which components a given template is dependent on. As
usual, if it is difficult for the human reader, the same is true for tools as
well. Specifically, this is hostile to "tree shaking" and other forms of static
(build time) dependency-graph analysis, since the dynamic form of the component
helper can invoke _any_ component available to the app.

We propose to remove support for these forms of dynamic resolutions in strict
mode. Specifically, passing a string to the `component` helper (as well as the
`helper` and `modifier` helpers), whether as a literal or at runtime, will
result in an error.

In practice, it is almost always the case that these dynamic resolutions are
switching between a small and bounded number of known components. For this
purpose, they can be replaced by patterns similar to this.

```js
import Component from '@glimmer/component';
import { First, Second, Third } from './contextual-components';

class ProviderComponent extends Component {
  get selectedComponent() {
    switch(this.args.selection) {
      case "first":
        return First;
      case "second":
        return Second;
      case "third":
        return Third;
    }
  }
}
```

```hbs
{{yield this.selectedComponent}}
```

This will make it clear to the human reader and enable tools to perform
optimizations, such as tree-shaking, by following the explict dependency graph.

### 5. No evals (no partials)

Ember currently supports the `partial` feature. It takes a template name, which
can either be passed as a literal `{{partial "foo-bar"}}` or passed as a
runtime value `{{partial this.someString}}`. In either case, Ember will resolve
the template with the given name (with a prefix dash, like `-foo-bar.hbs`) and
render its content _as if_ they were copy and pasted into the same position.

In either case, the rendered partials have full access to anything that is "in
scope" in the original template. This includes any local variables, instance
variables (via implicit `this` fallback or explicitly), implicit globals, named
arguments, blocks, etc.

This feature has all of the same problems as above, but worse. In addition to
the usual sources (globals, `this` fallback etc), each variable found in a
partial template could also be coming from the "outer scope" from the caller
template. Conversely, on the caller side, "unused" variables may not be safe
to refactor away, because they may be consumed in a nested partial template.

Not only do these make it difficult for humans to follow, the same is true for
tools as well. For example, linters cannot provide accurate undefined/unused
variables warning. Whenever the Glimmer VM encounter partials, it has to emit
a large amount of extra metadata just so they can be "wired up" correctly at
runtime.

This feature has already been deprecated, and we propose to remove support for
partials completely in strict mode. Until the feature has been removed from
Ember itself, invoking the `{{partial ...}}` keyword in strict mode will be a
static (build time) error.

The use case of extracting pieces of a template into smaller chunks can be
replaced by [template-only components](https://github.com/emberjs/rfcs/pull/278).
While this requires any variables to be passed explicitly as arguments, it also
removes the ambiguity and confusions.

It should also be mentioned that the `{{debugger}}` keyword also falls into the
category of "eval" in today's implementation, since it will be able to access
any variable available to the current scope, including `this` fallback and when
nested inside a partial template. However, with the other changes proposed in
this RFC, we will be able to statically determine which variables the debugger
will have access to. Therefore we would still be able to support debugger usage
in strict mode without a very high performance penalty.

## Detailed design

This RFC aims to introduce and define the semantics of the Handlebars strict
mode, as well as the low-level primitive APIs to enable it. However, it does
not introduce any new user-facing syntax or conveniences for opting into this
mode.

The intention is to unlock experimentation of features such as template
imports and single-file components, but those features will require further
design and iterations before they can be proposed and recommended to Ember
users.

During this phase of experimentation, these low-level APIs will also enable
other build tools (such as [ember-cli-htmlbars](https://github.com/ember-cli/ember-cli-htmlbars))
to provide their own API for users to opt-in. In addition, once this RFC is
approved and implemented in Ember, these low-level APIs will have the same
semver guarentees as any other APIs in Ember, allow these experimentations to
be built on stable grounds.

### Low-level APIs

We propose to add an option to Ember's template compiler to enable strict mode
compilation.

There are three primitive APIs involved in compiling Ember templates, `precompile`,
`template` and `compile`.

The `precompile` function (a.k.a. [`precompileTemplate`](https://github.com/ember-cli/ember-rfc176-data))
is responsible for taking a template string, running AST plugins, checking for
errors and returning the "wire format" representation of the template. The
exact details of this "wire format" is unspecified and changes from time to
time across minor Ember versions. The only guarantee is that it returns a
string whose content is a valid JavaScript expression.

For example:

```js
import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate('Hello, {{name}}!', {
  moduleName: 'hello.hbs'
}); /* => `{
  "id": "AoL2bkKU",
  "block": "{\"statements\":[\"...\"]}",
  "meta": {"moduleName":"hello.hbs"}
}` */
```

Again, the exact wire format changes from time to time, but the key is that the
content is valid JavaScript. This allows build tools to take this output and
insert it into any context where JavaScript expressions are allowed.

At runtime, the "wire format" can be "rehydrated" into something consumable by
Ember via the `template` function (a.k.a. [`createTemplateFactory`](https://github.com/ember-cli/ember-rfc176-data)).

Build tools typically compile templates into JavaScript modules by combining
these two pieces. In our example, the `hello.hbs` template is typically
compiled into a module similar to this:

```js
import { createTemplateFactory } from '@ember/template-factory';

export default createTemplateFactory({
  "id": "AoL2bkKU",
  "block": "{\"statements\":[\"...\"]}",
  "meta": { "moduleName": "hello.hbs" }
});
```

Finally, the `compile` function (a.k.a. [`compileTemplate`](https://github.com/ember-cli/ember-rfc176-data))
is a convenience helper that simply combines the two steps by taking a raw
template string and returning a ready-to-be-consumed template object (the
output of `createTemplateFactory`), instead of the wire format. This is
mostly used for compiling templates at runtime, which is pretty rare.

We propose to introduce a new `strictMode` option to the `precompile` and `compile`
functions to enable strict mode compilation:

```js
import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate('Hello, {{name}}!', {
  moduleName: 'hello.hbs',
  strictMode: true
});
```

### The ambient scope

Since there are no implicit globals in strict mode, there has to be an
alternative mechanism to introduce helpers and components into scope.

Whenever the strict mode compiler encounters an undefined reference, i.e. an
identifier that is not a currently in-scope local variable (block param), the
default behavior is to assume that these are references to variables in the
_ambient scope_. That is, the compiler will emit JavaScript code that contains
JavaScript references to these variables.

For example, consider the following template:

```hbs
{{#let this.session.currentUser as |user|}}
  <BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} />
{{/let}}
```

Here, `this.session.currentUser` is an explicit reference to the component's
instance state, `user` is a local variable introduced by the `#let` helper and
`@model` is a reference to a named argument. They all have obvious semantics.

On the other hand, `BlogPost` and `titleize` are undefined references. The
compiler will assume that they are defined in the surrounding _ambient scope_
at runtime and produce an output like this:

```js
import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate(`{{#let this.session.currentUser as |user|}}
  <BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} />
{{/let}}`, {
  moduleName: 'index.hbs',
  strictMode: true
}); /* => `{
  "id": "ANJ73B7b",
  "block": "{\"statements\":[\"...\"]}",
  "meta": { "moduleName": "index.hbs" },
  "scope": () => [BlogPost, titleize],
  "isStrictMode": true
}` */
```

Again, the specific format here is unimportant and subject to change. The key
here is that the JavaScript code produced by the compiler contains references
(via the `scope` closure in this hypothetical compilation) to the JavaScript
variables `BlogPost` and `titleize` in the surrounding JavaScript scope.

The build tool is responsible for "linking" these undefined references by
putting the compiled JavaScript code inside a JavaScript context where these
variables are defined. Otherwise, depending on the configuration, the undefined
references will either cause a static (build-time) error from the linter,
transpiler (e.g. babel) or packager (e.g. rollup or webpack), or a runtime
`ReferenceError` when the code is evaluated by a JavaScript engine.

This low-level, primitive feature is mainly useful for building user-facing
template import and single-file component features. While this RFC does not
propose a user-facing syntax for these features, here is a hypothetical
template import syntax for the illustrative purposes only:

```hbs
---
import { titleize } from '@ember/template-helpers';
import BlogPost from './components/blog-post';
---

{{#let this.session.currentUser as |user|}}
  <BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} />
{{/let}}
```

The build tool can compile this into a JavaScript module like this:

```js
import { createTemplateFactory } from '@ember/template-factory';
import { titleize } from '@ember/template-helpers';
import BlogPost from './components/blog-post';

export default createTemplateFactory({
  "id": "ANJ73B7b",
  "block": "{\"statements\":[\"...\"]}",
  "meta": { "moduleName": "index.hbs" },
  "scope": () => [BlogPost, titleize],
  "isStrictMode": true
});
```

When this is evaulated by a JavaScript engine, the references in the `scope`
closure will automatically be "linked up" with the imports, and Ember will be
able to reference these values when rendering the template. Note that these
references are _static_–the values are essentially "snapshotted" by the
rendering engine whenever the template is instantiated. Updates to these values
in the JavaScript scope will _not_ be observable by the rendering engine, even
in conjunction with `Ember.set` or `@tracked`.

Optionally, the build tool can choose to restrict the set of allowed ambient
references by suppling an array of available identifiers to the compiler:

```js
import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate(`{{#let this.session.currentUser as |user|}}
  <BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} />
{{/let}}`, {
  moduleName: 'index.hbs',
  strict: true,
  scope: ['BlogPost', 'titleize'],
  isStrictMode: true
});
```

If the template compiler encounters any undefined references outside of this
allowed list, it will throw an error with the appropiate location info. It also
follows that build tools can choose to disable this feature completely by
passing an empty array.

### Keywords

While most items should be imported into scope explicitly, some of the existing
constructs in the language are unimportable will be made available as keywords
instead:

* `action`
* `debugger`
* `each-in`
* `each`
* `has-block-params`
* `has-block`
* `hasBlock`
* `if`
* `in-element`
* `let`
* `link-to` (non-block form curly invocations)
* `loc`
* `log`
* `mount`
* `mut`
* `outlet`
* `query-params`
* `readonly`
* `unbound`
* `unless`
* `with`
* `yield`

These keywords do _not_ have to be imported into scope and will always be
ambiently available.

On the other hand, the following built-in constructs will need to be imported
(the current or proposed import paths in parentheses):

* `array` (`import { array } from '@ember/helper`)
* `concat` (`import { concat } from '@ember/helper`)
* `fn` (`import { fn } from '@ember/helper`)
* `get` (`import { get } from '@ember/helper`)
* `hash` (`import { hash } from '@ember/helper`)
* `on` (`import { on } from '@ember/modifier'`)
* `Input` (`import { Input } from '@ember/component`)
* `LinkTo` (`import { LinkTo } from '@ember/routing`)
* `Textarea` (`import { Textarea } from '@ember/component'`)

In general, built-ins that can be made importable should be imported. The main
difference are that some of the keywords uses internal language features (e.g.
implemented via AST transforms) that requires them to be keywords.

Some of the keywords included in the list are considered legacy, and may be
deprecated in the future via future RFCs. If that happens before strict mode
becomes available in a stable release of Ember, those RFC may propose to drop
support for the legacy keywords in strict mode altogether.

### Deprecations

The following features should be deprecated and removed in non-strict mode:

* Implicit `this` fallback, proposed in [RFC #308](https://github.com/emberjs/rfcs/blob/master/text/0308-deprecate-property-lookup-fallback.md)
* Implicit invocation of argument-less helpers, proposed in [RFC #432](https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md)
* Partials, proposed in [RFC #449](https://github.com/emberjs/rfcs/blob/master/text/0449-deprecate-partials.md)

When all of these features are removed, the main difference between non-strict mode
and strict mode will be the precense of globals and the ability to perform
dynamic runtime resolutions.

## How we teach this

Strict mode is intended to become the main way Ember developers author
templates going forward. We anticipate this is going to be a slow transition,
but once the majority of Ember developers have migrated, we expect them to find
it clearer, more intuitive and more productive.

Three of the strict mode restrictions—no implicit `this` fallback, no implicit
invocation of argument-less helpers and no eval—were already proposed in their
respective RFCs. These features will be deprecated in non-strict mode templates and
can be fixed incrementally. We should continue implementing these deprecatios
as already proposed and encouraged adoption. It is quite likely that by the
time strict mode becomes widely available, these deprecations will have already
been implemented and fixed in most Ember applications.

On the other hand, implicit globals and dynamic resolutions are not going away
anytime soon in non-strict mode. These features are intrinsically tied to non-strict
mode, and we expect developers to migrate to template imports or single-file
components when those over time, which would also opt them into strict mode,
when those features become available.

That being said, this RFC does not propose any user-facing changes and there
will be no official, application-level opt-in to strict mode until either
template imports or single-file components exit the experimental phase and
become adopted as official feature in Ember via a future RFC.

Therefore, we do not recommend making any changes to the guides to document the
strict mode semantics at this stage. Instead, the guides should be updated to
feature template imports or single-file components when they become available.

As for the low-level APIs, we should update the API documentation to cover the
new flags (`strictMode` and `scope`). The documentation should cover the details of
the "ambient scope" feature discussed in this RFC, and emphasize that it is
intended for linking static values such as helpers and components.

## Drawbacks

We could just deprecate without removing `this` fallback and partials, and let
implicit globals and dynamic resolution co-exist with template imports (the
primary consumer of the proposed strict mode). However, this will create a very
confusing compromise and users will not get most of the benefits of having
template imports in the first place. We will also lose out on the opportunity
to improve on the static guarantees in order to build better tools. Leaving
around implicit globals also has the [issues](https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals)
discussed in the contextual helpers RFC.

## Alternatives

1. Instead of bundling these into a single "strict mode" opt-in, we could
   allow developers to opt-in to each of these restrictions individually.

   In addition to the teaching and discoverability problems, we will also need
   to build additional tooling and configuration mechanism (`handlebars.json`?)
   for this.

   By adopting these piecemeal, we will also have to define the interaction and
   combined semantics for any possible combinations of these flags, and tooling
   will be unable to take advantage of the improved static guarantees without
   doing a lot of work to account for all these possibilities.

2. Instead of proposing a standalone strict mode, we could just bundle these
   semantics into the templates imports proposal.

   That would make it a very long and complex RFC. In addition, other build
   tools like [ember-cli-htmlbars-inline-precompile](https://github.com/ember-cli/ember-cli-htmlbars-inline-precompile)
   will not be able to adopt the same semantics.

3. Switch to HTML attributes by default in strict mode.

   Today, Glimmer uses a complicated set of heuristics to decide if a bound HTML
   "attribute" syntax should indeed be set using `setAttribute` or set as a
   JavaScript property using `element[...] = ...;`. This does not always work
   well in practice, and it causes a lot of confusion and complexity.

   We intend to move to an "attributes syntax always mean attributes" (and use
   modifiers for the rare cases of setting properties). We briefly considered
   grouping that change into the strict mode opt-in, but ultimately decided it
   would be too confusing for strict mode to include such a change. It's better
   to deprecate the feature and make this an app-wide setting.

4. Fix `(action ...)` binding semantics in strict mode.

   Similarly, there are some not ideal semantics issues with `(action ...)`
   around how the function's `this` is bound. We similarly considered fixing it
   in strict mode but ultimately decided it wouldn't be appropriate.

## Unresolved questions

None


---

---
stage: released
start-date: 2019-06-21T00:00:00.000Z
release-date: 2021-06-25T00:00:00.000Z
release-versions:
  ember-cli: v3.27.0

teams:
  - cli
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/507
project-link:
---

# v2 Addon Format (Embroider Compatibility)

## Summary

This RFC defines a new package format that is designed to make Ember packages (meaning both apps and addons) statically analyzable and more compatible with the rest of the NPM & Javascript ecosystem. This RFC is the first step in stabilizing [Embroider](https://github.com/embroider-build/embroider) as our next-generation build system.

## Motivation

One of the good things about Ember is that apps and addons have a powerful set of build-time capabilities that allow lots of shared code with zero-to-no manual integration steps for the typical user. We have been doing “zero config” since before it was a cool buzzword (it was just called “convention over configuration”). And we’ve been broadly successful at maintaining very wide backward- and forward-compatibility for a large body of highly-rated community-maintained addons.

But one of the challenging things about Ember is that our ecosystem’s build-time capabilities are more implementation-defined than spec-defined, and the implementation has accumulated capabilities organically while only rarely phasing out older patterns. I believe the lack of a clear, foundational, build-time public API specification is the fundamental underlying issue that efforts like the various packaging / packager RFCs have tried to work around.

The benefits to users for this RFC (and Embroider in general) are:

- faster builds and faster NPM installs
- “zero-config import from NPM — both static and dynamic” as a first-class feature that works for both third-party libraries and Ember addons
- support for arbitrary code splitting
- tree-shaking of unused modules, components, helpers, etc from the app and all addons
- a layered build system with clearly documented APIs between the layers, so it's easier to experiment and contribute
- a build system that can take advantage of current and future investments by the wider Javascript ecosystem into code bundling & optimization.

## Key Ideas

### Fully Embrace ES Modules

Ember was one of the earliest adopters of ECMAScript modules, and Ember core team members were directly involved in helping move that features through TC39. Ember’s early experiences with modules influenced the spec itself. _Yet we have lagged in truly embracing modules._

For example, how do Ember apps express that they depend on a third-party library? The [app.import](https://ember-cli.com/user-guide/#javascript-assets) API. This should be ECMA standard `import`.

Another way to state the problem is that apps and addons all _push_ whatever code they want into the final built app. Whereas ES modules can _pull_ each other into the build as needed.

### Play nice with NPM Conventions

The ECMA module spec by itself doesn’t try to define a module resolution algorithm. But the overwhelmingly most popular convention is the [node_modules resolution algorithm](https://nodejs.org/api/all.html#modules_all_together).

Ember addons do respect node_module resolution for build-time code, but they do not respect it for runtime code. This is an unhelpful distinction.

### Verbose, Static Javascript as a Compiler Target

Ember’s strong conventions mean that many kinds of dependencies can be inferred (including _statically_ inferred) without requiring the developer to laboriously manage them. This is a good thing and I believe the current fad in the wider Javascript ecosystem for making developers hand-write verbose static imports for everything confuses the benefits of having static analysis (which is good) with the benefits of hand-managing those static imports (which is unnecessary cognitive load when you have clear conventions and a compiler).

This design is about compiling today’s idiomatic Ember code into more “vanilla” patterns that leverage ES modules, node_modules resolution, and spec-compliant static and dynamic `import` to express the structure of an Ember application in a much more “vanilla Javascript” way.

This compile step lets us separate the authoring format (which isn’t changing in any significant way in this RFC) from the packaging format (which can be more verbose and static than we would want in an authoring format).

# Detailed design

## Definitions

**package**: every addon and app is a **package**. Every "NPM package" is a **package**, but not every **package** is an "NPM package" because we also include in-repo packages. The most important fact about a package is that it’s often the boundary around code that comes from a particular author, team, or organization, so coordination across packages is a more sensitive design problem than coordination within apps.

**app**: a package used at the root of a project.

**addon**: a package not used at the root of a project. Will be an **allowed dependency** of either an **app** or an **addon**.

**allowed dependency**: For **addons**, the **allowed dependencies** are the **packages** listed in `dependencies` and `peerDependencies` in `package.json` plus any in-repo addons. For **apps**, the **allowed dependencies** are the `dependencies`, `peerDependencies`, and `devDependencies` in `package.json` plus any in-repo addons.

**Ember package metadata**: the `ember` section inside `package.json`. This already exists in v1 (it's used to set `edition`), we’re going to extend it.

**v2 package**: a package with `package.json` like:

    "keywords": [ "ember-addon" ],
    "ember": {
      "version": 2
    }

**v1 package**: a package with `package.json` like:

    "keywords": [ "ember-addon" ]

and no `version` key (or version key less than 2) in **Ember package metadata**.

**non-Ember package**: a package without `keywords: ["ember-addon"]`

## Scope of this RFC

This RFC is intended as the base level spec for v2 Ember packages. **It does not attempt to cover everything a v1 package can do today**. For example, no provision is made in this RFC for:

- providing dev middleware
- providing commands and blueprints
- preprocessing your parent package's code
- modifying your parent package's babel config
- injecting content into index.html (contentFor)

It is understood that all of these are legitimate things for Ember addons to do. Defining these capabilities within v2 packages will be done in followup RFCs. It is simply too much scope to cover in one RFC.

Because we're hyper-focused on backward- and forward-compatibility, there is no harm in progressively converting some addons to v2 (which provides immediate benefits in terms of build performance and reduced fragility under Embroider) while others need to stay as v1 until we offer the features they need.

This RFC is carefully decoupled from other new Ember features (like [strict mode](https://github.com/emberjs/rfcs/pull/496) ), but it is understood that the spec created by this RFC will become a living standard that needs to both influence and be influenced by the rest of Ember's design.

## Package Public API Overview

The format we are about to describe _is a publication format_. Not necessarily an authoring format. By separating the two, we make it easier to evolve the authoring format without breaking ecosystem-wide compatibility. The publication format is deliberately more explicit and less dynamic that what we may want for an authoring format.

First, here’s the list of things a v2 package can provide. More detail on each of these will follow:

- **Own Javascript**: javascript and templates under the package’s own namespace (the v1 equivalent is `/addon/**/*.{js,hbs}/`)
- **App Javascript**: javascript and templates that must be merged with the consuming app’s namespace (the v1 equivalent is `/app/**/*.{js,hbs}`). Other RFCs are working to move Ember away from needing this feature, but we are not gated on any of those and fully support **App Javascript**.
- **Fastboot Javascript**: just like **App Javascript**, but only applies when running in Fastboot.
- **CSS**: available for `@import` by other CSS files (both in the same package and across packages) and by ECMA `import` directives in Javascript modules (both in the same package and across packages).
- **Implicit Dependencies**: scripts, modules, and stylesheets that should be implicitly included in the app or the app's tests whenever this addon is active. This is a backward-compatibility feature.
- **Renaming Rules**: allow a package to declare that some of its modules should be available at different import paths than their real, resolvable path. This is a backward-compatibility feature that new addons should not use.
- **Externals**: allows a package to declare that it imports some things that are not **allowed dependencies**. Instead of being resolved at build time, **externals** are deferred until runtime and get handled by the traditional `loader.js` `require()`.
- **Assets**: any files that must be available in the final built application directory such that they have public URLs (typical examples are images and fonts).
- **Build Hooks**: code that runs within Node at application build time. The v1 equivalent is an addon's `index.js` file.

## Own Javascript

The public `main` (as defined in `package.json`) of a v2 package points to its **Own Javascript**. The code is formatted as ES modules that follow the **Ember Language Standard** (which is defined later in this RFC). Addon authors can still author in whatever dialect they want, but they must transpile to Ember Language Standard before publishing to NPM.

Templates are in hbs format. No custom AST transforms are supported. Addon authors can still use custom AST transforms, but those transforms must have already been applied and re-emitted into hbs source text before publication to NPM. This means that only AST transforms whose output are serializable into hbs source text are permitted.

Unlike v1 addons, there is no `/app` or `/addon` directory that is magically removed from the runtime paths to the modules. All resolution follows the prevailing Node rules.

The benefit of this design is that it makes our packages understandable by a broader set of tooling. Editors and build tools can follow `import` statements across packages and end up in the right place.

In v1 packages, `main` usually points to a build-time configuration file. That file is moving and will be described in the **Build Hooks** section below.

### Own Javascript: Imports

Modules in **Own Javascript** are allowed to use ECMA static `import` and dynamic `import()` to resolve any **allowed dependency**, causing it to be included in the build whenever the importing module is included. This replaces `app.import`. Resolution follows prevailing Node rules. (This usually means the node_modules algorithm, but it could also mean Yarn PnP. The difference shouldn't matter if you are correctly declaring all your **allowed dependencies**.)

Notice that a package’s **allowed dependencies** do not include the package itself. This is consistent with how Node resolution works. To import files from within your own package you must use relative paths. This is different from how run-time AMD module resolution has historically worked in Ember Apps. (`@embroider/compat` implements automatic adjustment for this case when compiling from v1 to v2).

### Own Javascript: Co-located Component Templates

Modules in **Own Javascript** get no _automatic_ component template co-location. They should use Ember's `setComponentTemplate` explicitly. They can access their compiled templates either by importing them or by inlining them via the `hbs` macro provided by ember-cli-htmlbars.

We're assuming that template co-location will be handled by the build step _before_ an addon is published to NPM in V2 format.

Similarly, template-only components must be explicitly present as Javascript modules that invoke Ember's `templateOnlyComponent()` and `setComponentTemplate`.

### Own Javascript: Transpilation of imported modules

Any module you import, whether from an Ember package or a non-Ember package, gets transpiled by default such that it will support the app's set of browser targets. This ensures that the app's `config/targets.js` will always be respected and you won't accidentally break your older supported browsers by importing a dependency that uses newer ECMA features.

Today in practice this means everything you import will go through babel-preset-env, and babel-preset-env will use the same configuration that it uses in the app.

There is an explicit per-package opt-out for cases where you're _sure_ that transpilation is not needed and not desirable. (See **Build Hooks** for details on the `skipBabel` option.)

### Own Javascript: Supported module formats for non-Ember packages

As already stated, V2 Ember packages must contain only ES modules. However, non-Ember packages in your **allowed dependencies** are allowed to contain ES modules _or_ CommonJS modules. This provides the best compatibility with general-purpose NPM utilities.

### Own Javascript: Macros

The V2 format deliberately eliminates many sources of app-build-time dynamism from addons. Instead, we provide an equivalently-powerful macro system and consider it an always-supported language extension (the macros are always available to every V2 package, ambiently, and we promise to give them their faithful build-time semantics).

See **Macro System** for the full details.

## App Javascript

To provide **App Javascript**, a package includes the `app-js` key in **Ember package metadata**. For example, to duplicate the behavior of v1 packages, you could say:

    "ember": {
      "version": 2,
      "app-js": "./app"
    }

Like the **Own Javascript**, the code must be authored as ES modules in **Ember Language Standard**. ECMA static and dynamic imports from any **allowed dependency** are supported. Even though the app javascript will be addressable within the _app's_ module namespace, your own imports still resolve relative to your addon.

By making `app-js` an explicit key in **Ember package metadata**, our publication format is more durable (you can rearrange the conventional directory structure in the future without breaking the format) and more performant (less filesystem traversal is required to decide whether the package is using the **App Javascript** feature.

## Fastboot Javascript

To provide **Fastboot Javascript**, a package includes the `fastboot-js` key in **Ember package metadata**. This works almost identically to **App Javascript**, except it means the given directory will only be merged into the app's namespace when running in Fastboot (server-side rendering) mode. This key is a backward compatibility feature that allows addons with a `fastboot` directory to express their needs.

New v2 packages don't need to use `fastboot-js` because they can use the macro system to branch between browser and server implementations.

## CSS

To provide **CSS**, a package can include any number of CSS files. These files can `@import` each other via relative paths, which will result in build-time inclusion (as already works in v1 packages).

If any of the **Own Javascript** or **App Javascript** modules depend on the presence of a CSS file in the same package, it should say so explicitly via an ECMA relative import, like:

    import '../css/some-component.css';

This is interpreted as a build-time directive that ensures that before the Javascript module is evaluated, the CSS file's contents will be present in the DOM. ECMA import of CSS files must always include the explicit `.css` extension.

> Q: Does this interfere with the ability to do CSS-in-JS style for people who like that?

> A: No, because that would be a preprocessing step before publication. It’s a choice of authoring format, just like TypeScript or SCSS. CSS-in-JS people would compile all their things to ES modules before we deal with it.

It is also possible for other packages (including the consuming application) to depend on a CSS file in any of its **allowed dependencies**, from either Javascript or CSS. From Javascript it looks like:

    // This will resolve the `your-addon` package and find
    // './some-component.css' relative to the package root.
    // The .css file extension is mandatory
    import 'your-addon/some-component.css';

And from CSS it looks like:

    @import 'your-addon/some-component';

What about SCSS _et al_? You’re still free to use them as your authoring format, and they should be transpiled to CSS in your publication format. If you want to offer the original SCSS to consuming packages, you’re free to include it in the publication format too. Since we’re making all packages resolvable via normal node rules, it’s now dramatically easier to implement a preprocessor that supports inter-package dependencies. (The same logic applies to TypeScript.)

## Implicit Dependencies

Within **Ember package metadata** we support several flavors of implicit dependencies:

- implicit-modules
- implicit-scripts
- implicit-styles
- implicit-test-modules
- implicit-test-scripts
- implicit-test-styles

Each one is a list of package-relative paths to files within the package.

Whenever your package is active, all of its implicit dependencies will be included in the build. The `-test-` variants will be included only in test suites, and the non-`-test-` variants are always included.

`implicit-modules` and `implicit-test-modules` mean that the app should be built as if someone has explicitly typed ECMA import statements for each of the listed modules.

`implicit-scripts` and `implicit-test-scripts` are for Javascript in a script context. Script context is different from module context (as defined by the ECMA spec). This is how an addon can push things into the equivalent of the traditional `vendor.js`, which is in script context.

`implicit-styles` and `implicit-test-styles` are for stylesheets. This is how an addon can push things into the equivalent of the traditional vendor.css.

While **Implicit Dependencies** are a fully-supported part of the v2 spec, v2 packages are encouraged to use direct ECMA `import` or CSS `@import` instead, whenever possible. A direct `import` provides finer-grained dependency information: we know exactly _which_ module inside your package actually depends on the thing, rather than needing to assume that your entire package depends on it.

For example, if one of your components depends on a third-party library, you should `import` that library directly from your component. Then the library will only be included if somebody uses that particular component. Whereas if you use `implicit-scripts`, the library will always be included, even if nobody uses the component that needs the library.

## Renaming Rules

V1 Addons have multiple ways (at least five that I've found so far!) of emitting modules that escape the addon's own package namespace. Examples:

- `ember-lodash` remaps all of its modules to the package name `lodash`
- `@ember/test-helpers` provides some modules under its true name, but also some modules under `ember-test-helpers`.

In order for Embroider compile these packages to valid V2 packages, we give V2 packages the ability to express renaming rules using the following properties in **Ember package metadata**:

- `renamed-packages`: a map from the package name a user would type to the real package name that provides it. Example:

  ```js
  {
    "renamed-packages": {
      "lodash": "ember-lodash"
    }
  }
  ```

- `renamed-modules`: a map from modules that a user may try to import to the real paths where those modules live:

  ```js
   "renamed-modules": {
    "ember-test-helpers/index.js": "@ember/test-helpers/ember-test-helpers/index.js"
   }
  ```

  When Embroider compiles a V1 package like `@ember/test-helpers` it ensures that the modules that would have "escaped" the package end up _inside_ the package, so that this kind of renaming works.

  The renaming rules allow these addons to adopt V2 format without breaking their public API. New addons _should not_ use renaming rules because it's confusing when the imports people type don't align with their real dependencies.

## Externals

The `externals` property in **Ember package metadata** allows a V2 addon to declare specific imported modules that should not be resolved at build time. Instead they will be resolved at runtime using the traditional `loader.js` `require()`.

When Embroider compiles V1 packages to V2 it does automatic externals detection.

When publishing a native V2 package, any externals need to be listed explicitly in **Ember package metadata**.

An example of when you may need `externals` is when you need to consume a script (not a module) that contains arbitrary `define()` statements. The modules defined by those statements aren't resolvable, in general, at build time. So attempts to import them will generate build errors. By listing them in externals, you can defer them until runtime where they will work.

## Assets

To provide **Assets**, a package includes the `public-assets` key in **Ember package metadata**. It's a mapping from local paths to app-relative URLs that should be available in the final app. For example:

    "name": "my-addon",
    "ember": {
      "version": 2,
      "public-assets": {
        "./public/image.png": "/my-addon/image.png"
      }
    }

with:

    my-addon
    └── public
        └── image.png

will result in final build output:

    dist
    └── my-addon
        └── image.png

Notice that we’re _not_ choosing to include assets via explicit ECMA `import`. The reason is that fine-grained inclusion of asset files is not critical to runtime performance. Any assets that your app doesn’t actually need, it should never fetch. Assets are always things with their own URLs.

If two V2 packages try to emit assets with the same public URL, that's a build error.

> Q: Should we just automatically namespace them instead?
> A: That was considered, but it makes backward compatibility harder, and public URLs are not always free to choose/change.

## Build Hooks

In today’s v1 addon packages, the `index.js` file is the main entrypoint that allows an addon to integrate itself with the overall ember-cli build pipeline. The same idea carries forward to v2, with some changes.

It is no longer the `main` entrypoint of the package (see **Own Javascript**). Instead, it’s located via the `build` key in **Ember package metadata**, which should point at a Javascript file. `build` is optional — if you don’t have anything to say, you don’t need the file.

It is now an ECMA module, not a CJS file. The default export is a class that implements your build hooks (there is no required base class).

Here is a list of build hooks, each of which will have its own section below.

- configure
- configureDependencies
- skipBabel

I will describe the hooks using TypeScript signatures for precision. This does not imply anything about us actually using TypeScript to implement them. Each package has two type variables:

- `PackageOptions` is the interface for what options you accept from packages that depend on you. It's your package's build-time public API.
- `OwnConfig` is the interface for the configuration that you want to send to your own code, which your code can access via the `getOwnConfig` macro. This is how you influence your runtime code from the build hooks.

### Build Hook: configure

```ts
interface ConfigurationRequest<PackageOptions> = {
  options: PackageOptions,
  fromPackageName: string,
  fromPackageRoot: string,
};
configure<PackageOptions, OwnConfig>(
  requests: ConfigurationRequest<PackageOptions>[]
): OwnConfig
```

The configure hook receives an array of configuration requests. Each request contain the `PackageOptions` that a package that depends on this addon has sent to this addon. It also includes the `fromPackageName` and `fromPackageRoot` (the full path on disk to the requesting package) so that any configuration errors can blame the proper source.

`configure` deals with an array because multiple packages may depend on a single copy of our package. But our package can only be configured in one way (for example, we are either going to include some extra code or strip it out via the macro system, but we can't do both).

Addons are encouraged to merge configuration requests intelligently to try to satisfy all requesters. If it's impossible to do so, you can throw an error that explains the problem.

The `OwnConfig` return value must be JSON-serializable. It becomes available to your **Own Javascript** via the `getOwnConfig` macro, so that it can influence what code is conditionally compiled out of the build.

### Build Hook: configureDependencies

```ts
configureDependencies(): {
  [dependencyName: string]: PackageOptionsForDependency | "disabled"
}
```

The `configureDependencies` hook is how you send configuration down to your own dependencies. For each package in your **allowed dependencies** you may return either the `PackageOptions` expected by that package, or the string `"disabled"`.

Any dependencies that you don't mention are considered active, but don't receive any configuration from you.

Any dependency for which you provide `PackageOptions` is active, and will receive those `PackageOptions` in its own `configure` hook.

If you set a package to `"disabled"`, it will not become active _because of your addon_. It may still become active if another package depends on it and leave it active.

When and only when a package is active:

- all standard Ember module types (`your-package/components/*.js`, `your-package/services/*.js`, etc) from its **Own Javascript** _that cannot be statically ruled out as unnecessary_ are included in the build as if some application code has `import`ed them. (What counts as “cannot be statically ruled out” is free to change as apps adopt increasingly static practices. This doesn’t break any already published packages, it just makes builds that consume them more efficient.)
- all of the package's **Implicit Dependencies** are included in the build.
- all **App Javascript** is included in the build.
- all **Assets** are included in the build.
- the package's **Active Dependencies** become active recursively.

Whether or not a package is active:

- directly-imported **Own Javascript** and **CSS** are available to any other package as described in those sections. The rationale for allowing `import` of non-active packages is that (1) we follow node module resolution and node module resolution doesn’t care about our notion of “active”, and (2) `import` is an explicit request to use the module in question. It’s not surprising that it would work, it would be more surprising if it didn’t.

The `configureDependencies` hook is the _only_ way to disable child packages. The package hooks are implemented as a class with no base class. There is no `super` to manipulate to interfere with your children’s hooks.

### Build Hook: skipBabel

```ts
skipBabel(): { package: string, semverRange?: string }[]
```

By default, all imported dependencies (and their recursive imported dependencies) go through the app's babel config. This ensures browser compatibility safety. However, we provide `skipBabel` as an opt-out to work around transpilation problems in cases where the developer has verified that transpilation of a given package isn't needed.

`skipBabel` returns a list of package names and optionally semver ranges. If no range is included, it defaults to `*`. This is a place where you're allowed to mentioned packages that are _not_ in your **allowed dependencies** because it may be necessary to talk about deeper dependencies within them. The `skipBabel` settings for all active addons are combined and if any addon skips babel for a given package & version, that causes the package to not be transpiled.

The semver range is useful to disambiguate if there are multiple versions of the same package involved in the app, and in cases where a developer has manually verified that transpilation isn't needed, it's good practice to use the semver range so that `skipBabel` doesn't accidentally apply to a future version of the package that may indeed need transpilation.

## What about Test Support?

v1 packages can provide `treeForTestSupport`, `treeForAddonTestSupport`, and `app.import` with `type="test"`. All of these features are dropped.

To provide test-support code, make a separate module within your package and tell people to `import` it from their tests. As long as it is only imported from tests, it will not be present in non-test bundles. (Things get simpler when you respect the module dependency graph.)

## Macro System

v1 packages can run arbitrary Node code that completely alters their runtime code. This makes them impossible to analyze. v2 packages are not allowed to do this. There are no "treeFor\*" hooks. Instead, they can influence their runtime code only through the macro system.

It helps to think about the macro system as an extension to Javascript itself that we allow in v2 packages. Because the macros are allowed to appear in any published V2 package, and because the macros are _not_ a dependency that each package can control (you don't get to bring your own separate macro system version with you), it's important that we design a small core that we can support for the long-term. We probably can't make breaking changes to the macro system, we can only introduce new macros.

(I'm proposing the macros live under `@ember/macros`. The current implementation of them lives in `@embroider/macros`.)

The Javascript macros are:

- importSync
- getOwnConfig
- getConfig
- macroCondition
- each
- moduleExists
- dependencySatisfies
- failBuild

The Handlebars macros are:

- macroGetOwnConfig
- macroGetConfig
- macroCondition
- macroDependencySatisfies
- macroMaybeAttrs
- macroFailBuild

The difference in naming is because the JS macros get explicitly imported from `@ember/macros`, whereas the Handlebars macros do not, so they need an appropriate namespace prefix. (If we land template imports, I'm fine with adjusting this RFC to make the names align.)

### JavaScript Macro: importSync

```js
import { importSync } from "@ember/macros";
importSync("some-dependency").default;
```

`importSync` exists to do a thing that standard Javascript does not do: synchronous dynamic import. Ember historically needs synchronous dynamic import (it's what our runtime AMD `require` does). Until some future date at which Ember has migrated away from synchronous module resolution we need `importSync`.

`importSync` is defined as behaving exactly like the standards-compliant `import()` except instead of returning `Promise<Module>` it returns `Module`.

In this RFC we don't state explicitly what `importSync` compiles to. It compiles to whatever the Javascript bundler we're using supports in order to achieve synchronous dynamic import. For example, if we're internally using Webpack we can compile `importSync("something")` to `require("something")`, because Webpack supports CommonJS `require` anywhere.

### JavaScript Macro: getOwnConfig

```js
// this example:
import { getOwnConfig } from "@ember/macros";
const shouldEnableCoolFeature = getOwnConfig().coolFeature;
// might compile to:
const shouldEnableCoolFeature = true;
// assuming your ownConfig is `{ coolFeature: true }`.
```

`getOwnConfig()` behaves like a function that returns your `OwnConfig`, as determined by the return value of your `configure` **Build Hook**. You're allowed to chain property access and optional property access (including array indices) off of `getOwnConfig()`. Since the `OwnConfig` is required to be JSON-serializable, any subset of it can be accessed this way, and we inline that value directly into the code.

You can choose to inline the whole OwnConfig if you want to:

```js
// this example:
import { getOwnConfig } from "@ember/macros";
const myConfig = getOwnConfig();
// might compile to:
const myConfig = { coolFeature: true };
// assuming your ownConfig is `{ coolFeature: true }`.
```

Since `getOwnConfig` accesses the output of your `configure` build-hook, you have a place to run arbitrary build-time code and inject the results into runtime Javascript.

### Javascript Macro: getConfig

`getConfig` can access the `OwnConfig` of your dependencies.

```js
import { getConfig } from "@ember/macros";
const testSelectorsConfig = getConfig("ember-test-selector");
```

It supports property chaining the same as `getOwnConfig`.

This is a low-level power tool. It's mostly useful as a compile target for custom Babel plugins. For example, `ember-test-selectors` has a custom Babel plugin that _sometimes_ strips test properties out of your components. But if a V2 package is using ember-test-selectors, it needs to run the custom transform _before publishing_. At that point, it's too soon to decide whether to strip them.

Instead of actually doing the stripping, the ember-test-selector plugin would compile the user's code into code that uses `macroCondition` and `getConfig('ember-test-selectors')`. In this way, we get the powerful custom behavior, but only the standard core macros are needed at the time when the app itself is building.

### JavaScript Macro: macroCondition

`macroCondition` acts like a function that takes a boolean value and returns that same boolean value. But whenever `macroCondition` appears directly inside the predicate of an `if` statement or as the predicate of a ternary expression, it tells the macro system to do branch elimination based on the predicate. Here is an example that combines three of the macros we've seen so far:

```js
// This example:
import { macroCondition, getOwnConfig, importSync } from "@ember/macros";

let implementation;

if (macroCondition(getOwnConfig().useNewVersion)) {
  implementation = importSync("./new-component");
} else {
  implementation = importSync("./old-component");
}

export default implementation;

// ==============
// Could compile down to this if OwnConfig contains { useNewVersion: true }
let implementation;
implementation = importSync("./new-component");
export default implementation;

// ===============
// Or compile down to this if OwnConfig contains { useNewVersion: false }
let implementation;
implementation = importSync("./old-component");
export default implementation;
```

It is a build error if `macroCondition` cannot statically determine the truth status of its argument. It's a build error if `macroCondition` appears anywhere other than as the predicate of an if statement or ternary expression.

`macroCondition` supports boolean logic, like `macroCondition(getOwnConfig().a && getOwnConfig().b)`.

Here is an example of `macroCondition` in a ternary expression:

```js
// this example:
const flavor = macroCondition(getOwnConfig().prefersChocolate)
  ? "chocolate"
  : "vanilla";
// could compile down to:
const flavor = "chocolate";
```

`macroCondition` is the foundation that lets us choose which code to include in the build. You can choose to inline two different implementations within the branches of an `if` statement, or you can keep them in entirely separate modules and import only the correct one via `importSync`.

It would also be possible (in the future, when top-level await stabilizes) to use [top-level await](https://github.com/tc39/proposal-top-level-await) to replace usage of our `importSync` macro with standards-compliant `import()`:

```js
if (macroConditional(getOwnConfig().x)) {
  await import("x");
} else {
  await import("y");
}
```

Q: Why not allow `if (getOwnConfig().thing)` instead of `if (macroCondition(getOwnConfig().thing))`?

A: Because we don't want to leave any confusion over whether branch elimination will be done. Boolean expressions that include a macro like `getOwnConfig` alongside other runtime-only values are perfectly legal. But those expressions would not allow branch elimination. The ambiguity means you might accidentally defeat branch elimination without noticing. `macroCondition` is intended to signal -- both to the reader and to the compiler -- that this place absolutely _must_ do branch elimination. It's an error if we can't eliminate one branch or the other.

### JavaScript macro: each

`each` allows you to unroll a loop based on an array value provided by another macro. It behaves like the identity function (returning its argument unchanged), but it provides the special guarantee that if you use it as the argument of a `for ... of` loop, the loop will be unrolled:

```js
// This example:
import { getOwnConfig, each, importSync } from "@ember/macros";
let plugins = [];
for (let plugin of each(getOwnConfig().registeredPlugins)) {
  plugins.push(importSync(plugin).default);
}

// could compile to this, given OwnConfig
// containing { registeredPlugins: ['@bigco/bar-chart', '@bigco/line-chart']}

let plugins = [];
plugins.push(importSync("@bigco/bar-chart").default);
plugins.push(importSync("@bigco/line-chart").default);
```

It is a static error if the argument to `each` does not evaluate to a statically known array.

### JavaScript Macro: moduleExists

Allow you to test if an `import` (or `import()` or `importSync()`, since they all accept an argument with identical semantics) would succeed. Always compiles to a boolean literal.

```js
import { moduleExists, macroCondition, importSync } from "@ember/macros";
if (macroCondition(moduleExists("ember-data"))) {
  const DS = importSync("ember-data").default;
  DS.Adapter.extend({
    //
  });
}
```

Remember that you're always only allowed to `import` from your own **allowed dependencies**. So if an addon wants to optionally use another package only if that package is present, that package must be listed as an **Optional Peer Dependency**.

`moduleExists` differs in one respect from all the other macros: there is no reliable build-time polyfill for it in non-Embroider builds. So when you use it in a non-Embroider build, you get a runtime implementation instead (equivalent to today's `require.has()`. If you need build-time branch elimination, try to use `dependencySatisfies` instead, which works correctly in both Embroider and non-Embroider builds.

### JavaScript Macro: dependencySatisfies

Allows you to test if the given **allowed dependency** satisfies the given semver range. Always compiles to a boolean literal.

```js
import { dependencySatisfies, macroCondition } from "@ember/macros";
if (macroCondition(dependencySatisfies("ember-data", "^3.0.0"))) {
  // include code here for ember-data 3.0 compat
}
```

The package version will be `semver.coerce`d first, such that non-standard versions like "3.9.0-beta.0" will appropriately satisfy constraints like "> 3.8".

### Javascript Macro: failBuild

Allow you to cause a build failure with a custom error message. If `failBuild` isn't eliminated by `macroCondition`'s branch elimination, the build will fail.

```js
import { dependencySatisfies, macroCondition, failBuild } from "@ember/macros";
if (macroCondition(dependencySatisfies("ember-data", "^3.0.0"))) {
  // include code here for ember-data 3.0 compat
} else {
  failBuild(`We don't support ember-data versions other than ^3.0.0`);
}
```

### Handlebars Macro: macroGetOwnConfig

`macroGetOwnConfig` is very similar to the `getOwnConfig` JS macro, but it works as a Handlebars helper. Given this `OwnConfig`:

```json
{
  "items": [{ "score": 42 }]
}
```

Then:

```hbs
<SomeComponent @score={{macroGetOwnConfig "items" 0 "score" }} />
{{! ⬆️compiles to ⬇️ }}
<SomeComponent @score={{42}} />
```

If you don't pass any arguments, you can get the whole thing (although this makes your template bigger, so use arguments when you can):

```hbs
<SomeComponent @config={{macroGetOwnConfig}} />
{{! ⬆️compiles to ⬇️ }}
<SomeComponent @config={{hash items=(array (hash score=42))}} />
```

### Handlebars Macro: macroGetConfig

The equivalent of the `getConfig` JS macro as a Handlebars helper. Given a dependency `ember-score` exposes this config:

```json
{
  "items": [{ "score": 42 }]
}
```

Then:

```hbs
<SomeComponent @score={{macroGetConfig "ember-score" "items" 0 "score" }} />
{{! ⬆️compiles to ⬇️ }}
<SomeComponent @score={{42}} />
```


### Handlebars Macro: macroCondition

Used as a helper within a block `{{#if}}` or inline `{{if}}`. Just like the JS `macroCondition`, it ensures that branch elimination will happen.

```hbs
  {{#if (macroCondition (macroGetOwnConfig "shouldUseThing")) }}
    <Thing />
  {{else}}
    <OtherThing />
  {{/if}}

  {{! ⬆️compiles to ⬇️ }}
  <Thing />
```

### Handlebars Macro: macroDependencySatisfies

Acts like a helper that returns a boolean. Like the `dependencySatisfies` JS macro, it can only resolve things that are **allowed dependencies**, so the same need for peer dependencies and/or **Optional Peer Dependencies** applies.

```hbs
<SomeComponent @canAnimate={{macroDependencySatisfies "liquid-fire" "*"}} />
{{! ⬆️compiles to ⬇️ }}
<SomeComponent @canAnimate={{true}} />
```

### Handlebars Macro: macroMaybeAttrs

There is one place where `{{#if}}` doesn't work: within "element space". If you want to _sometimes_ set an attribute, but sometimes not, this doesn't work:

```hbs
<div {{#if this.testing}} data-test-target={{@id}} {{/if}} />
```

`macroMaybeAttrs` exists to conditionally compile away attributes and arguments out of element space:

```hbs
<div {{macroMaybeAttrs (macroGetConfig "ember-test-selectors" "enabled") data-test-target=@id }} />
```

It can be placed on both HTML elements and angle bracket component invocations.

### Handlebars Macro: macroFailBuild

Like the JS `failBuild` macro.

```hbs
{{#if (macroCondition (macroDependencySatisfies "some-peer-dep" "^3.0.0")) }}
  <UseTheThing />
{{else}}
  {{macroFailBuild "You tried to use <MyFancyComponent/> but it requires some-peer-dep ^3.0.0"}}
{{/if}}
```

### Macros: Overall Design

All the macros are intended to be valid syntax. They shouldn't break parsing or linting.

While we guarantee that branch elimination will run in production builds, we _don't_ guarantee that in development. The macros are designed so that in development they may have _runtime_ implementations. This is powerful because it lets us produce a single build that works in multiple contexts. For example:

- it solves the longstanding problem that when you run your tests by visiting `localhost:4200/tests` the tests see the `development` environment, not the `test` environment. To get the test environment you can't use `ember serve`, you must use `ember test`. This has remained unfixed because it's expensive to do the whole build twice for the two environments.

  We can solve this problem by producing a _single_ build containing _both_ environments, guarded by the macro system. The macros can evaluate at runtime, allowing each environment to get the right thing. In production builds, test-only or dev-only branches will still be eliminated.

- it makes Fastboot builds simpler because we can guard the fastboot-only and browser-only code with the macro system. In development, we can run a single build that leaves both branches in and evaluates the macros at runtime.

The macros package (`@ember/macros` as proposed, `@embroider/macros` as implemented) will work in both regular ember-cli and in Embroider. And it will work in both V1 and V2 packages.

## Peer Dependencies

V2 packages can only resolve their **allowed dependencies**. This is fundamental rule that we can't break if we want the broadest compatibility with NPM and future compatibility with other strict systems such as [Yarn PnP](https://github.com/yarnpkg/rfcs/pull/101). Node often allows you to resolve things that are not **allowed dependencies** due to hoisting optimizations. But this is not safe or guaranteed, so we forbid relying on it.

This means that many things addons will try to access from their surrounding environment will need to be listed as `peerDependencies`. For example, addons that want to import `ember-data` should list `ember-data` as a `peerDependency`, so the app can control the `ember-data` version and the addon is guaranteed to resolve the same copy.

This also applies recursively -- if your addon wants to use an addon that needs `ember-data`, your addon should also list `ember-data` as a `peerDependency`. The clearest documented description of how recursive peerDependencies should work is in the [Yarn PnP Formal Guarantees](https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md#c-formal-plugnplay-guarantees).

`ember-source` provides many "virtual" packages like `@ember/component`. If they were real packages, they would be `peerDependencies`, but having non-real packages in package.json is likely to result in errors. Pedantically, they can be listed in **externals** instead. In practice, they are a well-known set that we can always handle correctly automatically, so it's not very important whether an addon includes them in **externals**.

### Optional Peer Dependencies

Some addons optionally use another addon if it happens to be available in the app. In order to resolve such a dependency, we really need **Optional Peer Dependencies**.

NPM doesn't have a concept of optional peer dependencies. It has "optional dependencies", but they are something different and pretty useless.

Yarn did an [RFC for optional peer dependency support](https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-optional-peer-dependencies.md). It is basically compatible with NPM, with the only caveat being that if you use NPM you may see a spurious warning at install time. As non-actionable peerDependency warnings are rife throughout the NPM ecosystem this doesn't seem like a big deal.

V2 Packages are allowed to use optional peer dependencies as described in the Yarn RFC.

Our own tooling, like ember-cli-dependency-checker, we can make sure the warnings respect the Yarn standard.

## Apps as V2 Packages

This RFC is focused heavily on addons, because that is the area that is most critical to standardize. Publishing addons to NPM in V2 format has major benefits:

- build performance: there is much less work to do at app build time, and many `dependencies` of addons can become `devDependencies` of addons, resulting in smaller `node_modules` and faster `npm install`.
- tool integration: VSCode, Typescript, SCSS, etc will all understand your code better when the dependencies are in V2 format. Things like "jump-to-definition" will work.
- Embroider stability: `@embroider/compat` needs to use heuristics and some addon-specific rules to compile V1 addons into V2. This is necessarily more fragile than having addons published natively in V2. The first step in stabilizing Embroider for mainstream adoption is standardizing on this new addon format.

In contrast, apps are not published to NPM. So where would they use V2 publication format?

During the build process for an app, it will first build from its authoring format _to the standard v2 package format_. At that point, the whole project is just a collection of standard v2 packages with well-defined semantics, and we can confidently treat that stage in the build pipeline as supported public API.

The benefit of this approach is that we can separately evolve authoring formats and last-stage packaging tools, while keeping a stable interface between them. The stable interface is designed to leverage general-purpose ECMA-spec-compliant features wherever practical, which makes it a rich target. For more detail on Embroider's three-stage build pipeline see [the README](https://github.com/embroider-build/embroider/blob/f5181d0d7eab146fd0dfcafdff552ee4fc129f2a/README.md#embroider-a-modern-build-system-for-emberjs-apps).

v2-formatted apps do differ in a few ways from v2-formatted addon, as described in the following sections.

### Features that Apps May Not Use

Several features in the v2 addon format are designed to be consumed _by the app_. These features aren’t appropriate in an app, because that is the end of the line — a v2-formatted app should be understandable by general-purpose Javascript tooling and have very little _implicit_ Ember-specific build semantics left.

Features that apps may not use include:

- the `implicit-*` keys in **Ember package metadata**.
- the `app-js` key in **Ember package metadata**
- the `build` key in **Ember package metadata**. We should consider updating the _authoring_ format so that apps can use a build file with the standard package hooks, because that makes a lot of sense. But it’s not appropriate in the v2 format (which is a _publication_ format), and this change can be a separate RFC, and it will be an easier RFC after landing this one.
- automatic inclusion of resolvable types (components, services, etc) from the **Own Javascript** of all **Active Dependencies** and the app itself.
- the `public-assets` key in **Ember package metadata**.

All these features can appear in v2 _addons_, and the _app_ ensures each one is represented by standards-compliant Javascript within the app’s own code. To illustrate with some examples, the V2 format for an app (as already implemented in Embroider) includes:

- `<script>` tag(s) in index.html and tests/index.html that ensure `implicit-scripts` and `implicit-test-scripts` of all active addons are already accounted for.
- `<link rel="stylesheet">` tag(s) in index.html and tests/index.html that ensure `implicit-styles` and `implicit-test-styles` are accounted for.
- actual Javascript `import` statements within the app's code that ensure `implicit-modules` and `implicit-test-modules` are accounted for
- actual Javascript `import` statements and AMD `define` calls that handle automatic inclusion of resolvable types that cannot be statically ruled out.

## Features that only Apps may use

There are also a few V2 package features only supported in apps. These are mostly of interest only to people working within ember-cli and/or embroider to implement new packaging tools. Each of these is a property in **Ember package metadata**:

- `rootURL`: has the same meaning as `rootURL` in `config/environment.js` in a standard Ember app.
- `assets`: a list of relative paths to files. The intent of `assets` is that it declares that each file in the list must result in a valid URL in the final app.

  The most important assets are HTML files. All `contentFor` has already been applied to them. (Remember, we’re talking about the publication format that can be handed to the final stage packager, not necessarily the authoring format.) It is the job of the final stage packager to examine each asset HTML file and decide how to package up all its included assets in a correct and optimal way, emitting a final result HTML file that is rewritten to include the packaged assets.

  Note that packagers must respect the HTML semantics of `<script type="module">` vs `<script>` vs `<script async>`. For example: don’t go looking for `import` in `<script>`, it’s only correct in `<script type="module">`

  File types other than HTML are allowed to appear in `"assets"`. The intent is the same (it means these files must end up in the final build such that they’re addressable by URLs). For example, a Javascript file in `"assets"` implies that you want that JS file to be addressable in the final app (and we will treat it as a script, not a module, because this is for foreign JS that isn’t going through the typical build system. If you actually want a separate JS file as output of your build, use `import()` instead). This is a catch-all that allows things like your `/public` folder full of arbitrary files to pass through the final stage packager.

  A conventional app will have an `"assets"` list that include `index.html`, `tests/index.html`, and all the files that were copied from `/public`.

- `template-compiler.filename`: the relative path to a module that is capable of compiling all the templates. The module exports :
  - `compile: (moduleName: string, templateContents: string) => string` that converts templates into JS modules.
- `template-compiler.isParallelSafe`: true if the template compiler can be used in other node processes
- `babel.filename`: the relative path to a module that exports the app's babel config.
- `babel.isParallelSafe`: true if the `babel` settings can be used in a new node process.
- `babel.majorVersion`: the version of babel the app's settings were written for. Only 6 and 7 are supported at this time.

Unlike addons, an app’s **Own Javascript** is not limited to only ES latest features. It’s allowed to use any features that work with the config in `babel.filename`. This is an optimization — we _could_ logically require apps to follow the same rule as addons and compile down to ES latest before handing off to a final packager. But the final packager is going to run babel anyway, so we allow apps to do all their transpilation in that final single pass.

## Ember Language Standard

This RFC introduces the idea of `Ember Language Standard` as a way to be explicit about exactly what Javascript dialect we support in shared packages, and exactly what extensions to Javascript are required to understand the complete semantics of Ember apps.

As of this writing, Ember language standard contains the following subset of ECMAScript:

 - all of ECMAScript 2019
   - with the caveat that if you use un-transpile-able features (like `Proxy`) that aren't supported in all browsers that Ember supports, your package won't support those browsers
 - [decorators proposal](https://github.com/tc39/proposal-decorators) currently in TC39 stage 2.
 - [Optional Chaining](https://github.com/tc39/proposal-optional-chaining) and [Nullish Coalescing](https://github.com/tc39/proposal-nullish-coalescing), which are stage 4 (completed) proposals slated for inclusion in es2020.
 - A subset of [dynamic import](https://github.com/tc39/proposal-dynamic-import), a stage 4 (completed) proposal slated for inclusion in es2020, as detailed below.

We also incorporate the following extensions to Javascript. Our intent here is that this is the minimal set of things that aren't really expressible, even in principle, using Javascript itself:

 - handlebars templates may be imported as if they were ES modules. You get back an ES module with a default export containing an opaque value representing the compiled template. The only public-API for *consuming* the opaque value you get back is to pass it to Ember's `setComponentTemplate()` or set it as the `layout` property on an `Ember.Component`. The `.hbs` extension has lower priority than `.js`, so `import './foo'` will favor `./foo.js` over `./foo.hbs`.

 - CSS files may be imported as if they were ES modules. The `.css` extension is mandatory, unlike `.js` and `.hbs` it is never automatically inferred. We define *no exported value*. The meaning is: if you import a CSS file, the CSS file is guaranteed to be in the DOM before your module evaluates.

    The reason we define no exported value is that it's not clear we want to commit to one long-term standard. By not giving CSS a value in JS, we reserve the right to do so in the future if a web standard emerges. Users who want imported CSS to return a value are free to compile their CSS to actual JS modules *before* publishing their package.

 - JSON files may be imported as if they were ES modules. This is supported in Node and it's enabled by default in popular Javascript bundlers like Webpack, so it's common to encounter code on NPM that expects it to work. We interpret JSON as an ECMA module whose `default` export is the JSON object.


### Supported subset of dynamic import syntax

[Dynamic import](https://github.com/tc39/proposal-dynamic-import) aka `import()` is supported. However, we choose to support only a subset of possible syntax inside `import()`. Since we're choosing a strict subset, we can safely expand it later as needed.

First we'll illustrate by examples:

```js
// ALLOWED: string literal
import("./some-module")

// ALLOWED: template string with a static prefix containing
// a relative path
import(`./locale/${currentLocale}/messages`);

// ALLOWED: template string with a static prefix containing
// a complete package name
import(`some-package/${feature}`);

// ALLOWED: template string with a static prefix that clearly
// contains an absolute URL.
import(`https://example.com/components/${choice}`);

// FORBIDDEN: any syntax that is not a string literal or template string
import(arbitraryExpression());

// FORBIDDEN: template string that does not uniquely identify a package
import(`@ember/${which}`);
```

To be more precise, the only supported syntax inside `import()` is:

- a string-literal
- or a template string that begins with a static prefix which falls into one of these allowed cases:
   - the static prefix matches `/(\w+:)?\/\//`
     - this detects absolute URLs, both ones with protocols (starting with `http://`) and ones that are protocol-relative (starting with `//`).
     - in this case, Embroider will leave your `import()` alone so you can access the browser's implementation of `import()`. You are responsible for the contents of the URL, it is beyond the scope of the Embroider build.
   - the static prefix starts with `@` and contains at least two `/`
     - this detects a namespaced NPM package name. If the package can't be resolved or it contains zero files that match your pattern, we emit a static build error.
   - the static prefix does not start with `@` and contains at least one `/`
     - this covers patterns that start with a non-namespaced NPM package names or a relative path. If the pattern matches zero files, we emit a static build error.

Any other syntax is a static build error.

The rationale for this chosen subset is that we want it to be possible to introduced *controlled*, *intentional* dynamism, without accidentally blowing holes in the static analysis of whole programs. For example, if we simply allowed any non-statically-resolvable module specifier to silently become a runtime `import()`, it would mask many bugs that would otherwise be caught statically at build time. You can opt-in to fully-dynamic runtime `import()`, but you need to say so in a way that is statically legible so we can distinguish it from accidents.

## Compatibility Strategy

The `@embroider/compat` package exists to compile V1 packages to V2. This allows `@embroider/core` to always assume V2 packages as input, so we don't need to wait until every addon is natively available in V2 before we start getting the benefits of Embroider. However, there is still an incentive to convert as many addons as possible to V2, because they build faster and they will be more stable (the v1-to-v2 compilation isn't flawless, we need heuristics and package-specific rules to deal with some dynamic addon behaviors).

It also needs to be possible for an addon published as V2 to work in existing apps on existing ember-cli versions. This is enabled by:

- `ember-auto-import`, which serves as a high-fidelity polyfill for importing directly from NPM. V2 addons natively support importing from NPM, but they should depend on `ember-auto-import` so those imports will have the same meaning when used in classic ember-cli.
- `@ember/macros`, which shall provide correct semantics regardless of whether the package using them is published as V1 or V2 and regardless of whether the build is being done by classic ember-cli or Embroider. Native V2 packages under Embroider can alway use macros, without an explicit dependency on `@ember/macros`, but they should include the dependency so that macros will work in classic ember-cli.
- ember-cli already supports a `main` property in under `ember-addon` and has supported it for many versions. This allows an addon to put its classic `index.js` file in a place other than the package's true `main`. This means that V2 addons can have their runtime `index.js` as `main`, and should point `ember-addon.main` to a `classic.js` file. The `classic.js` file should `require` and `export` a compatibility shim library that we will provide. The compatibility shim will have the classic methods like `treeForAddon`, `treeForPublic` that take the V2-formatted features and present them in a way that classic ember-cli will understand. Since V2 packages are much more static than V1 packages, this shim is expected to not be very complicated.

# How we Teach This

This RFC should have no direct impact on what app authors need to learn. They keep using addons the same way they always have. Future RFCs that take Embroider mainstream _will_ have impact, but that can be discussed then.

The impact on addon authors is more significant. This design is fully backward compatible, and the intention is that all existing addons continue to work (some with worse compatibility hacks than others in the v1-to-v2 compiler). But there will be a demand for addons published in v2 format, since it is expected to result in faster build times. My prediction is that people who are motivated to get their own app build times down will send a lot of PRs to the addons they’re using.

In many cases, converting addons to v2 makes them simpler. For example, today many addons use custom broccoli code to wrap third-party libraries in a fastboot guard that prevents the libraries from trying to load in Node (where they presumably don’t work). In v2, they can drop all that custom build-time code in favor of a macro-guarded `importSync`.

This design does _not_ advocate loudly deprecating any v1 addon features. Doing that all at once would be unnecessarily disruptive. I would rather rely on the carrot of faster builds and Embroider stability than the stick of deprecation warnings. We can choose to deprecate v1 features in stages at a later time.

We should release an officially-supported package (tentatively named `@embroider/addon`) that provides tooling for addon authors who want to publish a V2 package that is backward compatible in non-embroider apps. This package's documentation is a natural starting point for teaching developers what to do.

# Alternative Designs

Embroider effectively supersedes both the [Packager RFC](https://github.com/ember-cli/rfcs/blob/master/active/0051-packaging.md) and the [Prebuilt Addons RFC](https://github.com/ember-cli/rfcs/pull/118). So both of those are alternatives to this one.

Packager creates an escape hatch from the existing ember-cli build that is supposed to provide a foundation for many of the same features enabled by this design. The intention was correct, but in my opinion it tries to decompose the build along the wrong abstraction boundaries. It follows the existing pattern within ember-cli of decomposing the build by feature (all app javascript, all addon javascript, all templates, etc) rather than by package (everything from the app, everything from ember-data, everything from ember-power-select, etc), which puts it into direct conflict with the Prebuilt Addons RFC.

The API that packager provides is also incomplete compared with this design. For example, to take the packager output and build it using Webpack, Rollup, or Parcel still requires a significant amount of custom code. Whereas taking a collection of v2 formatted Ember packages and building them with any of those tools requires very little Ember-specific code.

The prebuilt addons RFC addresses build performance by doing the same kind of work-moving as this design. Addons can do much of their building up front, thus saving time when apps are building. But it only achieves a speedup when apps happen to be using the same build options that addons authors happened to publish. This design takes a different approach that preserves complete freedom for app authors to postprocess all addon Javascript, including dead-code-elimination based on the addon features their app is using. The prebuilt addons RFC also doesn’t attempt to specify the contents of the prebuilt trees — it just accepts the current implementation-defined contents. This is problematic because shared builds artifacts are long-lived, so it’s worth trying to align them with very general, spec-compliant semantics.

# Supporting References

- There is a [SPEC draft](https://github.com/embroider-build/embroider/blob/master/SPEC.md) in the Embroider repo that predates this one, but covers a broader scope. Where this document contradicts SPEC.md, this document takes precedence and SPEC.md needs to be updated. But SPEC.md covers a broader scope, including the disposition of the other build hooks that will be handled in future RFCs.

- The definitive list of **Ember package metadata** fields is declared in [AppMeta and AddonMeta interfaces](https://github.com/embroider-build/embroider/blob/master/packages/core/src/metadata.ts). Each one is documented in an [Appendix in SPEC.md](https://github.com/embroider-build/embroider/blob/master/SPEC.md#appendix-list-of-ember-package-metadata-fields).


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2019-07-29T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
  - data
  - cli
  - learning
  - typescript
  - steering
prs:
  accepted: https://github.com/emberjs/rfcs/pull/519
project-link:
meta:
  heavily-revised: 2020-02-28T00:00:00.000Z
---

# Ember 2020 Roadmap

## Summary

The purpose of the Ember Roadmap process is to rally the community around a number of shared goals. This post documents those goals for 2020.

Since the Ember community cannot predict the future, we cannot be sure that we will achieve all of the individual items enumerated here. Instead, the purpose of this document is to give the community a common purpose to aspire towards.

This year our two headline priorities are:

- Polish the practical and conceptual details of Octane (tracked properties, Glimmer components, related tooling, accessibility, performance and payload improvements).
- Make Ember easier to try and adopt, but also lower barriers for Ember developers when collaborating with the greater JavaScript project. We will do this through improvements and simplifications to the framework, and through focused communication with the greater JavaScript community.

## Motivation

This document is a distillation of multiple sources:

1. The 2019 Community Survey.
2. Community #EmberJS2019 blog posts authored in response to our call for posts.
3. Discussion on [https://discuss.emberjs.com](https://discuss.emberjs.com/), Discord, Twitter, and other public venues.
4. Deliberations among the Ember core teams.
5. Your comments and feedback on the roadmap RFC itself.

The goal of the RFC is to align the Ember community around a set of shared, achievable goals that balance the needs of existing users with the need to grow and support new users.

## Detailed design

Now that Ember Octane has shipped, it’s time to turn our attention to new efforts in 2020. Our goal is to build on Octane's release and capitalize on that cutting-edge foundation.

- **Invest in Octane.** Octane's mental model and basic components are complete, but a number of practical and conceptual gaps remain. We will close these gaps with work on tooling, by deprecating classic APIs to simplify Ember for new users, and by introducing additional functionality where appropriate.
- **Modernize our build system.** This year we will prioritize improvements to the Ember application build pipeline, and to Ember itself, which will bring modern optimizations like tree shaking and code splitting to both new applications *and* existing codebases.
- **Better a11y by default**. We will better support assistive technologies via updates to the router. Additionally we will provide developers more tools for understanding and improving the accessibility of their Ember applications. Our goal is a great "out of the box" experience with Ember and assistive technologies.
- **Share Octane outside our community.** Octane's release put Ember in front of a lot of new eyes. We will continue that trend through 2020 by talking about Octane in front of new audiences.

### Invest in Octane

Ember Octane put the framework on a strong footing by modernizing its most foundational APIs. Many teams are already productive using Octane, and from their experience have provided a torrent of real-world feedback. We will continue improving the developer experience (DX) of Octane throughout 2020.

Many of the rough edges in Octane aren't on the features themselves, but in the supporting tooling. The usefulness of stack traces from Glimmer, the ability to use TypeScript with Ember templates, how tracked properties and Glimmer components are reflected in the Ember Inspector, and the build speed of our application pipelines are all important parts of Octane's DX. We will invest in these areas of work.

For developers who are new to Ember, the presence of classic non-Octane APIs can be disorienting. We will look for creative solutions that make those features trivial for existing apps to continue using while also making them less expensive (in payload, performance, and mental model) for new adopters.

Finally there are some areas of Octane features which can still benefit from new feature work:

- The `@tracked` system, for example, limits the expression of state in an application to defined properties on an object. Real-world codebases often want to maintain state as a list or a map, and we can extend on the well-designed internals of Ember's reactivity model to support these cases.
- Modifiers provide a hook into the DOM rendering lifecycle, but Octane has no APIs for hooking into other lifecycles in the rendering and object system. We will create these APIs.
- We will continue a push to make Ember templates better analyzable at build time by introducing a strict-mode template and static imports.
- We will make it easier to build ergonomic, reusable components by shipping named blocks.

We will introduce new features in Ember which improve Octane in these and other areas.

### Modernize our build system

Last year, we started work on Embroider, an overhaul of the Ember CLI compilation pipeline. This year, we will put the finishing touches on Embroider and start migrating the Ember ecosystem to this modernized build.

Embroider integrates Ember CLI with popular packagers like [webpack](https://webpack.js.org/) and [rollup](https://rollupjs.org/guide/en/). It allows Ember apps to trivially import from any dependency published as standard JavaScript modules, and will unblock shipping Ember itself as npm packages in the `@ember` namespace.

This new approach, through its foundation on common packaging libraries, will also unlock new build time optimizations. These optimizations, like tree-shaking and route-based code-splitting, will allow Embroider to produce smaller asset payloads.

Additionally, we will introduce a system into Ember which allows apps to drop framework code supporting deprecated features unused by an app. This will result in smaller vendor assets for applications which don't rely on deprecated features. For example, a modern Octane application may not require `Ember.Component`, and can benefit from having the code supporting that API being dropped at build time.

Finally, we will make sure this modernization effort provides benefits to existing applications. If a team has been steadily upgrading their app for years now, they won't need to rewrite it to get the benefits of a modern build packager.

### Better a11y by default

Ember applications should be accessible to everyone. Unfortunately, even seemingly small mistakes can make your app difficult or impossible to use with assistive technology like screen readers. We will do more to improve the out-of-the-box accessibility of Ember applications, and provide tools to help applications stay accessible as they grow.

- **Fix router accessibility** so that page navigation is correctly announced by screen readers, without needing a third-party addon.
- Incorporate **accessibility checks** into the built-in test helpers.
- **Engage with standards bodies** to help fill the gaps in existing web accessibility APIs.

To contribute to this effort see [RFC Issue 595](https://github.com/emberjs/rfcs/issues/595) which coordinates the Ember A11y Strike Team.

### Sharing Octane outside our community

There are more people building web applications than ever, and Ember must adapt to their changing needs and expectations in order to stay relevant. Octane better aligns Ember's API with what new users expect from a modern framework. We need to take advantage of that change.

This year, we’ll share with the world how Ember Octane is modern, productive, and *fun*. Through blog posts, videos, social media, meetups, and conferences, we will share our knowledge and experiences with the wider JavaScript community and encourage them to give Octane a try.

We will continue to make Octane more attractive to new users with a new documentation approach, more effective website, and with clearer communication about the Glimmer.js project.

## Lowering barriers to adoption and collaboration

Making Ember more attractive to new users doesn't mean compromising on what has made the framework so very successful for existing codebases and teams.

The most basic value of the Ember project is that we solve problems together. While we intend to grow the number of framework users and modernize the framework in many ways, we won't optimize for growth at the expense of our existing community. Instead, we will collaborate on solutions that come with a curated adoption story.

Because we understand and value the power of collaboration, we know we must lower barriers, technical and non-technical, which not only make new users hesitate to adopt Ember but also discourage Ember developers from participating the greater JavaScript community.

A great example of our progress in this is Octane's embrace of native JavaScript classes: A JavaScript developer starting out with Ember today isn't immediately forced to learn a new, Ember-specific class API before they can get to writing code. On the other hand, a developer who starts off with Ember can also contribute to most OSS JavaScript projects without needing to first un-learn the Ember class system.

By sharing common solutions to common problems with other communities we not only make Ember more approachable, we also benefit from the opportunity to exchange more ideas. Everyone wins.

With our efforts to flesh out Octane, improve the build system and align it with the rest of the JavaScript community, raise the baseline support for accessible applications, and to better communicate in 2020 we will lower barriers to adoption of Ember, but also to our own collaboration with the greater JavaScript project.


---

---
stage: released # FIXME: This may actually be recommended
start-date: 2019-08-29T00:00:00.000Z
release-date: 2021-12-11T00:00:00.000Z
release-versions:
  ember-data: v4.0.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/521
project-link:
---

# [DATA] findRecord/peekRecord via Identifier

## Summary

Users should be able to peek or find records based on `lid`.

## Motivation

Apps and Addons making use of [Identifiers](https://github.com/emberjs/rfcs/pull/403)
may wish to peek or find the record for a known `identifier`. This
RFC would allow them to do so.

## Detailed design

A new method signature would be added to `findRecord`
`peekRecord` and `getReference`. The existing signatures would not be
deprecated at this time.

For the case where calling `findRecord` would result in a request
being necessary but either no `type` or `id` information being known
we would error.

This is because there is no meaningful way for the store to create a
network request for a record that does not exist yet (a
`NewResourceIdentifierObject`), or for one for which the only thing
we know is a locally assigned id (`Identifier`).

```ts
interface Identifier {
  lid: string;
}

export interface ExistingResourceIdentifierObject {
  id: string;
  type: string;
  lid?: string;
}

export interface NewResourceIdentifierObject {
  id: string | null;
  type: string;
  lid: string;
}

export type Peekable =
  | Identifier
  | ExistingResourceIdentifierObject
  | NewResourceIdentifierObject;

class Store {
  peekRecord(type: string, id: string | number): Record | null {}
  peekRecord(identifier: Peekable): Record | null {}

  findRecord(type: string, id: string | number, options?: any): PromiseRecord {}
  findRecord(identifier: Peekable, options?: any): PromiseRecord {}

  getReference(modelName: string, id: string | number): RecordReference {}
  getReference(identifier: Peekable): RecordReference {}
}
```

## How we teach this

For existing usage of these methods no migration or changes are necessary. For folks wishing to use the new
APIs an example route is below that both peeks a record and makes a findRecord request.

**current style**

```ts
{
  @service('store') store;

  model({ user_id, post_id }) {
    let user = this.store.peekRecord('user', user_id);

    return hash({
        user,
        post: this.store.findRecord('post', post_id)
    });
  }
}
```

**using RecordIdentifiers instead**

```ts
{
  @service('store') store;

  model({ user_id, post_id }) {
    let user = this.store.peekRecord({ type: 'user', id: user_id });

    return hash({
        user,
        post: this.store.findRecord({ type: 'post', id: post_id })
    });
  }
}
```

If an `lid` is known the `RecordIdentifier` passed to these methods can provide it
in addition to or in place of `id`.

## Drawbacks

- It requires the user to create an object as an argument when seeking to use identifiers.
  However if the user does not do so we still do ourselves almost immediately, here we are
  shaping the object sooner.

## Alternatives

- `peekRecord(null, null, lid)` rejected for clumsy ergonomics
- `findRecord(identifier)` attempting to request with just an lid,
  rejected until reconsideration at such time as our request fulfillment doesn't rely heavily on per-type adapters
- `peekRecord(identifier)` but no `findRecord(identifier)` rejected because of the utility in these APIs mirroring each other, especially for relationships.
- `store.recordForIdentifier(identifier)` instead of these changes, rejected because we already have a `peek` API.


---

---
stage: recommended
start-date: 2019-07-27T00:00:00.000Z
release-date: 2019-11-07T00:00:00.000Z
release-versions:
  ember-data: v3.14.0

teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/522
project-link:
---

# Deprecate default Adapter and Serializer fallbacks

## Summary
As part of Project Trim, https://github.com/emberjs/data/issues/6166, this deprecates the fallback and default adapter and serializer across ember-data including:
1. deprecate -default serializer fallback in Store.serializerFor
2. deprecate `adapter.serializer` and `adapter.defaultSerializer` instance property fallbacks (which currently default to -json-api).
3. deprecate `store.defaultAdapter` instance property (which defaults to `-json-api`) and the `-json-api` adapter fallback behavior in `adapterFor`.
4. deprecate `record.toJSON` instance method since this relies on the `-json` serializer.

## Motivation

The adapter and serializer packages provide reference implementations and base classes that are not required for applications that implement their own following the required interfaces for adapters and serializers as defined in their respective base classes.  Deprecating them allows us to simplify the lookup pattern and remove automatic injection and registration of potentially unused classes.

In addition to removing use of initializer injection, this takes a significant step toward simplifying the mental model for how to determine what adapter/serializer is in use. Removing the defaults forces app developers to be more cognizant about the type of application level concerns vs model-specific concerns; they will now need to explicitly define and use specific adapters/serializers. After this deprecation RFC lands, apps will always use an adapter/serializer explicitly put into your application and the rule will be "the adapter matching modelName falling back to application".

## Detailed design
The injection of `-default` and `-json-api` serializers will be removed in the next major version (4.0). Since this changes some core assumptions we will deprecate the reliance on the existence of the defaults. All deprecation warnings will only be shown in Dev mode.

##### deprecate -default serializer fallback in store.serializerFor
A deprecation warning will be shown when [no model, application or adapter serializer](https://github.com/emberjs/data/blob/67affb0eca7048a1a0edc856af46d1305cd1fc1d/packages/store/addon/-private/system/store.ts#L2909) has specified and the default must be used. We will recommend implementing an application serializer.

##### deprecate adapter.serializer and adapter.defaultSerializer fallbacks
A deprecation warning will be shown when accessing the [adapter's defaultSerializer](https://github.com/emberjs/data/blob/67affb0eca7048a1a0edc856af46d1305cd1fc1d/packages/store/addon/-private/system/store.ts#L2896). This will be distinct from the warning about using the application level default. We will recommend implementing an application serializer.

##### deprecate store.defaultAdapter (-json-api) and the -json-api adapter fallback behavior
A deprecation warning will be shown when the [defaultAdapter](https://github.com/emberjs/data/blob/b0cf3225662bfb806cd0c02b55b763e37a319b32/packages/store/addon/-private/system/store.ts#L309) is accessed.  We will recommend implementing an application adapter.

##### deprecate record.toJSON
A deprecation warning will be shown when toJSON is called since it uses a serializer to create a JSON representation of [the model](https://guides.emberjs.com/release/models/customizing-serializers/#toc_customizing-serializers). Users may call record.serialize() or implement their own toJSON instead.

## How we teach this

Today we have extensive documentation about creating custom serializers, but we will need to update the guides to specify the desired serializer in [app/serializers/application.js](https://guides.emberjs.com/release/models/customizing-serializers/#toc_customizing-serializers)

The deprecation guide app will be updated with examples showing how to
migrate away from relying on the defaults.

## Drawbacks

The drawback to making this change is that apps relying on the default serializer need to add some boilerplate to explicitly set the serializer.

## Alternatives

We could not do this.


---

---
stage: recommended
start-date: 2019-08-05T00:00:00.000Z
release-date: 2019-10-29T00:00:00.000Z
release-versions:
  ember-source: v3.14.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/523
project-link:
---

# Provide `@model` named argument to route templates

## Summary

Allow route templates to access the route's model with `@model` in addition to
`this.model`.

Before:

```hbs
{{!-- The model for this route is the current user --}}

<div>
  Hi <img src="{{this.model.profileImage}}" alt="{{this.model.name}}'s profile picture"> {{this.model.name}},
  this is a valid Ember template!
</div>

{{#if this.model.isAdmin}}
  <div>Remember, with great power comes great responsibility!</div>
{{/if}}
```

After:

```hbs
{{!-- The model for this route is the current user --}}

<div>
  Hi <img src="{{@model.profileImage}}" alt="{{@model.name}}'s profile picture"> {{@model.name}},
  this is a valid Ember template!
</div>

{{#if @model.isAdmin}}
  <div>Remember, with great power comes great responsibility!</div>
{{/if}}
```

## Motivation

With the Octane release, templates are taking on a more important role in
idomatic Ember apps. As templates become more self-sufficient, many cases where
a JavaScript class was needed in the past (e.g. to customize the "wrapper"
element) can now be expressed with templates alone. This is a direction we will
continue post-Octane.

We would like to update the learning materials (guides) to focus on teaching
the template-centric component model. For example, components can be introduced
as a way to break up large templates into smaller, named pieces, similar to
refactoring a big function into smaller ones. Then, we can layer on making them
reusable through passing arguments. Next, we can introduce the idea of passing
a block and yielding. Finally, we can introduce the component class when we are
ready to discuss adding behavior to the component.

As you can see, we can accomplish quite a lot with template-only components in
Octane, and focusing on teaching templates first-and-foremost would provide
a gentle learning curve for developers and designers who are comfortable with
HTML but perhaps new to Ember (or even JavaScript). With this flow, the concept
of a component class, and consequently, the idea of a "`this` context" in a
template comes up quite late.

This presents a problem, as we may want or need to teach route templates before
that was introduced. As the model can only be accessed through `this.model` in
a route template, we would be forced to introduce that concept (and the contept
of a controller) at an earlier time than would be ideal.

Providing `@model` to route templates would solve this problem quite elegantly.
We will now be able to introduce the concept of arguments (`@name`) once and it
can be applied consistently between component and route templates.

This also aligns with the general mental model that arguments are things that
are passed into the template from the outside (which is true in the case of the
route model).

This can also be thought of as a small incremental step in the bigger picture
of reforming route templates and removing controllers from Ember. Specifically,
it moves us a bit closer to the mental model that controllers/route templates
are just a "special" kind of component. We expect to continually unify them and
remove the remaining differences, and this is a step towards that direction.

## Detailed design

Internally, route templates are _already_ modelled as components at the Glimmer
VM layer. To implement this, we would "synthesize" a named argument `@model`
containing the resolved route model, i.e. the same value as `this.model` on the
controller instance.

Just like the "reflected" named arguments in classic components, mutating
`this.model` on the controller instance would _not_ change the value of
`@model`. In practice, this seems unlikely to be relied upon and probably
considered a bad practice (it does not change the URL, does not affect what is
returned by `route.modelFor`, etc). In any case, this is consistent with the
general behavior for named arguments, in that they are immutable and should
always reflect what was "passed in" from the caller.

## How we teach this

In the guides, we should teach that `@names` are for things that are "passed
in", i.e. arguments to the template.

In the tutorial, basic components concepts (template-only components, invoking
a component with args, using the args with the template, etc) should be taught
before the `model` hook is encountered. At that point, explaining that `@model`
is passed into the component from the route, based on the resolution of the
async `model` hook, will be quite natural.

For reference, here is a relevant section from the [work-in-progress Octane
tutorial](https://github.com/ember-learn/guides-source/pull/1002). For context,
up until this point, we have taught all the basic component concepts above, plus
adding a (Glimmer) component class, adding instance variables and getters to the
component, accessing those with `{{this.*}}` in the template, etc.

> So far, we've been hard-coding everything into our `<Rental>` component. But
> that's probably not very sustainable, since eventually, we want our data to
> come from a server instead. Let's go ahead and move some of those hard-coded
> values out of the component in preparation for that.
>
> We want to start working towards a place where we can eventually fetch data
> from the server, and then render the requested data as dynamic content from
> the templates. In order to do that, we will need a place where we can write
> the code for fetching data and loading them into the routes.
>
> In Ember, [*route files*](todo://) are the place to do that. We haven't
> needed them yet, because all our routes are essentially just rendering static
> pages up until this point, but we are about to change that.
>
> Let's start by creating a route file for the index route. We will create a
> new file at `app/routes/index.js` with the following content:
>
> ```js {data-filename="app/routes/index.js"}
> import Route from '@ember/routing/route';
>
> export default class IndexRoute extends Route {
>   async model() {
>     return {
>       title: 'Grand Old Mansion',
>       owner: 'Veruca Salt',
>       city: 'San Francisco',
>       location: {
>         lat: 37.7749,
>         lng: -122.4194,
>       },
>       category: 'Estate',
>       type: 'Standalone',
>       bedrooms: 15,
>       image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
>       description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
>     };
>   }
> }
> ```
>
> There's a lot happening here that we haven't seen before, so let's walk
> through this. First, we're importing the [*`Route` class*](todo://) into the
> file. This class is used as a starting point for adding functionality to a
> route, such as loading data.
>
> ```js
> import Route from '@ember/routing/route';
> ```
>
> Then, since we are extending the `Route` class into our _own_ `IndexRoute`,
> which we are also exporting so that the rest of the application can use it.
>
> ```js
> export default class IndexRoute extends Route {
>   // ...snip...
> }
> ```
>
> So far, so good. But what's happening inside of this route class? We
> implemented a [*async method*](todo://) called `model()`. This method is also
> known as the [*model hook*](todo://).
>
> The model hook is responsible for fetching and preparing any data that you
> need for your route. Ember will automatically call this hook for when
> entering a route, so that you can have an opportunity to do what you need to
> get the data you need. The object returned from this hook is known as the
> _model_ for the route (surprise!).
>
> Usually, this is where we'd fetch data from a server. Since fetching data is
> usually an asynchronous operation, the model hook is marked as `async`. This
> gives us the option of using the `await` keyword to wait for the data
> fetching operations to finish.
>
> We'll get to that bit later on. At the moment, we are just returning the same
> hard-coding model data, extracted from the `<Rental>` component, but in a
> JavaScript object (also known as [_POJO_](todo://)) format.
>
> So, now that we've prepared some model data for our route, let's use it in
> our template. In route templates, we can access the model for the route as
> `this.model`. In our case, that would contain the POJO returned from our
> model hook.
>
> To test that this is working, let's modify our template and try to render
> the `title` property from our model:
>
> ```handlebars {data-filename="app/templates/index.hbs"}
> <h1>{{this.model.title}}</h1>
>
> <div class="rentals">
>   <ul class="results">
>     <li><Rental /></li>
>     <li><Rental /></li>
>     <li><Rental /></li>
>   </ul>
> </div>
> ```
>
> If we look at our page in the browser, we should see our model data reflected
> as a new header.
>
> <!-- TODO: screenshot -->
>
> Awesome! Looking good.
>
> <!-- TODO: Update the below if https://github.com/emberjs/rfcs/pull/523 is merged. -->
>
> > Zoey says...
> >
> > The `this` in `this.model` does _not_ refer to the route object. You
> > _cannot_ add instance variables or getters on the route class and have
> > access to them here. It's a good idea to keep your route template simple
> > and minimal &mdash; if you need to add state or getters, just add a
> > component and call it from your route template!
>
> Ok, now that we know that we have a model to use at our disposal, let's
> remove some of the hard-coding that we did earlier! Instead of explicitly
> hard-coding the rental information into our `<Rental>` component, we can pass
> the model object to our component instead.
>
> Let's try it out. First, let's pass in our model to our `<Rental>` component
> as the `@rental` argument. We will also remove the extraneous `<h1>` tag we
> added earlier, no that we know things are working:
>
> ```handlebars {data-filename="app/templates/index.hbs"}
> <div class="rentals">
>   <ul class="results">
>     <li><Rental @rental={{this.model}} /></li>
>     <li><Rental @rental={{this.model}} /></li>
>     <li><Rental @rental={{this.model}} /></li>
>   </ul>
> </div>
> ```
>
> ...snip...
>

As you can see, there are some awkwardness explaining `this.model` at this
point. Knowing that there is a `this` context on the template, it is only
natural to inquire what _is_ the `this` we are referring to here.

Up until this point in the tutorial, the only place where we have access to a
`this` object in the template is a component with a class. Since the route
class is the only related class we made at this point, and it happens to have
a `model` property (a method) on it, one natural conclusion is to think that
`this` refers to the route instance, and `this.model` refers to the model hook.

> Note: you don't always have a `this` context in templates. Template-only
> components _do not_ have a `this` context. Since template-only components
> make up roughly half of the components in the tutorials so far, _having_ a
> `this` from the template is a notable thing that stands out.

But that completely the wrong mental model! To avoid that, we put in a "Zoey
says..." sidebar that explicitly denies that incorrect mental model, stating
what it _is not_, without really explaining what it _is_.

To fully explain what is going on, we would have to pause and take a detour to
explain everyone's least favourite part of the Ember programming model –
controllers. This would be extremely disruptive to the teaching flow, to say
the least, but also serves no purpose at all.

We opted to avoid going down that rabit hole and just treated it as a
boilerplate syntax you have to type.

If we are able to explain this using `@model` instead, it would make things a
lot smoother here.

We wouldn't have to go into the details of _how_ things get invoked internally.
At the end of the day, it is still just a piece of syntax you type to get the
job done, but at least it is consistent with the general mental model that
`@names` means that thing was passed in, and it does not trigger the questions
about what `this` is.

It is also _not_ inconsistent with the fact that there is, in fact, a `this`
context on the template. The usage and preference of using `@names` does not
preclude the existance of a class (which provides the `this` context), as in
the case of `@ember/components`.

As for the concrete changes that need to be made in the documentation:

* We will explain that `@model` is passed into the component from the route.
  For example, in the `Route` class' `model` hook documentation, we can say
  something like:

  > The model hook is responsible for fetching and preparing any data that you
  > need for your route. Ember will automatically call this hook for when
  > entering a route, so that you can have an opportunity to do what you need to
  > get the data you need. The object returned from this hook is known as the
  > _model_ for the route.
  >
  > Note that since this is an `async` hook, if a promise is returned, it will
  > be automatically `await`ed by Ember, and the _resolved value_ of the
  > promise, as opposed to the promise object itself, will become the model of
  > the route.
  >
  > The model object can be accessed from the route's template as using the
  > `@model` argument. By default, the controller can also accessed the route's
  > model from `this.model`. The latter behavior is customizable, see the
  > _setupController_ method for details.
  >
  > The model of a route should be treated as read-only. For example, the
  > controller _should not_ mutate its `this.model` property, as doing so will
  > cause it to get out of sync with the rest of the system. Specifically,
  > doing so will _not_ update the current URL, the `@model` argument in the
  > template, the router service, etc. Instead, a _route transition_ should be
  > performed.

* Guides and API docs should be updated to prefer `@model` in route templates.
* API docs will still document the `model` property.
* We will remove any examples that uses `{{this.model}}` in templates, or replace them with `{{@model}}`. i.e. we won’t be documenting using `this.model` in templates, even thought it would “work”.

## Drawbacks

In some applications, developers have developed a pattern to override the
`setupController` method to assign the model to a different property on the
controller other than the default `model` naming convention.

Since this RFC does not provide any way to customize the name of the argument,
developers using this pattern will have to choose between one of the following
two options:

1. Refactor/revert to the default behavior of `setupController` and use the
   default `model` property. This makes it cognitively easy to understand the
   `@model` usages in the route templates.

2. Stick with the alternative names and avoid using `@model` in the route
   templates, until there is a way to customize both names at the same time.

Technically, it is also possible to use one name in the controller and
`@model` in the template. This doesn't cause any issues for the system, but
maybe confusing for the developers.

In the future, we expect to generalize the `model` hook and `@model` into
allowing passing arbitrary arguments into the template, perhaps replacing
the `model` hook with something like an `args` hook that returns a POJO of
arguments to pass.

## Alternatives

We can do nothing.

## Unresolved questions

None?


---

---
stage: recommended
start-date: 2019-11-08T00:00:00.000Z
release-date: 2020-08-24T00:00:00.000Z
release-versions:
  ember-source: v3.21.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/554
project-link:
---

# Deprecate getWithDefault

## Summary

Deprecate support for `getWithDefault` in Ember's Object module (@ember/object) – both the [function](https://api.emberjs.com/ember/release/functions/@ember%2Fobject/getWithDefault) and the [class method](https://api.emberjs.com/ember/release/classes/EmberObject/methods/getWithDefault?anchor=getWithDefault) – because its expected behaviour is confusing to Ember developers.

## Motivation

The problem with `getWithDefault` is that its behaviour is confusing to Ember developers. The API will only return the default value when the value of the property retrieved is `undefined`. This behaviour is often overlooked when using the function where a developer might expect that `null` or other _falsy_ values will also return the default value.

Given the JavaScript language will soon (currently in Stage 3) give us the appropriate tool for this use case using the [Nullish Coalescing Operator `??`](https://github.com/tc39/proposal-nullish-coalescing), we can deprecate usage of `getWithDefault` and use that instead.

## Transition Path

Ember will start logging deprecation messages for `getWithDefault` usage.

We can codemod our current usage of `getWithDefault` with the equivalent behaviour using plain JavaScript. The migration guide will cover this example:

Before:

```js
import { getWithDefault } from '@ember/object';

let result = getWithDefault(obj, 'some.key', defaultValue);
```

After:

```js
import { get } from '@ember/object';

let result = get(obj, 'some.key');
if (result === undefined) {
  result = defaultValue;
}
```

#### Using Nullish Coalescing Operator

We cannot codemod directly into the nullish coalescing operator since the expected behaviour of `getWithDefault` is to only return the default value if it is strictly `undefined`. The nullish coalescing operator accepts either `null` or `undefined` to show the default value.

The function `getWithDefault` **will not return** the default value if the provided value is `null`. The function will **only return** the default value for `undefined`:

```js
let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let undefinedValue = getWithDefault(obj, 'undefinedKey', defaultValue);

// Returns null, nullValue = null
let nullValue = getWithDefault(obj, 'nullValue', defaultValue);

// Returns obj's falseValue, falseValue = false
let falseValue = getWithDefault(obj, 'falseValue', defaultValue);
```

The nullish coalescing operator (`??`) **will return** the default value when the provided value is `undefined` or `null`:

```js
let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let undefinedValue = get(obj, 'undefinedKey') ?? defaultValue;

// Returns defaultValue 1, nullValue = 1
let nullValue = get(obj, 'nullValue') ?? defaultValue;

// Returns obj's falseValue, falseValue = false
let falseValue = get(obj, 'falseValue') ?? defaultValue;
```

This can be an option if we are aware that either `null` or `undefined` should return the default value.

Tooling Support:

- [Babel](https://babeljs.io/) already supports the [nullish coalescing operator](https://babeljs.io/docs/en/next/babel-plugin-proposal-nullish-coalescing-operator.html) so we can use that for future use cases where we need to check if a property is `null` or `undefined` before applying a default value.

- [TypeScript](https://github.com/microsoft/TypeScript), similarly, as of [version 3.7](https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing) also supports the operator so we will not be breaking that flow either.

#### Using Object Destructuring With Defaults

If we would like to return the default value if the existing value is `undefined` we can also use [object destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) with defaults.

Object destructuring with defaults **will return** the default value when the provided value is `undefined`:

```js
let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let { undefinedKey = defaultValue } = obj;

// Returns defaultValue 1, nullValue = null
let { nullValue = defaultValue } = obj;

// Returns obj's falseValue, falseValue = false
let { falseValue = defaultValue } = obj;
```

## How We Teach This

Add the transition path to the [Ember Deprecation Guide](https://deprecations.emberjs.com/).

The references to `getWithDefault` will need to be removed from the [API docs](https://api.emberjs.com/ember/release/functions/@ember%2Fobject/getWithDefault).

There are no changes needed for the [Ember Guides](https://guides.emberjs.com/release/) since we do not use it anywhere.

## Drawbacks

The downside to deprecating `getWithDefault` would be an increase to the line length of component files that use it. This change will also cause some deprecation noise but could be mitigated with a codemod.

## Alternatives

### Adding `null` as a condition

We could add `null` as a condition alongside `undefined` which would return the default value provided. This is similar to what is proposed in [Nullish Coalescing for JavaScript](https://github.com/tc39/proposal-nullish-coalescing). This would however still be a breaking change since people who are depending on `getWithDefault` to work the way it does for `null` today will be broken if we change it.

### Do nothing

We could keep support in place, and provide more guidance around using it. There are already [some](https://dockyard.com/blog/2016/03/18/get-with-default) articles cautioning usage of `getWithDefault` when dealing with `null` or _falsy_ values.

## Unresolved questions

None at the moment.


---

---
stage: recommended
start-date: 2019-11-20T00:00:00.000Z
release-date: 2019-12-19T00:00:00.000Z
release-versions:
  ember-cli: v3.15.0

teams:
  - framework
  - cli
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/558
project-link:
---

# Edition detection

## Summary

Introduces a mechanism that an application can use to specify which Edition of
Ember it intends to target. This RFC will define:

* How to specify the edition that the application is using
* How other packages (addons, codemods, etc) can detect the applications intended edition
* What the edition should be used for

## Motivation

As Ember approaches its first edition (see
[emberjs/rfcs#364](https://github.com/emberjs/rfcs/pull/364)) various addons
need to modify their behavior based on the edition that is being used. An
initial implementation (done without RFC) used the `setEdition` method from
`@ember/edition-utils` inside the application or addon's `.ember-cli.js`
file to specify which edition to use. That implementation worked well
enough throughout the intial preview period, but a number of major issues were
(rightfully!) surfaced by the community:

1. it seems unnecessary/redundant
2. it's not clear what this flag actually does (likely due to having no RFC!)
3. it's not statically analyzable (and therefore cannot be used by things like codemods)

This RFC will review these issues in light of the updated implementation,
showing how each of the concerns have been met.

## Detailed design

### Specifying the edition

A new entry will be added to the project's `package.json`:

```js
{
  "name": "project-name",
  // ...snip
  "ember": {
    "edition": "octane"
  }
}
```

The value will be expected to be one of the valid edition names (currently
`classic` and `octane`). Using the `package.json` for this allows us to ensure
that the value is statically analyzable and easy to discover.

For applications specifying `ember: { edition: 'octane' }` in `package.json` is
generally all that is needed. In an addon this new property would be specifying
the edition that the addons own dummy app uses. However, many addons may want
to test against _multiple_ editions that they support. In order to support
this, ember-try will be updated to allow specifying (and merging) the `ember`
property in the `package.json` from their `config/ember-try.js` scenarios.

### Valid use of the edition value

The edition flag should only be used by addons to determine what blueprint
output to generate and to provide helpful warnings (or errors) at build time.

Note that the above definition does **not** allow for an addon to detect the
edition configuration and change its fundamental implementation. This is quite
intentional!

Instead, addons should rely on feature detection techniques like the following
to alter implementations:

* Check to see if given methods/properties exist (this is essentially like how
  browser polyfills work)
* Use a tool like
[ember-compatibility-helpers](https://github.com/pzuraq/ember-compatibility-helpers)'s
`gte` method (e.g. `if (gte('ember-source', '3.14.0')) { }`)
* Use
  [@ember/optional-features](https://github.com/emberjs/ember-optional-features)'s
  [`isFeatureEnabled`
  method](https://github.com/emberjs/ember-optional-features#at-build-time-from-an-addon)

### Detecting the edition

The existing `@ember/edition-utils` package will still be used by addons to
detect which edition is in use, but it will be updated to check the new
location (instead of relying on folks leveraging `setEdition`).

The API documentation for `@ember/edition-utils` would be:

```ts
module '@ember/edition-utils' {
  /**
    Determine if the application that is running is running under a given Ember
    Edition.  When the edition in use is _newer_ than the requested edition it
    will return `true`, and if the edition in use by the application is _older_
    than the requested edition it will return `false`.

    @param {string} requestedEditionName the Edition name that the application/addon is requesting
    @param {string} [projectRoot=process.cwd()] the base directory of the project
  */
  has(requestedEditionName: string, projectRoot?: string): boolean;

  /**
    Sets the Edition that the application should be considered a part of.
    This method is deprecated, and will be phased out in the next major release.

    @deprecated
  */
  setEdition(editionName: string): void;
}
```

For a period of time the `@ember/edition-utils` package will continue to
support existing users of `setEdition` when an edition is not detected via the
new mechanism. This allows users that have been testing out Ember Octane
(either via the `@ember/octane-app-blueprint` or manually using `setEdition` in
their `.ember-cli.js`) a period of time in order to migrate.

## How we teach this

The official guides at `https://guides.emberjs.com/release/configuring-ember/`
will be updated to include documentation of the new `package.json`
configuration and clearly explain what the edition flag is used for (warnings
and blueprints).

This will not be a difficult concept to teach to folks (most users won't
care, and will get upgraded as part of a future `ember-cli` blueprint update).

## Drawbacks

> Changing existing app and addon usage of the prior flag will cause churn.

This is significantly mitigated by ensuring that `@ember/edition-utils`
continues to support users of `setEdition` API as a fallback (with a
deprecation), and that the existing `has` API continues to work (defaulting the
project root to the current working directory).

## Alternatives

### Use `emberEdition` in `package.json`

Some folks may prefer to use a single new property in `package.json` (vs the
`"ember": { "edition": "octane" }` setup proposed above). I personally think it
makes more sense to start with an `"ember":` key, as there are additional
possible usages (e.g. moving `"ember-addon"` configuration to be within
`"ember"`) and migrating from `emberEdition` to the nested syntax would be
needless churn.

### Use `.ember-cli` instead of `package.json`

Instead of adding the `emberEdition` value to the `package.json` we could add
it to the existing `.ember-cli` file. However, doing this would **not** satisfy
the static analysis constraint mentioned in the motivation section (because
`.ember-cli.js` is transparently supported by `ember-cli`'s build system).
In addition, any values that are included in `.ember-cli` are automatically
passed in to every command invocation which would be both unintended (we don't
want commands to access the edition in this way) and possibly breaking (if the
command already accepted an option with whatever value we chose).

## Unresolved questions

TBD?


---

---
stage: accepted
start-date: 2019-12-08T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/560
project-link:
---

# Adding Equality Operators to Templates

## Summary

Add new built-in template `{{eq}}` and `{{neq}}` helpers to perform basic equality operations in templates, similar to those included in `ember-truth-helpers`.

This RFC is a subset of the changes proposed in #388.

## Motivation

It is a very common need in any sufficiently complex Ember app to perform some equality operations and often the most convenient place to do it is right in the templates.
Because of that, [ember-truth-helpers](https://github.com/jmurphyau/ember-truth-helpers) is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.

The fact that `ember-truth-helpers` is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.

A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of comparing values in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.


## Detailed design

Add `{{eq}}` and `{{neq}}` helpers.

#### `{{eq}}`
Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> === <arg2>
This is identical to the `eq` helper in `ember-truth-helpers`

#### `{{neq}}`
Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> !== <arg2>
This is identical to the `not-eq` helper in `ember-truth-helpers`, except for the name.

This RFC intentionally leaves the implementation details unspecified, those could be implemented in Glimmer VM or
in a higher level in Ember itself.

## How we teach this

While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be
written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.

Previously users were encouraged to put computed properties in the javascript file of the components, even for
the most simple tasks like negating a comparing two values using `computed.eq`.

With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes
forced users to create javascript files for what could have been template-only components.

In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers
over computed properties where it makes more sense, adding illustrative examples and stressing out where
the definition of truthiness of handlebars differs from the one of Javascript.

### Note on Object Equality

We should also add an additional section to the guides or API docs which discusses using object equality in templates.
In general, object equality in JavaScript can be tricky. There are times when it makes perfect sense, for instance finding
out if an item is the currently selected item in a list:

```js
class MySelect extends Component {
  items = [{ value: 1 }, { value: 2 }, { value: 3 }];

  @tracked selectedItem = this.items[0];

  isSelected(item) {
    item === this.selectedItem;
  }
}
```

The `{{eq}}` helper can be used in a similar way in templates:

```hbs
<select>
  {{#each this.items as |item|}}
    <option selected={{eq item this.selectedItem}}>
      {{item.value}}
    </option>
  {{/each}}
</select>
```

There are many valid use cases for object equality. However, there are also times when object equality is not guaranteed,
especially in cases where it would have been in Classic Ember. Consider this component:

```js
class MyComponent extends Component {
  @computed('foo')
  get someObj() {
    return { foo: this.foo }
  }

  checkEqual() {
    return this.someObj === this.someObj;
  }
}
```

`checkEqual` will return `true`, because `@computed` _caches_ the object itself, and returns the same object every time unless `foo`
changes. With Ember Octane, though, by default getters are not cached:

```js
class MyComponent extends Component {
  get someObj() {
    return { foo: this.foo }
  }

  checkEqual() {
    return this.someObj === this.someObj;
  }
}
```

Now, the `someObj` getter will rerun every time the property is accessed, returning a _new_ object every time. `checkEqual` will
now always return `false`, since the objects are not equal to each other.

Now, we can do the same thing in a template with `eq`:

```js
{{eq this.someObj this.someObj}}
```

And the result depends here on Ember template's caching strategy. Ember only accesses a given property _once_, and then it caches
the result, so this will return `true`. However, the semantics of template caches are not guaranteed, and in time may change, so relying
on object equality in this way is not generally a good pattern.

Even if the semantics do not change, there are still observable ways that users can trigger the getter twice and generate another object.
For instance:

```js
class MyComponent extends Component {
  get someObj() {
    return { foo: this.foo }
  }

  get someObjAlias() {
    return this.someObj;
  }
}
```

```hbs
{{eq this.someObj this.someObjAlias}}
```

Overall, the point here is that if users expect an object generated by a getter or helper to remain _stable_ between accesses, such that
object equality or state can be valid, then the user should explicitly cache that value themselves. This can be accomplished in a number
of ways, one option being the proposed `@cached` decorator:

```js
class MyComponent extends Component {
  @cached
  get someObj() {
    return { foo: this.foo }
  }
}
```

## Drawbacks

Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.

## Alternatives

One alternative path is don't do anything and let users continue to define their own helpers (or install `ember-truth-helpers`).

## Unresolved questions

- If an app already use `ember-truth-helpers`, the `{{eq}}` helper will conflict with the one proposed here. How do we
  update `ember-truth-helpers` to make sure the helper of the same name doesn't collide with the built-in one?
- The inequality helper proposed in this RFC is `{{neq}}` while the one in ember-truth-helpers is `{{not-eq}}`. It is
  worth considering the benefits that keeping the same name might have in helping apps and addon migrate to the built-in helper.


---

---
stage: accepted
start-date: 2019-12-08T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/561
project-link:
---

# Adding Comparison Operators to Templates

## Summary

Add new built-in template `{{lt}}`, `{{lte}}`, `{{gt}}`, and `{{gte}}` keywords to perform basic numeric comparison operations in templates, similar to those included in `ember-truth-helpers`.

This RFC is a subset of the changes proposed in #388.

## Motivation

It is a very common need in any sufficiently complex Ember app to perform some numeric comparison operations and often the most convenient place to do it is right in the templates.
Because of that, [ember-truth-helpers](https://github.com/jmurphyau/ember-truth-helpers) is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.

The fact that `ember-truth-helpers` is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.

A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of comparing numbers in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.


## Detailed design

The new comparison operators will be made keywords, so they are easily accessible in current and future templates without needing to be imported.

#### `{{lt}}`

Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> < <arg2>
This is identical to the `{{lt}}` helper in `ember-truth-helpers`

#### `{{lte}}`

Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> <= <arg2>
This is identical to the `{{lte}}` helper in `ember-truth-helpers`

#### `{{gt}}`

Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of `<arg1> > <arg2>`
This is identical to the `{{gt}}` helper in `ember-truth-helpers`.

#### `{{gte}}`

Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of `<arg1> >= <arg2>`.
This is identical to the `{{gte}}` helper in `ember-truth-helpers`.

## How we teach this

While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.

Previously users were encouraged to put computed properties in the JavaScript file of the components, even for the most simple tasks like comparing if a value is less than another using `computed.lt`.

With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes forced users to create JavaScript files for what could have been template-only components.

In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers over computed properties where it makes more sense, adding illustrative examples and stressing out where the definition of truthiness of handlebars differs from the one of Javascript.

### API Docs

#### `{{lt}}`

The `{{lt}}` helper can be used to compare two values in a template. It returns `true` if the first value is
less than the second value, and `false` otherwise. It is equivalent to the `<` operator in JavaScript.

```hbs
{{#if (lt @number 5)}}
  The number is less than 5!
{{/if}}
```

#### `{{lte}}`

The `{{lte}}` helper can be used to compare two values in a template. It returns `true` if the first value is
less than or equal to the second value, and `false` otherwise. It is equivalent to the `<=` operator in JavaScript.

```hbs
{{#if (lte @number 5)}}
  The number is less than or equal to 5!
{{/if}}
```

#### `{{gt}}`

The `{{gt}}` helper can be used to compare two values in a template. It returns `true` if the first value is
greater than the second value, and `false` otherwise. It is equivalent to the `>` operator in JavaScript.

```hbs
{{#if (gt @number 5)}}
  The number is greater than 5!
{{/if}}
```

#### `{{gte}}`

The `{{gte}}` helper can be used to compare two values in a template. It returns `true` if the first value is
greater than or equal the second value, and `false` otherwise. It is equivalent to the `>=` operator in JavaScript.

```hbs
{{#if (gte @number 5)}}
  The number is greater than or equal to 5!
{{/if}}
```

## Drawbacks

Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.

## Alternatives

One alternative path is don't do anything and let users continue to define their own helpers (or install `ember-truth-helpers`).

## Unresolved questions

- The proposed version of those helpers mimic the behavior of the `<` and `>` operators in Javascript. While this is the
  least surprising thing to do, one could argue that we could add extra logic to protect users from the usual pitfalls
  and edge cases of those operators, **like throwing exceptions if any of the values is `NaN` or a value other than a number**.
- We must decide if it's worth adding `{{lte}}` and `{{gte}}` helpers, equivalent to `<=` and `>=` respectively.
- `BigInt` support. The BigInt proposal has recently reached stage 4 and will be part of ECMASCRIPT 2020. According to
  the spec comparisons using `<` and `>` work as expected and I don't anticipate problems, but ensure we explicitly
  test for those numbers.


---

---
stage: accepted
start-date: 2019-12-08T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/562
project-link:
---

# Adding Logical Operators to Templates

## Summary

Add new built-in template `{{and}}`, `{{or}}` and `{{not}}` helpers to perform basic logical operations in templates, similar to those included in `ember-truth-helpers`.

This RFC is a subset of the changes proposed in #388.

## Motivation

It is a very common need in any sufficiently complex Ember app to perform some logical comparison operations and often the most convenient place to do it is right in the templates.
Because of that, [ember-truth-helpers](https://github.com/jmurphyau/ember-truth-helpers) is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.

The fact that `ember-truth-helpers` is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.

A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of performing logical operations in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.

A third reason, this time technical, is that by implementing those helpers at a lower-level, we can make them more performant by making them short-circuit.
Right now helpers implemented using public APIs like those in `ember-truth-helpers` eagerly consume their arguments. In the case of logical operations like `{{and a b}}`,
once the first argument (`a`) is evalued to _falsey_, the second argument (`b`) is irrelevant. Sometimes arguments can be expensive properties to calculate,
and by short-circuiting we can avoid computing them at all sometimes.


## Detailed design

Add `{{and}}`, `{{or}}` and `{{not}}` helpers.

#### `{{and}}`
Takes at least two positional arguments. Raises an error if invoked with less than two arguments.
It evaluates arguments left to right, returning the first one that is not _truthy_ (**by handlebar's definition of truthiness**)
or the right-most arguments if **all** evaluate to _truthy_.
This is *NOT* equivalent to the `{{and}}` helper from `ember-truth-helpers` because unlike this proposed helper, the one in `ember-truth-helpers`
uses Javascript's definition of truthiness.

#### `{{or}}`
Takes at least two positional arguments. Raises an error if invoked with less than two arguments.
It evaluates arguments left to right, returning the first one that is _truthy_ (**by handlebar's definition of truthiness**) or the
right-most argument if all evaluate to _falsy_.
This is *NOT* equivalent to the `{{or}}` helper from `ember-truth-helpers` because unlike this proposed helper, the one in `ember-truth-helpers`
uses Javascript's definition of truthiness.

#### `{{not}}`
Unary operator. Raises an error if invoked with more than one positional argument. If the given value evaluates to a _truthy_ value (**by handlebar's definition of truthiness**),
the `false` is returned. If the given value evaluates to a _falsy_ value (**by handlebar's definition of truthiness**) then it returns `true`.
This is *NOT* equivalent to the `{{not}}` helper from `ember-truth-helpers` because unlike this proposed helper, the one in `ember-truth-helpers`
uses Javascript's definition of truthiness.

#### Handlebar's definition of truthiness
This is the most important detail of this proposal because it's where it deviates from `ember-truth-helpers`.
Handlebars has its own definition of _truthyness_, which is similar to Javascripts except that empty arrays are
considered **falsy**, while in JS are considered **truthy**.


This RFC intentionally leaves the implementation details unspecified, but one can think of those helpers as macros that
expand to combinations of `if`s.

##### `{{and}}`
- `{{and a b}}` is equivalent to `{{if a b a}}`
- `{{and a b c}}` is equivalent to  `{{if a (if b c b) a}}`
- and so on

##### `{{or}}`
- `{{or a b}}` is equivalent to `{{if a a b}}`
- `{{or a b c}}` is equivalent to  `{{if a a (if b b c)}}`
- and so on

##### `{{not}}`
- `{{not a}}` is equivalent to `{{if a false true}}`

## How we teach this

While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be
written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.

Previously users were encouraged to put computed properties in the javascript file of the components, even for
the most simple tasks like negating a boolean condition using `computed.not` or adding them with `computed.and`.

With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes
forced users to create javascript files for what could have been template-only components.

In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers
over computed properties where it makes more sense, adding illustrative examples and stressing out where
the definition of truthiness of handlebars differs from the one of Javascript.

## Drawbacks

Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.

## Alternatives

One alternative path is to not take any action and let users continue to define their own helpers (or install `ember-truth-helpers`).
Additionally the core could explore ways of making helpers not consume arguments eagerly to allow the implementation
of short-circuiting helpers in userland.

## Unresolved questions

- Consider following Javascript's definition of truthiness. This would also help with the transition from `ember-truth-helpers`.


---

---
stage: recommended
start-date: 2019-12-22T00:00:00.000Z
release-date: 2021-12-28T00:00:00.000Z
release-versions:
  ember-source: v4.1.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/566'
  recommended: 'https://github.com/emberjs/rfcs/pull/914'
project-link:
---

# @cached

## Summary

Add a `@cached` decorator for memoizing the result of a getter based on
autotracking. In the following example, `fullName` would only recalculate if
`firstName` or `lastName` is updated.

```js
class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  @cached
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

## Motivation

One of the major differences between computed properties and tracked properties
with autotracking in Octane is that native, autotracked getters do not
automatically cache their values, where computed properties were cached by
default. This was an intentional design choice, as the memoization logic for
computed properties was actually more costly, on average, than rerunning the
getter in the first place. This was especially true given that computed
properties would usually only ever be calculated and used once or twice per
render before being updated.

However, there are absolutely cases where getters _are_ expensive, and their
values are used repeatedly, so memoization would be very helpful. Strategic,
opt-in memoization is a useful tool that would help Ember developers optimize
their apps when relevant, without adding extra overhead unless necessary.

## Detailed design

The `@cached` decorator will be exported from `@glimmer/tracking`, alongside
`@tracked`. It can be used on native getters to memoize their return values
based on the tracked state they consume while being calculated.

```js
import { tracked, cached } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  @cached
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

In this example, the `fullName` getter will be memoized whenever it is called,
and will only be recalculated the next time the `firstName` or `lastName`
properties are set. This would apply to any autotracking tags consumed while
calculating the getter, so changes to `EmberArray`s and other tracked
primitives, for instance, would also cause invalidations.

If used on a non-getter, `@cached` will throw an error in `DEBUG` modes.
Properties can also include a setter, but it won't affect the memoization of the
getter (except by potentially setting the state that was tracked in the first
place).

### Invalidation

`@cached` will propagate invalidations whenever any of the properties it is
entangled with are invalidated, causing any downstream state that has consumed
to be invalidated at the same time.

This is necessary in order to have the memoized value be pulled on again in
general. There is no way to, for instance, only propagate changes if the
memoized value has changed, since we must calculate the memoized value first to
know what it's new value is, and we must propagate the change in order to ensure
that it will be recalculated.

### Cycles

Cycles will not be allowed with `@cached`. The cache will only be activated
_after_ the getter has fully calculated, so any cycles will cause infinite
recursion (and eventually, stack overflow), just like un-memoized getters. If a
cycle is detected in `DEBUG` mode, it will throw an error.

## How we teach this

`@cached` is not an essential part of the reactivity model, so it shouldn't be
covered during the main component/reactivity guide flow. Instead, it should be
covered in the intermediate/in-depth guides, and in any performance related
guides. We should also note that the decorator should not be sprinkled around
carelessly or defensively - instead, it should only be used when the computation
being cached is confirmed to be computationally expensive.

### API Docs

The `@cached` decorator can be used on getters in order to cache the return
value of the getter. This is useful when a getter is expensive and used very
often. For instance, in this guest list class, we have the `sortedGuests`
getter that sorts the guests alphabetically:

```js
import { tracked } from '@glimmer/tracking';

class GuestList {
  @tracked guests = ['Zoey', 'Tomster'];

  get sortedGuests() {
    return this.guests.slice().sort()
  }
}
```

Every time `sortedGuests` is accessed, a new array will be created and sorted,
because JavaScript getters do not cache by default. When the guest list is
small, like the one in the example, this is not a problem. However, if the guest
list were to grow very large, it would mean that we would be doing a large
amount of work each time we accessed `sortedGetters`. With `@cached`, we can
cache the value instead:

```js
import { tracked, cached } from '@glimmer/tracking';

class GuestList {
  @tracked guests = ['Zoey', 'Tomster'];

  @cached
  get sortedGuests() {
    return this.guests.slice().sort()
  }
}
```

Now the `sortedGuests` getter will be cached based on _autotracking_. It will
only rerun and create a new sorted array when the `guests` tracked property is
updated.

In general, you should avoid using `@cached` unless you have confirmed that the
getter you are decorating is computationally expensive. `@cached` adds a small
amount of overhead to the getter, making it more expensive. While this overhead
is small, if `@cached` is overused it can add up to a large impact overall in
your app. Many getters and tracked properties are only accessed once, rendered,
and then never rerendered, so adding `@cached` when it is unnecessary can
negatively impact performance.

## Drawbacks

- Adds extra complexity when programming (whether or not a value should be
  memoized is now a decision that has to be made). In general, we should make
  sure this is not an issue by recommending that memoization idiomatically _not_
  be used _unless_ it is absolutely necessary.

- Adds extra overhead for each memoized getter. This again should be addressed
  by teaching that it should be avoided when possible. The cost tradeoff should
  be noted in documentation in particular to emphasize this, and discourage
  overuse.

- `@cached` may rerun even if the values themselves have not changed, since
  tracked properties will always invalidate even if their underlying value did
  not change. Unfortunately, this is not really something that `@cached` can
  circumvent, since there's no way to tell if a value has actually changed, or
  to know which values are being accessed when the memoized value is accessed
  until the getter is run.

  Instead, we should be sure that the rules of property invalidation are clear,
  and in performance sensitive situations we recommend diff checking when
  assigning the property:

  ```js
  if (newValue !== this.trackedProp) {
    this.trackedProp = newValue;
  }
  ```

## Alternatives

- `@memo` or `@memoized` could be alternative names. Initially `@memo` was used,
  but it was decided to switch to `@cached`.

- `@cached` could receive arguments of the keys to memoize based on. This would
  bring us back to the ergonomics of computed properties, however, and would not
  be ideal. It also would bring no actual benefits, except being able to exclude
  certain values from recalculation.




---

---
stage: recommended
start-date: 2020-01-10T00:00:00.000Z
release-date: 2020-10-05T00:00:00.000Z
release-versions:
  ember-source: v3.22.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/580'
  recommended: 'https://github.com/emberjs/rfcs/pull/915'
project-link:
---

# Destroyables

## Summary

Adds an API for registering destroyables and destructors with Ember's built in
destruction hierarchy.

```js
class MyComponent extends Component {
  constructor() {
    let timeoutId = setTimeout(() => console.log('hello'), 1000);

    registerDestructor(this, () => clearTimeout(timeoutId));
  }
}
```

The API will also enable users to create and manage their own destroyables, and
associate them with a parent destroyable.

```js
class TimeoutManager {
  constructor(parent, fn, timeout = 1000) {
    let timeoutId = setTimeout(fn, timeout);

    associateDestroyableChild(parent, this);
    registerDestructor(this, () => clearTimeout(timeoutId));
  }
}

class MyComponent extends Component {
  manager = new TimeoutManager(this, () => console.log('hello'));
}
```

## Motivation

Ember manages the lifecycles and lifetimes of many built in constructs, such as
components, and does so in a hierarchical way - when a parent component is
destroyed, all of its children are destroyed as well. This is a well established
software pattern that is useful for many applications, and there are a variety
of libraries, such as [ember-lifeline](https://github.com/ember-lifeline/ember-lifeline)
and [ember-concurrency](https://github.com/machty/ember-concurrency), that would
benefit from having a way to extend this hierarchy, adding their own "children"
that are cleaned up whenever their parents are removed.

Historically, Ember has exposed this cleanup lifecycle via _hooks_, such as the
`willDestroy` hook on components. However, methods like these have a number of
downsides:

1. Since they are named, they can have collisions with other properties. This is
   historically what led to the actions hash on classic components, in order to
   avoid collisions between actions named `destroy` and the `destroy` lifecyle
   hook.
2. On a related note, relying on property names means that all framework classes
   _must_ implement the `willDestroy` function (or another name), making it very
   difficult to change APIs in the future.
3. Methods are difficult for _libraries_ to instrument. For instance,
   `ember-concurrency` currently replaces the `willDestroy` method on any class
   with a task, with logic that looks similar to:

   ```js
   let PATCHED = new WeakSet();

   function patchWillDestroy(obj) {
     if (PATCHED.has(obj)) return;

     let oldWillDestroy = obj.willDestroy;

     obj.willDestroy = function () {
       if (oldWillDestroy) oldWillDestroy.call(this);

       teardownTasks(this);
     };

     PATCHED.add(obj);
   }
   ```

   This logic becomes especially convoluted if _multiple_ libraries are
   attempting to patch `willDestroy` in this way.

4. Finally, since this isn't a standard, it's difficult to add _layers_ of new
   destroyable values that can interoperate with one another. For instance,
   there is no way for `ember-concurrency` to know how to destroy tasks on
   non-framework classes that users may have added themselves.

This RFC proposes a streamlined API that disconnects the exact implementation
from any interface, allows for multiple destructors per-destroyable, and
maximizes interoperability in general.

## Detailed design

The API consists of 6 main functions, imported from `@ember/destroyable`:

```ts
declare function associateDestroyableChild<T extends object>(parent: object, child: T): T;

declare function registerDestructor<T extends object>(
  destroyable: T,
  destructor: (destroyable: T) => void
): (destroyable: T) => void;

declare function unregisterDestructor<T extends object>(
  destroyable: T,
  destructor: (destroyable: T) => void
): void;

declare function destroy(destroyable: object): void;
declare function isDestroying(destroyable: object): boolean;
declare function isDestroyed(destroyable: object): boolean;
```

In addition, there is a debug-only mode function used for testing:

```ts
declare function assertDestroyablesDestroyed(): void;
```

For the remainder of this RFC, the terms "destroyable" and "destroyable object"
will be used to mean any object which is a valid `WeakMap` key
(e.g. `typeof obj === 'object' || typeof obj === 'function'`). Any JS object
that fulfills this property can be used with this system.

#### `associateDestroyableChild`

This function is used to associate a destroyable object with a parent. When the
parent is destroyed, all registered children will also be destroyed.

```js
class CustomSelect extends Component {
  constructor() {
    // obj is now a child of the component. When the component is destroyed,
    // obj will also be destroyed, and have all of its destructors triggered.
    this.obj = associateDestroyableChild(this, {});
  }
}
```

Returns the associated child for convenience.

- Attempting to associate a parent or child that has already been destroyed
  or is being destroyed should throw an error.

##### Multiple Inheritance

Attempting to associate a child to multiple parents should currently throw an
error. This could be changed in the future, but for the time being multiple
inheritance of destructors is tricky and not scoped in. Instead, users can add
destructors to accomplish this goal:

```js
let parent1 = {},
  parent2 = {},
  child = {};

registerDestructor(parent1, () => destroy(child));
registerDestructor(parent2, () => destroy(child));
```

The exact timing semantics here will be a bit different, but for most use cases
this should be fine. If we find that it would be useful to have multiple
inheritance baked in in the future, it can be added in a followup RFC.

#### `registerDestructor`

Receives a destroyable object and a destructor function, and associates the
function with it. When the destroyable is destroyed with `destroy`, or when its
parent is destroyed, the destructor function will be called.

```js
import { registerDestructor } from '@ember/destroyable';

class Modal extends Component {
  @service resize;

  constructor() {
    this.resize.register(this, this.layout);

    registerDestructor(this, () => this.resize.unregister(this));
  }
}
```

Multiple destructors can be associated with a given destroyable, and they can be
associated over time, allowing libraries like `ember-lifeline` to dynamically
add destructors as needed. `registerDestructor` also returns the associated
destructor function, for convenience.

The destructor function is passed a single argument, which is the destroyable
itself. This allows the function to be reused multiple times for many
destroyables, rather than creating a closure function per destroyable.

```js
import { registerDestructor } from '@ember/destroyable';

function unregisterResize(instance) {
  instance.resize.unregister(instance);
}

class Modal extends Component {
  @service resize;

  constructor() {
    this.resize.register(this, this.layout);

    registerDestructor(this, unregisterResize);
  }
}
```

- Registering a destructor on a destroyed object or object that is being destroyed should throw an error.
- Attempting to register the same destructor multiple times should throw an
  error.

#### `unregisterDestructor`

Receives a destroyable and a destructor function, and de-associates the
destructor from the destroyable.

```js
import { unregisterDestructor } from '@ember/destroyable';

class Modal extends Component {
  @service modals;

  constructor() {
    this.modals.add(this);

    this.modalDestructor = registerDestructor(this, () => this.modals.remove(this));
  }

  @action pinModal() {
    unregisterDestructor(this, this.modalDestructor);
  }
}
```

- Calling `unregisterDestructor` on a destroyed object should throw an error.
- Calling `unregisterDestructor` with a destructor that is not associated with
  the object should throw an error.

#### `destroy`

`destroy` initiates the destruction of a destroyable object. It runs all
associated destructors, and then destroys all children recursively.

```js
let obj = {};

registerDestructor(obj, () => console.log('destroyed!'));

destroy(obj); // this will schedule the destructor to be called

// ...some time later, during scheduled destruction

// destroyed!
```

Destruction via `destroy()` follows these steps:

1. Mark the destroyable such that `isDestroying(destroyable)` returns `true`
2. Schedule calling the destroyable's destructors
3. Call `destroy()` on each of the destroyable's associated children
4. Schedule setting destroyable such that `isDestroyed(destroyable)` returns `true`

This algorithm results in the entire tree of destroyables being first marked as
destroying, then having all of their destructors called, and finally all being
marked as `isDestroyed`. There won't be any in between states where some items
are marked as `isDestroying` while destroying, while others are not.

Calling `destroy` multiple times on the same destroyable is safe. It will not
throw an error, and will not take any further action.

Calling `destroy` with a destroyable that has no destructors or associated children
will not throw an error, and will do nothing.

#### `isDestroying`

Receives a destroyable, and returns `true` if the destroyable has begun
destroying. Otherwise returns false.

```js
let obj = {};
isDestroying(obj); // false
destroy(obj);
isDestroying(obj); // true
// ...sometime later, after scheduled destruction
isDestroyed(obj); // true
isDestroying(obj); // true
```

#### `isDestroyed`

Receives a destroyable, and returns `true` if the destroyable has finished
destroying. Otherwise returns false.

```js
let obj = {};

isDestroyed(obj); // false
destroy(obj);

// ...sometime later, after scheduled destruction

isDestroyed(obj); // true
```

#### `assertDestroyablesDestroyed`

This function asserts that all objects which have associated destructors or
associated children have been destroyed at the time it is called. It is meant to
be a low level hook that testing frameworks like `ember-qunit` and `ember-mocha`
can use to hook into and validate that all destroyables have in fact been
destroyed.

### Built In Destroyables

The root destroyable of an Ember application will be the instance of the owner.
All framework managed classes are destroyables, including:

- Components
- Services
- Routes
- Controllers
- Helpers
- Modifiers

Any future classes that are added and have a container managed lifecycle should
also be marked as destroyables.

## How we teach this

Destroyables are not a very commonly used primitive, but they are fairly core to
Ember applications. Most destruction lifecycle hooks will be rationalized as
destroyables under the hood, and and it is key to how the application manages
lifecycles. As such, destroyables should be covered in an _In-Depth Guide_ in
the Core Concepts section of the guides.

### Guide Outline

The guide should start by discussing lifecycle, in particular focusing on in the
existing lifecycle hooks that users will already know about, such as
`willDestroy` on components. It should cover how at a high level, every
framework concept exists in a _lifecycle tree_, where children are tied to the
lifecyles of their parents. When something in the tree is destroyed, like a
component so are all of its children.

The destroyable APIs can then be brought in to discuss how one might add to the
tree, if they have concepts whose lifecycles would logically belong to it. This
should be done primarily through examples. Some ideas for possible examples
include:

1. A simple remote data fetcher. The request needs to be cancelled if the parent
   is destroyed, which is a perfect use case for a destroyable.
2. A task manager that manages a variety of long lived tasks.
3. Possibly another example where a completely independent tree is made, for
   some sort of library that would be otherwise external to Ember.

The rest of the guide could show in detail how the user would use the APIs to
accomplish this goal, and how it would be better and more scalable than doing it
with lifecycle hooks.

There should also be a section on _when_ to use the low-level destroyable APIs,
vs the standard lifecycle hooks.

### API Docs

The descriptions of the APIs above in the RFC are sufficient detail for the bulk
of API documentation, with some light editing.

## Drawbacks

- Adds another destruction API which may conflict with the existing destruction
  hooks. Since this is a low-level API, it shouldn't be too problematic - most
  users will be guided toward using the standard lifecycle hooks, and this API
  will exist for libraries like `ember-concurrency` and `ember-lifeline`.

## Alternatives

- Continue using existing lifecycle hooks for public API, and don't provide an
  independent API.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2020-01-14T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/581
project-link:
---

# Summary

Test waiters have been around in Ember in one form or another since version 1.2.0, and provide a way for developers to signal to the testing framework system that async operations are currently active, when to keep waiting, and when those async operations have completed. This allows the active test to wait during the test in a deterministic fashion, and only proceed once the active async is completed.

The current test waiters implementation has a simple but confusing API, and the test waiters themselves lack some key features. This RFC proposes replacing them with a new test waiters system: [ember-test-waiters](https://github.com/rwjblue/ember-test-waiters).

# Motivation

Recently, an updated replacement for the original test waiters API was created. This new library, ember-test-waiters, seeks to provide an easy-to-use API that can be used to interleave unmanaged async behaviors with Ember’s test framework. Using a test waiter can help mark begin and end points for your async operations, allowing the test to deterministically pause during execution.

The new system will provide a few benefits:

1. A new API that removes the existing foot guns (e.g. "Do I return `false` or `true` if I want to continue waiting?")
1. A more robust way to gather debugging information for the test waiter
1. Default test waiters with the ability to author your own, more complex test waiters

# Detailed design

Ember’s test framework has an internal concept of settledness, that is used by all of its internal helpers. Settledness can be defined as **_all known active async operations have completed, and there’s no outstanding work to be done_**. This is codified in the [settled](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#settled) helper.

The settled helper, as noted, wires itself up to known asynchronous behaviors. Those include whether there

- is an active runloop (more on the runloop)
- are any pending timers within the runloop (run.later, run.debounce, run.throttle)
- are any pending test waiters (more on waiters later!)
- are any pending `jQuery.ajax` requests
- are any pending route transitions.

The settled check returns a Promise that is fulfilled when all of the above behaviors return `false`, indicating all async for each behavior is completed. These cover a vast number of async behaviors that are typical in our applications.

An enhancement was added to [`ember-qunit`](https://github.com/emberjs/ember-qunit) that allowed for detecting a lack of settledness at the end of a test. This enhancement, [test isolation validation](https://github.com/emberjs/ember-qunit/blob/master/docs/TEST_ISOLATION_VALIDATION.md), evaluated the settled state once a test was considered done and reported to the user whether there were active async operations pending. This helped developers quickly identify and fix known asynchronous leaks in their tests, allowing for a more deterministic test suite.

During the development of the test isolation validation feature, we discovered that most asynchronous operations used in the settled check provided good debug information that could be provided to the end user, with the exception of the existing test waiters. Those waiters only provided rudimentary information that could be exposed, specifically whether there were any active test waiters pending, but nothing more.

To address this, a new addon was written to experiment on a new test waiter system that would provide a number of things (as noted above):

1. A new API that's _explicit_ and _straightforward_
1. A more robust way to gather debugging information for the test waiter
1. Default test waiters with the ability to author your own, more complex test waiters

This allows developers to utilize `ember-test-waiters` to annotate their asynchronous operations that are not tracked by an `await settled()` check, and for those annotations to provide useful debugging information in the event their async extended past the expected duration of the test.

## Comparison of old waiters system to new

In the old test waiters system, you would do the following:

```js
import { registerWaiter } from '@ember/test';

registerWaiter(function() {
  return myPendingTransactions() === 0;
});
```

While reading the above is straightforward, when writing a test waiter using the old system it's easy to forget what the expected return value is: `true` or `false`. Additionally, it's a bit more cognitive overhead to derive what the intended result of the particular boolean return value is: does returning `true` result in the test waiter waiting or not?

As mentioned before, there's no additional information provided via `registerWaiter`, and capturing stack traces at the call site is currently not implemented. Unmanaged async that 'hangs' can cause your tests to stall and ultimately timeout. Not having stack traces is particularly problematic when trying to identify which of many test waiters has caused this timeout, as it's like looking for a needle in a haystack.

The new system captures an error object when the waiter's `beginAsync` method is called (more on `beginAsync` later), but evaluates the `stack` property lazily, when this value is processed by `@ember/test-helpers`' `getSettledState`. This allows for identifying the offending code more easily.

The new test waiters system looks like this:

```js
import Component from '@ember/component';
import { buildWaiter } from 'ember-test-waiters';

let waiter = buildWaiter('friend-waiter');

export default class Friendz extends Component {
  didInsertElement() {
    let token = waiter.beginAsync();

    someAsyncWork()
      .then(() => {
        //... some work
      })
      .finally(() => {
        waiter.endAsync(token);
      });
  }
}
```

In the above example, a new test waiter is built that is identified via a `name` string passed into the `buildWaiter` function. This allows the waiter to be identifiable, and that name is ultimately used with test isolation validation to help developers narrow down problems in their tests.

## New Test Waiters Design

The new test waiters addon is built using low-level primitives that are complimented with some convenience utilities.

### `Waiter`

At its core, the addon uses an `Waiter` interface defined as follows:

```ts
export type WaiterName = string;
export type Token = unknown;

export interface Waiter {
  name: WaiterName;
  waitUntil(): boolean;
  debugInfo(): TestWaiterDebugInfo[];
}
```

- `name`: The name of the test waiter, which is used to help identify it in test isolation validation output.
- `waitUntil`: Used to determine if the waiter system should still wait for async
  operations to complete. The `waitUntil` method will return `true` to signal completion.
- `debugInfo`: Returns the `debugInfo` for each item tracking async operations in a waiter. The `debugInfo` for each waiter item is ultimately used in `@ember/test-helpers`' `getSettledState` function, which is used for test isolation validation output.

This allows for maximum flexibility when creating your own waiter implementations.

### `TestWaiter`

The `Waiter` interface is built upon to create a more specific interface for a test waiter, `TestWaiter`:

```ts
export interface TestWaiter<T extends object | Primitive | unknown = Token>
  extends Waiter {
  beginAsync(token?: T, label?: string): T;
  endAsync(token: T): void;
  reset(): void;
}
```

- `beginAsync`: Should be used to signal the beginning of an async operation that
  is to be waited for. Invocation of this method should be paired with a subsequent
  `endAsync` call to indicate to the waiter system that the async operation is completed.
- `endAsync`: Should be used to signal the end of an async operation. Invocation of this
  method should be paired with a preceding `beginAsync` call, which would indicate the
  beginning of an async operation.
- `reset`: Resets the waiter state, clearing items tracking async operations in this waiter.

This interface is used for the concrete `TestWaiter` type. This type forms the basis for the addon, and will likely satisfy the majority of use cases.

The most common practice is to import and invoke the `buildWaiter` function to create a new test waiter. The recommendation is to do so at the module level, which allows a single waiter to be created per type (this should likely be enforced via a lint rule added to `eslint-plugin-ember`). A single waiter is then usable across multiple instances.

```ts
function buildWaiter(name: string): TestWaiter;
```

In anything but a production build, this function will return a `TestWaiter` instance. When in production mode, we make this instance _inert_ and essentially no cost to invoke. Since test waiters are intended to be called from application or addon code, but are only required to be _active_ when in tests, this process of making the instance _inert_ is important. Even though code is still invoked, this has a negligible impact on performance.

### Using the `TestWaiter` class

After building a test waiter, most users interact with a limited set of methods within this class, namely `beingAsync` and `endAsync`.

The API used to signal whether an asynchronous operation has begun and ultimately ended is through the **_paired_** calls of `beginAsync` and `endAsync`: begin to denote the start of the asynchronous operation, and end to denote the end. Unique instances of async operations are identified using a `token` returned from `beginAsync`, which is subsequently provided to the `endAsync` call.

To annotate the example provided above:

```js
import Component from '@ember/component';
import { buildWaiter } from 'ember-test-waiters';

// Creates a test waiter with the name 'friend-waiter' that
// is usable by all instances of the `Friendz` component.
let waiter = buildWaiter('friend-waiter');

export default class Friendz extends Component {
  didInsertElement() {
    // Alerts the test waiter system that an async operation has started,
    // storing the resulting unique token to be used to notify the test
    // waiter system that the operation has ended.
    let token = waiter.beginAsync();

    someAsyncWork()
      .then(() => {
        //... some work
      })
      .finally(() => {
        // Notifies the test waiter system that
        // this unique async operation has ended.
        waiter.endAsync(token);
      });
  }
}
```

### `waitForPromise`

The `waitForPromise` utility provides a convenience wrapper around the `TestWaiter` class for use with promises. It ensures the `endAsync` call is invoked in the `finally` of the configured promise.

```js
import Component from '@ember/component';
import { waitForPromise } from 'ember-test-waiters';

export default class MoreFriendz extends Component {
  didInsertElement() {
    waitForPromise(someAsyncWork).then(() => {
      doOtherThings();
    });
  }
}
```

This new test waiters system has been through multiple iterations of refinement, and is in use and integrated with the test isolation validation system.

## Rename of `ember-test-waiters` to `@ember/test-waiters`

We should consider renaming the `ember-test-waiters` repository to `@ember/test-waiters`, which would relocate it to the Ember org and scope it more explicitly.

## Compatibility

The `ember-test-waiters` addon is backwards compatible with the old test waiters system, allowing applications and addons to gradually migrate to using the new system.

Specifically:

- `registerWaiter` continues to work, and is not deprecated
- addons using `ember-test-waiters` work _even if consumed in applications that do not use a new enough `ember-test-helpers` version_ (they won't get additional output via test isolation validation such as test waiter names or stack traces)

The old test waiters system ultimately should be deprecated in its own deprecation RFC.

## Rollout

- Rename `ember-test-waiters` to `@ember/test-waiters`, moving it to the `emberjs` org
- Add `@ember/test-waiters` to the default app and addon blueprints
- Add new optional lint rule to `eslint-plugin-ember` that flags usage of legacy test waiters, recommending the new waiters as a replacement
- Open a new RFC proposing deprecation of legacy test waiters

# How We Teach This

API documentation should be available at `api.emberjs.com`.

## New Testing Section in Ember Guides - "Handling Async"

This new test waiters system should be included in the Ember guide's testing section. Information and examples should be provided to allow users to correctly author asynchronous code that can be correctly managed by the testing system.

Specifically, calling this out in a separate section will allow readers to understand the intent of the test waiters system from a high level, as test waiters apply broadly to all the associated types in the testing section.

There are a few concepts that we should focus on:

1. What patterns of asynchronous code can lead to issues in testing
1. How to utilize test waiters to address those asynchronous patterns
1. How to leverage the built-in test waiters utilities

## New Testing Section in Ember CLI Guides - "Handling Async (for Addon Authors)"

The important requirement that addon authors need to know about is that when using `ember-test-waiters`, that package should be added as a `dependency`.

Specifically for addon authors, we want to encourage the use of test waiters to prevent async leaks in tests due to unmanaged async. A special section directed at addon authors should be added to help them understand the value to their consumers by adding test waiters, or providing test helpers via `addon-test-support` integrated with test waiters.

# Drawbacks

- the new test waiters system ships code to production bundles, though this is quite small

# Alternatives

- the existing test waiters system could be left in place


---

---
stage: accepted
start-date: 2020-01-27T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/585
project-link:
---

# Improved Ember Registry APIs

## Summary

Introduce a new, object-based API for all registry APIs; deprecate the current string-based microsyntax registry APIs; and introduce a `capabilities` property to the resolver to safely support existing resolvers. Extend the new API for service and controller injections, and deprecate their microsyntax for namespaced injections.

Today the registry APIs are all of shapes roughly like this:

```js
getOwner(this).lookup('service:session');
```

This RFC proposes that they would instead be written like this:

```js
getOwner(this).lookup({ type: 'service', name: 'session' })
```

Service and controller injections which include a namespace currently look like this:

```js
class Example {
  @service('global@session')
  session;
}
```

This RFC proposes that these would instead be written like this:

```js
class Example {
  @service({ namespace: 'global', name: 'session' })
  session;
}
```

### Table of Contents

- [Summary](#summary)
  - [Table of Contents](#table-of-contents)
- [Motivation](#motivation)
  - [Microsyntax problems](#microsyntax-problems)
  - [TypeScript problems](#typescript-problems)
  - [Performance benefits?](#performance-benefits)
- [Detailed design](#detailed-design)
  - [`Identifier` types](#identifier-types)
  - [`Resolver`](#resolver)
  - [Owner APIs](#owner-apis)
    - [Options](#options)
    - [`Factory` and `FactoryManager`](#factory-and-factorymanager)
    - [`Owner` API diff](#owner-api-diff)
  - [Service and Controller Injections](#service-and-controller-injections)
  - [Codemod](#codemod)
  - [Deprecation messaging](#deprecation-messaging)
    - [Guide](#guide)
    - [In-app](#in-app)
  - [Rollout](#rollout)
- [How we teach this](#how-we-teach-this)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
  - [Supply just `schema` instead of `capabilities`](#supply-just-schema-instead-of-capabilities)
  - [A new String-based API](#a-new-string-based-api)
  - [String-based API as “sugar”](#string-based-api-as-sugar)
  - [Object-based API](#object-based-api)
  - [Do nothing](#do-nothing)
- [Unresolved questions](#unresolved-questions)
- [Appendix: TypeScript](#appendix-typescript)
  - [TypeScript motivation](#typescript-motivation)
  - [Proposed type definitions](#proposed-type-definitions)

## Motivation

There are two primary motivations here: replacing the string-based microsyntax with an idiomatic JavaScript API, and making the API more amenable to correct types for TypeScript users.

### Microsyntax problems

The current design has worked well enough for a long time, but it adds conceptual overhead to learning how to use Ember. JavaScript has a lightweight and easy way of defining sets of related data: plain old JavaScript objects. By contrast, the existence of this Ember-specific microsyntax requires users to learn a new string-based syntax (which is *not* used elsewhere in the JavaScript community) and internalize how it works when they first encounter the registry APIs.

This need often comes relatively early in the learning process: the first time a user needs to write a unit test for a service. We currently devote [an entire section of the guides](https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-registrations) to explaining how factory registrations work, including a paragraph devoted to explaining the microsyntax. A normal JavaScript API would simplify this entire section.

Changing to a normal JavaScript-object-based API means tooling can provide in-editor benefits around autocompletion for the API, which is simply not possible for the microsyntax. Finally, a non-microsyntax API will be more amenable to future codemods if this should need to change in the future.

### TypeScript problems

For TypeScript users, the current API is not type-safe, and can be made so only with considerable extra work by developers and the Typed Ember maintainers. Blueprint maintenance and end users’ mental overhead associated with existing solutions for Ember’s stringly-typed APIs would effectively have to *double* to provide type safety for today’s registry APIs. For details, see [**Appendix: Typescript**](#appendix-typescript).

### Performance benefits?

Finally, there *may* be some very small performance wins here, since in this schema there is no need to parse a string. This is not considered to be a significant motivator, however, since the tradeoffs between object allocation (memory utilization) and string parsing (CPU utilization) are likely to be largely irrelevant in practice for this API.

## Detailed design

Every registry API will be updated to take a new `Identifier` type in place of the string microsyntax, while maintaining backwards compatibility by introducing versioning to the resolver. A codemod will be provided to allow users to migrate directly to the new API. The legacy resolver APIs are deprecated until Ember 4.0.

(TypeScript consumers should see [**Proposed Type Definitions**](#proposed-type-definitions) in the appendix for additional details on type safety and resolution.)

<i>**Note:** the diff views used throughout are meant to highlight the new APIs compared to the old, *not* to indicate the removal of the deprecated items. They will only be removed at Ember 4.0.</i>

### `Identifier` types

The core new type in the design of the API is an *identifier*, which is always passed as the first argument to resolver APIs. There are three kinds of identifiers: `FactoryIdentifier` and `FactoryTypeIdentifier` (discussed here), and `InjectionIdentifier` (discussed below in [**Session and Controller Injections**](#service-and-controller-injections)).

```ts
interface FactoryIdentifier {
  type: string;
  name: string;
  namespace?: string;
}
```

Here the `type` corresponds to the prefix component of the legacy API, and `name` to the postfix component of the legacy API: `service:foo` becomes `{ type: 'service', name: 'foo' }`.

The `namespace` field allows for identifiers to be restricted to a particular namespace, as in looking up a resolution from an addon. It is optional since it is not required in normal usage, as is the case in the microsyntax today, where it may be provided via a prefix and delimited with `@`: `<namespace>@<type>:<name>`. This also supports experimental tools which namespace lookups for addons (e.g. [ember-holy-futuristic-template-namespacing-batman](https://github.com/rwjblue/ember-holy-futuristic-template-namespacing-batman)).

We also introduce `FactoryTypeIdentifier` to distinguish between injections for *all factories of a given type* (`FactoryTypeIdentifier`) and *specific factories* (`Identifier`):

```ts
interface FactoryTypeIdentifier {
  type: string;
}
```

As is the case in the microsyntax-based design, these factory type injections may not be namespaced.

### `Resolver`

Ember’s `Resolver` function is public API, designed to be customized and overridden. To support backwards compatibility with existing custom resolvers, and following the lead of the [Custom Components RFC (#0213)](https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md#capabilities) and the [Element Modifiers RFC (#0373)](https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md#capabilities), we introduce a `capabilities` property to the `Resolver` API, which may be `undefined` or the return value of a new `capabilities` function, which defines a `Capabilities` type.

The `capabilities` function is a public export of the `@ember/application` module:

```ts
interface OptionalCapabilities {
  modulesBased?: boolean;
  disableMicrosyntax?: boolean;
}

export function capabilities(compatVersion: '3.18', capabilities?: OptionalCapabilities): unknown;
```

The return type of `capabilities` is `unknown` for public consumers; the actual return type is private API and should not be relied on by implementors of custom resolvers.

The `modulesBased` capability rationalizes the existing `moduleBasedResolver` property on the `Resolver` class, integrating it into the new `capabilities` API.

During the 3.x Ember series, if `capabilities` is `undefined`, the legacy behavior of the resolver is maintained. The signature of the `Resolver` type is therefore:

```ts
interface Resolver {
  capabilities?: Capabilities;
  resolve(identifier: string | FactoryIdentifier);
}
```

After Ember 4.0, the type a custom resolver must implement will be updated so that `capabilities` will be required and `resolve` will only accept a `FactoryIdentifier`:

```ts
interface Resolver {
  capabilities: Capabilities;
  resolve(identifier: FactoryIdentifier);
}
```

This design is completely backwards compatible: it continues working exactly as it does today. (See [**Detailed Design > Rollout**](#rollout) below for details.) Until 4.0, both apps and addons will be able to use the microsyntax-based API *or* the new identifier-based API. It also allows for clean interop for existing custom resolvers.

Besides the recent use of capabilities in the modifier and component managers, there is also some prior art for this kind of versioning applied to the resolver specifically: [a similar “stamp”](https://github.com/emberjs/ember.js/pull/9994) was used for accomodating different behaviors when using the modules-based resolver vs. not (back in 2014)!

### Owner APIs

The owner APIs all change to use `Identifier` (or `FactoryTypeIdentifier` as appropriate) instead of strings.

Throughout, for the purposes of registration lookup, we use deep object value equality, *not* object identity. This specifically applies to:

- `Owner.factoryFor`
- `Owner.lookup`
- `Owner.registerOptions`
- `Owner.registerOptionsForType`
- `Owner.registeredOption`
- `Owner.registeredOptions`
- `Owner.registeredOptionsForType`
- `Owner.resolveRegistration`

####  Options

Some `Owner` registry APIs take lookup or registration options. This RFC does not propose changing these options in any way, but their definitions are provided here for completeness:

```ts
export interface LookupOptions {
  singleton?: boolean;
  instantiate?: boolean;
}

interface RegisterOptions {
  singleton?: boolean;
  instantiate?: boolean;
}
```

#### `Factory` and `FactoryManager`

Some APIs refer to *factories* and *factory managers*. The API for these classes adds a new `identifier` field and deprecates the `fullName` and `normalizedName` fields:

```diff
 interface FactoryClass {
   positionalParams?: string | string[] | undefined | null;
 }

 interface Factory<T, C extends FactoryClass | object = FactoryClass> {
   class?: C;
-  fullName?: string; // DEPRECATED
-  normalizedName?: string; // DEPRECATED
+  identifier: FactoryIdentifier;
   create(props?: { [prop: string]: any }): T;
 }

 interface FactoryManager<T = object> {
   readonly class: Factory<T>;
-  readonly fullName?: string; // DEPRECATED
-  readonly normalizedName?: string; // DEPRECATED
+  identifier: FactoryIdentifier;
   create(props?: object): T;
 }
```

#### `Owner` API diff

```diff
 interface Owner {
-  factoryFor(fullName: string, options: LookupOptions): FactoryManager;
+  factoryFor(identifier: FactoryIdentifier, options: LookupOptions): FactoryManager;

-  hasRegistration(fullName: string): boolean;
+  hasRegistration(identifier: FactoryIdentifier): boolean;

-  inject(factoryNameOrType: string, property: string, injectionName: string): void;
+  inject(factory: FactoryIdentifier | FactoryTypeIdentifier, property: string, injection: FactoryIdentifier): void;

-  lookup(fullName: string, options?: LookupOptions): any;
+  lookup(identifier: FactoryIdentifier, options?: LookupOptions): any;

-  register(fullName: string, factory: any, options?: RegisterOptions): void;
+  register(identifier: FactoryIdentifier, factory: any, options?: RegisterOptions): any;

-  registerOptions(fullName: string, options: RegisterOptions): void;
+  registerOptions(identifier: FactoryIdentifier, options: RegisterOptions): any;

-  registerOptionsForType(fullName: string, options: RegisterOptions): void;
+  registerOptionsForType(identifier: FactoryTypeIdentifier, options: RegisterOptions): any;

-  registeredOption(fullName: string, optionName: string): RegisterOptions;
+  registeredOption(identifier: FactoryIdentifier, optionName: string): RegisterOptions;

-  registeredOptions(fullName: string): RegisterOptions;
+  registeredOptions(identifier: FactoryIdentifier): RegisterOptions;

-  registeredOptionsForType(type: string): RegisterOptions;
+  registeredOptionsForType(type: FactoryTypeIdentifier): RegisterOptions;

-  resolveRegistration(type: string): Factory;
+  resolveRegistration(identifier: FactoryIdentifier): Factory;

-  unregister(fullName: string): void;
+  unregister(identifier: FactoryIdentifier): void;
 }
```

### Service and Controller Injections

The other major examples of registry interactions are service and controller injections. This RFC proposes to normalize both to support the same identifier-based lookup as the `Owner` APIs.

We introduce an `InjectionIdentifier` type, representing the service or controller to be injected:

```ts
interface InjectionIdentifier {
  name: string;
  namespace?: string;
}
```

The `inject` (whether `as service` or `as controller`) function now accepts *either* a string representing the local injection name (sans namespace) *or* an `InjectionIdentifier`:

- **Service:**
    ```ts
    export function inject(name: string): Service;
    export function inject(identifier: InjectionIdentifier): Service;
    ```

- **Controller:**
    ```ts
    export function inject(name: string): Controller;
    export function inject(identifier: InjectionIdentifier): Controller;
    ```

The `'<namespace>@<name>'` form is deprecated and will be removed at 4.0. The no-argument form, and the name-only string form are still allowed. Users *may* invoke using `{ name: '<name>' }` but are not required to.

- **Good** (using services as an example):

    ```js
    import { inject as service } from '@ember/service';

    export default class Example {
      @service foo;

      @service('bar')
      barRenamed;

      @service({ name: 'quux' })
      quuxViaIdentifier;

      @service({ namespace: 'baz', name: 'neato' })
      neatoNamespaced;
    }
    ```

- **Deprecated:**

    ```js
    import { inject as service } from '@ember/service';

    export default class Example {
      @service('baz@neato') neatoNamespaced;
    }
    ```

### Codemod

All existing *static* microsyntax invocations can be straightforwardly migrated to the new syntax with a codemod. Some dynamic invocations will not be possible to migrate this way.

For example, this (in a test) is migrate-able:

```diff
- this.owner.lookup('service:session');
+ this.owner.lookup({ type: 'service', name: 'session' });
```

But this is not:

```js
function buildLookup(type, name) {
  return `${type}:${name}`;
}

this.owner.lookup(buildLookup('service', 'session'));
```

The majority of uses are likely to be codemoddable, but not *all* will.

### Deprecation messaging

#### Guide

> #### Deprecate registry string-based microsyntax
> ##### until: 4.0.0
> ##### id: ember-resolver.string-based-microsyntax
>
> Ember has historically supported a string-based microsyntax of the format `'<namespace>@<type>:<name>'` (where both `<namespace>@` and `:<name>` are optional) for registering, resolving, looking up, and injecting items into Ember’s dependency injection container. These have been replaced with an object-based API where each part of the registry identifier is named explicitly.
>
> You should replace calls using the string-based microsyntax with the new API. For example, these lookups in a test context:
>
> ```js
> this.owner.lookup('service:session');
> this.owner.register(
>   'shared@service:clipboard',
>   class Clipboard {
>     copyToClipboard(source) {/* no-op */}
>   }
> )
> this.owner.inject('controller', 'session', 'service:session');
> ```
>
> Should be changed to:
>
> ```js
> this.owner.lookup({ type: 'service', name: 'session' });
> this.owner.register(
>   { namespace: 'shared', type: 'service', name: 'clipboard' },
>   class Clipboard {
>     copyToClipboard(source) {/* no-op */}
>   }
> );
> this.owner.inject(
>   { type: 'controller' },
>   'session',
>   { type: 'service', name: 'session' }
> );
> ```

#### In-app

Invocation of v0 resolver APIs which require a `FactoryIdentifier` will trigger the following deprecation message (using `lookup` as an example):

> You invoked `Owner.lookup` with a `string` full name: `'<type>:<name>'`. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an object identifier: `{ type: '<type>', name: '<name>' }`.

Here, the message should substitute the *actual* passed type and name. For example, if the user tried to look up a service named `session` by invoking `lookup('service:session')` the deprecation will read:

> You invoked `Owner.lookup` with a string full name: `'service:session'`. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an identifier object: `{ type: 'service', name: 'session' }`.

If the user tried to look up a service named `session` from the `shared` namespace by invoking `lookup('shared@service:session')` the deprecation will read:

> You invoked `Owner.lookup` with a string full name: `'shared@service:session'`. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an identifier object: `{ namespace: 'shared', type: 'service', name: 'session' }`.

For methods which require a `FactoryTypeIdentifier`, the wording is adjusted appropriately:

> You invoked `Owner.lookup` with a string type name: `'service'`. This usage is deprecated and will be removed in Ember 4.0. Instead, pass a factory type identifier object: `{ type: 'service' }`.

Methods which support either `Identifier`s or `FactoryTypeIdentifier`s should display the appropriate variant of the message according to what the user actually supplied.

### Rollout

The rollout will be phased. For both Ember’s `Resolver` API and the default resolver supplied with `ember-resolver`:

- The new API will be introduced in a minor release as normal, *without* introducing the deprecation warning for the microsyntax-based design, and *including* the two codemods required for this API change: one for all Ember users, and one for TypeScript users (see [**Proposed Type Definitions**](#proposed-type-definitions) in the [**TypeScript Appendix**](#appendix-typescript) below.)

- After *at least* one minor version, the deprecation message will be introduced. This will give addons time to adopt the new API *before* their consumers start experience deprecation noise from addon usage.

For Ember only:

- We will supply a polyfill for the new behavior, supporting *at least* the current LTS. The behavior here can be polyfilled to many if not all existing LTS releases; we would likely limit this slightly, but would support *many* LTS releases.

## How we teach this

- **New concepts:** this RFC introduces the concept of an identifier through the `FactoryIdentifier`, `FactoryTypeIdentifier`, and `InjectionIdentifier` types. These define the arguments to the various registry functions. The basic shapes of these objects, and perhaps their names (as inline text like “factory identifier,” “factory type identifier,” and “injection identifier”) will need to be integrated into the guides and API docs. See also [**Unresolved Questions**](#unresolved-questions): there may be other names which work better.

- The existing documentation about dependency injection can unchanged apart from simplifications in certain key areas. Paragraphs explaining the microsyntax can be eliminated or simplified by showing the identifier object types. New Ember users will continue to benefit from the detailed introduction to the concepts in the guides, but will have one fewer concept to learn along the way.

- All instances of the API documentation will need to be updated to reflect the changes to their signatures.

- The deprecation message must be added to Ember’s deprecation page and tooling.

- For the duration of Ember 3.x releases, the Guides and API docs will need explanations of the previous, deprecated APIs. These explanations should be brief, focused on how to migrate away from them preferably via the supplied codemod, rather than diving into the details of how the legacy system worked.

## Drawbacks

- The existing APIs have served Ember well for a long time. Introducing any new change involves some risk, particularly in areas so core to how Ember behaves.

- The proposed API here deprioritizes brevity in favor of clarity, readability, maintainability, tooling support, and being “normal” JavaScript. `'service:session'` is many fewer characters to type than `{ type: 'service', name: 'session' }`. (While many people highly value brevity and we should avoid overly verbose APIs, long experience suggests that *reading* and *changing* are more important than *first writing* code.)

## Alternatives

### Supply just `schema` instead of `capabilities`

Instead of the manager-inspired `capabilities` API, we could implement a simpler design with simply supplies a `schemaVersion` (or just `schema`) property on the `Resolver` type. This is less flexible, but also simpler.

```ts
interface ResolverV0 {
  schemaVersion?: 0;
  resolve(fullName: string);
}
```

If `schemaVersion` is `1`, the `resolve` function has a new signature, using the `FactoryIdentifier` type introduced above:

```ts
interface ResolverV1 {
  schemaVersion: 1;
  resolve(identifier: FactoryIdentifier)
}
```

The public API is *either* of the Resolver variants:

```ts
type Resolver = ResolverV0 | ResolverV1;
```

The other registry API changes may also be implemented in terms of the new resolver `schemaVersion` check.

### A new String-based API

Instead of providing an object-based API, we could provide a new string-based API. The `lookup` method, then, would have a signature like this:

```ts
interface Owner {
  lookup(type: string, name: string, options: Options);
}
```

This has the advantage of being a smaller diff from today’s world, and cutting down on the extra typing of the new API design:

```diff
- lookup('service:foo')
+ lookup('service', 'foo')
```

vs.

```diff
- lookup('service:foo');
+ lookup({ type: 'service', name: 'foo' })
```

This is a less flexible proposal, and—more importantly—it has a significant downside for usability beyond the simplest case. Supporting namespaces here would require *another* string argument, and functions with multiple arguments of the same type are notoriously easy to misuse. (“Wait, what’s the order? Namespace first or type first? Does namespace come after type, or after name?” etc.)

### String-based API as “sugar”

While this RFC recommends the object-based API as the *primary* API, we could supply the string-based API outlined above for the simple and most common case, so that this—

```js
lookup('service', 'foo')
```

—would be equivalent to this:

```js
lookup({ type: 'service', name: 'foo'})
```

This could be nice from an ergonomics perspective, and introduces only a small amount of extra complexity in the implementation: the resolver `capabilities` key still allows the implementation to distinguish between the `lookup('<type>:<name>')` form and the `lookup(type, name)` form.

However, it does require introspection on the arguments passed to the functions (extra implementation overhead), and it comes with confusion and arguments about which form to use: should users prefer the string based version where it is possible, or default to the object version for consistency? It would also means changes (e.g. to introduce a namespace) would become large and more error prone. Finally, as with the alternative where this is the *only* API, it is still less explicit and clear; users have to *remember* that `type` precedes `name`, whereas the object-form eliminates that issue.

### Object-based API

Another brief syntax might use the type as the key and the name as its value:

```js
lookup({ service: 'foo' })
```

While this initially seems nice from the perspective of the consumer of the API, it muddies the API substantially and makes the implementation worse as well.

On the API front, for example, what would this mean?

```js
lookup({ service: 'foo', route: 'bar' });
```

The API proposed by the RFC avoids this confusing scenario entirely!

As far as implementation goes, this would be more complex and have much worse performance: the lookup would have to iterate over all keys on the object passed every time, mapping those keys to the *known* identifer interface and then checking the others against the registry. This also makes the TypeScript implementation considerably more difficult, for similar reasons to the runtime implementation, but at compile time. (Implementer concerns should not be *primary*, but they are important, and here they have performance implications that, while not dramatic, can easily be avoided by other proposals.)

### Do nothing

Leaving the API as it is remains an option, with both the upsides and downsides of the _status quo_.

## Unresolved questions

- Is `@ember/application` the appropriate home for the new exports? Or should they liver somewhere else, such as `@ember/resolver` or `@ember/application/resolver`?

- Is `FactoryIdentifier` the right name for the primary identifier interface? `Identifier` is shorter but overlaps with the notion of identifiers from Ember Data and is perhaps overly generic. We could use any of a number of other names:
    - `RegistrationIdentifier`
    - `RegistryIdentifier`
    - `FactoryId`
    - `RegistryId`
    - `RegistrationId`
    - etc.

- Similarly, is `FactoryTypeIdentifier` the correct name? Alternatives might be:
    - `FactoryRegistrationIdentifier`
    - `FactoryTypeRegistrationIdentifier`
    - `FactoryRegistryIdentifier`
    - `FactoryTypeRegistryIdentifier`
    - `FactoryIdentifier` (mutually exclusive with using it as a replacement for `Identifier`
    - `FactoryRegistryId`
    - `FactoryTypeRegistryId`
    - etc.

- Are `identifier` and `type` the right names for the arguments in the new design?

## Appendix: TypeScript

This design is motivated in part by a desire for the API to better support type-safe TypeScript usage. This appendix explains the motivation and design as it impacts the declarations maintained by the Typed Ember team. The big idea here is to make registry lookups type-safe, including support for autocomplete and refactoring, while not making the boilerplate situation *worse* (eliminating it entirely is unfortunately not yet possible).

### TypeScript motivation

The type definitions for Ember currently make use of a pattern we call a “type registry”: a mapping of *strings* to *types*. This allows the types to safely represent string-based lookups like `story.findRecord('some-model')` or `service('session')`.

For example, to make service lookups work with the classic API, users had to write something like this:

```ts
import Service from '@ember/service';

export default class Session extends Service {
  login(email: string, password: string) {
    // ...
  }

  logout() {
    // ...
  }
}

declare module '@ember/service' {
  interface Registry {
    session: Session;
  }
}
```

Then, users could write fairly idiomatic Ember and have the types resolve correctly:

```ts
import Component from '@ember/component';
import { inject as service } from '@ember/service';

export default Component.extend({
  session: service('session'), // type: `Session`
})
```

The Typed Ember blueprints generate that boilerplate for users, which (hopefully) minimizes the pain of working with these definitions. However, to make this work for the registry APIs, users (and therefore the blueprints) would have to add *another* declaration to the bottom of the file:

```diff
  import Service from '@ember/service';

  export default class Session extends Service {
    login(email: string, password: string) {
      // ...
    }

    logout() {
      // ...
    }
  }

  declare module '@ember/service' {
    interface Registry {
      session: Session;
    }
  }

+ declare module 'TBD-some-registry-spot' {
+   interface Registry {
+     'service:session': typeof Session;
+   }
+ }
```

This *works*, but is additional boilerplate and, more importantly, *duplication of information*, which can get out of sync. Both of these problems are avoided by the new design proposed by this RFC. With the new design, users would still need the same boilerplate required today, but the types for `lookup` and other registry APIs can be extended in a way transparent to users so that they “just work” with *zero* additional effort, as covered in the next section.

### Proposed type definitions

If we were to ship this, we would make one significant change to the *existing* types on DefinitelyTyped, supplying a codemod for ember-cli-typescript users. Where today, the various type registries refer to the class types, we would update them to refer to the *constructor* type for the class. For example, for the service registry:

```diff
 interface Registry {
-  session: Session;
+  session: typeof Session;
 }
```

This single change unlocks the ability to rigorously and exhaustively supply types for the API proposed above, with no further changes to existing user code.

We would introduce the following types at DefinitelyTyped for the new API, along with rigorous type tests to guarantee they provide the guarantees they specify. (A basic working demo of this is available on [this TypeScript playground][types-demo].)

**Note:** the injection types for service and controller are *slightly* simplified here to demonstrate how they work in practice; in fact they will include the appropriate `PropertyDecorator` semantics (as they do today).

```ts
// ----- type utilities ----- //

type ConstructorArgs<T> = T extends new (...args: infer U) => unknown ? U : never;

type InstanceOf<T> = T extends new (...args: any) => infer R ? R : never;

// ----- types to implement this RFC ----- //

// NOTE: some of these lookups will be newly defined as part of this
//       project, e.g. the registries for routes and components.
interface TypeRegistry {
  service: import('@ember/service').Registry;
  controller: import('@ember/controller').Registry;
  route: import('@ember/routing/route').Registry;
  component: import('@typed-ember/component').Registry;
  adapter: import('ember-data/types/registries/adapter').default;
  model: import('ember-data/types/registries/model').default;
  serializer: import('ember-data/types/registries/serializer').default;
  transform: import('ember-data/types/registries/transform').default;
}

interface FactoryIdentifier<
  Type extends keyof TypeRegistry,
  Name extends keyof TypeRegistry[Type]
> {
  type: Type;
  name: Name;
  namespace?: string;
}

interface FactoryTypeIdentifier<Type extends keyof TypeRegistry> {
  type: Type;
}

export interface LookupOptions {
  singleton?: boolean;
  instantiate?: boolean;
  source?: string;
  namespace?: string;
}

interface RegisterOptions {
  singleton?: boolean;
  instantiate?: boolean;
}

interface FactoryManager<Class> {
  class: Class;
  create(
    initialValues?: {
      [K in keyof InstanceOf<Class>]?: InstanceOf<Class>[K];
    }
  ): InstanceOf<Class>;
}

interface Factory<Class> {
  class: Class;
  create(
    initialValues?: {
      [K in keyof InstanceOf<Class>]?: InstanceOf<Class>[K];
    }
  ): InstanceOf<Class>;
}

interface Owner {
  factoryFor<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>,
    options?: LookupOptions
  ): FactoryManager<TypeRegistry[Type][Name]>;

  hasRegistration<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>
  ): boolean;

  inject<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    factory: FactoryIdentifier<Type, Name> | FactoryTypeIdentifier<Type>,
    property: string,
    injection: FactoryIdentifier<Type, Name>
  ): void;

  lookup<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>,
    options?: LookupOptions
  ): InstanceOf<TypeRegistry[Type][Name]>;

  register<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>,
    factory: any,
    options?: RegisterOptions
  ): void;

  registerOptions<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>,
    options: RegisterOptions
  ): void;

  registerOptionsForType<Type extends keyof TypeRegistry>(
    identifier: FactoryTypeIdentifier<Type>,
    options: RegisterOptions
  ): void;

  registeredOption<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type],
    OptionName extends keyof RegisterOptions
  >(
    identifier: FactoryIdentifier<Type, Name>,
    optionName: OptionName
  ): Pick<RegisterOptions, OptionName>;

  registeredOptions<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>
  ): RegisterOptions;

  registeredOptionsForType<Type extends keyof TypeRegistry>(
    type: FactoryTypeIdentifier<Type>
  ): RegisterOptions;

  resolveRegistration<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>
  ): Factory<TypeRegistry[Type][Name]>;

  unregister<
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  >(
    identifier: FactoryIdentifier<Type, Name>
  ): void;
}
```

[types-demo]: https://www.typescriptlang.org/play/index.html#code/PTAEFpM0BcE8AOBTUBXGBLANhzSDOEU4oIAUGfMqAMID2AdvjAE6oDGMdLAgiwOb4APABUAfKAC8oEaCQAPGEgYATQgyQB3UAAoAdAYCGA-AC5QGBgDMkLUAFUAlFImoGAawZ1NDUAH4HUHMNADdbAG4KKhQASSYYQwZ2JAB5K1EJaVkFJVV1LV0DPWNBc0S4Z0kJSxs7ACV-UAbgpDCWSLIQIihQBBYkcAUMZkt+UH7+YdY4WEQCUE1cAAtQQwQ+uj6MQyVQdiXE-nniEnIySyUWK0Nk0ABlWxCMZLqkSeYWGYBvMlBQfAI+AwjHM0ToVnugOBDEiAF8KBdbNdbvQGKw6FgsLZXu9pqAfn81ggcOwdtDQXNwaAeOsSWTGKj0ZiImR4ec0UibigRHMcVNPvjfv9Hs8kOYHiwni83vy4JE-uxGEysSxzIyWBiVXyPnLWRQuidZshCFwLABbYlIM3KGCwJbDJoAMRo3WgZ0RVy5oEdNy4nxiKhtGCsGFsQiFPOoOWUalA7iQcCpkaQ2umABohQA5QzWuSKGOEeOJiHJ1OfADayYAumQJASjWKZHN5aAGDnG9nrS229b8AguX5zB9RnCERzPbcfZxuHBkwGgyGw8m87lY0Wk7yZTq60LouZk6P2ZdkSgJVKkHEAFZITjQ+do4OhlhCTsoaN5OMJqln0VluA7v4ew7dtu3bPsByHVgRz1TowAUBBuCUFRVkIAADSxr04VC01bdtkNQgFJVFVDQCWWwUCsbg9kYMIGFDJIkDIQN2CwYwKLcW9GGFIjkhfdsVwLT9i0hHiUy3aYxB0IDzFfRxzDiZhEmSNIhB-aVcQrV8qzESJmNY-pQCsDjMC4wjzz43N3zXL8ITUsSNP-HQhQwQMH0XVURPPK8bxMhh70wdyLKQMQyDk0AFISBiVLsv9yy0nSx2PL11U1WxvM4vzXICp8goEj91whFLmRYP8ANw60ZJAoUgPA5JB3+KCGH4Q89LYwzjOhai0Q1YrcqswsbNoJUeq1cTPkk6TQFk+T4iU1J0iK0aHLi9ttN0m99PYpJfK65Uw1fPLrOExbsTGxznKyx9bDVYbUpYdLfP8q7n1fEKwoiuaVJOkqzpW601v1OD5AQlgkJQ0B0IYTCYGw8qkHwxVurukiyIMyi7ER2j6OSCh4MQixxxPUAABk6DodxUAQFIEF8wh6yBJqsS4Bh6oAIzJrFEhbSxFIfHYkDZjmkC5oV8DoVAWDqyCWGgwCwP7KWGplprDw9InU1sanacFP4Gf4JnGEFjFhZhZzZr5pQjc5022TVr0pz9OAAFlEkMI5nxoVj8HwMqWMMb21S9-AW3Yfp+acv4-ksXBtiwAA1QwsFQAh6vrSPQHLABpAmhKpD6ooWoOxCrer8+Uwv-Z9rOqxbP54T+d7zfLoRPcrhLbcJ+3fRnFui51vYg8DyuQ7DpQI8j6PMEThOk5T8w08jrOc4K8Km-m3u25Lmbeeb1vvbEava9AevQEbnf173n3Vc724Uh8Wx++RR3HW4cN0+Xfrc5LTcHIzdODs-ivUsv1qxCkkkKKOl13LmAdjOJ6gVkw4Ven-SOmxab1VJuTSmWtoT4CFGFWBnwXZtndqIH+spKxzCrH9JAAMhQHHwGWekDA36Rw-vmfKg1gG-wgVNfigCuHkJ1JQ5ANY-jgPTi5BcT4YHd39FAnKiC+HWhCg3cw7NjYizNtDVhfx2GrgGsJbhsoUF-AARwo6G5kCxVAeI8efwn4zlkdOeR0ilxzCQe2CQAAfb0cjZxzHgYouYYhTG9A1MgUGcBpajDCRhHy5I-EuLgEE9xyBPEqPweYEIdAXIdD+FgMmFMEC6KbFGCxhirH2RMbw8xBiv5lOqcI2xoAJETwUddJJjtUnPiUcg3haDcEYKKdgmmuCsmr3PipYxzSqE0LoX8CYUwwy8P0YJIBQj0y1P4RUhpMzpgiNoWA+xFgOkeUISks5ZD0nKOCmExxnwygMDgGEwZjB8D1Q1iwHB7yJk5LyRQRZ4lNZjPeaUtZnCjGbM+GEup6zBHWJAVQ45vCpFuRkV0uBVy+leNeaCpg5gvk-KYH83JKh8njGBd8-F+AX4sGTNct8uyNmIocm0yBbjzn+LnNikJeLaaEqpcSvBajQD-PJYCyluJyIqGJeCuYh1Knf1ZTU-+Oz6ksqaQc6sYTiVwshVSIlNKUWSLOc47pvKbn9PTm8hgr5zB6vbBMgACs8dwQgjW0xwo6lRFKlnMBlcK+V5SNUIq1TC7ZllmVhpsciuxqKzWYtceitJSAMnBQmZ63BfqqXw2FXShlELLHKvDeddOe4k0BOQD0xlqjT6CuldS2mOaxZYDCEw3ywamWhqhSqnUsL1Xwt7aWw5YjWknLRdlTpFya04syaKi5jLY2iPmQlIUbh-WXC7YqvZ0KXmRu7UOqpy6jnxtNZy81WLOWMvTXWsK4rDwGmIA2Qg6NQCBjNHQV0pxgAUD9t7SE3tOr1kRh8DgfodBbBCPzUA3gNAeTvvB5wXw2QFLoJMBgOhUCEXtUrWJvRK6aG4CoGJTUwrOo1GaYYSAhDirKkCmAEtfAUboFRgEeh+itrCDoL4aAcPthwv2b2RGWDIVhI4PQMAyKYZ0JUejkdQPGz0IU-gOgABE+AODJG9gAQjU44I+4mWyob47YVOvDsO2Fw8OFWQpYSHn-YQGkxJnjMO+v3VqBlP2BiwPPVswsuDqKFokY+LUNptSZrB++CHouREiwCIDjALlSCi-BvQDy4B0p4w2cwGmRTJDUzhSaeXEsMDU8fAzZBIsPFK5fFLCWgRJf8XoRzcWkC2ga9CAAmkgBAKWNDaBq41hgl8dBwdsJV+LUJGCZk2CgaQA3APDdGwZ0gYAAAkABRYGPlNssA1CwKr7XhSlc22aVmtgsAzGkJ1prySWujyQDx9dhF54Wf4xVUAan2aszU3Z1kEmVOWB0AAch+yDnCIOhP4BEyoEHlWyDjZYMpkZCBssVrU4jPaLBCtw1y5eYwrMsT4HK0ZtboAts7c4Htg7FAkccdzbK-F49eMY6xyNWwuPitEjpL5UnKC1M80ilPJQf2JNC8SCLpAHR6eFKwWj1ncxctmVFFz9syvptlYqyjjD6mfu47U9D2H+nIiy9R+jpXX32d3TV59tTPPXN8+195pAWBTfRYZ1x8NzCLfIFy9b4qtvGz29pI76EpOJOhwC09+sLvfP90AgFugoI2CMTrgDmXHu5fFN942EHAeVQQ7x6AEHDvSS+RBxVunHuN1Utzxr0SQeNelYjx0FXyRQe3YYPDyI7eY-F5B13yvRmyB9+y5NQfmui81QVnn-WdBWaJ2HwjgvthQdl+YT3sgq+WDj-VyXjfFeKuRB33vz7pfQ-l+hNP+WXJzCD9YwMZQGGkDL8iEAA


---

---
stage: recommended # FIXME: This may be a further stage
start-date: 2020-04-17T00:00:00.000Z
release-date: 2020-10-05T00:00:00.000Z
release-versions:
  ember-source: v3.22.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/615
project-link:
---

# Autotracking Memoization

## Summary

Provides a low-level primitive for memoizing the result of a function based on
autotracking, allowing users to create their own reactive systems that can
respond to changes in autotracked state.

```js
import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

let computeCount = 0;

class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  #fullName = createCache(() => {
    ++computeCount;
    return `${this.firstName} ${this.lastName}`;
  })

  get fullName() {
    return getValue(this.#fullName);
  }
}

let person = new Person();

console.log(person.fullName); // Jen Weber
console.log(count); // 1;
console.log(person.fullName); // Jen Weber
console.log(count); // 1;

person.firstName = 'Jennifer';

console.log(person.fullName); // Jennifer Weber
console.log(count); // 2;
```

## Motivation

Autotracking is the fundamental reactivity model within Ember Octane, and has
been highly successful so far in its usage and adoption. However, users today
can only integrate with autotracking via the `@tracked` decorator, which allows
them to _create_ tracked root state. There is no way to write code that responds
to changes in that root state directly - the only way to do so is indirectly via
Ember's templating layer.

An example of where users might want to do this is the [`@cached`](https://github.com/emberjs/rfcs/pull/566)
decorator for getters. This decorator only reruns its code when the tracked
state it accessed during its previous computation changes. Currently, it would
be quite difficult and error prone to build this decorator with public APIs.

For a more involved example, we can take a look at [ember-concurrency](http://ember-concurrency.com/),
which allows users to define async tasks. Ember Concurrency has an `observes()`
API for tasks, which allows tasks to rerun when a property changes. This API is
not documented or encouraged, and instead lifecycle hooks are recommended to
rerun tasks. However, in Octane, lifecycle hooks on components are no longer
available, removing that as an option. A more ergonomic, autotracked version of
concurrency tasks could be created if users had a way to react to changes in
autotracked state.

Data layers like Ember Data could also benefit from this capability. These
layers tend to have to keep state in sync between multiple levels of caching,
which traditionally was done with computed properties and eventing systems. The
ability to use autotracking to replace these systems, and to define their own
reactive semantics, could help complex libraries and data layers out immensely.

## Detailed design

This RFC proposes four functions to be added to Ember's public API:

```ts
interface Cache<T = unknown> {}

function createCache<T>(fn: () => T): Cache<T>;

function getValue<T>(cache: Cache<T>): T

function isConst(cache: Cache): boolean;
```

These functions are exposed as exports of the `@glimmer/tracking/primitives/cache`
module:

```ts
import {
  createCache,
  getValue,
  isCache,
  isConst,
} from '@glimmer/tracking/primitives/cache';
```

### Usage

`createCache` receives a function, and returns a cache instance for that function.
Users can call `getValue()` with the cache instance as an argument to run the
function and get the value of its output. The cache will then return the same
value whenever `getValue` is called again, until one of the tracked values that
was _consumed_ while it was running previously has been _dirtied_.

```ts
class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() => {
  // consume the state
  state.value;

  return ++computeCount;
});

getValue(counter); // 1
getValue(counter); // 1

state.value = 'foo';

getValue(counter); // 2
```

Getting the value of a cache also _consumes_ the cache. This means caches can be
nested, and whenever you use a cache inside of another cache, the outer cache
will dirty if the inner cache dirties.

```ts
let inner = createCache(() => { /* ... */ })

let outer = createCache(() => {
  /* ... */

  inner();
});
```

This can be used to break up different parts of a execution so that only the
pieces that changed are rerun.

### Constant Caches

Caches will only recompute if any of the tracked inputs that were consumed
previously change. If there _were_ no consumed tracked inputs, then they will
never recompute.

```ts
let computeCount = 0;

let counter = createCache(() => {
  return ++computeCount;
});

getValue(counter); // 1
getValue(counter); // 1
getValue(counter); // 1

// ...
```

When this happens, it often means that optimizations can be made in the code
surrounding the computation. For instance, in the Glimmer VM, we don't emit
updating bytecodes if we detect that a memoized function can never change, because
it means that this piece of DOM will never update.

In order to check if a memoized function is constant or not, users can use the
`isConst` function:

```ts
import { createCache, getValue, isConst } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() => {
  // consume the state
  state.value;

  return ++computeCount;
});


let constCounter = createCache(() => {
  return ++computeCount;
});

getValue(counter);
getValue(constCounter);

isConst(counter); // false
isConst(constCounter); // true
```

It is not possible to know whether or not a cache is constant before its
first usage, so `isConst` will throw an error if the cache has never been
accessed before.

```ts

let constCounter = createCache(() => {
  return count++;
});

isConst(constCounter); // throws an error, `constCounter` has not been used
```

This helps users avoid missing optimization opportunities by mistake, since most
optimizations happen on the first run only. If a user calls `isConst` on the
function prior to the first run, they may assume that the function is
non-constant on accident.

## How we teach this

This topic is one that is meant for advanced users and library authors. It
should be covered in detail in the Autotracking In-Depth guide in the Ember
guides.

This guide should cover how memoization works, and various techniques for using
memoization. It should cover a variety of ways to use memoization to accomplish
common tasks of other reactivity systems. Pull-based reactivity is unfamiliar to
many programmers, so we should try to familiarize them with as many common
examples as possible.

Some possibilities include:

- Building the `@cached` decorator from scratch.
- Building a data layer that syncs changes to models to localStorage or a
  backend in real time, as the changes occur (note: requires polling of some
  kind, or a component to do this).
- Building a `RemoteData` implementation, a helpful wrapper that sends a fetch
  request to a remote url and loads data whenever the url input changes.

### API Docs

#### `createCache`

Receives a function, and returns a wrapped version of it that memoizes based on
_autotracking_. The function will only rerun whenever any tracked values used
within it have changed. Otherwise, it will return the previous value.

```ts
import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() => {
  // consume the state. Now, `counter` will
  // only rerun if `state.value` changes.
  state.value;

  return ++computeCount;
});

getValue(counter); // 1

// returns the same value because no tracked state has changed
getValue(counter); // 1

state.value = 'foo';

// reruns because a tracked value used in the function has changed,
// incermenting the counter
getValue(counter); // 2
```

#### `getValue`

Gets the value of a cache created with `createCache`.

```ts
import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

let computeCount = 0;

let counter = createCache(() => {
  return ++computeCount;
});

getValue(counter); // 1
```

#### `isConst`

Can be used to check if a memoized function is _constant_. If no tracked state
was used while running a memoized function, it will never rerun, because nothing
can invalidate its result. `isConst` can be used to determine if a memoized
function is constant or not, in order to optimize code surrounding that
function.

```ts
import { tracked } from '@glimmer/tracking';
import { createCache, getValue, isConst } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() => {
  // consume the state
  state.value;

  return computeCount++;
});


let constCounter = createCache(() => {
  return computeCount++;
});

getValue(counter);
getValue(constCounter);

isConst(counter); // false
isConst(constCounter); // true
```

If called on a cache that hasn't been accessed yet, it will throw an
error. This is because there's no way to know if the function will be constant
or not yet, and so this helps prevent missing an optimization opportunity on
accident.

## Alternatives

- Stick with higher level APIs and don't expose the primitives. This could lead
  to an explosion of high level complexity, as Ember tries to provide every type
  of construct for users to use, rather than a low level primitive.

- Expose a more functional or more object-oriented API. This would be a somewhat
  higher level API than the one proposed here, which may be a bit more
  ergonomic, but also would be less flexible. Since this is a new primitive and
  we aren't sure what features it may need in the future, the current design
  keeps the implementation open and lets us experiment without foreclosing on a
  possible higher level design in the future.


---

---
stage: released
start-date: 2020-04-22T00:00:00.000Z
release-date: 2022-11-22T00:00:00.000Z
release-versions:
teams:
  - framework
  - data
  - cli
  - learning
  - typescript
  - steering
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/617'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/836'
  released: 'https://github.com/emberjs/rfcs/pull/862'
project-link:
---

# RFC Stages

## Summary

Ember's users should be able to look at an RFC and know more about how close it is to being part of a stable release. This proposal introduces explicit stages for RFCs, covering the steps from the initial draft to the shipped result. Inspired by TC39, these stages are a communication and collaboration tool. They can give the community greater visibility into Ember's development, encourage participation, and improve cross-team coordination. This RFC does not aim to substantially change the existing process, but rather apply labels to what already happens informally.

## Motivation

It can be difficult for both users and contributors of Ember to know the status of a new feature. Has it been approved? Is it a work in progress? What still needs to be done? Which version of Ember did it ship in?

We can see that stages are needed when we consider the following:

1. Community feedback that it was difficult to follow along with the progression of Ember Octane's features
2. Challenges uncovered in the existing RFC Tracking process
3. The long-standing, but stagnant goal of providing a public-facing status board
4. Confusion about what it means for an RFC to be merged. There is a common myth that a merged RFC indicates that a feature will be in the next release, when instead it is a green flag for implementation work to begin.

To understand the problem, it is helpful to think of the informal stages a merged RFC already can progress through: We have RFCs for which we have needed to indicate a change in direction ([MU](https://emberjs.github.io/rfcs/0143-module-unification.html)), RFCs that have needed to be clarified/replaced ([Named Blocks](https://emberjs.github.io/rfcs/0226-named-blocks.html)), RFCs waiting to be implemented, and RFCs whose features have been included in a stable release. Each of these scenarios was handled in a thoughtful manner, but they were difficult for users to follow along with.

This proposal aims to build on the success of RFC 300, [RFC (Request for Comments) Process Update]([https://github.com/emberjs/rfcs/blob/master/text/0300-rfc-process-update.md](https://github.com/emberjs/rfcs/blob/master/text/0300-rfc-process-update.md)).

## Detailed design

### Current Process

For details of the current RFC process, see the current [README of the RFCs repo](https://github.com/emberjs/rfcs/blob/2a7b9e8605a56277a4dd515bf8e192d9ac09c12f/README.md):

### Stages

A successful RFC can move through the following sequential stages. Whenever an RFC moves to the next stage, there is a PR to update it.

| Stage| Description| Requires FCP to enter? |
| -----| -----------|----- |
| [0 - Proposed](#Proposed) | A proposal for a change to Ember or its processes that is offered for community and team evaluation. | no |
| [1 - Exploring](#Exploring) | An RFC deemed worth pursuing but in need of refinement. | no |
| [2 - Accepted](#Accepted) | A fully specified RFC. Waiting for or in the process of implementation. | yes |
| [3 - Ready for Release](#Ready-for-Release) | The implementation of the RFC is complete, including learning materials. | yes |
| [4 - Released](#Released) | The work is published. If it is codebase-related work, it is in a stable version of the relevant package(s). | no |
| [5 - Recommended](#Recommended) | The feature/resource is recommended for general use. | yes |

There are two additional statuses for RFCs that will not move forward:

- **[Discontinued](#Discontinued)** - a previously Accepted RFC that is either in conflict with Ember's evolving programming model or is superseded by another active RFC.
- **[Closed](#Closed)** - Proposed RFCs that will not be moved into the next stage.

#### Proposed

Proposed RFCs are opened as pull requests to the RFC repository. Anybody may
create an RFC. The format should follow the templates in the RFC repository.
There is currently a default template and a deprecation RFC template. This
process is discussed in depth in the RFCs repo README.

An RFC's number is the number of it's original proposal PR.

From "Proposed" an RFC may move to [Exploring](#Exploring),
or [Closed](#Closed) stages.
To move to [Closed](#Closed) an FCP is required as in the existing process.
A "Proposed" RFC may be moved to "Exploring" by consensus of the relevant
team(s) without an FCP. See [Exploring](#Exploring).

#### Exploring

An Exploring RFC is one the Ember team believes should be pursued, but the RFC
may still need some more work, discussion, answers to open questions,
and/or a champion before it can move to the next stage.

An RFC is moved into Exploring with consensus of the relevant teams. The
relevant team expects to spend time helping to refine the proposal. The
RFC remains a PR and will have an `Exploring` label applied.

An Exploring RFC that is successfully completed can move to [Accepted](#Accepted)
with an FCP is required as in the existing process.

#### Accepted

An RFC that has been "accepted" has complete prose and has successfully passed
through an "FCP to Accept" period in which the community has weighed in and consensus
has been achieved on the direction. The relevant teams believe that the
proposal is well-specified and ready for implementation.
The RFC has a champion within one of the relevant teams.

This is equivalent to today's RFCs being merged.

If there are unanswered questions, we have outlined them and expect that they
will be answered before [Ready for Release](#Ready-for-Release).

When an RFC is merged and moved to "Accepted", a new PR will be opened to move
it to [Ready for Release](#Ready-for-Release). This PR should be used to track
the implementation progress and gain consensus to move to that next stage.

#### Ready for Release

The implementation is complete according to plan outlined in the RFC,
and is in harmony with any changes in Ember that have occurred since the RFC was first written.
This includes any necessary learning materials.
At this stage, features or deprecations may be available for use behind a feature flag,
or with an optional package, etc.
The team reviews the work to determine when it can be included in a stable release.
For codebase changes, there are no open questions that are anticipated to require
breaking changes; the Ember team is ready to commit to the stability of any
interfaces exposed by the current implementation of the feature.
Today, this would be the "go/no-go" decision by a particular team.

This stage should include a list of criteria for determining when the proposal
can be considered [Recommended](#Recommended) after being [Released](#Released).

A PR is opened on the repo (see [Accepted](#Accepted)) to move an accepted RFC
into this stage. An FCP is required to move into this stage.

Each Ember core team will be requested as a reviewer on the PR to move into this stage.
A representative of each team adds a review. If a team does not respond to the
request, and after the conclusion of the FCP, it is assumed that the release may proceed.

#### Released

The work is published. If it is codebase-related work, it is in a stable version
of the relevant package(s). If there are any critical deviations from the original RFC,
they are briefly noted at the top of the RFC.

If the work for an RFC is spread across multiple releases of Ember or other packages,
the RFC is considered to be in the Released stage when all features are available in
stable releases and those packages and versions are noted in the RFC frontmatter.

Ember's RFC process can be used for process and work plans that are not about code.
Some examples include Roadmap RFCs, this RFC itself, and changes to learning resources.
When such an RFC is a candidate for Released, the work should be shipped as described,
and the result should presented to the team with the intent of gathering feedback
about whether anything is missing. If there is agreement that the work is complete,
the RFC may be marked "Released" and a date is provided instead of a version.

An RFC is moved into "Released" when the above is verified by consensus of the
relevant team(s) via PR to update the stage.

#### Recommended

The "Recommended" stage is the final milestone for an RFC. It provides a signal
to the wider community to indicate that a feature has been put through its
ecosystem paces and is ready to use.

The "Recommended" stage is most important for suites of features that are designed
as a number of separate RFCs. It allows the Ember maintainers to stabilize individual
features once they are technically feature complete, an important goal for maintaining
technical velocity.

To reach the "Recommended" stage, the following should be true:

- If appropriate, the feature is integrated into the tutorial and the guides prose.
API documentation is polished and updates are carried through to other areas of
API docs that may not directly pertain to the feature.
- If the proposal replaces an existing feature, the addon ecosystem has largely
updated to work with both old and new features.
- If the proposal updates or replaces an existing feature, high-quality codemods are
available
- If needed, Ember debugging tools as well as popular IDE support have been
updated to support the feature.
- If the feature is part of a suite of features that were designed to work together
for best ergonomics, the other features are also ready to be "Recommended".
- Any criteria for "Recommended" for this proposal that were established in the
[Ready For Release](#Ready-for-Release) stage have been met.

An RFC is moved into "Recommended" via PR to update the stage. An FCP is required
to enter this stage. Multiple RFCs may be moved as a batch into "Recommended" with
the same PR.

#### Closed

A [Proposed](#Proposed) RFC may be closed after an FCP period. This is the same
as the existing process. A closed RFC is discontinued.

#### Discontinued

An previously [Accepted](#Accepted) RFC may be discontinued at any point. The RFC
may be superseded, out-of-date, or no longer consistent with the direction of
Ember.


### Editing merged RFCs

A merged RFC may be edited via a Pull Request process. Edits may include things like:

- Updating the stage
- An optional note at the top that summarizes minor adjustments to the RFC design, at the time that the RFC's work became available for general use. This note can be very brief, and link out to other resources like a blog post. For example, an update might simply say "See `<blog post>` for more information about this feature." This note is not intended to be updated across time.
- Updating any part of the RFC prose, in order to keep a written record of the changes and rationale.

Today, these types of changes do happen. We just don't write them down. So, merge criteria should be very loose.

Major changes should have a new RFC. The old RFC is later marked "Discontinued" when the replacement is merged.

### Changes to RFC meta

RFC meta ("frontmatter") is the block of text at the start of an RFC that includes data about its stage, links to relevant info, etc.

Before:

    - Start Date: (fill me in with today's date, YYYY-MM-DD)
    - Relevant Team(s): (fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies)
    - RFC PR: (after opening the RFC PR, update this with a link to it and update the file name)
    - Tracking: (leave this empty)

After:

    - Stage: Proposed (later updated to other stages)
    - Start Date: (fill me in with today's date, YYYY-MM-DD)
    - Release date: Unreleased (later update with YYYY-MM-DD)
    - Release Versions: (Include any package with work necessary for the feature, n/a for non-code RFCs)
      - ember-source: vX.Y.Z
      - ember-data: vX.Y.Z
    - Relevant Team(s): (fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies)
    - RFC PR: (after opening the Propsoal RFC PR, update this with a link to it and update the file name)

For RFCs that have moved through to at least the [Accepted](#Accepted) stage,
this data will be used to add and update a block at the top of the RFC prose to
indicate the current stage, with a brief explanation of that stage. It should
link to any open PRs to update the stage of the RFC.

We will make use of automation to add/update a section to the RFC with links to
each PR that caused the RFC to move to a new stage.

`Tracking` will be removed for new RFCs. Links that would have appeared here should
be found on the PR to move the RFC to [Ready for Release](#Ready-for-Release).

### Reconciling past RFCs

For codebase-related RFCs that have already been merged, the release version is only required to be added to RFCs whose implementation was released after February 1st, 2018 (near the release of Ember 3). This is to preserve the time and effort of our contributors and volunteers.

A stage will be applied to all previously merged RFCs.

### Non-code RFCs

The names of the stages make the most sense with RFCs that propose features in
Ember, with code that will follow a release process. For many non-code RFCs,
such as this one, those names, especially of later stages, may seem "off".
However, it is still  valuable to have a stage for every RFC where the teams and
community agree that the RFC has been implemented ([Ready for Release](#Ready-for-Release)) and a
stage where the community agree that the RFC has been polished ([Recommended](#Recommended)).
We may further refine this in a future RFC as we learn more.

## How we teach this

- The Stages section above will be added to the README of the RFCs repository.
- Frontmatter will be added to the template for new RFCs (see below)
- A blog post will announce the updates to the RFC process
- Past RFCs should be updated to include their stage and release version, following the description in "Reconciling past RFCs."
- We will use automation to add helpful links and guidance to the RFC files themselves.

### Stages as communication tool

Additionally, this RFC would unlock our ability to create a status board where everyone can easily see the progress of RFC. Today, if you need to know when an RFC feature was available in a stable release, you need to comb through release blog posts. Instead, we could use the frontmatter as data that powers the app. This app is not a requirement for this RFC, but rather an example of how we could use the information provided by stages.

### Non-goals

This RFC does not intend to:

- substantially alter the functional process for RFCs
- speed up the RFC process
- change the timing of when a feature is released
- exhaustively cover all steps and processes

## Case study

Here is how we could have applied this model to Tracked Properties, which was split across two RFCs: [#410](https://github.com/emberjs/rfcs/blob/master/text/0410-tracked-properties.md) and [#478](https://github.com/emberjs/rfcs/blob/master/text/0478-tracked-properties-updates.md).

### 0 - Proposed

A PR is opened to the RFCs repo for Tracked Properties. The framework team talks
about the RFC in the weekly meetings, and there's general agreement to pursue the
idea. The RFC moves to [Exploring](#Exploring). A label is added to the PR to
indicate that stage.

### 1 - Exploring

@pzuraq keeps adding details to the RFC, explores the design space, and
collaborates with others to get to the final design. The full story has been
thought out. @pzuraq expects to have the time resources to work on implementation.
There were no "known unknowns" questions. The RFC reaches consensus. The RFC
makes it through a week-long FCP process. The PR is merged and the stage
is now [Accepted](#Accepted).

### 2 - Accepted

@pzuraq works on implementation. The feature is enabled in canary under feature flag.
We learn that the feature causes a behavior regression in the interop story.
@pzuraq works out a new plan to accommodate interop, then opens a PR to update the RFC prose.

The implementation is complete. There are API docs. A PR is opened to move the proposal to
[Ready for Release](#Ready-for-Release). It includes a list of criteria required
for this feature to be [Recommended](#Recommended).
On the PR to move to [Ready for Release], each Ember team is requested as a reviewer.
Each team reviews the RFC and implementation, ensuring that any changes to the
projects they are responsible for have been completed and that the criteria for
[Recommended](#Recommended) also considers those areas. After a successful FCP
period, the PR is merged and the stage is now [Ready for Release](#Ready-for-Release).

### 3 - Ready for Release

The mechanics of releasing the feature proceed. The feature proceeds through
Ember.js' beta cycle. The next stable of Ember.js is released with the feature
available. The API docs are published. A PR to update the stage to [Released](#Released)
and the frontmater with release details is opened and merged with the consensus
of the framework team.

### 4 - Released

The feature is available for use by users of Ember.js. The learning team works to
carry through the concepts of 'Tracked Properties' to the tutorial and guides. Changes
to API doc examples are prepared. Other criteria for moving to Recommended are worked on, as defined
in the [Ready for Release](#Ready-for-Release) step. This work is documented on
a PR to move the proposal to [Recommended](#Recommended). This proposal, along with
several others, are PRed to move to Recommended at the same time,
as part of Octane around Ember.js 3.14. It is determined that the features are not
yet polished enough and criteria to get to Recommended has not yet
been met. More work proceeds and the features are again proposed as Recommended
and put into a "FCP for Recommended", it succeeds and the stages of several
proposals are updated to Recommended as part of the Octane Edition.

### 5 - Recommended

The feature is released and suggested for use by the wider Ember community. They
should encounter a polished feature that has ecosystem support. The feature should
be well represented in learning materials and the guides, tutorial and API docs
use the feature in a consistent manner.

How was the actual process different from the imaginary case study above? In reality, there were two separate RFCs needed to land the feature, and there were fewer opportunities for people to follow along, give input, and understand the status.

## Drawbacks

Making updates to past RFCs can generate a lot of  GitHub notifications for people who watch the repository. We think that the benefit of knowing when an RFC is available in a stable release outweighs this drawback. Additionally, in the future, if an app displays the frontmatter data, someone could use that as their main source of information. Lastly, the Ember Times does a great job curating RFC updates, so someone could watch it instead if the RFC repo itself has too much information.

## Alternatives/State of the Art

This section covers how other projects have handled this type of tracking, and how we have done it in the past.

### Vue

[Vue's stages](https://github.com/vuejs/rfcs#the-rfc-life-cycle) are concise and to the point. This is worth considering because you don't need to know the process deeply in order to understand it. The lower number of stages equates to less overhead, but also less fidelity.

- **Pending:** when the RFC is submitted as a PR.
- **Active:** when an RFC PR is merged and undergoing implementation.
- **Landed:** when an RFC's proposed changes are shipped in an actual release.
- **Rejected:** when an RFC PR is closed without being merged.

### TC39

TC39 is an interdisciplinary group that is responsible for determining the direction of JavaScript. Staged proposals are greatly inspired by their process and the success. The shorthand provided by stage names helps bring clarity in communication.

 [Their process](https://tc39.es/process-document/) is divided into five numbered stages:

0. Strawperson

1. Proposal
2. Draft
3. Candidate
4. Finished

This format is not exactly suited to Ember because stages 0-3 are what we already do. What we need to offer is more detail for stages 3-4. However, thanks to TC39, we can see how useful it would be to have clarity and a shared language around the status of a feature.

### Rust

The [Rust RFC lifecycle](https://github.com/rust-lang/rfcs#the-rfc-life-cycle) is very similar to Ember's, because ours was inspired by it. Following an FCP (Final Comment Period), an RFC is either merged, closed, or postponed. Merged RFCs are considered to be "active."

The concept of postponed RFCs is relevant to Ember's development, and possibly a good lesson to take:

- Some RFC pull requests are tagged with the "postponed" label when they are
closed (as part of the rejection process). An RFC closed with "postponed" is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
"postponed" was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.
- Usually an RFC pull request marked as "postponed" has already passed an
informal first round of evaluation, namely the round of "do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it." (When the answer to the latter question
is "no", then the appropriate response is to close the RFC, not postpone it.)

 As of the writing of this RFC, there are over [70 open pull requests](https://github.com/emberjs/rfcs/pulls) for Ember's RFCs. Having so many open PRs is confusing for everyone, yet simply closing many of these PRs would not reflect the reality of the wish to bring these good ideas into Ember.

Another aspect of Rust's process that is relevant is the idea of modification, which is already part of Ember's process, but not widely used:

- Modifications to "active" RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of the process means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of the next major release.

Many of Ember's merged RFCs are not implemented exactly as written. Once implementation is underway, new knowledge gained influences design. In other cases, implementation takes so long that some aspects of an RFC no longer apply. These decisions should be captured in writing as part of the process.

### Yarn and React

Both Yarn and React have adopted an RFC process similar to Ember and Rust.

You can see an example of updating a merged RFC in this [React RFC Pull Request](https://github.com/reactjs/rfcs/pull/52/files).

### Make no changes to existing process

Following RFC 300, the [RFC tracking issue repository](https://github.com/emberjs/rfc-tracking/issues?q=is%3Aopen+is%3Aissue) was created. This repository contained checklists that were meant to show the general, high-level requirements to ship an RFC in a stable release. Although the issues were helpful to learning resource writers, including the Learning Team, the Ember Times, and contributors, the tracking system did not provide much utility for our broader user community. Tracking issues were rarely updated.

Although it is still helpful to have a detailed view into the work being done, our community's greatest need is to show the overall status of an RFC's implementation in a consistent, reliable way. For this reason, it is necessary that we adopt RFC stages, and not stop at our current process.

## Unresolved questions

There are some ambiguities because RFCs take many forms. Our process cannot cover 100% of scenarios, but we should strive to find answers that cover the vast majority of RFCs.

## Glossary

- **FCP**: "final comment period" An FCP is an opportunity for the community and
core team members to weight in before an RFC moves a following stage.


---

---
stage: recommended
start-date: 2020-04-28T00:00:00.000Z
release-date: 2020-11-16T00:00:00.000Z
release-versions:
  ember-source: v3.23.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/625
project-link:
---

# Helper Managers

## Summary

Provides a low-level primitive for defining helpers.

## Motivation

Helpers are a valuable template construct in Ember. They have a number of
benefits that come from having their lifecycle being managed by the template and
container, including:

1. Behavior can be _self-contained_. Some APIs need to run at multiple points in
   time based on a template's lifecycle, such as for a plugin that needs to be setup
   on initialization and torn down upon destruction. Doing this in components
   via lifecycle hooks usually forces users to split their API across multiple
   touch points in a component, which requires a lot of boilerplate and can make
   it difficult to understand how the whole system works together. Helpers
   provide a way for these shared concerns to be contained in a single location.

2. It doesn't require _multiple inheritance_. Alternatives for sharing behaviors
   that touch multiple parts of the lifecycle such as mixins and strategies like
   them create complicated inheritance hierarchies that can be difficult to debug.
   Helpers do not insert themselves into the inheritance hierarchy of a class,
   they are children of the template instead, which is much easier to reason
   about in practice.

3. They are highly _composable_. Helpers, like components, can be used multiple
   times in a template and can be used within `{{if}}` and `{{each}}` blocks.
   Combined with their ability to be hold a self contained lifecycle, this makes
   them a powerful tool for composing declarative behavior.

4. They can be _destroyed_. They tie in naturally to the destruction APIs that
   we have recently added to Ember, and that allows their lifecycle to be
   managed in a self contained way.

Helpers are currently the only template construct in Ember that do not have a
low-level primitive that is public. With components and modifiers, users can define
component managers and modifier managers respectively to create their own high
level APIs, but for helpers the only option currently is to use the high level
`helper()` wrapper function, or the `Helper` base class.

These APIs are beginning to show their age in Ember Octane, and unlocking
experimentation via a helper manager would allow us to begin designing a new
generation of helpers. Some possible areas to explore here would include:

* Using a native base class for helpers, instead of `EmberObject`
* Adding lifecycle hooks, similar to modifiers, to class-based helpers
* Adding the ability to inject services to functional helpers
* Allowing normal functions to operate as helpers

In addition, it would allow us to begin adding new functionality to helpers via
manager capabilities. This RFC proposes one such capability, `hasScheduledEffect`.

### Effect Helpers

Usually, template helpers are supposed to return a value. However, if a helper
returns `undefined` and rendered in a template, it will produce no output. This
can be used to accomplish a _side-effect_:

```js
// app/helpers/title.js
export default helper(([title]) => {
  window.document.title = title;
});
```

```hbs
{{title "My Document Title"}}
```

Addons such as [ember-page-title](https://github.com/adopted-ember-addons/ember-page-title)
use this to make helpers that can be added to the template to specify
_app behavior_ declaratively. This is a much better way to approach certain
types of behavior and APIs, compared to the alternative of using mixins and
lifecycle hooks to manage them.

However, this pattern has some issues today, mostly stemming from the fact that
they execute _during_ render, which is not an ideal time for side-effecting.
They can also be abused to modify app state, which can lead to difficult to
follow code paths reminiscent of observers. These issues stem from a mismatch
between two different goals, the goal of calculating a result or value, and the
goal of triggering side-effects.

The `hasScheduledEffect` capability would schedule side-effecting helpers to execute
_after_ render, and would _disable_ Ember's state mutations while they were
running. This would ensure that side-effecting helpers run at the optimal time,
and do not enable antipatterns and complicated codepaths.

## Detailed design

This RFC proposes adding the `setHelperManager` and `capabilities` APIs,
imported from `@ember/helper`. Like `setComponentManager` and
`setModifierManager`, `setHelperManager` receives a callback that is passed
the owner, and returns an instance of the helper manager. When a helper
definition is resolved by Ember, it will look up the manager recursively on the
definition's prototype chain until it finds a helper manager. If it does not
find one, it will throw an error.

```ts
// object is used here to mean any valid WeakMap key
type HelperDefinition = object;

export declare function setHelperManager(
  factory: (owner: Owner) => HelperManager,
  definition: HelperDefinition
): HelperDefinition;
```

And like the `capabilities` functions for component and modifier managers, the
`capabilities` function for helper managers receives a version string as the
first parameter and a options object as the second with optional flags as
booleans. It produces an opaque `HelperCapabilities` object, which is assigned
to the helper manager.

```ts
interface HelperCapabilitiesOptions {
  hasValue?: boolean;
  hasDestroyable?: boolean;
  hasScheduledEffect?: boolean;
}

type HelperCapabilities = Opaque;

export declare function capabilities(
  // to be replaced with the version of Ember this lands in
  version: '3.21.0',
  options: HelperCapabilitiesOptions
): HelperCapabilities;
```

Helper managers themselves have the following interface:

```ts
interface HelperManager<HelperStateBucket> {
  capabilities: HelperCapabilities;

  createHelper(definition: HelperDefinition, args: TemplateArgs): HelperStateBucket;

  getValue?(bucket: HelperStateBucket): unknown;

  runEffect?(bucket: HelperStateBucket): void;

  getDestroyable?(bucket: HelperStateBucket): object;
}
```

Let's dig into these hooks one by one:

### Hooks

#### `createHelper`

`createHelper` is a required hook on the HelperManager interface. The hook is
passed the definition of the helper that is currently being created, and is
expected to return a _state bucket_. This state bucket is what represents the
current state of the helper, and will be passed to the other lifecycle hooks at
appropriate times. It is not necessarily related to the definition of the
helper itself - for instance, you could return an object _containing_ an
instance of the helper:

```js
class MyManager {
  createHelper(Definition, args) {
    return {
      instance: new Definition(args);
    };
  }
}
```

This allows the manager to store metadata that it doesn't want to expose to the
user.

This hook is _not_ autotracked - changes to tracked values used within this hook
will _not_ result in a call to any of the other lifecycle hooks. This is because
it is unclear what should happen if it invalidates, and rather than make a
decision at this point, the initial API is aiming to allow as much expressivity
as possible. This could change in the future with changes to capabilities and
their behaviors.

If users do want to autotrack some values used during construction, they can
either create the instance of the helper in `runEffect` or `getValue`, or they
can use the `cache` API to autotrack the `createHelper` hook themselves. This
provides maximum flexibility and expressiveness to manager authors.

This hook has the following timing semantics:

**Always**
- called as discovered during DOM construction
- called in definition order in the template

#### `getValue`

`getValue` is an optional hook that should return the value of the helper. This
is the value that is returned from the helper and passed into the template.

This hook is called when the value is requested from the helper (e.g. when the
template is rendering and the helper value is needed). The hook is autotracked,
and will rerun whenever any tracked values used inside of it are updated.
Otherwise it does not rerun.

> Note: This means that arguments which are not _consumed_ within the hook will
> not trigger updates.

This hook is only called for helpers with the `hasValue` capability enabled.
This hook has the following timing semantics:

**Always**
- called the first time the helper value is requested
- called after autotracked state has changed

**Never**
- called if the `hasValue` capability is disabled

#### `runEffect`

`runEffect` is an optional hook that should run the effect that the helper is
applying, setting it up or updating it.

This hook is scheduled to be called some time after render and prior to paint.
There is not a guaranteed, 1-to-1 relationship between a render pass and this
hook firing. For instance, multiple render passes could occur, and the hook may
only trigger once. It may also never trigger if it was dirtied in one render
pass and then destroyed in the next.

The hook is autotracked, and will rerun whenever any tracked values used inside
of it are updated. Otherwise it does not rerun.

The hook is also run during a time period where state mutations are _disabled_
in Ember. Any tracked state mutation will throw an error during this time,
including changes to tracked properties, changes made using `Ember.set`, updates
to computed properties, etc. This is meant to prevent infinite rerenders and
other antipatterns.

This hook is only called for helpers with the `hasScheduledEffect` capability
enabled. This hook is also not called in SSR currently, though this could be
added as a capability in the future. It has the following timing semantics:

**Always**
- called after the helper was first created, if the helper has not been
  destroyed since creation
- called after autotracked state has changed, if the helper has not been
  destroyed during render

**Never**
- called if the `hasScheduledEffect` capability is disabled
- called in SSR

#### `getDestroyable`

`getDestroyable` is an optional hook that users can use to register a
destroyable object for the helper. This destroyable will be registered to the
containing block or template parent, and will be destroyed when it is destroyed.
See the [Destroyables RFC](https://github.com/emberjs/rfcs/blob/master/text/0580-destroyables.md)
for more details.

`getDestroyable` is only called if the `hasDestroyable` capability is enabled.

This hook has the following timing semantics:

**Always**
- called immediately after the `createHelper` hook is called

**Never**
- called if the `hasDestroyable` capability is disabled

### Capabilities

There are three proposed capabilities for helper managers:

* `hasDestroyable`
* `hasValue`
* `hasScheduledEffect`

Out of these capabilities, one of `hasScheduledEffect` or `hasValue` _must_ be
enabled. The other must _not_ be enabled, meaning they are mutually exclusive.

#### `hasDestroyable`

- Default value: false

Determines if the helper has a destroyable to include in the destructor
hierarchy. If enabled, the `getDestroyable` hook will be called, and its result
will be associated with the destroyable parent block.

#### `hasValue`

- Default value: false

Determines if the helper has a value which can be used externally. The helper's
`getValue` hook will be run whenever the value of the helper is accessed if this
capability is enabled.

#### `hasScheduledEffect`

- Default value: false

Determines if the helper has a scheduled effect. If enabled, the helper's
`runEffect` hook will run after render, and will not allow any type of state
mutation when running.

### Scheduled Helpers Timing

Scheduled helpers run their effects after render, and after modifiers have been
applied for a given render, but before paint. The exact timing may shift around,
and may or may not correspond to a single rendering pass in cases where there
are multiple rendering passes in a single paint.

In the future different timings may be added as options for scheduling. For
instance, a timing to call the effect using `requestIdleCallback`, when the
browser has finished rendering and handling higher priority work, could be
added. However, this is out of scope for this RFC.

## How we teach this

Helper managers are a low-level construct that is generally only meant to be
used by experts and addon authors. As such, it will only be taught through API
documentation. In addition, for precision and clarity, the API docs will include
snippets of TypeScript interfaces where appropriate.

### API Docs

#### `setHelperManager`

Sets the helper manager for an object or function.

```js
setHelperManager((owner) => new ClassHelperManager(owner), Helper)
```

When a value is used as a helper in a template, the helper manager is looked up
on the object by walking up its prototype chain and finding the first helper
manager. This manager then receives the value and can create and manage an
instance of a helper from it. This provides a layer of indirection that allows
users to design high-level helper APIs, without Ember needing to worry about the
details. High-level APIs can be experimented with and iterated on while the
core of Ember helpers remains stable, and new APIs can be introduced gradually
over time to existing code bases.

`setHelperManager` receives two arguments:

1. A factory function, which receives the `owner` and returns an instance of a
   helper manager.
2. A helper definition, which is the object or function to associate the factory function with.

The first time the object is looked up, the factory function will be called to
create the helper manager. It will be cached, and in subsequent lookups the
cached helper manager will be used instead.

Only one helper manager is guaranteed to exist per `owner` and per usage of
`setHelperManager`, so many helpers will end up using the same instance of the
helper manager. As such, you should only store state that is related to the
manager itself. If you want to store state specific to a particular helper
definition, you should assign a unique helper manager to that helper. In
general, most managers should either be stateless, or only have the `owner` they
were created with as state.

Helper managers must fulfill the following interface (This example uses
[TypeScript interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)
for precision, you do not need to write helper managers using TypeScript):

```ts
interface HelperManager<HelperStateBucket> {
  capabilities: HelperCapabilities;

  createHelper(definition: HelperDefinition, args: TemplateArgs): HelperStateBucket;

  getValue?(bucket: HelperStateBucket): unknown;

  runEffect?(bucket: HelperStateBucket): void;

  getDestroyable?(bucket: HelperStateBucket): object;
}
```

The capabilities property _must_ be provided using the `capabilities()` function
imported from the same module as `setHelperManager`:

```js
import { capabilities } from '@ember/helper';

class MyHelperManager {
  capabilities = capabilities('3.21.0', { hasValue: true });

  // ...snip...
}
```

Below is a description of each of the methods on the interface and their
functions.

> The remaining API docs should be copied from the descriptions in the Detailed
> Design section of this RFC.

#### `capabilities`

`capabilities` returns a capabilities configuration which can be used to modify
the behavior of the manager. Manager capabilities _must_ be provided using the
`capabilities` function, as the underlying implementation can change over time.

The first argument to capabilities is a version string, which is the version of
Ember that the capabilities were defined in. Ember can add new versions at any
time, and these may have entirely different behaviors, but it will not remove
old versions until the next major version.

```js
capabilities('3.x');
```

The second argument is an object of capabilities and boolean values indicating
whether they are enabled or disabled.

```js
capabilities('3.x', {
  hasValue: true,
  hasDestructor: true,
});
```

If no value is specified, then the default value will be used.

##### `3.x` capabilities

> The remaining API docs should be copied from the descriptions in the Detailed
> Design section of this RFC. 3.x above should be replaced with the version that
> helper managers are initially released in.

## Drawbacks

- Adds a layer of indirection to helpers, which could add to complexity and
  cost in terms of performance. This isn't likely, as we haven't seen this
  happen with other managers we've introduced.

## Alternatives

- We could continue using the current helper APIs, and try to incrementally
  migrate them to only use native classes. This wouldn't match the strategy
  we've taken with other template constructs, like components and modifiers, and
  would result in less ability for the community to experiment and less
  flexibility if we chose to change helpers again in the future.

- The `hasScheduledEffect` capability could be broken out into a separate RFC.
  It is mostly separable, except for the impact it has on `getValue`. Value-less
  and effect-less helpers don't really make sense, so in isolation `getValue`
  would probably not be an optional hook, and the `hasValue` capability wouldn't
  exist.

  Capabilities can change from version to version, so this is still not a major
  issue, but it seems like it would be easier to add from the get go.

## Appendix

### Implementation of Current Helper APIs

The following is an implementation of the current helper APIs using this manager
API. There are two separate managers, one for class based helpers and one for
functional helpers:

```js
import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { setHelperManager, capabilities } from '@ember/helper';

const RECOMPUTE = symbol();

export class Helper extends EmberObject {
  @tracked [RECOMPUTE];

  constructor(...args) {
    super(...args);

    registerDestructor(this, () => this.destroy());
  }

  recompute() {
    // update the value to force a recompute
    this[RECOMPUTED] = undefined;
  }
}

class ClassHelperManager {
  capabilities = capabilities({
    hasValue: true,
    hasDestroyable: true,
  });

  ownerInjection = {};

  constructor(owner) {
    setOwner(this.ownerInjection, owner);
  }

  createHelper(Definition, args) {
    let helper = Definition.create(this.ownerInjection);

    return { helper, args };
  }

  getValue({ helper, args }) {
    // Consume the RECOMPUTE tag, so if anyone ever
    // calls recompute() it'll force a recompute
    helper[RECOMPUTE];

    return helper.compute(args.positional, args.named);
  }

  getDestroyable({ helper }) {
    return helper;
  }
}

setHelperManager((owner) => new ClassHelperManager(owner), Helper.prototype);
```

```js
import { tracked } from '@glimmer/tracking';
import { setHelperManager, capabilities } from '@ember/helper';

class FunctionalHelperManager {
  capabilities = capabilities({
    hasValue: true,
  });

  createHelper(fn, args) {
    return { fn, args };
  }

  getValue({ fn, args }) {
    return fn(args.positional, args.named);
  }
}

const FUNCTIONAL_HELPER_MANAGER = () => new FunctionalHelperManager();

export function helper(fn) {
  setHelperManager(FUNCTIONAL_HELPER_MANAGER, fn);

  return fn;
}
```

### Implementation of Ember Page Title using Effects

This adapts the [ember-page-title](https://adopted-ember-addons.github.io/ember-page-title/)
addon to use the implementation proposed in this RFC. The biggest change to the
public API is that using `push` and `remove` directly schedules updates to the
title, so they can in theory be made public. The scheduling could also be moved
back to the helper itself to avoid that issue, this just cleans it up.

```js
// ember-page-title/addon/services/page-title-list

import Service, { inject as service } from '@ember/service';
import { getOwner } from '@ember/application';
import { scheduleOnce } from '@ember/run';

export default class PageTitleListService extends Service {
  @service headData;

  tokens = [];

  /**
    The default separator to use between tokens.
    @property defaultSeparator
    @default ' | '
   */
  defaultSeparator = ' | ';

  /**
    The default prepend value to use.
    @property defaultPrepend
    @default true
   */
  defaultPrepend = true;

  /**
    The default replace value to use.
    @property defaultReplace
    @default null
   */
  defaultReplace = null;

  constructor(owner) {
    super(owner);
    this._removeExistingTitleTag();

    let config = getOwner(this).resolveRegistration('config:environment');
    if (config.pageTitle) {
      ['separator', 'prepend', 'replace'].forEach((key) => {
        if (isPresent(config.pageTitle[key])) {
          set(this, `default${capitalize(key)}`, config.pageTitle[key]);
        }
      });
    }
  }

  applyTokenDefaults(token) {
    let {
      defaultSeparator,
      defaultPrepend,
      defaultReplace,
    } = this

    if (token.separator == null) {
      token.separator = defaultSeparator;
    }

    if (token.prepend == null && defaultPrepend != null) {
      token.prepend = defaultPrepend;
    }

    if (token.replace == null && defaultReplace != null) {
      token.replace = defaultReplace;
    }
  }

  inheritFromPrevious(token) {
    let { previous } = token;

    if (previous) {
      if (token.separator == null) {
        token.separator = previous.separator;
      }

      if (token.prepend == null) {
        token.prepend = previous.prepend;
      }
    }
  }

  push(token) {
    let { tokens } = this;
    let tokenForIdIndex = tokens.findIndex(({ id }), token.id === id);

    if (tokenForIdIndex) {
      let tokenForId = tokens[tokenForIdIndex];
      let { previous, next } = tokenForId;

      token.previous = previous;
      token.next = next;

      this.inheritFromPrevious(token);
      this.applyTokenDefaults(token);

      tokens.splice(tokenForIdIndex, 1, token);
      return;
    }

    let previous = tokens.slice(-1)[0];
    if (previous) {
      token.previous = previous;
      previous.next = token;
      this.inheritFromPrevious(token);
    }

    this.applyTokenDefaults(token);

    tokens.push(token);

    scheduleOnce('actions', this, this.updateTitle);
  }

  remove(id) {
    let { tokens } = this;

    let tokenIndex = tokens.findIndex(({ id }), token.id === id);
    let token = tokens[tokenIndex];
    let { next, previous } = token;

    if (next) {
      next.previous = previous;
    }

    if (previous) {
      previous.next = next;
    }

    token.previous = token.next = null;
    tokens.splice(tokenIndex, 1);

    scheduleOnce('actions', this, this.updateTitle);
  }

  updateTitle() {
    if (this.isDestroying || this.isDestroyed) return;

    this.headData.set('title', this.toString());
  }

  get visibleTokens() {
    let { tokens } = this;

    let replaceIndex = tokens.length;

    while (replaceIndex--) {
      if (tokens[replaceIndex].replace) {
        break;
      }
    }

    return tokens.slice(replaceIndex - 1);
  }

  get sortedTokens() {
    let visible = this.visibleTokens;
    let appending = true;
    let group = [];
    let groups = [group];
    let frontGroups = [];
    visible.forEach((token) => {
      if (token.front) {
        frontGroups.unshift(token);
      } else if (token.prepend) {
        if (appending) {
          appending = false;
          group = [];
          groups.push(group);
        }
        let lastToken = group[0];
        if (lastToken) {
          token = copy(token);
          token.separator = lastToken.separator;
        }
        group.unshift(token);
      } else {
        if (!appending) {
          appending = true;
          group = [];
          groups.push(group);
        }
        group.push(token);
      }
    });

    return frontGroups.concat(
      groups.reduce((E, group) => E.concat(group), [])
    );


  }

  toString() {
    let tokens = this.sortedTokens;

    return tokens
      .filter(token => Boolean(token.title))
      .map((token, index) => {
        if (index + 1 < tokens.length) {
          return token.title + token.separator;
        }

        return token.title;
      })
      .join('');
  }

  /**
   * Remove any existing title tags from the head.
   * @private
   */
  _removeExistingTitleTag() {
    if (this._hasFastboot()) {
      return;
    }

    let titles = document.getElementsByTagName('title');
    for (let i = 0; i < titles.length; i++) {
      let title = titles[i];
      title.parentNode.removeChild(title);
    }
  }

  _hasFastboot() {
    return !!getOwner(this).lookup('service:fastboot');
  }
}
```

```js
// ember-page-title/addons/helpers/title

import { setOwner } from '@ember/application';
import { inject as service } from '@ember/service';
import { setHelperManager, capabilities } from '@ember/helper';

class TitleHelperManager {
  capabilities = capabilities('3.21', {
    hasScheduledEffect: true,
  });

  constructor(owner) {
    this.owner = owner;
  }

  createHelper(Title, args) {
    return new Title(this.owner, args);
  }

  runEffect(instance) {
    instance.update();
  }

  getDestroyable({ instance }) {
    registerDestructor(instance, () => instance.teardown());

    return instance;
  }
}


export default class Title {
  @service pageTitleList;

  constructor(owner, args) {
    setOwner(this, owner);
    this.args = args;
    this.pageTitleList.push({ id: guidFor(this) });
  }

  update() {
    let token = assign({}, this.args.named, {
      id: guidFor(this),
      title: this.args.positional.join(''),
    });

    this.pageTitleList.push(token);
  },

  teardown() {
    this.pageTitleList.remove(guidFor(this));
  }
}

setHelperManager((owner) => new EffectHelperManager(owner), Title);
```

```hbs
{{title "Blog"}}
```


---

---
stage: recommended
start-date: 2020-04-30T00:00:00.000Z
release-date: 2020-11-16T00:00:00.000Z
release-versions:
  ember-source: v3.23.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/626
project-link:
---

# JavaScript Helper Invocation API

## Summary

This RFC proposes a new API, `invokeHelper`, which can be used to invoke a
helper definition, creating an instance of the helper in JavaScript.

```js
// app/components/data-loader.js
import Component from '@glimmer/component';
import Helper from '@ember/component/helper';
import { invokeHelper } from '@ember/helper';

class PlusOneHelper extends Helper {
  compute([number]) {
    return number + 1;
  }
}

export default class PlusOneComponent extends Component {
  plusOne = invokeHelper(this, PlusOneHelper, () => {
    return {
      positional: [this.args.number],
    };
  });
}
```
```hbs
{{this.plusOne.value}}
```

## Motivation

As Ember has evolved, the framework has been developing a model of reactive,
incremental computation. This model is oriented around _templates_, which map
data and JavaScript business logic into HTML that is displayed to the user.

On the first render, this mapping is fairly similar to standard programming
languages. You can imagine that every component is like a _function call_,
receiving arguments and data, processing it, and placing it within its own
template, ultimately producing HTML as the "return value" of the component.
Components can use other components, much like functions can call other
functions, resulting in a tree structure of nested components, which is
the application. At the root of our application is a single "main" component
(similar to the main function in many programming languages) which takes
arguments and returns the full HTML of the initial render.

Where Ember's programming model really begins to differ is in _subsequent_
renders. Rather than re-running the entire program whenever something changes,
producing new HTML as a result, Ember incrementally re-runs the portions of the
program which have changed. It knows about these portions via its change
tracking mechanism, _autotracking_.

This means fundamentally that the tree of components differs from a tree of
functions because components can _live longer_. They exist until the portion of
the program that they belong to has been removed by an incremental update, and
as such, they have a _lifecycle_. Unlike a function, a component can _update_
over time, and will be _destroyed_ at some unknown point in the future.

Components previously exposed this lifecycle directly via a number of
lifeycle hooks, making components the smallest _atom_ for reactive composition.
This presented an issue for composability in general. In the world of functions,
a piece of code can always be broken out into a new function, giving the user
the ability to extract repeated functionality, abstracting common patterns and
concepts and reducing brittleness. For instance, in the following example we
extract several portions of the `myProgram` function to make it clearer what
each section is doing, and isolate its behavior.

```js
// before
function myProgram(data = []) {
  for (let item of data) {
    // ...
  }

  let values = data.map(() => {
    // ...
  });

  while (values.length) {
    let value = values.pop();
    // ...
  }
}
```
```js
// after
function initialProcessing(data) {
  for (let item of data) {
    // ...
  }
}

function extractValues(data) {
  return data.map(() => {
    // ...
  });
}

function processValues(values) {
  while (values.length) {
    let value = values.pop();
    // ...
  }
}

function myProgram(data = []) {
  initialProcessing(data);

  let values = extractValues(data);

  processValues(values);
}
```

Since components are the smallest reactive atom, there often is not a way to do this
transparently, since the only portions of the code that are reactive are the
component hooks themselves. This results in related code being spread across
multiple locations, with the user being forced to keep the relationships between
these bits of code in their head at all times, and understand the interactions
between them.

Consider this search component, which updates performs a cancellable fetch
request and updates the document title whenever the search query is updated:

```js
import Component from '@ember/component';
import { fetch, cancelFetch } from 'fetch-with-cancel';

export default class Search extends Component {
  // Args
  query = '';

  @tracked data;

  didReceiveAttrs() {
    // Update the document title
    document.title = `Search Result for "${this.query}"`;

    // Cancel the previous fetch if it's still running
    cancelFetch(this.promise);

    // create a new fetch request, and set the data property to the response
    this.promise = fetch(`www.example.com/search?query=${this.query}`)
      .then((response) => response.json());
      .then((data) => this.data = data);
  }

  willDestroy() {
    cancelFetch(this.promise);
  }
}
```

This component mixes two separate concerns in its lifecycle hooks - fetching the
data, and updating the document title. We can extract these into utility
functions in some isolated cases, but it becomes difficult when functionality
covers multiple parts of the lifecycle, like with the fetch logic here:

```js
import Component from '@ember/component';
import { fetch, cancelFetch } from 'fetch-with-cancel';

function updateDocumentTitle(title) {
  document.title = title;
}

function updateFetch(url, callback, previousPromise) {
  // Cancel the previous fetch if it's still running
  cancelFetch(previousPromise);

  // create a new fetch request, and set the data property to the response
  return fetch(url)
    .then((response) => response.json());
    .then((data) => callback(data));
}

function teardownFetch(promise) {
  cancelFetch(promise);
}

export default class Search extends Component {
  // Args
  query = '';

  @tracked data;

  didReceiveAttrs() {
    updateDocumentTitle(`Search Result for "${this.query}"`)

    this.promise = updateFetch(
      `www.example.com/search?query=${this.query}`,
      (data) => this.data = data,
      this.promise
    );
  }

  willDestroy() {
    teardownFetch(this.promise);
  }
}
```

We can see here that we needed to add two separate helper functions to extract
the data fetching functionality, one to handle updating the fetch, and one to
handle tearing it down, because those different pieces of code need to run at
different portions of the component lifecycle. If we want to reuse these
functions elsewhere, this adds a lot of boilerplate to integrate the functions
in each lifecycle hook.

There are a few alternatives that would allow us to extract this functionality
together.

1. We could use mixins, since they allow us to specify multiple functions and
   mix them into a class. Mixins however introduce a lot of complexity in the
   inheritance hierarchy and are considered an antipattern, so this is not a
   good choice overall.

2. We could extract the functionality out to separate components. Components
   have a contained lifecycle, so they can manage any piece of functionality
   completely in isolation. This works nicely for the document title, but adds
   a lot of complexity for the data fetching, since we need to yield the data
   back out via the template:

    ```js
    // app/components/doc-title.js
    import Component from '@ember/component';

    export default class DocTitle extends Component {
      didReceiveAttrs() {
        document.title = this.title;
      }
    }
    ```
    ```js
    // app/components/fetch-data.js
    import Component from '@ember/component';
    import { fetch, cancelFetch } from 'fetch-with-cancel';

    export default class FetchData extends Component {
      @tracked data;

      didReceiveAttrs() {
        // Cancel the previous fetch if it's still running
        cancelFetch(this.promise);

        // create a new fetch request, and set the data property to the response
        this.promise = fetch(this.url)
          .then((response) => response.json());
          .then((data) => this.data = data);
      }

      willDestroy() {
        cancelFetch(this.promise);
      }
    }
    ```
    ```hbs
    <!-- app/components/fetch-data.hbs -->
    {{yield this.data}}
    ```
    ```hbs
    <!-- app/components/search.hbs -->
    <DocTitle @title='Search Result for "{{@query}}"'/>

    <FetchData @url="www.example.com/search?query={{@query}}" as |data|>
      ...
    </FetchData>
    ```

   This structure is also not ideal because the components aren't being used for
   templating, they're just being used for logic effectively.

3. We could use other template constructs, such as helpers or modifiers. Both
   helpers and modifiers have lifecycles, like components, and can be used to
   contain functionality. Modifiers aren't really a good choice here though,
   because it would require us to add an element that we don't need. So, helpers
   are the better option.

   Helpers work, but like components they require us to move some of our logic
   into the template, even if that isn't really necessary:

    ```js
    // app/helpers/doc-title.js
    import { helper } from '@ember/component/helper';

    export default helper(([title]) => {
      document.title = title;
    });
    ```
    ```js
    // app/helpers/fetch-data.js
    import Helper from '@ember/component/helper';
    import { fetch, cancelFetch } from 'fetch-with-cancel';

    export default class FetchData extends Helper {
      @tracked data;

      compute([url]) {
        if (this._url !== url) {
          this.url = url;

          // Cancel the previous fetch if it's still running
          cancelFetch(this.promise);

          // create a new fetch request, and set the data property to the response
          this.promise = fetch(url)
            .then((response) => response.json());
            .then((data) => this.data = data);
        }

        return this.data;
      }

      willDestroy() {
        cancelFetch(this.promise);
      }
    }
    ```
    ```hbs
    <!-- app/components/search.hbs -->
    {{doc-title 'Search Result for "{{@query}}"'}}

    {{#let (fetch-data "www.example.com/search?query={{@query}}") as |data|}}
      ...
    {{/let}}
    ```

Out of these options, helpers are the closest to what we want - they produce
computed values directly without a template, and with the recent addition of
effect helpers they can be used side-effect to accomplish tasks like setting the
document title. The only downside is that they can only be invoked in templates,
so they require you to design your components around using them in templates
only. This can be difficult to do in many cases, where the data wants to be
accessed to create derived state for instance.

This RFC proposes adding a way to create helpers within JavaScript directly,
extending the reactive model in a way that allows users to extract common
reactive code and patterns, and reuse them transparently. This will make helpers
the new reactive atom of the system - the reactive equivalent of a "function" in
our incremental model. Like components, they have a lifecycle, and can update
over time. Unlike components, they can exist nested in JavaScript classes _and_
in templates, and they can produce any type of value, making them much more
flexible.

```js
// app/components/search.js
import Component from '@ember/component';

export default class Search extends Component {
  data = invokeHelper(this, FetchData, () => {
    return {
      positional: [`www.example.com/search?query=${this.query}`],
    };
  });

  constructor() {
    super(...arguments);

    invokeHelper(this, DocTitle, () => {
      return {
        positional: [`Search Result for "${this.query}"`],
      };
    });
  }
}
```

Note how the concerns are completely separated in this version of the component.
The polling logic is self contained, and separated from the data fetching logic.
Both sets of logic are able to contain their lifecycles, updating based on
changes to tracked state, and tearing down when the program destroys them. In
the future, convenience APIs can be added to make invoking them easier to read:

```js
export default class Search extends Component {
  @use data = fetchData(() => `www.example.com/search?query=${this.query}`);

  constructor() {
    super(...arguments);

    use(this, docTitle(() => `Search Result for "${this.query}"`));
  }
}
```

## Detailed design

This RFC proposes adding the `invokeHelper` function, imported from
`@ember/helper`. The function will have the following interface (using
TypeScript types for brevity and clarity):

```ts
interface TemplateArgs {
  positional?: unknown[],
  named?: Record<string, unknown>
}

type HelperDefinition<T = unknown> = object;

function invokeHelper<T = unknown>(
  parentDestroyable: object,
  definition: HelperDefinition<T>,
  computeArgs?: (context: object) => TemplateArgs
): Cache<T>;
```

Let's step through the arguments to the function one by one:

#### `parentDestroyable`

This is the parent for the helper definition. The helper will be associated as a
destroyable to this parent context, using the [destroyables API](https://github.com/emberjs/rfcs/blob/master/text/0580-destroyables.md),
so that its lifecycle is tied to the parent. The only requirement of the parent
is that it is an object of some kind that can be destroyed. If the parent has an
owner, this owner will also be passed to the helper manager that it is invoked on.

This allows helper's lifecycles to be entangled correctly with the parent, and
encourages users to ensure they've properly handled the lifecycle of their
helper.

#### `definition`

This is the helper definition. It can be any object, with the only requirement
being that a helper manager has been associated with it via the
[`setHelperManager` API](https://github.com/emberjs/rfcs/blob/master/text/0625-helper-managers.md#detailed-design).

#### `computeArgs`

This is an optional function that produces the arguments to the helper. The
function receives the parent context as an argument, and must return an object
with a `positional` property that is an array and/or a `named` property that is
an object.

This getter function will be _autotracked_ when it is run, so the process of
retrieving the arguments is autotracked. If any of the values used to create the
arguments object change, the helper will be updated, just like in templates.

### Return Value

The function returns a Cache instance, as defined in the [Autotracking Memoization RFC](https://github.com/emberjs/rfcs/blob/master/text/0615-autotracking-memoization.md#detailed-design).
This cache returns the most recent value of the helper, and will update whenever
the helper updates. Users can access the value using the `getValue` function for
caches.

If the helper has a scheduled effect, using `getValue` on the cache will not run
it eagerly. It will run as scheduled, until the helper is destroyed.

The cache will be also be destroyable, so that using `destroy()` from the
destroyables API on it will trigger its destruction early. Users can do this to
clean up a helper before the parent context is destroyed.

### Effect Helper Timing Semantics

Standard helpers that return a value will only be updated when they are used,
either in JavaScript or in the template. The args getter and the relevant helper
manager lifecycle hooks will be called when the `value` property on the helper
is used.

Side-effecting helpers, by contrast, run their updates specifically when
scheduled. When introduced by the Helper Manager RFC, there was no relative
ordering specified in the scheduling of side-effecting helpers, because there
was no way for them to have _children_, and we don't generally specify ordering
of siblings. With this RFC, it will be possible to invoke a side-effecting
helper within another side-effecting helper, so they will be able to have
children for the first time.

This RFC proposes modifying the Helper Manager RFC to specify that the
`runEffect` hook of a helper always runs _after_ the `runEffect` hooks of its
children. This mirrors the timing semantics of modifier hooks in templates.

### Ergonomics

This is a low-level API for invoking helpers and creating instances. The API is
meant to be functional, but not particularly readable or ergonomic. This API can
be wrapped with higher level, more ergonomic APIs in the ecosystem, until we're
sure what the final API should be.

## How we teach this

This API is meant to be a low-level primitive which will eventually be replaced
with higher level wrappers, possibly decorators, that will be much easier to use
and recommend to average app developers. As such, it will only be taught through
API documentation.

Once community addons are built with higher level APIs that are more ergonomic,
we should also add a section in the guides that uses them to demonstrate
techniques for using helpers in JS. This strategy is similar to how modifiers
are documented today.

### API Docs

#### `invokeHelper`

The `invokeHelper` function can be used to create a helper instance in
JavaScript.

```js
// app/components/data-loader.js
import Component from '@glimmer/component';
import Helper from '@ember/component/helper';
import { invokeHelper } from '@ember/helper';

class PlusOneHelper extends Helper {
  compute([num]) {
    return number + 1;
  }
}

export default class PlusOneComponent extends Component {
  plusOne = invokeHelper(this, PlusOneHelper, () => {
    return {
      positional: [this.args.number],
    };
  });
}
```
```hbs
{{this.plusOne.value}}
```

It receives three arguments:

* `context`: The parent context of the helper. When the parent is torn down and
  removed, the helper will be as well.
* `definition`: The definition of the helper.
* `computeArgs`: An optional function that produces the arguments to the helper.
  The function receives the parent context as an argument, and must return an
  object with a `positional` property that is an array and/or a `named`
  property that is an object.

And it returns a Cache instance that contains the most recent value of the
helper. You can access the helper using `getValue()` like any other cache. The
cache is also destroyable, and using the `destroy()` function on it will cause
the helper to be torn down.

Note that using `getValue()` on helpers that have scheduled effects will not
trigger the effect early. Effects will continue to run at their scheduled time.

## Drawbacks

- Additional API surface complexity. There will be additional ways to use
  helpers that we will have to teach users about in general. This is true, but
  given it helps to solve a lot of common problems that users have in Octane it
  should be worthwhile.

- This API is a primitive that is not particularly ergonomic or user friendly,
  but this is part of the point. It gets the job done, and can be built on top
  of to create a better high level API.

## Alternatives

- The [`@use` and Resources RFC](https://github.com/emberjs/rfcs/pull/567)
  proposes a higher level approach to this problem space, but had a number of
  concerns and drawbacks. After much discussion, we decided that it would be
  better to ship the primitives to build something like it in user-space, and
  prove out the ideas in it.


---

---
stage: recommended
start-date: 2020-05-18T00:00:00.000Z
release-date: 2021-01-05T00:00:00.000Z
release-versions:
  ember-cli: v3.24.0

teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/628
project-link:
---

# Add Prettier

## Summary

This RFC proposes adding [Prettier](https://prettier.io/) to the blueprints
that back `ember new` and `ember addon`.

## Motivation

Using Prettier removes the ever present and ongoing stylistic debates that tend
to happen on teams. Prettier is incredibly freeing for both developers **and**
reviewers of a codebase. The developer can author in whatever format they find
easiest to type out, avoiding needless wasted time trying to get that
indentation _just_ right, and either setup an automated "format on save"
operation in their editor or use a quick command line invocation to `--fix` all
files at once.

This dove tails very nicely with Embers deeply ingrained goal of using shared
solutions to solve common problems, and aligns very well with the general trend
to play better with the general JavaScript ecosystem.

## Detailed design

Due to the pre-existing design (and improvements added to the blueprints in
[ember-cli/rfcs#121](https://github.com/emberjs/rfcs/blob/master/text/0121-remove-ember-cli-eslint.md))
implementation is very straight forward. The general idea is that we will
update the `app` and `addon` blueprints to add a few Prettier related packages
to the `package.json`, update the linting configuration to enforce Prettier
styles, and update the other blueprint code to ensure that its output is
Prettier compatible.

### Packages

The following packages will be added to the `package.json` of both `app` and `addon` blueprints:

* [prettier](https://www.npmjs.com/package/prettier) - The main package (used by the other packages).
* [eslint-config-prettier](https://www.npmjs.com/package/eslint-config-prettier) - Disables stylistic ESLint rules that would conflict with the Prettier output.
* [eslint-plugin-prettier](https://www.npmjs.com/package/eslint-plugin-prettier) - Enables `eslint-config-prettier`s `recommended` set, and adds the `prettier/prettier` rule to enforce styles.

### Configuration Changes

#### ESLint

The `.eslintrc.js` that is generated will be updated to add:

```js
{
  extends: ['plugin:prettier/recommended'],
}
```

#### Prettier

A `.prettierrc.js` will be added with the following contents:

```js
module.exports = {
  singleQuote: true,
};
```

There is a [small number of configuration
options](https://prettier.io/docs/en/options.html) that can be used in this
file, but we are intentionally avoiding modifying the default values for things
that are not _nearly_ universally agreed on in the Ember ecosystem.

A `.prettierignore` will be added to match the `.eslintignore` contents:

```
# unconventional js
/blueprints/*/files/
/vendor/

# compiled output
/dist/
/tmp/

# dependencies
/bower_components/
/node_modules/

# misc
/coverage/
!.*

# ember-try
/.node_modules.ember-try/
/bower.json.ember-try
/package.json.ember-try
```

#### Git

The `.gitignore` will be updated to add `.eslintcache` so that when using
`eslint --cache` the cache file itself won't be added to the repositories
history.

### Blueprint Changes

In general, it is recommended that all blueprints provided by addons should
satisfy the default linting configuration of a new Ember application. As such
the blueprints provided by `ember-cli`, `ember-source`, and `ember-data` will
be updated to ensure that they satisfy these new linting rules requirements.

In order to ensure blueprint output follows each individual projects custom
stylistic linting settings as much as possible. The following will be updated
to run `lint:fix` (when available) after their existing functionality:

* `ember generate`
* `ember init`
* `ember-cli-update`

#### `package.json` scripts

The `app` and `addon` blueprints will be updated to add the following
additional entries to `scripts`:

```json
{
  "scripts": {
    "lint": "npm-run-all --aggregate-output --continue-on-error --parallel 'lint:!(fix)'",
    "lint:fix": "npm-run-all --aggregate-output --continue-on-error --parallel lint:*:fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "lint:hbs:fix": "ember-template-lint . --fix"
  }
}
```

A few callouts here:

* The `lint:fix`, `lint:js:fix`, `lint:hbs:fix` scripts are new (introduced with this RFC)
* The `lint` script will be updated to ensure that it avoids running the new `lint:fix` script
* The `lint:js` script will be updated to add caching

This configuration is specifically intending to allow users to add additional
linters (e.g. `stylelint` or `markdownlint`) by adding scripts for them, and
they would automatically be rolled up into `lint:fix`.

### Codemod

In order to make the migration as simple as possible, a codemod will be created: `ember-cli-prettier-codemod`.

The codemod will do the following:

* Install the new/required dependencies
* Migrate an application / addon to the new linting configuration
* Commit _just_ the configuration changes.
* Run the new `lint:fix` script to update all files to the new format.
* Commit just the auto-fixed output.

While this seems quite simple (and in fact it is pretty easy), leveraging a
codemod will make it much easier to deal with rebasing large Prettier migration
pull requests. If one of those pull requests gets out of date (e.g. due to a
conflict in one of the files) you can simply re-run the codemod on the branch
and it will replace the previously created commits.

## How we teach this

We do not currently discuss linting or stylistic formatting in either guides.emberjs.com or cli.emberjs.com.

This RFC proposes adding a new subsection that discusses linting under [`Basic
Use` section of the CLI guides](https://cli.emberjs.com/release/basic-use/). In
addition, when this RFC is implemented we should do a throughough audit of the
`cli.emberjs.com` and `guides.emberjs.com` content to ensure that all code
snippets are formatted correctly (e.g. using the Prettier specific formatting
introduced here).

## Drawbacks

> The largest drawback is generally the cost of the _initial_ migration to Prettier. That migration tends to be quick, but it can cause pain for folks maintaining long lived branches.

## Alternatives

> Why not adopt [standard](https://standardjs.com/) instead of Prettier?

Prettier is **much** more popular with [9,249,847 weekly
downloads](https://www.npmjs.com/package/prettier) vs [265,658 weekly
downloads](https://www.npmjs.com/package/standard) (we all know these download
numbers don't mean a ton, but the order of magnitude can tell us something),
and (aside from the defaulting of `singleQuotes`) is much more aligned with the
Ember ecosystems inherent preferences.

Additionally, a very large number of the Ember ecosystem
projects are _already_ using Prettier internally. These include `ember-source`,
`ember-cli`, `ember-data`, `@ember/test-helpers`, `eslint-plugin-ember`, the
various packages composing the rendering engine, `@glimmer/component`,
`ember-template-lint`, and many more. Additionally a large number of community
maintained addons are also using it already ([here is a
listing](https://emberobserver.com/code-search?codeQuery=prettier&fileFilter=package.json&sort=score&sortAscending=false)
using EmberObservers awesome code search feature).

## Unresolved questions

> In general, users of `yarn` could be perfectly happy with `yarn lint:js --fix` / `yarn lint:hbs --fix` (which works today). Should we still add the `lint:js:fix`/`lint:hbs:fix` scripts?

I went with "yes" here in the initial RFC prose, as I'd general prefer to _reduce_ the differences between users of `npm` and `yarn` over time.


---

---
stage: recommended
start-date: 2020-05-23T00:00:00.000Z
release-date: 2021-12-28T00:00:00.000Z
release-versions:
  ember-source: v4.1.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/631'
  recommended: 'https://github.com/emberjs/rfcs/pull/913'
project-link:
---

# RouterService#refresh

## Summary

Add a refresh method to the router service that calls refresh on all currently active routes,
or refreshes the descendents of the active route referred to by the pivot route name provided as an argument.

## Motivation

We want to be able to call refresh on all currently active routes, or a subset of them,
from a centralized service or from a component.
As a side benefit, we will be able to do this without relying on the send api,
which is being discussed as a possible deprecation in
[RFC 632](https://github.com/emberjs/rfcs/pull/632).
This enables us to get the latest data from the model hook.

## Detailed design

The following pseudocode represents the overall technical design of this method.
This code implementation is not normative.

```js
class RouterService {
    refresh(pivotRouteName?: string): Transition {
        let pivotRoute = pivotRouteName && lookupRoute(pivotRouteName);
        assert("If an argument provided must be the name of an active route", !pivotRouteName || isActiveRoute(pivotRoute));
        return this._router._routerMicroLib.refresh(pivotRoute);
    }
}
```

where *lookupRoute* gets the route specified by the pivotRouteName,
and *isActiveRoute* determines if the specified route is active.
The method optionally takes the route name that will, along with its descendents, be refreshed.
The method will return a promise that resolves when the refresh is complete.

## How we teach this

The following documentation will be added to the method:

```js
/**
 * Refreshes all currently active routes, doing a full transition.
 * If a pivotRouteName is provided and refers to a currently active route,
 * it will refresh only that route and its descendents.
 * Returns a promise that will be resolved once the refresh is complete.
 * All resetController, beforeModel, model, afterModel, redirect, and setupController
 * hooks will be called again. You will get new data from the model hook.
 *
 * @method refresh
 * @param {String} [pivotRouteName] the route to refresh (along with all child routes)
 * @return Transition
 * @public
 */
```

## Drawbacks

This is a slight increase in API surface area.

## Alternatives

We could provide a direct link to the current route via the router service. However,
this would encourage people to use routes to store information and provide methods
that should be idiomatically placed in a service.


---

---
stage: released # FIXME: This may be recommended
start-date: 2020-05-29T00:00:00.000Z
release-date: 2020-09-01T00:00:00.000Z
release-versions:
  ember-cli: v3.21.0

teams:
  - cli
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/635
project-link:
meta:
  authors: Joseph Sumner, Ava Wroten, Jamie White, Melanie Sumner
---

# Ember New Lang

## Summary

This RFC introduces the `--lang` flag as an option for `ember new`, `ember init`, and `ember addon` commands within the Ember CLI. The feature targets the ember-cli build process -- specifically, when generating the file for the application's entry point at `app/index.html`. If the flag is used with a valid language code, it will assign the `lang` attribute in the file's root `<html>` element to that code. The `lang` attribute is [formally defined within the current HTML5 specification](https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes); it is used to specify the base human language of an element or a document in a way that can be programmatically understood by assistive technology.

## Motivation

The overall motivation for this RFC is the viewpoint that brand-new Ember apps should not immediately fail [global legal conformance requirements](https://www.lflegal.com/2013/05/gaad-legal/#International-Laws-Regulations-and-Treaties-Impacting-Digital-Accessibility-Partial-Listing) as they pertain to digital accessibility.

The solution presented in this RFC offers the first stage of a resolution to one of the issues documented in the framework's [list of long-standing Technical Accessibility Issues for New Ember Apps](https://github.com/emberjs/rfcs/issues/595) -- specifically, *“Missing default language declaration”* (Section #4). Note: acceptance or implementation of this RFC does not implicitly or explicitly endorse any related RFCs that are related to this issue.

This RFC and its proposed approach have both been developed within the Ember.js Accessibility Strike Team with the explicit objective of helping to ensure that Ember applications achieve [WCAG Success Criterion 3.1.1: Language of Page](https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html) from the moment they are created. The state of the `lang` attribute has a usability impact on the experience of users that require screen-reading assistive technology. When the attribute is properly assigned:

> "Both assistive technologies and conventional user agents can render text more accurately when the language of the Web page is identified. Screen readers can load the correct pronunciation rules. Visual browsers can display characters and scripts correctly. Media players can show captions correctly. **As a result, users with disabilities will be better able to understand the content.**"
>
> **Source: [WCAG Success Criterion 3.1.1: Intent](https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html#intent)**

When the language of the page cannot be identified, the integrity of the above information cannot be guaranteed.
Consider the following use case:

- the application developer is unaware that Ember now includes the lang attribute
- the application does not require internationalization
- the application's content is in a language that is not English
- an end-user with a screen reader turned on, whose operating system (OS) is set to a different language, navigates to that page with their screen reader turned on
- the screen reader would attempt to read the page in the language that is defined by the lang attribute on the page, but the supporting element information ("button", "link", etc) is read out in the language that is set by the operating system.

### Testing it out
To see what happens when this information does not match, we created a new Ember application and created four buttons:

```html
<button type="button">Click Me</button>
<button type="button">点击我</button>
<button type="button">Haz click en mi</button>
<button type="button">Нажми на меня</button>
```

#### No Language Defined

If no lang attribute is set for the page or the parts:

- the screen reader defaults to the operating system (OS) language
- it reads Spanish in an English accent, and the button element was also still read in English
- for the Chinese and Russian letters, it spelled out the letters (i.e., "Cyrillic Letter E")

#### Language Defined

We then changed the lang attribute value and listened to these buttons in Chinese(zh), Spanish(es) and Russian(ru). Here's what happened:

- in each case, the announcer's voice changed for the content
- since the OS was set to English, the supporting element information that the assistive tech (AT) announces was in the OS language (English)
- when set to Chinese, the AT read the English, Chinese and Spanish well enough to understand, but did not read out the Russian; likewise, Russian behaved similarly (read all of them except the Chinese)

We then tested what happens if the `lang` attribute was explicitly defined on each of the buttons with the app language set to English:

```html
<button type="button">Click Me</button>
<button type="button" lang="zh">点击我</button>
<button type="button" lang="es">Haz click en mi</button>
<button type="button" lang="ru">Нажми на меня</button>
```

Each were read correctly by AT in their respective languages, followed with the word "button" in the OS language (English).

In this context, it is the users of screen readers, braille translation software, and similar assitive technologies for whom valid page language specifications provide the greatest improvements to user experience and technical operation. It is, however, extremely important to note that that although digital accessibility concerns are the primary motivators for developing formalized page language specifications, achieving WCAG SC-3.1.1 should certainly be considered a global application improvement. The following list contains application use cases that all benefit from having a valid page language specified, but are not strictly tied to digital accessibility requirements or assistive technology:

- Captions with synchronized media (such as video subtitles)
- Correct dictionary lookups for translations
- Assisting search engines
- Improving typography in certain situations

Accordingly, while the primary motivation of this RFC is to address an unresolved digital accessibility issue in Ember, it is expected that a successful implementation of the proposed `--lang` flag solution will provide additional, non-accessibility-related improvements to the baseline quality of new Ember applications.

## Detailed design

Link to [candidate implementation](https://github.com/josephdsumner/ember-cli/compare/master...ember-new-lang-base).

We have explicitly chosen `--lang` as the flag (vs `--language`) for consistency with the HTML attribute itself.

```bash
ember new my-app --lang en-US
# -l is also a valid alias
```

The above ember-cli command will result in the following `index.html` header change.

```html
<html lang="en-US">
```

The flag is added to relevant ember-cli help commands, such as the following:

```bash
ember help new
ember new <app-name> <options...>
  ...
  --lang (String) (Default: "") Sets the base human language of the application via index.html
    alias: -l <value>
```

### Misusage and Error Handling


Broadly, incorrect usage of the `--lang` flag covers three use-case categories:

- The flag has been specified with a programming language as the argument
- The flag has been specified with no argument
- The flag has been specified with an invalid language code

This RFC proposes that these cases cause the build process to halt with a revelant error and help message as opposed to simply reverting to the default value and reporting a message. **The rationale for the recommendation to halt instead of just report is that in these all of these cases, the user has explicitly typed `--lang` into their CLI tool. This is an unambiguous declaration of intent by the user to use the `--lang` flag correctly.**



#### Invalid Language Codes

Language codes are verified against [is-language-code](https://www.npmjs.com/package/is-language-code). (see [examples of valid ISO country codes](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes))

If an invalid language code is given such as `--lang en-UK` the indended output should be a shell error that will halt the build.

```bash
ember new my-app --lang en-UK
Unrecognized language subtag, "uk".
```

#### No argument passed
Additionally, if the `--lang` flag is used but no argument is defined, e.g., `ember new my-app --lang`, the build will also be halted. An error message and usage info should be shown in these cases:

```bash
# Detect trailing option (declared)
ember new my-app --lang --skip-git

An error with the `--lang` flag returned the following message:
  Detected lang specification starting with command flag `-`.
  Is `--skip-git` meant to be an ember-cli command option?
  This issue is likely caused by using the `--lang` flag without a specification.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember <command> help` for more information.
```

```bash
# Detect trailing option (undeclared)
ember new my-app --lang

An error with the `--lang` flag returned the following message:
  Detected lang specification starting with command flag `-`.
  Is `--disable-analytics` meant to be an ember-cli command option?
  This issue is likely caused by using the `--lang` flag without a specification.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember <command> help` for more information.
```

#### Common Misunderstandings: Programming Languages

A developer may encounter the flag and make incorrect assumptions about what it can mean. Such as, `-l typescript` or `-l glimmer`. Such incorrect assumptions will be manually caught by the implementation and the developer will be shown a friendly error message such as the following:


```bash
ember new my-app --lang=typescript

An error with the `--lang` flag returned the following message:
  Trying to set the app programming language to `typescript?`
  This is not the intended usage of the `--lang` flag.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember <command> help` for more information.
```

## How we teach this

1. Update the [Ember CLI API documentation](https://ember-cli.com/api/) to reflect the new flag.
2. Update the [Ember.js CLI Guides](https://cli.emberjs.com/release/basic-use/cli-commands/) to reflect the new flag much like we demonstrate `--yarn` usage.
3. Update the Ember CLI `--help` command so it explains what kind of value is expected to be passed to the `--lang` flag.
4. Update the Super Rental tutorial to include updated information.
5. Update the Guides - specifically the section that discusses the language attribute.

### For the Ember CLI Guides:

The `--lang` flag can be used to set the spoken language of the app or addon.

To use with a language code only, this is the syntax that would be used:

```bash
ember new my-app --lang en
```

To use with a language code and a region code:

```bash
ember new my-app --lang en-US
```

An error will be thrown if the country and region codes are incorrect. Additionally, helpful error text has been added in cases where the developer misunderstands the `--lang` flag and thinks that it is the programming language rather than the HTML attribute.

### For the Ember.js Guides

Specifically, update to https://guides.emberjs.com/release/accessibility/application-considerations/#toc_language-attribute:

Every application must have a primary language declaration. This language declaration is important for assistive technology like screen readers, internationalization tools built into browsers, and search engines.

To indicate the primary language, use the `--lang` flag when generating a new Ember app. This is inherited by all other elements, and will set a default language for the text in the document head element. If app globalization is desired, then consider using the `ember-intl` addon.

If there happens to be any content on the page that is in a different language from that declared in the <html> element, the `lang` attribute can be used on the parent element to indicate a different language.

Note: While an app cannot have multiple language attribute values defined at the same time, the language of specific elements can be defined to be different than the language of an app. For example, a language (e.g., `lang="en"`) could be set on the page's HTML element and then a different language (e.g., `lang="es"`) could be set on a different element in the page content (if appropriate).

### As this relates to ember-intl

The popular [localization library ember-intl](https://github.com/ember-intl/ember-intl) does not conflict with the addition of this new Ember CLI flag. The addition of this flag offers some out of the box support where it was previously missing for new Ember apps. It is still recommended that globalized apps leverage `ember-intl`.

## Drawbacks

* More flags means more combinations of ways to run `ember new` which can be hard to test for and is potentially unsustainable.
* Users may be confused about whether or not they are supposed to specify a human language or a programming language (i.e. `--lang typescript`). However, we think we've mitigated this by using the HTML attribute as the flag name, and having helpful error messages that guide developers in the right direction.

## Alternatives
These are the alternative approaches that we are aware of; if more become apparent in discussion, this RFC will be updated to include them.

- Set the default html lang attribute to `en-US` (the language of the Ember.js project) and assume users will either change the `lang` value themselves, or rely exclusively on `ember-intl` (and not just for apps that require full globalization).
  - [Valuable discussion points in this issue](https://github.com/emberjs/rfcs/issues/595)
  > The data we already have suggests that most Ember applications are:... in English... use internationalization if other languages are required
  - We have existing art in other frameworks (Vue sets `lang="en"` by default)
  - It's consistent with the "80%" rule (solve for 80% of the use cases)
  - We prop up this new default with supporting Ember documentation to describe to users how to use ember-intl to choose another language along with the potential "bug" of an Ember app being interpreted as the wrong language.
- Make no flag change
  - By having no `lang` attribute an Ember app will default to using the system OS language.
  - Update the Ember documentation to include the pro's and con's of setting a language, along with how to do so.

## Unresolved questions

No unresolved questions currently but if RFC discussion yields additional unresolved questions, we will add them here.

## References

- [Understanding Success Criterion 3.1.1: Language of Page](https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html)
- [Technique H57: Using the language attribute on the HTML element](https://www.w3.org/WAI/WCAG21/Techniques/html/H57)
- [HTML5 Specification: `lang` attribute](https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes)


---

---
stage: recommended
start-date: 2020-06-01T00:00:00.000Z
release-date: 2020-05-02T00:00:00.000Z
release-versions:
  ember-source: v4.4.0
  ember-cli: v4.3.0
teams:
  - framework
  - cli
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/637'
  recommended: 'https://github.com/emberjs/rfcs/pull/888'
project-link:
---

# Facilitate customization of setupTest* functions

## Summary

Provide a default and convenient way for each project to customize the
`setupApplicationTest`, `setupRenderingTest`, and `setupTest` functions from
[RFC #268](https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md)
and [RFC #232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md).
The app and addon blueprints will be updated to create a file at
`tests/helpers/index.js` where those functions will be wrapped and exported,
creating a local place to edit for each type of test setup. Tests generated
using `ember generate` will import the setup functions from that file.


## Motivation

Projects often need to customize setup for every test. For example, in
acceptance tests, it is often necessary to override services, mock APIs, etc.
in every test of that type.

A common use-case is `ember-cli-mirage`, which provides a `setupMirage` function
to be called after `setupApplicationTest`. In a project using this, it can be
necessary to remember to add that call to every test file.

If it is necessary to add new setup to every test (for example, when adding a
service that must be replaced in test), every test file must be individually
modified.

For these reasons, many projects create their own `setup*Test` functions in the
`test/helpers` directory, either wrapping the addon-provided `setup*Test`
functions or composing with them in each test file.

For example:

```js
  import { module, test } from 'qunit';
  import { setupTest } from 'ember-qunit';

  module('Unit | Service | tomster', function(hooks) {
    setupTest(hooks);

    test('this works', function(...
  });
```

in a generated test where the setup functions have been wrapped in a helper must
manually be changed to:

```js
    import { module, test } from 'qunit';
    import { setupTest } from 'my-app/tests/helpers';

    module('Unit | Service | tomster', function(hooks) {
      setupTest(hooks);

      test('this works', function(//...
    });
```

or where the setup functions are to be composed, this must be added:

```js
    import { module, test } from 'qunit';
    import { setupTest } from 'ember-qunit';
    import { setupMyTest } from 'my-app/tests/helpers';

    module('Unit | Service | tomster', function(hooks) {
      setupTest(hooks);
      setupMyTest(hooks);

      test('this works', function(//...
    });
```

Developers of these projects must remember to change the imports or additionally
call their custom setup in every test file. It is easy to forget to make these
changes and waste time to debug test failures or weird test side effects.

## Detailed design

When generating tests in an Ember project today, the setup functions in the
generated test are imported from `ember-qunit` or `ember-mocha`. This RFC
proposes adding a file at `test/helpers/index.js` that would look like:

```js
import { setupApplicationTest as upstreamSetupApplicationTest } from 'ember-qunit';
export function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);
  // customize here
}
export { setupTest, setupRenderingTest } from 'ember-qunit';
```

The current imports in newly generated tests:
```js
import { setupApplicationTest } from 'ember-qunit';
// OR
import { setupRenderingTest } from 'ember-qunit';
// OR
import { setupTest } from 'ember-qunit';
```

will change in the relevant generated tests to:

```js
import { setupApplicationTest } from 'my-app-name/tests/helpers';
// OR
import { setupRenderingTest } from 'my-app-name/tests/helpers';
// OR
import { setupTest } from 'my-app-name/tests/helpers';
```

`ember-qunit` has been used for demonstrative purposes, but the blueprints for
generated tests using `ember-mocha` are also maintained in `ember-source`
and `ember-data`. Those blueprints will also be updated to use the local test
helpers. The `test/helpers/index.js` file will import from the appropriate
test framework.

We will provide a codemod to update existing tests. @rwjblue has created a
[proof-of-concept codemod](https://astexplorer.net/#/gist/ba7e5ae104aac099bc5ca60ef874eb74/fc6cd9ad60df7abf17813136d7cdc75b0f313496).

An `eslint-plugin-ember` lint rule will be created to solely allow the imports
of `setup*Test` directly from `ember-qunit`/`ember-mocha` in the
`test/helpers/index.js` file.

## How we teach this

The Ember.js guides extensively cover testing and use the `setup*Test` functions.
Those guides will need to be updated to reflect the new imports that will be in
generated tests. Because of this, the guides will need to explain the file at
`test/helpers/index.js` as a place for customization.

The tutorial also covers testing, using the `setup*Test` functions. It will need
to be updated, as other existing Ember apps will, likely by using the codemod.

This change will not substantially alter how a developer new to Ember would
learn and use the framework.

## Drawbacks

Developers will need to trace imports through the local file before finding the
the bulk of the setup methods come from `ember-qunit` or `ember-mocha`.
Projects without a need to customize the behavior of these test setup functions
may find that slightly inconvenient.

## Alternatives

We could leave it to each project, as we do now, to create helpers to customize
behavior as needed. The downsides of this current state would remain as
discussed in [Motivation](#Motivation).

Another alternative would be to create base classes from which test modules could
extend, similar to how it is done within [`Ember.js`](https://github.com/emberjs/ember.js/blob/master/packages/internal-test-helpers/lib/test-cases/application.js).
This would be a much larger change to how we write tests in Ember projects and
would have many details to be discussed and hashed out. It may be worth exploring
but the change proposed in this RFC would still provide value until that idea
were realized.

### Prior Art

A very similar proposal was discussed in
[a CLI Issue](https://github.com/ember-cli/ember-cli/pull/7657), over two years
ago.

## Unresolved questions

> Optional, but suggested for first drafts. What parts of the design are still
TBD?


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2020-06-12T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - cli
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/638
project-link:
---

# Interactive New Ember App Creation

## Summary

As part of the effort to make new Ember apps more conformant for digital accessibility requirements at a global scale, this RFC proposes an interactive workflow for new Ember apps. This will also have the benefit of assisting new users who prefer an interactive model of new app creation.

## Motivation

This RFC is the result of [analysis and discussion in Ember's accessibility strike team](https://github.com/ember-a11y/core-notes/blob/ember-a11y/ember-a11y/2020-05/may-20.md). The overall roadmap for addressing this issue is with a series of RFCs that intend to (independently) offer:
* a partial resolution to ensuring new Ember apps achieve [WCAG Success Criteria 3.1.1 (language of the page)](https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html)
* enhancements to Ember CLI that empower developers to make their applications more accessible-by-default
* global improvements to new Ember applications (i.e., improvements gained by achieving WCAG SC-3.1.1 that aren't specifically related to digital accessibility)

The underlying motivation for this RFC is the desire to improve the accessibility of new Ember apps as [previously documented in Issue 595/Section 4](https://github.com/emberjs/rfcs/issues/595). Specifically, it aims to prevent new Ember apps from failing legal requirements for accessibility conformance according to [WCAG 2.1](https://w3c.github.io/wcag/21/guidelines/), the standard used by most countries around the world to inform digital accessibility requirements. In that context, this RFC seeks to help new Ember applications achieve [WCAG Success Criteria 3.1.1: language of page](https://www.w3.org/TR/WCAG21/#language-of-page) by providing users of `ember-cli` to specify the base human language of their new application within an interactive setup workflow.

That being said, the overall developer experience improvement is the primary motivation. Interactive app creation helps new developers understand the important decisions they must make, and safely explore the options that they have (as defined in the question options). This provides a learning environment that will help build up the confidence of the new Ember developer by providing them with an interactive environment and helpful feedback during troubleshooting and error handling, thus flattening the learning curve. This will also help more experienced developers move faster; the strong defaults that Ember is known for will make it even easier than before to set up a new repo with the confidence that the important things are not being forgotten.

## Detailed design

The first step of the solution was presented in [RFC 635](https://github.com/emberjs/rfcs/pull/635)-- the addition of the `--lang` flag as a way to add the language attribute to the `<html>` tag in the `index.html` file of new Ember apps. As such, successful implementation of [RFC 635](https://github.com/emberjs/rfcs/pull/635) (or similar) is a necessary pre-requisite for this RFC, which in turn proposes an interactive workflow that can be initiated in the CLI when creating a new Ember app. With this in mind, this RFC will endeavor to not repeat the information in that RFC, but rather build on it, and reference when appropriate. The intention of [RFC 635](https://github.com/emberjs/rfcs/pull/635) was to provide the appropriate underlying mechanism for setting the page language to align new Ember apps with WCAG Success Criteria 3.1.1 (language of the page); the interactive workflow proposed in **this** RFC intends to harness that mechanism.

### Prior Art
It would be remiss to introduce this RFC without mentioning the prior art that we analyzed for wizard-like app creation. In the Ember community, [@gossi](https://gist.github.com/gossi) first introduced this idea with [ember-cli-create](https://github.com/gossi/ember-cli-create). In the wider web community, the Vue community offers this through `vue create` ([see docs](https://cli.vuejs.org/guide/creating-a-project.html#vue-create)).

### Intro
When considering what questions to ask, we considered a few things:
1. What questions do we have to ask ourselves every time we create a new Ember app?
1. How many questions do we think developers will tolerate?
1. Should the questions be different if it is an app vs addon?

We will also endeavor to provide strong defaults for these questions, based on the results from the community surveys we have been conducting over the past few years and the defaults as stated by Ember itself (either explicitly or implicitly). **If these defaults change over time as the result of community RFCs, the default values or other responses for the interactive questions should be updated as part of those RFCs.**

So, how then do we decide which questions to include and which not to include? It became necessary to then develop a rubric by which the proposed list of questions could be measured.

### Question Rubric
We intend for this section to be normative; that is, we intend for it to define how questions are evaluated for inclusion both now and in the future.

Evaluating criteria:
1. Is it a choice that is hard (or time-consuming) to change one's mind about later? *For example, it's easy to remove the `ember-welcome-page` addon, so we did not include it. But it's time consuming to change from `yarn` to `npm` (or vice-versa) so we made sure to include that.*
1. Is it difficult to discover the option?
1. What is the maintenance cost? *For example, a nice question to add could be something like, Do you want to use a CSS preprocessor? But, because Ember does not deal with SASS, LESS... by default, the interactive workflow will have to install an addon (like `ember-cli-less`) which would imply that the CLI team will have to ensure it never fails.*
1. Does the question affect another one? *For example, the LTS question can affect the CI file generated by the CI question (setup tests on CI with `ember-try`). Questions that modify the result of other questions too much should be avoided to prevent high maintenance.*

### Triggering the Workflow

The following commands, and reasonable combinations thereof, should work to enter into the interactive workflow:

1. `ember new`
1. `ember new --interactive`
1. `ember new -i`
1. `ember new my-app -i`

### App/Addon

Starting a new Ember app or addon as we do now (at the time of this writing) will not change. If a user types `ember new my-app` they will still get a new Ember app generated in the usual ways. However, if the user types `ember new` they will enter into an interactive workflow that will ask them a few key questions about their application.

If a user were to type in existing flags that are also questions in the interactive workflow (i.e., `ember new my-app --lang en-US --interactive`), it will skip the question entirely.

When a user types `ember new` into their command line, they will be asked these questions (defaults indicated by a `>`):

- `Is this an app or an addon? (use arrow keys)`
  - `> app`
  - `addon`
- `Please provide the name of your app/addon:`
- `Please provide the spoken/content language of your app/addon: (use arrow keys)`
  - `> en-US`
  - `my computer's default language`
  - `manually define a different language`
- `Pick the package manager to use when installing dependencies:  (use arrow keys)`
  - `> NPM`
  - `Yarn`
  - `ignore/skip`
- `What CI system do you want to use? (use arrow keys)`
  - `> travis-ci`
  - `ignore/skip`

#### App/Addon Name
There will be no default for this question. The user must enter a response.

#### App/Addon Language

- the default would be `en-US`
- if your system has a different language set (which can be confirmed by using the `echo $LANG` command in the terminal), then _that_ language would be shown as the second option
- if your system was already set to the default language, the second option would not be shown.
- for "manually define a language", we will validate the response against the allowed language codes
- we have not added a "skip" option here, because the purpose is to focus on improved accessibility in Ember apps.

#### Package Manager

- ignore/skip has been added to cover the use case where the developer is in a workspace

#### CI Option

Separate RFCs should further define more options for CI.

### Current Limitations
Explicitly, the goal of this RFC is to only include `ember-cli` flags that already exist. Any other possibilities should be considered future work.

This interactive workflow will also ignore any ~/.ember-cli settings that already exist. A separate RFC should be written that makes it possible for these to things to co-exist and respect the settings of the other.

### Future possibilities
An example of a future RFC that could be specific to addons, would be to add a `--supported-version` flag for addons and add that to the wizard:

- `What is the earliest version of Ember that you intend to support? (use arrow keys)`
  - `> recommended (last two LTS)`
  - `last LTS`
  - `manually define a version number`

### Implementation
This section is not normative, but provided for extra context for folks who might be new to this idea in general. We could use something like [inquirer.js](https://github.com/SBoudrias/Inquirer.js) to implement this wizard, if the mechanism doesn't already exist within the ember-cli codebase. However, it should be explicitly noted that inquirer is only being used as an example of a library that could be used, and this RFC isn't explicitly defining that inquirer.js should be or will be used.

### Versioning and Stability Statement
Because the `ember new` command only affects new apps, it is not subject to the same semver guarantees that official Ember.js framework libraries currently follow.

The `ember new` interactive workflow SHOULD NOT be used in other scripts; it is the intent of the design to make this workflow flexible and changeable over time. As such, it should not be considered stable enough to be integrated into other automated tooling. Users should continue to make use of the commands available via `ember-cli` for any other integration scripts.

## How we teach this

As this is a wholly new idea, it should be documented and added to the guides along with screenshots of the new workflow. Until that prototype exists, this section will largely remain empty. However, we intend to explain it similarly to Vue's documentation for a similar feature (https://cli.vuejs.org/guide/creating-a-project.html#vue-create).

## Drawbacks

It could be considered a drawback to make this not the default for new Ember apps, even if an app name is defined.

The general drawback with wizards is that it can lead to a large number of combinations, which increases the risk for fragmentation. We believe that we have limited this risk by limiting the number of questions asked, but it is still a risk and should be identified as such.

## Alternatives

1. We could decide on a different list of questions. See the notes from the [strike team discussion on May 20th](https://github.com/ember-a11y/core-notes/blob/ember-a11y/ember-a11y/2020-05/may-20.md) to review the other possibilities considered.
1. We could make this the default for new Ember apps and add it in the appropriate version as a change.
1. We could have this workflow be opt-in only, via the `--interactive` flag (e.g., `ember new --interactive`). Using the `ember new` command would error and trigger the help workflow (which would be updated to include the `--interactive` flag).
1. We could set the default language to US English (the default language of the Ember project) and remove the language question from the interactive workflow.
1. We could set the default language to US English (the default language of the Ember project) and not have an interactive option at all.

## Unresolved questions

As we identify additional unresolved questions, we will add them here.


---

---
stage: recommended
start-date: 2020-06-15T00:00:00.000Z
release-date: 2022-07-11T00:00:00.000Z
release-versions:
  ember-cli: v4.5.0

teams:
  - cli
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/639
project-link:
---

# Replace terms blacklist & whitelist in Ember CLI

## Summary

Ember.js prides itself (rightly) on being an inclusive framework. To further improve on this, we should remove the terms "blacklist" and "whitelist" with more neutral replacements.

## Motivation

The terms "blacklist" and "whitelist" can be considered racially insenstive. While the origin of these terms in this context is not in itself racially motivated, the fact that in todays context it _can be considered racially insensitive_ has been discussed frequently - see for example [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6148600/), [here](https://bugs.chromium.org/p/chromium/issues/detail?id=981129#c16) or [here](https://www.zdnet.com/article/uk-ncsc-to-stop-using-whitelist-and-blacklist-due-to-racial-stereotyping/).

Other projects have already taken similar steps, for example [Go](https://go-review.googlesource.com/c/go/+/236857/), [Android](<https://android-review.googlesource.com/q/topic:%22soong_inclusive_language%22+(status:open%20OR%20status:merged)>), [curl](https://github.com/curl/curl/pull/5546) or [PHPUnit](https://github.com/sebastianbergmann/phpunit/issues/4275).

These terms are used in Ember CLI for rather advanced functionality, which should make providing a better alternative naming and deprecating the current one rather easy.

## Detailed design

You can use `blacklist` and `whitelist` to include/exclude certain addons from your build:

https://ember-cli.com/user-guide/#whitelisting-and-blacklisting-assets

We should replace these with `exclude` or `include`:

```js
// Before
let app = new EmberApp(defaults, {
  addons: {
    blacklist: ["fastboot-app-server"],
  },
});

// After
let app = new EmberApp(defaults, {
  addons: {
    exclude: ["fastboot-app-server"],
  },
});

// Before
let app = new EmberApp(defaults, {
  addons: {
    whitelist: ["ember-cli-sass"],
  },
});

// After
let app = new EmberApp(defaults, {
  addons: {
    include: ["ember-cli-sass"],
  },
});
```

The old keys (`blacklist` and `whitelist`) should be aliased to the new ones. Functionally, they behave the same.

If both keys are used at the same time (so either `blacklist` AND `exclude` or `whitelist` AND `include`), an error is thrown.

The old keys should be removed at some point - there should be a dedicated deprecation RFC for this (at a later point), ideally in time for them to be removed in the next major release.

## How we teach this

We should update the Ember CLI API docs with the new terms.

## Drawbacks

This might be considered "churn" by some. However, it is a small enough change to not really impact anybody meaningfully, while ensuring that Ember.js feels inclusive to everybody.

## Alternatives

There are also other possible terms that could be used to replace `blacklist` and `whitelist`. For example:

- `allowlist` / `denylist`
- `allowlist` / `disallowlist`
- `allow` / `deny`
- `allowed` / `disallowed`
- `allowedlist` / `disallowedlist`
- `safelist` / `blockedlist`

For reference, this is how often these terms are used accross the Ember ecosystem according to Ember Observer - all searches done inside of index.js files for easier comparison:

- blacklist: 16 addons
- whitelist: 20 addons
- allowlist, allowedlist, denylist, deniedlist, disallowlist, disallowedlist, blockedlist: 0 addons
- blocklist: 2 addons
- safelist: 1 addon
- allow: 4 addons
- deny: 1 addon
- allowed: 18 addons
- disallowed: 1 addon
- include: 207 addons
- exclude: 101 addons

## Unresolved questions

- Should we use different replacements than `exclude`/`include`?


---

---
stage: recommended
start-date: 2020-06-24T00:00:00.000Z
release-date: 2021-01-05T00:00:00.000Z
release-versions:
  ember-cli: v3.24.0

teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/645
project-link:
meta:
  authors: Benjamin Jegard, Melanie Sumner, Ricardo Mendes
---

# Add ember-page-title to the app blueprint

## Summary

Add [`ember-page-title`](https://github.com/adopted-ember-addons/ember-page-title) to the default blueprint for new Ember apps as a way to provide improved out-of-the-box (OOB) accessibility for Ember applications.

## Motivation

This RFC is part of the work made by the Ember.js Accessibility Strike Team to ensure that newly created ember apps have no accessibility issues.

Users with assistive technology rely on the page title to know if they are on the correct page of a website.
Adding this addon will provide developers a simple solution to achieve the [WCAG Success Criterion 2.4.2: Page Titled](https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html).

While there're other addons that provide the same capabilities it has been decided to go with [`ember-page-title`](https://github.com/adopted-ember-addons/ember-page-title) because it's the most aligned with the current and future direction taken Ember, which is the template-based solution.

## Detailed design

1. Make [`ember-page-title`](https://github.com/adopted-ember-addons/ember-page-title) an official Ember addon by transferring `ember-page-title` repo to the [Ember CLI org](https://github.com/ember-cli) (it's currently in the [Adopted Ember Addons org](https://github.com/adopted-ember-addons))
2. Add the dependency to the app blueprint here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/package.json#L19
4. Update route blueprint to include `{{page-title RouteName}}` at the top of the route [template.hbs](https://github.com/emberjs/ember.js/blob/master/blueprints/route/native-files/__root__/__templatepath__/__templatename__.hbs) (this [template.hbs](https://github.com/emberjs/ember.js/blob/master/blueprints/route/files/__root__/__templatepath__/__templatename__.hbs) too) where `RouteName` is the name of the route provided to the `ember generate route` command

## How we teach this

- Update the "Page Title" section in [Page Template Considerations](https://guides.emberjs.com/release/accessibility/page-template-considerations) to use `ember-page-title`.
- Update code examples in [Building Pages](https://guides.emberjs.com/release/tutorial/part-1/building-pages/) to include uses of `{{page-title}}`. Also explain that updating the page title with the current page name will help users with assistive technology locate themself on the website.
- Update [ember-welcome-page](https://github.com/ember-cli/ember-welcome-page) addon and [WelcomePage](https://github.com/ember-cli/ember-welcome-page/blob/master/addon/templates/components/welcome-page.hbs) component to explain the contents of the fresh project a bit better. The component should explain the presence of `{{page-title}}` and link to the "Page Title" section in [Page Template Considerations](https://guides.emberjs.com/release/accessibility/page-template-considerations)

## Drawbacks

- An additional dependency to new projects. But, no noticeable size differences it's only all +10kb of js for production builds (not gzipped, ~2kb js gzipped)
- Add an extra helper `{{page-title}}` (possible name clashing)
- Slightly increases the learning curve. Increases the amount of code in a first-starter project, which could become overwhelming.
- The addon will have to be maintained by the [Ember CLI org](https://github.com/ember-cli)

## Alternatives

N/A

## Unresolved questions

None

## References

- [WCAG Success Criterion 2.4.2: Page Titled](https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html)


---

---
# FIXME: This seems to be at least partially implemented in Ember 3.24
stage: accepted
start-date: 2020-06-18T00:00:00.000Z
release-date: # FIXME
release-versions: # FIXME
teams:
  - framework
  - learning
  - steering
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/649
project-link:
---

# Deprecation Staging

## Summary

Establish a staging system for deprecations that allows Ember and other
libraries to roll them out more incrementally. This system will also enable
users to opt-in to a more strict usage mode, where deprecations will assert if
encountered.

The initial stages would be:

1. Available
2. Enabled

## Motivation

Ember has a robust deprecation system that has served the community well. However,
there are a number of pain points and use cases that it does not cover very well:

* **Ecosystem Absorption**: Generally, deprecations need to be absorbed by the
  addon ecosystem before they can be absorbed by applications. This is because
  apps may see a deprecation that is triggered by addon code, that they have no
  control over (other than jumping in and helping out the addon author by reporting
  an issue or sending in a pull request). However, today there is no way to add a
  deprecation just for
  addons - adding a deprecation will make it appear everywhere at once.

  This creates pressure to only add deprecations when most of the community has
  already transitioned away from the API. However, it also means that we can't
  send a strong signal, like a deprecation, to let the community know that it
  _should_ begin transitioning. This cyclic dependency can make it difficult to
  push the community forward over time.

  Deprecation staging would allow deprecations to be added incrementally.
  Combined with default settings for apps and addons that enable deprecations at
  different stage levels, this would allow incremental rollout throughout the
  ecosystem.

* **Pacing**: Currently, deprecations must have their timeline built
  directly into the deprecation RFC from the beginning. The deprecation API requires an `until` version,
  and there isn't much flexibility during the rollout process because of this.
  Once a deprecation is RFC'd and merged, there isn't much the community can do
  to slow down the process.

  Staging would give the community multiple checkpoints to decide
  whether or not a deprecation was ready to move forward in the process, and to
  update the timeline if so. This would allow a deprecation to slow down or
  speed up based on real world feedback and absorption.

* **Early Adoption**: Since the current system discourages us from adding
  deprecations until we are sure they are ready, it also prevents early adopters
  from getting good signals about which patterns are on the way out. This
  prevents them from exploring replacements, which means the ecosystem has even
  less ability to adapt to deprecations and move forward.

  Staging would allow us to introduce deprecations and allow early adopters to
  explore them. This would allow us to determine if the new APIs that have been
  introduced fully cover the use cases of the APIs that are being deprecated.

* **Restricting Usage/Preventing Backsliding**: Finally, many times deprecations
  are fully removed from an Ember app or addon, only to accidentally be added
  again in the future. Since deprecations only produce a console warning by default,
  it is difficult and unintuitive to prevent this today.

  With staging, users will be able to opt-in to deprecations becoming
  assertions at a particular stage, in a non breaking way. This will allow users
  to prevent backsliding as they incrementally migrate their applications to new
  APIs. It will also provide the basis for future RFCs to explore compiling away deprecated features -
  if they throw an error when used, they can't be used, so they can also be
  removed and the app will continue to work.

## Detailed design

There are two stages that are proposed for deprecations in this RFC:

1. **Available**: Deprecations are initially released in the available stage.
   Available deprecations are enabled by default in addons, but not in apps.
   This is explained in more detail later.

2. **Enabled**: Enabled is the final stage for deprecations. Deprecations
   should be moved into Enabled after the replacement APIs have moved into
   Recommended in the RFC process, and there is generally high confidence that
   the addon ecosystem has absorbed the deprecation for the most part.
   Enabled deprecations cannot be disabled.

Deprecations will progress through these stages linearly. In the future, more
stages could be added, but the progression will remain linear. Deprecations that
involve an RFC (as most do), should lay out a plan for how and when a deprecations
will advance to the next stage, but _this_ RFC does not try to prescribe that
progress.

There are two mechanisms that will need new behavior for the proposed staging
system:

* The `deprecate` function
* The `ember` config on `package.json`

### `deprecate`

The current deprecation function receives the following options:

```ts
interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
}
```

This will be updated to the following:

```diff
interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
+ for?: string;
+ since?: {
+   available: string;
+   enabled: string;
+ }
}
```

Stepping through the new options individually:

* `for`: This is used to indicate the library that the deprecation is for.
  `deprecate` is a public API that can be used by anyone. Now that we intend to
  show or hide deprecations based on their stage, we need to have some more
  information about what library the deprecation belongs to. It should be the
  package name for the library. This can be any string, but in the future, we may
  be able to loosen this requirement by using a macro that can get the name of
  the package that invokes `deprecate()`.

* `since`: This property contains a set of keys corresponding to
  each deprecation stage. If a value for a stage if present, the value of all
  previous stages must also be present. Each key's value is an exact SemVer
  value. To start, only two keys (`available` and `enabled`) will
  be allowed, and the rest will be ignored.

  Any SemVer value can be used here, even if it does not correspond to a published
  artifact in a package registry. This is for the sake of simplicity and flexibility,
  but it should be noted that creating a deprecation that becomes available in the
  future is not recommended.

  The highest stage that has a value is considered the stage of the
  deprecation is in. Any of the values may be used for deprecation compliance
  assertions, depending on the app or addon configuration. This is explained
  more below.

  If the `since` key is not provided (as is the case for existing
  deprecations), the deprecation is assumed to be `enabled`.

This RFC also... wait for it... deprecates the usage of the `deprecate()`
function without the `for` or `since` keys. This meta deprecation will be
enabled at the same time as it becomes available like this (using `since` as the
example):

```js

// 3.21.0 is fabricated here. It will be the next version that is released
// after this RFC is merged / when the work is done.
const NEXT_VERSION = '3.21.0';

deprecate('Calling deprecate() without the \'since\' key is deprecated', false, {
  id: 'ember-source.deprecate',
  until: '4.0.0',
  since: {
    available: NEXT_VERSION,
    enabled: NEXT_VERSION,
  }
})
```

At 4.0, both `for` and `since` will become required:

```diff
interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
- for?: string;
+ for: string;
- since?: {
+ since: {
    available: string;
    enabled: string;
  }
}
```

### Configuring Apps

Users can configure their application using the `ember.deprecations`
property in `package.json`. This property is empty by default, but can be
customized to indicate which versions of an addon the app is compliant with.
This configuration can be described like this:

```ts
type DeprecationStage = 'available' | 'enabled';
type Editions = 'classic' | 'octane';

interface AddonDeprecationConfig {
  stage: DeprecationStage;
  version: StrictSemVerString;
  display?: DeprecationStage;
}

interface EmberPackageJSONKey {
  edition?: Editions;
  deprecations?: {
    display?: DeprecationStage;
    addons?: {
      [packageName: string]?: AddonDeprecationConfig;
    }
  }
}
```

The new `deprecations` key has two keys of its own:

- `display`: which configures the default stage of deprecations the app owner
  wants to see from their app and all addons. If this config is not provided, it defaults to `'enabled'`.
- `addons`: which declares which versions of each library the app is compliant with.

    Each key points to an object conforming to the `AddonDeprecationConfig` interface.

    Note that while deprecations can be created by applications themselves
    (by calling `deprecate()` in app code), the top level key is still called `addons`.
    The reasoning is that _most_ of the time, Ember does not need to know about
    deprecations from applications, as it needs no build-time signaling. These deprecations
    will always be displayed and treated as if they are at the `enabled` stage. Because
    there is no compliance config, they will not be promoted to runtime assertions.

### AddonDeprecationConfig

The keys in each `AddonDeprecationConfig` are:

* `stage`: This declares compliance with the addon's deprecations to the stage given.
* `version`: This declares compliance with the addon's deprecations to the version given.
* `display`: This overrides the root level `display` config, to allow fine grain control over logged deprecations.

The `stage` and `version` keys are explained in more detail below.

### Deprecation Compliance

Users can opt-in to some deprecations becoming assertions. They do this by
stating that their application is _compliant_ with a given library's
deprecations as of a certain stage and version.

This means that the app is guaranteeing that it does not use _any_ deprecated
APIs that were in _the given stage_ in _the given version_.
If they _do_ use an API that was deprecated prior to version specified, the invocation of `deprecate` will
throw an error instead of logging a warning. The error will contain the same
message, with an additional note that the user is encountering this error
because of their deprecation compliance settings.

Deprecation compliance cannot be specified for a version of the
library newer than the one that is installed. Attempting to do this will throw an
error. This is to prevent developers from optimistically declaring compliance with
code that they are not yet running. This also prevents an edge case scenario where
compliance is declared with a version that has not been released yet and accidentally
opting into unknown deprecations when that version _does_ get released.

### Parsing Compliance Declarations

Apps can declare compliance with an addon in two ways:

- by omitting a declaration
- by passing an object conforming to the `AddonDeprecationConfig` interface.

If a declaration is omitted, Ember will assume that the app is compliant with
all deprecations in the "enabled" stage, but will not opt the app into any assertions.
This ensures backwards compatibility with apps that do not add this config.

If a `AddonDeprecationConfig` object is passed, Ember will assume that the app
is compliant with deprecations of the configured `stage` and later, and the
configured `version` and earlier. Deprecations that fit this configuration
will also throw assertions in development builds.

Note that `AddonDeprecationConfig` must have both the
`version` and the `stage` properties to be be valid. If both are not provided
a build time error will be thrown.

### Usage and Config Example

Let's say that we use `deprecate()` to add a new deprecation to our library.
Because it's new, we're going to put it in the "available" stage.

```js
deprecate('this feature is deprecated!', false, {
  id: 'my-awesome-library.my-awesome-feature',
  for: 'my-awesome-library',
  since: {
    available: '1.2.3'
  },
  until: '2.0.0'
});
```

There are a few common variations of compliance config:

- No config

    ```json
    {
      "ember": {}
    }
    ```

    This means that an app may not be compliant with the deprecation from
    `my-awesome-library`. Because Ember doesn't have an explicit declaration,
    it will not promote the deprecation to an assertion, regardless of which
    version of `my-awesome-library` is installed.

- Later stage, current version

    ```json
    {
      "ember": {
        "deprecations": {
          "addons": {
            "my-awesome-library": {
              "stage": "enabled",
              "version": "1.2.3"
            }
          }
        }
      }
    }
    ```

    This indicates that the app is not compliant with `my-awesome-feature`
    deprecation, so Ember will not promote it to an assertion, regardless of which
    version of `my-awesome-library` is installed.

- Current stage, but older version.

  ```json
  {
    "ember": {
      "deprecations": {
        "addons": {
          "my-awesome-library": {
            "stage": "available",
            "version": "1.0.0"
          }
        }
      }
    }
  }
  ```

  This config indicates that the app is not compliant with deprecations added
  after 1.0.0, so Ember will not promote the `my-awesome-feature` deprecation to
  an assertion.

- Matching stage and version

    ```json
    {
      "ember": {
        "deprecations": {
          "addons": {
            "my-awesome-library": {
              "stage": "available",
              "version": "1.2.3"
            }
          }
        }
      }
    }
    ```

    This indicates that the app _is_ compliant with the `my-deprecation-feature` and
    Ember will throw a runtime assertion if this deprecation is invoked.

Now consider that `my-awesome-feature` becomes a enabled deprecation in 1.5.0:

```diff
deprecate('this feature is deprecated!', false, {
  id: 'my-awesome-library.my-awesome-feature',
  for: 'my-awesome-library',
  since: {
    available: '1.2.3',
+   enabled: '1.5.0',
  },
  until: '2.0.0'
});
```
The configurations described above would be affected in the following ways:

- No config: no change
- Later stage, current version: no change, because it was not enabled in 1.2.3
- Current stage, older version: no change
- Matching stage and version: no change

In order to opt-in to an assertion for this enabled config, the app would have
to update their declaration to match the `since.enabled` value:

```json
{
  "ember": {
    "deprecations": {
      "addons": {
        "my-awesome-library": {
          "stage": "enabled",
          "version": "1.5.0"
        }
      }
    }
  }
}
```

### Configuring Addons

Addons are also able to declare their compliance with other libraries in the same
way as above. A declaration from an addon tells Ember that its _parent_ addon or application
cannot declare compliance to a higher version.

This allows _application_ developers to feel confident that if they declare a
compliance with a _high_ version, Ember's tooling will tell them early that they
have incompatible addons installed.

An addon can specify its deprecation config in the same way as an application,
but there are some notable differences:

#### Limited to ember-source

Addons are recommended to declare compliance _only_ with the `ember-source` library.
This recommendation does not _prevent_ this mechanism from being used with other libraries,
but the core team would like to exercise this feature before recommending good
patterns and behavior. A warning will be logged in development, if addons declare
compliance with libraries other than `ember-source`.

#### Declaration and Defaults

While applications must set a `StrictSemVerString` value for
`addons.[packageName].version`, addons can additionally set a special
value of `"auto"`, to indicate that the addon is compliant with
deprecations from the _minimum_ version of the SemVer range specified by the
`dependencies` or `devDependencies` in its `package.json`. The configured stage
would still be used as that stage of declared compliance.

The benefit of these new semantics is that the majority of addon authors don't
have to declare that they are compliant and runtime assertions are not introduced
to apps without any major version updates.

Additionally, this `auto` keyword would allow addon authors to use automation
(e.g Dependabot) to update their package's dependencies and get valuable CI
feedback about their addon violating new deprecations, without having to update
any compliance config.

#### Example

Let's look at a complete example with a real world scenario. In 3.15.0,
Ember deprecated [use of the `isVisible` property][1] in components. Although
Deprecation Stages did not exist at the time, this is how that deprecation would
be created after this RFC:

```js
deprecate('\`isVisble\` is deprecated!', false, {
  id: 'ember-component.is-visible',
  for: 'ember-source', // new property
  until: '4.0.0',
  since: {
    available: '3.15.0',
    enabled: '3.16.0', // this is fabricated for this example
  }
});
```

This means that the deprecation for the `isVisible` property became _available_
in 3.15, but became enabled in 3.16.

Now let's consider an addon that has a component that uses `isVisible`, but
doesn't declare any deprecation compliance. In other words, it does not make
any changes or release any new versions. Its `package.json` config looks like this:

```json
{
  "devDependencies": {
    "ember-source": "~3.16.0"
  },
  "ember": {}
}
```

Because no compliance is declared, Ember will not make any assumptions about
this addon's compliance. On the other hand, Ember will also not actively
_prevent_ an app from declaring its own compliance. This not only lets apps
use this feature without updating every addon in the ecosystem, it also provides
incentive for the community to add compliance declarations into every addon, so
that they can provide valuable signals to apps and Ember.

**TODO**: if the app declares it's compliant with available+3.15 deprecations,
and uses this addon, should Ember promote the deprecation to a runtime assertion?
Pro: apps know immediately that they are not actually compliant when they thought
they were. Con: the only way to "unbreak" an app is to update the addon or to lower
their own compliance config -- both are manual steps.

Next, let's consider that the addon declares its compliance using the `auto` keyword instead.
(All new addons will have this config from the addon blueprint, so this will be the
next most common scenario.)

```json
{
  "devDependencies": {
    "ember-source": "~3.16.0"
  },
  "ember": {
    "deprecations": {
      "addons": {
        "ember-source": {
          "stage": "available",
          "version": "auto"
        }
      }
    }
  }
}
```

Here, the addon is actively declaring that it is compliant with all available
deprecations in `ember-source` 3.16.0, but not in 3.16.1 and beyond. Because this is an active
declaration, Ember will use it for two things:

1. It will not allow parent addons/apps to declare compliance above 3.16.0.
1. It will promote usage of `isVisible` (and other deprecations that fit the same criteria)
to a runtime assertion, assuming that these usages are unexpected.

If the addon were to change its devDependencies to `~3.17.0`, _more_ deprecations
would fall into this category, without the addon author needing to update anything
else. In this way, the `"auto"` configuration allows addon authors to give parent
apps the best scenario, without having to micromanage another config.

Lastly, the addon can explicitly state that it does _not_ comply with the `isVisible`
deprecation by setting their compliance to a SemVer version (similar to how an
application would declare the same):

```json
{
  "devDependencies": {
    "ember-source": "~3.16.0"
  },
  "ember": {
    "deprecations": {
      "addons": {
        "ember-source": {
          "stage": "enabled",
          "version": "3.14.3"
        }
      }
    }
  }
}
```

In this config, the `ember-source` version installed in `devDependencies` is
irrelevant and is ignored.

This config tells Ember that parent apps _cannot_ declare themselves to be in
compliance with even _available_ deprecations in 3.15.0, because they install
a dependency that is not compliant. Ember will throw a build time error for
parent apps that attempt to do this. For example, this config will throw an error:


```json
{
  "ember-source": {
    "stage": "available",
    "version": "3.15.0"
  }
}
```

This means that apps that use dependencies that have pinned their compliance to
an older version, must either contribute to the dependency or fork it.

There are some rare cases in which a addon declares its compliance to a version
due to a deprecation it cannot address, but that part of the addon is not used
by the parent app. This RFC does _not_ attempt to solve this use case as deprecation
compliance is namespaced by the name of the package, rather than individual features.

### New apps and addons

App blueprints will be updated to include the following config:

```json
{
  "ember": {
    "deprecations": {
      "addons": {
        "ember-source": {
          "stage": "enabled",
          "version": "<%= version %>"
        }
      }
    }
  }
}
```

Addon blueprints will be updated opt addons into all `available` deprecations
with this config:

```json
{
  "ember": {
    "deprecations": {
      "addons": {
        "ember-source": {
          "stage": "available",
          "version": "auto"
        }
      }
    }
  }
}
```

### Existing Method of handling deprecations

Today, apps have three mechanisms for handling deprecations:

1. `registerDeprecationHandler()`: which allows apps a custom way to handle deprecations
1. `Ember.ENV.RAISE_ON_DEPRECATION` configuration, which promotes deprecations to assertions
1. `ember-cli-deprecation-workflow` which makes it easier to work on one deprecation at a time

This RFC treats these as out of scope, but also should not affect how they work.
Future RFCs may address them individually.

## How we teach this

Advancing a deprecation through stages is conceptually easy to understand.
Application and addon developers who have no knowledge of this RFC should be
able to read a deprecation message and understand both that "available" deprecations
are not urgent and "enabled" deprecations require an action. This should be
reflected in the deprecation message that is logged.

New applications will have a much easier time understanding this as blueprints
will be updated to include some default configurations.

There will need to be new Guides for existing apps to be able to understand
new deprecations more easily. The deprecation message should log links to these
guides.

Some places in the guides that will have to be updated:

- https://cli.emberjs.com/release/writing-addons/deprecations/
- https://guides.emberjs.com/release/configuring-ember/handling-deprecations/
- https://guides.emberjs.com/release/configuring-ember/debugging/#toc_dealing-with-deprecations

## Drawbacks

- Confusion about what the config means.

## Alternatives

Not sure.

## Unresolved questions

- How does addon config interact with the dummy app, since there is only one package.json?

[1]: https://github.com/emberjs/ember.js/blob/master/CHANGELOG.md#v3150-december-9-2019


---

---
stage: recommended
start-date: 2020-08-25T00:00:00.000Z
release-date: 2022-05-02T00:00:00.000Z
release-versions:
  ember-source: v4.4.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/659'
  recommended: 'https://github.com/emberjs/rfcs/pull/865'
project-link:
---

# {{unique-id}} helper

## Summary

Add a new built-in template helper `{{unique-id}}` for generating unique IDs.

See [pre-RFC issue #612](https://github.com/emberjs/rfcs/issues/612)

## Motivation

When working with HTML it is very common to need to create and reference [DOM IDs that are unique within the HTML document](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). Classic Ember components provide the `elementId` attribute which can be used to construct unique ids within classic components, but `elementId` is not available within Glimmer components or route templates.

There are several common use cases where a developer may need to generate a unique ID for use in a template:
1. Associating `label` and `input` elements using the label's `for` attribute and the input's `id` attribute.
2. Using WAI-ARIA attributes to improve accessibility (eg. `aria-labelledby`, `aria-controls`)
3. Integrating 3rd party libraries that attach themselves to DOM elements using DOM IDs (eg. maps, datepickers, jquery plugins, etc)

Since providing some faculty for generating unique IDs for DOM elements can reasonably be considered a requirement for most Ember apps wishing to implement an accessible UI (via labelled inputs and/or WAI-ARIA), it is reasonable for Ember to provide this functionality at the framework level. Ember already provides the `guidFor` utility in javascript, so it is reasonable for Ember to provide similar functionality within templates.

## Detailed design

Add built-in `{{unique-id}}` template helper.

### `{{unique-id}}`

The `unique-id` helper can be invoked with no arguments. When invoked this way, the `unique-id` helper will return a new unique id string for every invocation.

In practice this invocation style would usually be paired with a `let` block to enable re-use of the unique id generated by `{{unique-id}}`.

```hbs
{{#let (unique-id) as |emailId|}}
  <label for={{emailId}}>Email address</label>
  <input id={{emailId}} type="email" />
{{/let}}

{{#let (unique-id) as |passwordId|}}
  <label for={{passwordId}}>password</label>
  <input id={{passwordId}} type="password" />
{{/let}}
```

In the future, an inline or template version of `let` could enable a single invocation of `{{unique-id}}` for re-use of the id within a template.

### Implementation

The `{{unique-id}}` helper can be implemented using the existing mechanisms Ember uses for generating unique ids. An implementation should ideally be designed to prevent id collisions among other ids generated by Ember.

## How we teach this

### Ember API docs: Ember.templates.helpers

The Ember API docs can be updated to include the `unique-id` helper on the page for [Ember.templates.helpers](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers)

> Use the `{{unique-id}}` helper to generate a unique ID string suitable for use as an ID attribute in the DOM.
>
> ```hbs
> <input id={{unique-id}} type="email" />
> ```
>
> Each invocation of `{{unique-id}}` will return a new, unique ID string. You can use the `let` helper to create an ID that can be reused within a template.
> ```hbs
> {{#let (unique-id) as |emailId|}}
>   <label for={{emailId}}>Email address</label>
>   <input id={{emailId}} type="email" />
> {{/let}}
> ```


### Ember Guides: Associating labels and inputs
The Ember guides currently include a section on associating labels and inputs. This section can be updated to use this new `{{unique-id}}` helper.

[Guides: associating labels and inputs](https://guides.emberjs.com/release/components/built-in-components/#toc_ways-to-associate-labels-and-inputs)

> Every input should be associated with a label. Within HTML, there are several different ways to do this. In this section, we will show how to apply those strategies for Ember inputs.
>
> You can nest the input inside the label:
> ```hbs
> <label>
>   Ask a question about Ember:
>   <Input type="text" @value={{this.val}} />
> </label>
> ```
> You can associate the label using for and id:
> ```hbs
> <label for={{this.myUniqueId}}>
>     Ask a question about Ember:
> </label>
> <Input id={{this.myUniqueId}} type="text" @value={{this.val}} />
> ```
>
> In HTML, each element's id attribute must be a value that is unique within the HTML document. Ember provides the built-in `{{unique-id}}` helper to assist you with generating unique IDs.

> ```hbs
> {{#let (unique-id) as |myId|}}
>   <label for={{myId}}>
>     Ask a question about Ember:
>   </label>
>   <Input id={{myId}} type="text" @value={{this. val}} />
> {{/let}}
> ```
>
> The `aria-label` attribute enables developers to label an input element with a string that is not visually rendered, but still available to assistive technology.
> ```hbs
> <Input id="site" @value="How do text fields work?" aria-label="Ember Question"/>
> ```
>
> While it is more appropriate to use a <label> element, the `aria-label` attribute can be used in instances where visible text content is not possible.

### Accessibility guides
This helper will be an important part of Ember's out-of-the-box accessibility story. Future improvements to Ember's accessibility guides will be able to use this helper when discussing how to build forms and how to work with WAI-ARIA attributes such as `aria-controls` or `aria-describedby`.


## Drawbacks

Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.

There is nothing about this proposal that could not be instead implemented in an add-on.

## Alternatives

1. Do nothing; developers can use backing classes for templates that require an ID, and either use `elementId` in classic components or import `guidFor` in glimmer components or via a hand-rolled helper.

2. Introduce a keyword-style syntax that leverages a build-time AST transform to convert this:
```hbs
<label for="{{unique-id}}-toggle">Toggle</label>
<input id="{{unique-id}}-toggle" type="checkbox">
```
into
```hbs
{{#let (unique-id) as |_id|}}
  <label for="{{_id}}-toggle">Toggle</label>
  <input id="{{_id}}-toggle" type="checkbox">
{{/let}}
```
This approach is implementable in userland or in add-ons, so it may not be appropriate to consider this alternative for the core primitive introduced into Ember.js itself.

This approach may be slightly more ergonomic but relies on a more magical, non-standard keyword-like API that will need to be specifically taught, and will be a larger maintenance burden.

## Unresolved questions

none


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2020-09-26T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/669
project-link:
---

# Tracked Storage Primitives

## Summary

Provide a low level primitive for storing tracked values:

```js
let storage = createStorage();

// Set the value of the storage
setValue(storage, 123);

// Get the value of the storage
getValue(storage);
```

## Motivation

Today, there are two methods for creating a tracked value in Ember apps:

1. The `@tracked` decorator, which turns class properties into tracked
   properties
2. `Ember.get`, which can be used to track a key on an object so that it updates
   if it is set with `Ember.set`, or dirtied with `notifyPropertyChange`.

The `@tracked` decorator is good for cases where there are a known set of
mutable values on a class, which is one of the most common use cases in Ember
applications. There are a number of cases, however, where there are unknown,
dynamic, or potentially infinite numbers of decoratable keys. An example of this
is _maps_.

[Maps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
are used as key-value stores, typically in cases where the keys are not known
upfront or are dynamic. In many cases, there are many thousands of potential
keys that could be used in a map, even if only a few ever actually are used.
Decorating each and every potential key on a class in these types of cases is
not practical, and if non-alpha-numeric keys are used, not possible.

There are a few different ways that this type of use case can be solved with
public APIs today:

1. We can use the "immutable pattern", where the map is duplicated whenever we
   wish to change it, the change is applied, and the result is re-assigned to
   the tracked property the map is assigned to.

   ```js
   @tracked map = new Map();

   updateMapValue(key, value) {
     let newMap = new Map(this.map);
     newMap.set(key, value);
     this.map = newMap;
   }
   ```

   This pattern works nicely when followed rigorously, and was the initial
   pattern proposed for _all_ of these types of data structures and operations
   (it's even in the official documentation). However, it is fairly unergonomic
   without the aid of additional libraries, such as [Immer.js](https://github.com/immerjs/immer),
   and it incurs a decent amount of overhead, especially in cases where the data
   structures are large.

   One solution for that is to re-set the tracked property with the same value,
   after the mutation:

   ```js
   @tracked map = new Map();

   updateMapValue(key, value) {
     this.map.set(key, value);
     this.map = this.map;
   }
   ```

   This pattern is problematic however, because it's not obvious what the
   purpose of re-setting the property is. A developer unfamiliar with Ember may
   mistakenly believe this was an error, and remove this statement, causing
   bugs. It's not a very google-able pattern either, which makes it more
   difficult to learn and to teach. Finally, it's fairly easy this way for the
   state to get out of sync with the rest of the system if a developer forgets
   to add the extra re-set after mutating the value.

   Over time, it's become clear that this pattern is in actuality an antipattern
   for these reasons, and something we should begin to discourage in general.

   Note that the _original_ immutable pattern, in which state is fully copied,
   does not have these problems, and remains a fully valid pattern. However, due
   to performance constraints, ergonomics, and personal preferences, it does not
   make sense for _every_ Ember application, so we still need to enable
   alternative patterns.

2. We can continue to use `Ember.get` and `Ember.set` with plain objects.
   This pattern works now and will continue to work for the forseeable future,
   but does not support using non-string values as keys, so it cannot cover all
   the same use cases as Map. In addition, it's not practical for other types of
   collections, such as as arrays, since `get` and `set` were not built to work
   with them.

   In addition, it presents a mismatch between the models put forward in Octane,
   and the models of Ember classic. In Octane, the idea is that the details of
   state tracking are _opaque_ to the user. Using `get` and `set` manually means
   that every time the object is accessed or updated, the user has to
   consciously remember to use these special functions - they have to _think_
   about the details of tracking state. This is a bug-prone process, because it
   only takes one mistake in one usage, and the state itself could be used in
   many places. In Octane, users should only need to declare reactivity once -
   when the state itself is defined.

3. We can use the Cell pattern, as described in [this blog post](https://www.pzuraq.com/autotracking-case-study-trackedmap/).
   This pattern is robust, and can be used to make many types of tracked data
   structures, as the [tracked-built-ins](https://github.com/pzuraq/tracked-built-ins)
   library shows. There are a few main downsides to it:

   - Since it is not a formalized pattern, anyone who wants to use it has to
     reimplement it. This is not a huge amount of code to add to any given
     addon, but it means addon authors have to rederive the pattern themselves
     from scratch, which is not ideal. It means there is more overhead overall
     to learning these patterns in the first place.
   - It is not an optimal pattern, because it adds a layer of decoration and an
     instance of a class for every cell. This is not a major amount of overhead,
     but ideally we wouldn't incur it at all.
   - It has no potential for future extensibility, particularly with regards to
     _debug_ tooling. Ideally, tracked state, even custom tracked state, should
     be easy to understand and debug with standard Ember tooling. Currently,
     when users look at a stack trace with an issue caused by a cell, they get
     something that is very difficult to understand ("why is it telling me
     there's an issue with setting `value` when I'm setting a completely
     different key on my TrackedMap?")

Out of these patterns, the Cell pattern is the most robust and most in-line with
state management in Ember Octane. This RFC seeks to formalize it and add it to
the framework, so we can standardize on a common pattern and address the issues
that it currently has.

## Detailed design

This RFC proposes adding the following APIs, exported from
`@glimmer/tracking/primitives/storage`:

```ts
declare function createStorage<T>(
  initialValue?: T,
  isEqual?: (oldValue: T, newValue: T) => boolean
): Storage<T>;

declare function getValue<T>(storage: Storage<T>): T;

declare function setValue<T>(storage: Storage<T>, value: T): void;
```

### `createStorage`

This function creates and returns an instance of a tracked storage. Tracked
storage instances contain one value, which can be read with `getValue` and set
with `setValue`. Reading the value consumes it, so that any tracked computations
which are currently active will become entangled with it, and setting value
later will dirty it and cause them to recompute. Creating the value does _not_
consume it.

`createStorage` can receive an optional initial value as its first parameter.
It also receives an optional `isEqual` function. This function runs whenever the
value is about to be set, and determines if the value is equal to the previous
value. If it is equal, it does not set the value or dirty it. This defaults to
`===` equality.

### `getValue`

This function receives a tracked storage instance, and returns the value it
contains, consuming it so that it entangles with any currently active
autotracking contexts.

### `setValue`

This function receives a tracked storage instance and a value, and sets the
value of the tracked storage to the passed value if it is not equal to the
previous value. If the value is set, it will dirty the storage, causing any
tracked computations which consumed the stored value to recompute. If the value
was _not_ changed, then it does not set the value or dirty it.

### Re-implementing `@tracked` with storage

We can see how the `@tracked` decorator itself can be re-implemented using
tracked storage.

```js
function tracked(target, key, { initializer }) {
  let storages = new WeakMap();

  function getStorage(obj) {
    let storage = storages.get(obj);

    if (storage === undefined) {
      storage = createStorage(initializer.call(this), () => false);
      storages.set(this, storage);
    }

    return storage;
  };

  return {
    get() {
      return getValue(getStorage(this));
    },

    set(value) {
      return setValue(getStorage(this), value);
    },
  };
}
```

### A note on this design

In general, API design and cohesiveness is an important value in Ember. We work
very hard as a community to develop patterns which are uniform across many
different types of APIs, which in turn leads to a better DX as developers can
generally know what to expect from a given API without even needing to read the
documentation.

The API proposed in this RFC, which uses functions to access and manipulate a
value via an opaque handle, is an unusual API design when compared to most other
Ember APIs. It is a pattern which provides extra flexibility to the implementers
of the API, at the cost of a _severe_ DX penalty for the users of the API,
because of this unusual-ness.

As such this pattern should be used extremely sparingly, on APIs which meet the
following criteria:

1. They are not expected to be used by _every_ Ember developer. If the API will
   be used in the Super Rentals tutorial, or the standard non-advanced sections
   of the guides, then it should not use this pattern.
2. They are for extremely core parts of Ember, such as autotracking, where the
   primitives underlying them could potentially change significantly in the
   future, and maximum flexibility is desired because of this.
3. They are for extremely performance critical parts of Ember, with usages in
   the hundreds of thousands or millions per app, and so maximum flexbility is
   desired in order to be able to leverage changes to the primitives for
   optimizing performance.

In general, most Ember APIs will _not_ meet these requirements, and so this API
design should not be used for them.

## How we teach this

The API docs for this feature can be taken from the descriptions of the
functions in the detailed design section of the RFC. The following guide should
be added to the Autotracking In-Depth guide in the official guides, and the
section on [POJOs](https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_plain-old-javascript-objects-pojos)
should be removed.

### Creating custom tracked data structures

Tracked properties are a great solution for many different use cases. However,
sometimes they aren't the right tool for the job. For instance, you may need
have a problem that requires you to work with a number of dynamically created
properties, rather than ones that you know up front.

For example, we could make a scoreboard component that keeps score for an
arbitrary number of players, and keep track of the score for each player using
a JavaScript [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).

```js
// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class Scoreboard extends Component {
  // Mock data for players - this would eventually be replaced with an argument
  // so players could be passed in
  players = [
    { name: 'Zoey' },
    { name: 'Tomster' },
  ];

  // Create a map from player -> score, with each player's score starting at 0
  scores = new Map(this.players.map(p => [p, 0]));

  @action
  incrementScore(player) {
    let currentScore = this.scores.get(player);

    this.scores.set(player, currentScore + 1);
  }
}
```
```hbs
{{#each-in this.scores |player score|}}
  <div>
    {{player.name}}: {{score}}

    <button type="button" {{on "click" (fn this.incrementScore player)}}>
      +
    </button>
  </div>
{{/each-in}}
```

This component will loop over the map of scores and show each player's name and
score, along with a button to increment the score. The logic for this component
is all correct, but it won't update when we increment the score because the
`scores` map is not tracked state. Let's fix that!

Ember provides a set of primitive APIs for creating _tracked storage_. These
APIs can be used to create higher level tracked data structures. In fact, the
`@tracked` decorator is _implemented_ using tracked storage, and we can see how
it boils down to tracked storage under the hood in this example.

```js
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked name;
}

// could be thought of as:
import {
  createStorage,
  getValue,
  setValue
} from '@glimmer/tracking/primitives/storage';

class Person {
  #name = createStorage();

  get name() {
    return getValue(this.#name);
  }

  set name(value) {
    setValue(this.#name, value);
  }
}
```

In this case, we'll create `TrackedMap`, a class that has the same public API
and behavior as `Map`, but is integrated with autotracking so that if we read or
update a value in the map our app will correctly rerender.

First off, let's start off with the basics for our class. We want it to have the
same semantics as a standard map, and there's no need to re-implement the wheel.
We can use a standard map as the backing storage for our custom wrapper, and
defer to it directly.

```js
// app/utils/tracked-map.js
class TrackedMap {
  #map = new Map();

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  get(key) {
    return this.#map.get(key);
  }

  set(key, value) {
    this.#map.set(key, value);
  }

  forEach(fn) {
    this.#map.forEach(fn);
  }

  // Other methods and APIs omitted...
}
```

Now, we need to add our tracked storage. We'll use the `createStorage` API to do
this.

```js
// app/utils/tracked-map.js
import {
  createStorage,
  getValue,
  setValue,
} from '@glimmer/tracking/primitives/storage';

class TrackedMap {
  #map = new Map();

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  _getStorage(key) {
    let storage = this.#map.get(key);

    if (storage === undefined) {
      storage = createStorage();
      this.#map.set(key, storage);
    }

    return storage;
  }

  get(key) {
    return getValue(this._getStorage(key));
  }

  set(key, value) {
    setValue(this._getStorage(key), value);
  }

  forEach(fn) {
    this.#map.forEach((storage, key) => fn(getValue(storage, key, this)));
  }

  // Other methods and APIs omitted...
}
```

Now, instead of setting values directly in our internal private map, we're
wrapping those values in tracked storage. We create the storage instances with
`createStorage`, we get the value from them with `getValue`, and we set
the value in the with `setValue`. Each tracked storage contains exactly one
value, and whenever we read that value with `getValue`, it is consumed in any
tracked computations that are currently occuring - just like reading the value
of a tracked property. Likewise, setting the value of a tracked storage instance
with `setValue` will dirty it, and cause any tracked computations which used it
previously to recompute, just like setting the value of a tracked property.

There's just one issue with this implementation so far - what happens to
`forEach` if we add a _new_ value to the `TrackedMap`, one that didn't exist
before? Currently, `forEach` will consume every _existing_ value and entangle
it, but it will not rerun if we were to add a new key to the map.

Logically, the thing we're trying to represent here is the state of the
collection's iteration. We can do this by creating another storage, and placing
the collection in it.

```js
// app/utils/tracked-map.js
import {
  createStorage,
  getValue,
  setValue,
} from '@glimmer/tracking/primitives/storage';

class TrackedMap {
  #map = new Map();
  #collection = createStorage(this, () => false);

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  _getStorage(key) {
    let storage = this.#map.get(key);

    if (storage === undefined) {
      storage = createStorage();
      this.#map.set(key, storage);
    }

    return storage;
  }

  get(key) {
    return getValue(this._getStorage(key));
  }

  set(key, value) {
    // dirty the collection state
    setValue(this.#collection, this);
    setValue(this._getStorage(key), value);
  }

  forEach(fn) {
    // Entangle the collection state
    getValue(this.#collection);
    this.#map.forEach((storage, key) => fn(getValue(storage, key, this)));
  }

  // Other methods and APIs omitted...
}
```

Now we have a storage that we use to represent the value of the collection
itself. We pass a custom equality function to this storage which always returns
`true`, meaning that whenever we set the value of this storage, it will _always_
notify, even if the value hasn't changed. We then entangle the collection
storage in `forEach` by using `getValue` on it, even though we don't actually
use the value, and we dirty with `setValue` whenever we `set` a value. Since we
used a custom equality function that will always notify, we can set it to the
collection itself again.

That should cover all of the basic functionality! If we now use `TrackedMap` in
our original example instead of `Map` everything should update and work as
expected:

```js
// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import TrackedMap from '../utils/tracked-map';

export default class Scoreboard extends Component {
  // Mock data for players - this would eventually be replaced with an argument
  // so players could be passed in
  players = [
    { name: 'Zoey' },
    { name: 'Tomster' },
  ];

  // Create a map from player -> score, with each player's score starting at 0
  scores = new TrackedMap(this.players.map(p => [p, 0]));

  @action
  incrementScore(player) {
    let currentScore = this.scores.get(player);

    this.scores.set(player, currentScore + 1);
  }
}
```
```hbs
{{#each-in this.scores |player score|}}
  <div>
    {{player.name}}: {{score}}

    <button type="button" {{on "click" (fn this.incrementScore player)}}>
      +
    </button>
  </div>
{{/each-in}}
```

## Alternatives

- Stick with higher level APIs and don't expose the primitives. This could lead
  to an explosion of high level complexity, as Ember tries to provide every type
  of construct for users to use, rather than a low level primitive.

- Expose a more functional or more object-oriented API. This would be a somewhat
  higher level API than the one proposed here, which may be a bit more
  ergonomic, but also would be less flexible. Since this is a new primitive and
  we aren't sure what features it may need in the future, the current design
  keeps the implementation open and lets us experiment without foreclosing on a
  possible higher level design in the future. It also matches with the
  previously added primitive APIs.

## Open Questions

- Should we add a `peekValue` API to check the value without entangling it? This
  API is something we've avoided doing for some time because it's very easy to
  accidentally cause bugs with it, but it's also something that is possible to
  emulate today with a little extra bookkeeping. It's something that has been
  asked for a few times as well.

- Should we add some debug tooling information as the final argument to these
  APIs? If so, what should that information be?


---

---
stage: recommended
start-date: 2020-10-02T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/671
project-link:
---

# Stop Leaking Implementation Details of Built-in Components

## Summary

In order to stop leaking implementation details of built-in components, we
propose to:

1. Deprecate importing the following modules
   1. `@ember/component/checkbox`
   2. `@ember/component/text-area`
   3. `@ember/component/text-field`
   4. `@ember/routing/link-component`
2. Deprecate accessing the following properties on the `Ember` global
   1. `Ember.Checkbox`
   2. `Ember.LinkComponent`
   3. `Ember.TextArea`
   4. `Ember.TextField`
   5. `Ember.TextSupport` (already private, no import path available)
   6. `Ember.TargetActionSupport` (already private, no import path available)
3. Deprecate calling `reopen` or `reopenClass` on the classes and mixins listed
   above, whether they were obtained through an import or the `Ember` global
4. Deprecate calling `reopen` or `reopenClass` on the `Ember.Component` super
   class (which is also the default export of `@ember/component`), but not when
   called on a subclass of `Ember.Component` other than those listed above
5. Deprecate calling `lookup` or `factoryFor` on an `Owner` with the following
   specifiers
   1. `component:input`
   2. `component:link-to`
   3. `component:textarea`
   4. `component:-checkbox` (already considered private)
   5. `component:-text-field` (already considered private)
   6. `template:component/input`
   7. `template:component/link-to`
   8. `template:component/textarea`
   9. `template:component/-checkbox` (already considered private)
   10. `template:component/-text-field` (already considered private)
6. Deprecate overriding the following factories on an `Owner`, through placing
   files the corresponding locations in the `app` tree or through any other
   means such as runtime registrations or using a custom `Resolver`
   1. `component:-checkbox`
   2. `component:-text-field`
   3. `template:component/input`
   4. `template:component/link-to`
   5. `template:component/textarea`
   6. `template:component/-checkbox` (already considered private)
   7. `template:component/-text-field` (already considered private)

## Motivation

The ultimate goal is to stop leaking implementation details of built-in
components and be able to move away from subclassing `Ember.Component` in their
internal implementations.

This RFC is part of a bigger plan to accomplish this goal, which requires at
least one other follow-up RFC. This section will attempt to provide context for
this overall plan. Please note that this RFC does not attempt to address every
problem mentioned here and should ultimately be evaluated on its own merits.

### The Problems

Ember's built-in components, that is `<Input>`, `<Textarea>` and `<LinkTo>`,
are currently implemented as subclasses of `Ember.Component`, also known as the
"classic" component API. This made sense historically, as that was the only
component API available in Ember at the time. While this is arguably an
implementation detail, in practice, this aspect of their implementations has
leaked and become relied upon.

Since then, we have identified some design flaws of the `Ember.Component` API,
which motivated the [Custom Components](0213-custom-components.md) and
[Glimmer Components](0416-glimmer-components.md) API, the latter of which
became the primary component programming model in modern Ember as of the
[Octane Edition](0364-roadmap-2018.md).

The same design flaws of `Ember.Component` that impacted Ember app developers
have also had an impact on these built-in components, and we would like to move
away from their legacy implementation for largely the same reason as Ember app
developers.

* * *

The most concerning aspect of these design flaws was that any named arguments
passed to a classic component during invocation will be set as properties on
the component instance. For example:

```hbs
{{!-- This is NOT supported, do not do this! --}}
<Input
  @init={{this.customInit}}
  @willDestroyElement={{this.customWillDestroyElement}}
/>
```

Here, the `@init` and `@willDestroyElement` arguments will be made available as
`instance.init` and `instance.willDestroyElement`, essentially replacing and
overriding the `init` and `willDestroyElement` methods on the component class,
which are part of the `Ember.Object` and `Ember.Component` API, respectively.

Clearly, this is not something that we intended to support, but it is simply a
consequence that falls out of the design of the `Ember.Component` API design.

A more likely example of this is the event handling hooks that we inherited
from `Ember.Component`. In classic components, the way to handle events on the
component's element is to implement hooks like `click()` and `keyDown()` on the
component class, which is what the implementation of the component does.

Even though these hooks considered private implementation details (and [clearly
marked as such](https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/views/lib/mixins/text_support.js#L299)),
developers have observed that they can pass callbacks into arguments of the
same name during invocation, and they will be called when the corresponding
events are dispatched to the components. For example:

```hbs
{{!-- This is NOT supported, do not do this! --}}
<Input
  @click={{this.myClickCallback}}
  @focusIn={{this.myFocusInCallback}}
  @keyDown={{this.myKeyDownCallback}}
/>
```

This is essentially the same category of bugs as passing `@init` as an
argument, but it has become relatively common practice and even made it into
the official guides at one point (this is currently being addressed).

* * *

On top of this, until [Angle Bracket Invocations](0311-angle-bracket-invocation.md)
were introduced, there was no convenient way of passing HTML attributes to a
component. Components implemented using the `Ember.Component` API relied on the
`attributeBindings` API to map instance properties to HTML attributes.

The built-in components were historically bound by the same constraints, so
they are documented to take [a large amount of HTML attributes as arguments](https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/glimmer/lib/components/text-field.ts#L62-L122).

Post-Octane, this has caused some confusion as to what should be passed as
arguments and what should be passed as HTML attributes using the angle bracket
invocation syntax. With a few rare exceptions, the latter should suffice and
the named arguments are mostly obsolete at this point.

* * *

Similarly, until [modifiers](0373-Element-Modifier-Managers.md) were available
[with Angle Bracket Invocations](0435-modifier-splattributes.md) and the
[{{on}} Modifier](0471-on-modifier.md) was introduced, there was no first-class
API for listening to DOM events on components you do not control. This required
the component authors to enumerate events they want to expose and accept them
as callback arguments, manually dispatching them in the `Ember.Component`
event-handling hooks.

The built-in components were historically bound by the same constraints here
as well. Before modifiers, the [documented way](https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/views/lib/mixins/text_support.js#L87-L108)
of handling events on the built-in input components are via the "dasherized"
named arguments, such as `<Input @key-down={{this.myAction}} />`.

However, as mentioned above, due to the way arguments are handled, the event
handling hooks inherited from `Ember.Component` were frequently misused
instead, which would prevent these "dasherized" callbacks from running, as they
would overwrite the re-dispatching logic.

On top of this, there has also been [a bug](https://github.com/emberjs/ember.js/pull/18997)
that prevented these callback arguments from working reliably. Unfortunately,
this was not investigated in a timely manner and was only fixed very recently.
This nudged developers towards the incorrect approaches even more and further
propagated the confusion, some of which has made their way into the official
learning materials (this is currently being addressed).

* * *

In addition, for a variety of historical reasons, the implementation of the
built-in components, that is, the `Checkbox`, `LinkComponent`, `TextArea` and
`TextField` component classes were documented as public API, as well as the
`TextSupport` and `TargetActionSupport` mixins, which are considered private
but are well-documented and accessible through the `Ember` global.

Because of this, the fact that they are implemented as `Ember.Component`
subclasses are highly observable. Some common use cases and consequences are:

1. These classes can be imported for subclassing. For example, an app can
   export a custom subclass of `TextField` at, say, `app/components/my-text-field.js`
   which can then be invoked as <MyTextField>.

2. These classes can be reopened to modify the behavior of the built-in
   components. For example, this will add a CSS class to all `<Input>`
   components rendered in the app:

   ```js
   import TextField from '@ember/component/text-field';

   TextField.reopen({
     classNames: ['i-am-a-text-field']
   });
   ```

   Likewise, `reopenClass` can be used to modify the class itself.

3. Similar to the above, reopening the `Ember.Component` super class will
   affect all built-in components as well. For example, this will also add a
   CSS class to all built-in components rendered in the app:

   ```js
   import Component from '@ember/component';

   Component.reopen({
     classNames: ['i-am-a-component']
   });
   ```

   Likewise, `reopenClass` can be used to modify the super class itself, which
   will be inherited by the built-in component classes.

4. It is possible to lookup (or even replace) the built-in components using the
   `owner.factoryFor` and `owner.lookup` runtime APIs.

These are all opportunities for the internal implementation to leak, therefore
making changes to how the built-in components are implemented – specifically
stop subclassing from `Ember.Component` – will likely be a breaking change for
some, even if the new implementations otherwise supported all documented APIs
perfectly.

### The Plan

At their core, the designs of the built-in components are rather simple. Take
the `<Input>` component for example, its job is to provide a convince on top of
the native `<input>` element. It accepts `@type` and `@value` (or `@checked`)
as arguments and keeps the underlying `<input>` element in sync with the given
app state.

That description should cover 90% of what the average developer need to know
about this component. It should feel pretty similar to using any other modern
components in the Ember ecosystem – attributes can be passed in angle bracket
invocation, and native events can be listened to with the `{{on}}` modifier.

There is a little bit extra this component does – it takes callbacks for some
higher-level "logical events" such as `@enter` and `@escape-press`. Arguably
these aren't strictly necessary with the ubiquity of the `{{on}}` modifier or
specialized addons like [ember-keyboard](http://adopted-ember-addons.github.io/ember-keyboard/usage).
Perhaps we wouldn't have introduced these features today, but since there is
not a direct 1:1 translation to migrate away and there aren't really anything
wrong with them, we are not proposing to remove them to avoid needless churn.

Beyond that, everything else that is now redundant or obselete (such as named
arguments that exists purely for binding HTML attributes and callback arguments
that have corresponding native events) should be deprecated and removed.

Concretely, the plan is to:

1. Deprecate and remove any mechanisms that could leak the implementation
2. Deprecate and remove any features that are specific to `Ember.Component`
3. Deprecate and remove any redundant or obselete features

This RFC focuses on the first step, and the rest will be proposed separately
in follow-up RFC(s).

## Detailed design

This RFC proposes the following deprecations:

1. Deprecate importing the following modules
   1. `@ember/component/checkbox`
   2. `@ember/component/text-area`
   3. `@ember/component/text-field`
   4. `@ember/routing/link-component`
2. Deprecate accessing the following properties on the `Ember` global
   1. `Ember.Checkbox`
   2. `Ember.LinkComponent`
   3. `Ember.TextArea`
   4. `Ember.TextField`
   5. `Ember.TextSupport` (already private, no import path available)
   6. `Ember.TargetActionSupport` (already private, no import path available)
3. Deprecate calling `reopen` or `reopenClass` on the classes and mixins listed
   above, whether they were obtained through an import or the `Ember` global
4. Deprecate calling `reopen` or `reopenClass` on the `Ember.Component` super
   class (which is also the default export of `@ember/component`), but not when
   called on a subclass of `Ember.Component` other than those listed above
5. Deprecate calling `lookup` or `factoryFor` on an `Owner` with the following
   specifiers
   1. `component:input`
   2. `component:link-to`
   3. `component:textarea`
   4. `component:-checkbox` (already considered private)
   5. `component:-text-field` (already considered private)
   6. `template:component/input`
   7. `template:component/link-to`
   8. `template:component/textarea`
   9. `template:component/-checkbox` (already considered private)
   10. `template:component/-text-field` (already considered private)
6. Deprecate overriding the following factories on an `Owner`, through placing
   files the corresponding locations in the `app` tree or through any other
   means such as runtime registrations or using a custom `Resolver`
   1. `component:-checkbox`
   2. `component:-text-field`
   3. `template:component/input`
   4. `template:component/link-to`
   5. `template:component/textarea`
   6. `template:component/-checkbox` (already considered private)
   7. `template:component/-text-field` (already considered private)

The first two sets of deprecations removes the classes themselves from being
public APIs.

In order to support apps that have implemented custom components by subclassing
these built-in classes, the current implementations of the `Ember.Checkbox`,
`Ember.LinkComponent`, `Ember.TextArea` and `Ember.TextField` classes will be
moved to a legacy addon and remain "frozen" in there. Future versions of Ember
will stop basing the built-in components on these legacy implementations, but
custom subclasses will continue to work. The deprecation message should provide
information about the legacy addon, or link to the deprecation details page
with the relevant information.

The private mixins, on the other hand, will be deprecated without replacement.

Note that in accordance with [RFC #496](0496-handlebars-strict-mode.md), the
following import paths will be made available for use in strict mode:

* `Input` (`import { Input } from '@ember/component`)
* `LinkTo` (`import { LinkTo } from '@ember/routing`)
* `Textarea` (`import { Textarea } from '@ember/component'`)

However, unlike the deprecated import paths in group 1, these modules provide
opaque values that are intended for use in templates only. Since they do not
expose the implementation details of the built-in components, these new import
paths do not have the same issue described in this RFC.

The third and forth prevents globally modifiying the behavior of built-in
components. Users are encouraged to create wrapper components for use in their
apps or create custom subclasses using the legacy addon.

The fifth deprecation prevents leakage of the classes to runtime code, which is
complimentary to the first two sets of deprecations.

The last group of deprecation prevents partially replacing the built-in
components, such as replacing only the template but not the class.

Notably, the last group of deprecation does not prevent replacing the built-in
components in general, by defining a component with the same name. While this
is not necessarily _encouraged_ and would certainly be confusing for developers
and tools alike, we do not intend to "reserve" the built-in component names, so
if an app provides a component with the same name, they will take precedence
over the built-in components.

## Transition Path

### Importing and Accessing Globals For Subclassing

Example deprecation message:

```
Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
deprecated, install the `@ember/legacy-built-in-components` addon and use
`import { Checkbox } from '@ember/legacy-built-in-components';` instead.
```

* * *

Example that causes deprecation:

```js
import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
// deprecated, install the `@ember/legacy-built-in-components` addon and use
// `import { Checkbox } from '@ember/legacy-built-in-components';` instead.

export class MyCheckbox extends Checkbox {
  // ...
}
```

Fixed example:

```js
import { Checkbox } from '@ember/legacy-built-in-components';

export class MyCheckbox extends Checkbox {
  // ...
}
```
* * *

Alternative example that triggers the deprecation:

```js
export function initialize(owner) {
  owner.register(
    'component:my-checkbox',
    Ember.Checkbox.extend({ /* ... */ })
//  ~~~~~~~~~~~~~~
// Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
// deprecated, install the `@ember/legacy-built-in-components` addon and use
// `import { Checkbox } from '@ember/legacy-built-in-components';` instead.
  );
}
```

Fixed example:

```js
import { Checkbox } from '@ember/legacy-built-in-components';

export function initialize(owner) {
  owner.register(
    'component:my-checkbox',
    Checkbox.extend({ /* ... */ })
  );
}
```

* * *

Additional prose in the deprecation guide:

> The implementation of the built-in components are no longer based on these
> legacy classes, so they are now unused by the framework and will be removed
> in the future.
>
> If you have implemented custom subclasses of these components, you can
> install the `@ember/legacy-built-in-components` addon. This addon vendors the
> legacy classes and make them available for import. See the addon's README for
> more details.
>
> Note that this addon merely makes the legacy classes available, it does not
> "restore" the built-in components' implementation to be based on these legacy
> classes.

### Reopening Legacy Built-in Component Classes

Example deprecation message:

```
Reopening Ember.Checkbox has been deprecated. Consider implementing your own
wrapper component or create a custom subclass.
```

* * *

Example that causes deprecation:

```js
import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This still triggers the deprecation from above

Checkbox.reopen({
//      ~~~~~~~
// Reopening Ember.Checkbox has been deprecated. Consider implementing your own
// wrapper component or create a custom subclass.
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
```

Fixed example:

```hbs
{{!-- app/components/my-checkbox.hbs --}}

<Input
  @type="checkbox"
  @checked={{@checked}}
  ...attributes
  data-my-metadata={{@metadata}}
/>
```

* * *

Alternative example that triggers the deprecation:

```js
import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This still triggers the deprecation from above

Checkbox.reopen({
//      ~~~~~~~
// Reopening Ember.Checkbox has been deprecated. Consider implementing your own
// wrapper component or create a custom subclass.
  change(...args) {
    console.log('changed');
    this._super(...args);
  }
})
```

Fixed example:

```js
// app/components/my-checkbox.js

import { Checkbox } from '@ember/legacy-built-in-components';

export default class MyCheckbox extends Checkbox {
  change(...args) {
    console.log('changed');
    super.change(...args);
  }
}
```

* * *

Additional prose in the deprecation guide:

> The implementation of the built-in components are no longer based on these
> legacy classes, so reopening them will soon have no effect.
>
> To customize the behavior of these built-in components, create your own
> wrapper components as a template-only component and invoke that instead.
>
> Alternatively, you may also implement your own customized version of the
> component installing the `@ember/legacy-built-in-components` addon. This
> addon vendors the legacy classes and make them available for subclassing. See
> the addon's README for more details.
>
> Note that this addon merely makes the legacy classes available, it does not
> "restore" the built-in components' implementation to be based on these legacy
> classes. You cannot simply reopen the classes provided by this addon.

### Reopening Classic Component Super Class

Example deprecation message:

```
Reopening the Ember.Component super class itself has been deprecated. Consider
alternatives such as installing event listeners on the document or add the
customizations to specific subclasses.
```

* * *

Example that causes deprecation:

```js
import Component from '@ember/component';

Component.reopen({
//       ~~~~~~~
// Reopening the Ember.Component super class itself has been deprecated. Consider
// alternatives such as installing event listeners on the document or add the
// customizations to specific subclasses.
  click() {
    console.log('Clicked on a classic component');
  }
});
```

Fixed example:

```js
document.addEventListener('click', event => {
  if (e.target.classList.contains('ember-view')) {
    console.log('Clicked on a classic component');
  }
});
```

* * *

Alternative example that triggers the deprecation:

```js
import Component from '@ember/component';

Component.reopen({
//       ~~~~~~~
// Reopening the Ember.Component super class itself has been deprecated. Consider
// alternatives such as installing event listeners on the document or add the
// customizations to specific subclasses.
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
```

Fixed example:

```js
// app/components/base.js

import Component from '@ember/component';

// Subclass from this in your app, instead of subclassing from Ember.Component
export default Component.extend({
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
```

* * *

Additional prose in the deprecation guide:

> Reopening a the `Ember.Component` super class is dangerous and has
> far-reaching consequences. For example, it may unexpectedly break addons that
> are not expecting the changes.
>
> To respond to DOM events globally, consider using global event listeners
> instead.
>
> Alternatively, you may create a custom subclass of `Ember.Component` with the
> behavior you want and subclass from that in your app. That way, only those
> components which explictly opted into the changes will be affected.

### Runtime Lookups

Example deprecation message:

```
Looking up `component:input` is deprecated. The implementations of the built-in
components are considered private and should not be relied upon. In the future,
the runtime registry will no longer contain entries for built-in components.
```

* * *

Example that causes deprecation:

```js
this.owner.lookup('component:input');
```

Fixed example:

**(None)**

### Partial Registration Override

Example deprecation message:

```
Registering `component:-checkbox` or having a `app/components/-checkbox`
module in your app is deprecated. To replace the `<Input>` built-in component,
you must fully replace it in its entirity, by registering `component:input` or
defining a `app/components/input` module.
```

* * *

Example that causes deprecation:

```js
// app/components/-checkbox.js

import Component from '@glimmer/component';

export default class MyBetterCheckbox extends Component {
  // ...only handles <Input @type="checkbox" />
}
```

Fixed example:

```js
// app/components/input.js

import Component from '@glimmer/component';

export default class MyBetterInput extends Component {
  // ...must handle all cases of <Input />
}
```

## How we teach this

The API documentation should be updated to document the built-in components as
components, not as classes. When reading the documentation, developers should
be able to understand the components in terms of what _arguments_ they are able
to pass. The exact format for documenting components is left unspecified to
provide the learning team some flexibility in accomplish this goal.

## Drawbacks

Apps that heavily customizes the built-in components will have to put in some
work to migrate, though this is largely mitigated by making the existing
implementations available through the legacy addon.

## Alternatives

* We can leave the existing built-in components around, ship new, modernized
  versions under new names, without deprecating the old ones. This will create
  more cruft and confusion in the long run, as may be difficult for developers
  to determine which ones are the recommended ones.

* We can leave the existing built-in components around, ship new, modernized
  versions under new names, and deprecating the old ones. Assuming the new
  components are roughly a subset of the existing ones, this will have more or
  less the same end result as the plan laid out above, but possibly with more
  intermediate churn.

  In this case, developers would have to figure out how to refactor away from
  legacy features that are no longer supported by the new version before they
  could fully migrate, similar to how developers are migrating from classic to
  Glimmer components today.

  By deprecating and removing individual features, as proposed in this plan, we
  will be able to provide more directly actionable guidance in each case.

* We can remove the built-in components altogether. This is a much bigger lift
  that would require analyising all existing use cases and likely requires
  designing new capabilities and features to fill some of those gaps.

  Other than the problems outlined in this RFC, the built-in components mostly
  get the job done adequately, and we feel like there is not a lot of value in
  taking on the project to reimagine them significantly and force the entire
  community to migrate to completely new patterns at this moment.

  Our preference would therefore be to pare down the existing components to
  address the problems raised here. In the meantime, we will work on providing
  primitives and capabilities that underpins these built-in components (such as
  [router helpers](0391-router-helpers.md)), so the community can experiment
  with alternatives and new patterns.

  If and when they mature to the point of becoming widely accepted as best
  practices in the ecosystem, we can revisit deprecating and removing any of
  these built-in components as they become redundant. Broadly speaking, we do
  not believe we are at that point yet, so in the meantime, we should not stop
  improving what we have.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2020-10-02T00:00:00.000Z
release-date: 2020-12-28T00:00:00.000Z
release-versions:
  ember-source: v3.24.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/673
project-link:
---

# Deprecate `tryInvoke`

## Summary

Deprecate support for `tryInvoke` in Ember's Utils module (@ember/utils) because native JavaScript has [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) for developers to use as an alternative solution. Deprecating `tryInvoke` will help to reduce Ember API redundancy.

## Motivation

In most cases, Function arguments should not be optional, but in the rare occasion that a Function argument is intentionally optional by design, we can use native JavaScript's [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) as a solution. Deprecating `tryInvoke` will help to reduce Ember API redundancy.

## Transition Path

Ember will start logging deprecation messages for `tryInvoke` usage. Deprecation text: `Using tryInvoke has been deprecated. Instead, consider using native JavaScript optional chaining.`

We can codemod our current usage of `tryInvoke` with the equivalent behaviour using plain JavaScript. The migration guide will cover this example:

Before:

```js
import { tryInvoke } from '@ember/utils';

foo() {
 tryInvoke(this.args, 'bar', ['baz']);
}
```

After:

```js
foo() {
 this.args.bar?.('baz');
}
```

#### Using Optional Chaining Operator

The optional chaining operator `?.` permits reading the value of a property located deep within a chain of connected objects without having to expressly validate that each reference in the chain is valid. The `?.` operator functions similarly to the `.` chaining operator, except that instead of causing an error if a reference is nullish (`null` or `undefined`), the expression short-circuits with a return value of `undefined`. When used with Function calls, it returns `undefined` if the given function does not exist:

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah'
  }
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// expected output: undefined
```

Tooling Support:

- [Babel](https://babeljs.io/) already supports the [optional chaining operator](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining) so we can use that for future use-cases.

- [ember-cli-babel](https://www.npmjs.com/package/ember-cli-babel) all recent versions support optional chaining operator.

- [TypeScript](https://github.com/microsoft/TypeScript), similarly, as of [version 3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining) also supports the operator so we will not be breaking that flow either.

## How We Teach This

### Add to Ember Deprecation Guide

In the [Ember Deprecation Guide](https://deprecations.emberjs.com/) we will add the following text:

Deprecate support for `tryInvoke` in Ember's Utils module (@ember/utils). In most cases, Function arguments should not be optional, but in the rare occasion that a Function argument is intentionally optional by design, we can use native JavaScript's [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) as a solution. Deprecating `tryInvoke` will help to reduce Ember API redundancy.

Before:

```js
import { tryInvoke } from '@ember/utils';

foo() {
 tryInvoke(this.args, 'bar', ['baz']);
}
```

After:

```js
foo() {
 this.args.bar?.('baz');
}
```

### Remove from API docs

The references to `tryInvoke` will need to be removed from the [API docs](https://api.emberjs.com/ember/release/functions/@ember%2Futils/tryInvoke).

### Add to Ember Guides

In [Ember Guides](https://guides.emberjs.com/release/) under the [Arguments](https://guides.emberjs.com/release/components/component-arguments-and-html-attributes/) section, we will create 2 new sub-headings called `Function Arguments` and `Optional Function Arguments`:

#### Function Arguments
Arguments passed into components can be of type [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions). In most cases, Function arguments should be treated as required arguments and therefore should be invoked with normal Function invocation `()`. It is important to intentionally treat Function arguments as required because in the off chance that the Function argument is `undefined`, normal Function invocation `()` will cause a runtime exception and produce a stack trace, making it easier for the developer to find the root cause of the bug.

```js
// app/components/parent.js
@action
fooParent() {
 // ...
}
```

```hbs
{{!-- app/components/parent.hbs --}}
<Child @bar={{this.fooParent}} />
```

```js
// app/components/child.js
fooChild() {
 this.args.bar('baz');
}
```

#### Optional Function Arguments
In the rare occasion that a Function argument is intentionally optional by design, you can use native JavaScript's [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) to invoke the optional Function argument `?.()`. We want to avoid unintentionally treating Function arguments as optional because optional chaining invocation has the side effect of failing silently with no stack trace logged. This will cause a difficult debugging experience for the developer.

```hbs
{{!-- app/components/parent.hbs --}}
<Child @bar={{this.fooParent}} />
```

```hbs
{{!-- app/components/some-other-parent.hbs --}}
<Child />
```

```js
// app/components/child.js
fooChild() {
 this.args.bar?.('baz');
}
```

## Drawbacks

This change will cause some deprecation noise but could be mitigated with a codemod.

## Alternative Solutions

We could check that the Function name exists on the object before invocation using an `if` block, but this alternative leaves the developer to have to wrap each Function call in an `if` block, making this pattern very cumbersome.

```js
foo() {
  if (typeof this.args.bar === 'function') {
    this.args.bar('baz');
  }
}
```

## Alternatives

#### Do nothing
We could keep support in place, and provide more guidance around using it.

## Unresolved questions

None at the moment.


---

---
stage: recommended
start-date: 2020-10-12T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/674
project-link:
---

# Deprecate transition methods of controller and route

## Summary

The methods `transitionTo` and `replaceWith` of the `Route` and the methods
`transitionToRoute` and `replaceRoute` of `Controller` should be deprecated.
Existing methods `transitionTo` and `replaceWith` of `RouterService` should
be used instead.

## Motivation

The main motivation is to reduce public API surface related to routing. This
will make the required refactoring of router easier as soon as the methods
have been removed.

The router is known to be poorly documented and underspecified. Especially timing
of the different APIs has been an issue in the past. Some timing related bugs
are open since years.¹

The implementation of `Router#transitionTo`, `Router#replaceWith`,
`Controller#transitionToRoute` and `Controller#replaceRoute` on one side and
`RouterService#transitionTo` and `RouterService#replaceWith` on the other side
are very different. Therefore it's very likely that they have different timings
in edge cases - even if that's not documented. Changing the timing of the
methods is considered a breaking change, which makes refactorings difficult.

Supporting different ways to do the same increases complexity without providing
much value. Especially if it's not only about true shortcuts. Supporting
transitions through `RouterService` and `<LinkTo>` component *only* will reduce
complexity for maintainers.

Additionally it reduces learning costs as new developers do not need to learn
different APIs to do the same thing. The [current guides](https://guides.emberjs.com/release/routing/defining-your-routes/#toc_transitioning-between-routes)
showcase this issue by listing all four methods existing today and when they
could be used:

> It depends on where the transition needs to take place:
>
> - From a template, use <LinkTo /> as mentioned above
> - From a route, use the transitionTo() method
> - From a controller, use the transitionToRoute() method
> - From anywhere else in your application, such as a component, inject the Router Service and use the transitionTo() method

Deprecating `Route#transitionTo` and `Controller#transitionToRoute` will reduce
this list to two options without dropping any use case.

Naming `RouterService` as the only option to trigger a transition in JavaScript
will also help with teaching Ember as a a component-service framework.
`RouterService#transitionTo` and `RouterService#replaceWith` are not only
available in `Route` and `Controller` but also in any services and components.

The current architecture might mislead developers not being aware of
`RouterService` to bubble an action up to the controller or route in order to
trigger a transition. Or pass `Controller#transitionToRoute` or
`Controller#replaceRoute` methods down to a component as an argument.

## Transition Path

`Router#transitionTo`, `Route.replaceWith`, `Controller.transitionToRoute`
and `Controller.replaceRoute` should trigger a deprecation if being used.
The deprecation message should recommend using `RouterService#transitionTo`
or `RouterService#replaceWith` instead.

```diff
  // app/route/foo.js

  import Route from '@ember/routing/route';
  import { inject as service } from '@ember/service';

  export default class FooRoute extends Route {
+   @service router;
    @service session;

    beforeModel() {
      if (!this.session.isAuthenticated) {
-       this.transitionTo('login');
+       this.router.transitionTo('login');
      }
    }
  }
```

```diff
  // app/controllers/foo.js

  import Controller from '@ember/controller';
+ import { inject as service } from '@ember/service';

  export default class FooController extends Controller {
+   @service router;
+
    @action
    async save({ title, text }) {
      let post = this.store.createRecord('post', { title, text });
      await post.save();
-     return this.transitionToRoute('post', post.id);
+     return this.router.transitionTo('post', post.id);
    }
  }
```

A codemod should be provided, which replaces the usage of `transitionTo` method
in any class that extends `Route` and `transitionToRoute` method in any class
that extends `Controller` with `this.router.transitionTo`. The same should be
done for `Route#replaceWith` and `Controller#replaceRoute`. Additionally the
`RouterService` should be injected if needed.

In case consumers face timing issues while refactoring to
`RouterService#transitionTo` and `RouterService#replaceWith` they should change
their project to be compatible with the timing provided by these two methods.
The deprecation phase should be long enough to allow all applications to adopt.
For now it's assumed that it will be enough time for all relevant projects to
migrate before *v5.0* release. The deprecation period might be increased if a
relevant number of projects weren't able to migrate before that date.

## How We Teach This

The guides need to be updated to only use `RouterService#transitionTo`,
`RouterService#replaceWith` and `<LinkTo>` component in order to trigger
a transition.

The routing guides list available option to transition between routes in
[*defining your routes* chapter](https://guides.emberjs.com/release/routing/defining-your-routes/#toc_transitioning-between-routes).
As already discussed in motivation section `Route#transitionTo` and
`Controller#transitionToRoute` should be removed from that list.

The [*redirecting* chapter](https://guides.emberjs.com/release/routing/redirection/)
of routing guides names `Route#transitionTo`, `Controller#transitionToRoute`
and `Route#replaceWith` as options to trigger a redirect. It doesn't mention
`RouterService` yet at all. It also doesn't list `Controller#replaceRoute` as
an option. This two paragraphs should be simplified by naming
`RouterService#transitionTo` and `RouterService#replaceWith` only.

The same applies to [*transitionTo* paragraph of *query parameters* chapter](https://guides.emberjs.com/release/routing/query-params/#toc_transitionto)
of routing guides. Instead of `Route#transitionTo` and
`Controller#transitionToRoute` only `RouterService#transitionTo` should be
mentioned.

Additionally `Route.transitionTo` is used in some code examples in the guides.
These should be changed to use `RouterService#transitionTo` instead.

The deprecated methods should be marked as such in the API docs.

No changes to the tutorial are needed. Transitions in the tutorial are done
using `<LinkTo>` component only.

## Drawbacks

`Route#transitionTo` is a highly used API in existing applications. Deprecating
it will very likely require changes to nearly all existing applications.

Using `RouterService` instead of methods directly available on `Route` or
`Controller` requires explicit injection of router service. This could be seen
as boilerplate code.

Some editors are able to suggest methods which are available on a class
directly which is the case for `Router#transitionTo` and the other methods
proposed for deprecation. This makes discovering them very easy. Discovering
methods only being available on services that need to be injected first, is not
that easy. Developers not being familar with the API might need to reach out
to guides or API docs to find them.

Deprecating (and later removing) these four methods will not enforce all
transitions to be triggered by either `RouterService#transitionTo`,
`RouterService#replaceWith` or `<LinkTo>`. A transition could be still
triggered by setting a controller property, which is bound to a query
parameter. But this should be addressed in a separate RFC, which reworks
registration of query parameters in general.

Ember Engines [injects `Route#transitionToExternal`, `Route#replaceWithExternal`](https://github.com/ember-engines/ember-engines/blob/v0.8.7/packages/ember-engines/addon/-private/route-ext.js)
and [`Controller#transitionToExternalRoute`](https://github.com/ember-engines/ember-engines/blob/v0.8.7/packages/ember-engines/addon/-private/controller-ext.js)
methods. These methods allow the consumer to transition between routes external
to the engine. Ember Engines [does not provide a service like `RouterService` yet](https://github.com/ember-engines/ember-engines/issues/587)
to do this. But it's [under active development](https://github.com/ember-engines/ember-engines/pull/669).

Ember Engines uses the methods deprecated by this RFC to implement
`Route#transitionToExternal`, `Route#replaceWithExternal` and
`Controller#transitionToExternalRoute`. This will trigger a deprecation warning
for all users of Ember Engines until Ember Engines is refactored to not use the
deprecated methods anymore.

While this RFC does not intend to decision how Ember Engines should address
the deprecations, it will very like force Ember Engines to deprecate
`Route#transitionToExternal`, `Route#replaceWithExternal` and
`Controller#transitionToExternalRoute` de facto in mid-term for two reasons:

1. These methods would not align anymore with the method provided by Ember to
   transition between routes.
2. Ember Engines would not be able to change the implementations of these
   methods to not use the methods deprecated by this RFC anymore. Using the
   `RouterService` would very likely change timing and other details of the
   methods, which could be seen as breaking changes. Keeping the current
   timings and other details would require usage of private method of the
   router.

## Alternatives

Three possible alternative are discovered so far:

1. Instead of deprecating `Route#transitionTo`, `Route#replaceWith`,
   `Controller#transitionToRoute` and `Controller#replaceWith` we could try to
   align their implementations to match `RouterService#transitionTo` and
   `RouterService.replaceWith` in regards to timing and other details.

   Doing so will very likely require breaking changes as existing applications
   do very likely depend onto the existing timings and other details. Even if
   not being specified and documented these details became part of our public
   API over the years.

   Therefore we would need to introduce an optional feature which allows
   applications to opt-in into the new timings as soon as they have verifed
   everything is working as expected.

2. We could introduce new methods on `Route` and `Controller`, which are true
   shortcuts for using `RouterService`. This would prevent introducing the need
   to explicitly inject `RouterService` in `Route` and `Controller` in order to
   trigger a transition. As mentioned above this could be seen as boilerplate.

   Coming up with good names for these new methods would be challening as most
   of the names has been taken already. Additionally introducing new methods on
   `Controller` and `Route` will not help with reducing public API surface and
   teaching a component-service architecture.

3. We could do nothing and continue the different ways to trigger a transition
   in JavaScript - including different timings and other details.

## Unresolved questions

No open questions have been discovered so far.

## Footnotes

1. Some example for routing related bugs which are open for quite some time
   now:

   - https://github.com/emberjs/ember.js/issues/10262
   - https://github.com/emberjs/ember.js/issues/11152
   - https://github.com/emberjs/ember.js/issues/12945
   - https://github.com/emberjs/ember.js/issues/14875
   - https://github.com/emberjs/ember.js/issues/15801
   - https://github.com/emberjs/ember.js/issues/18416
   - https://github.com/emberjs/ember.js/issues/18577
   - https://github.com/emberjs/ember.js/issues/19037

   This list does not contain a represantive list of bugs. Neither does it
   include bugs, which I verified myself. It's nothing more than a collection
   of bug reports that I found by [searching for issues containing
   *transitionTo* in ember.js repository](https://github.com/emberjs/ember.js/search?p=1&q=transitionTo&type=issues).


---

---
stage: recommended
start-date: 2020-10-04T00:00:00.000Z
release-date: 2021-11-15T00:00:00.000Z
release-versions:
  ember-source: v4.0.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/680
project-link:
---

# Implicit Injection Deprecation

## Summary

This RFC seeks to deprecate implicit injections on arbitrary Ember Framework objects. This is commonly done via `owner.inject` in an intializer or instance-initializer.

A prevalent example of implicit injection is found in `ember-data` [injecting](https://github.com/emberjs/data/blob/4bd2b327c4cbca831f9e9f8bc6b497200a212f9b/packages/-ember-data/addon/setup-container.js) their default `@ember-data/store` into all `@ember/routing/route` and `@ember/controller` factory objects. Here is a pruned example of how this looks.

```js
// app/initializers/store-inject.js
export function initialize(application) {
    application.inject('route', 'store', 'service:store');
    application.inject('controller', 'store', 'service:store');
}

export default {
    name: 'store-inject',
    initialize,
};
```

```js
export default class PostRoute extends Route {
  // This proposal seeks to make this service injection explicit
  // Currently users do not need to specify this injection if ember-data is installed
  // @service store;

  model() {
    return this.store.findRecord('post', 1);
  }
}
```

Ensuring a property is present on Ember's Framework objects should be explicitly defined. This will allow the Ember ecosystem to further progress the framework while easing the learning curve for all developers.

## Motivation

Implicit injections have long confused developers onboarding into Ember projects. Without an explicit injection visible on the class body, developers start to wonder how certain properties got there. We can infer from a common implicit injection in `ember-data` to reason about some of the downsides this presents. If a project has `ember-data` installed, an initializer at runtime registers the `@ember-data/store` on both
`@ember/routing/route` and `@ember/controller` factory objects.  This is a nice convenience for a project with many routes that are used for data fetching. However, it leads to many inconveniences that hinder learning and advancement of the framework. This includes:

1. By entangling specific objects with the whole dependency tree, we might be preventing incremental adoption. For example, `ember-data` has laid out its plan for adopting only specific packages in [Project Trim](https://github.com/emberjs/data/issues/6166). However, because `@ember-data/store` is injected by default on all `@ember/routing/route` and `@ember/controller` factory objects, a user cannot easily opt out of `@ember-data/store`. This is a common problem space in other communities as well. With previous JetBrains IDE installations, adding plugins required a reload. However, by removing a constructor function that injected all the dependencies at once, they were able to avoid reload after installation of a plugin.

2. Eager initialization of the dependency tree from which the property came from prevents tree shaking and incurs a performance hit. For example, if you app does not need `ember-data` to render the entry route, the `@ember-data/store` injection will take up more CPU cycles than necessary, hurting common user facing metrics.

3. Eager initialization makes it hard to users to write tests that need to take advantage of a stub. This is often a silent and annoying hurdle that users have to get around when writing tests. Moreover, this is especially apparent for users moving to Ember's new testing APIs in [RFC 232](https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md) and [RFC 268](https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md), ensuring instance initializers run before each test.

4. Injection on commonly used framework objects can lead to deviation of project specific styleguides. For instance, injecting the `router` on the `@ember/component` factory object will certainly lead to instances where the `router` is explicitly injected and other instances where is it implicitly injected.

5. Users have come to associate `Route.model()` with a hook that returns `ember-data` models in the absense of explicit injection. While this can be true, it is not wholly true. New patterns of data loading are becoming accepted in the community including opting to fetch data in a Component.


## Detailed design

Removing implicit injections is not possible until we first issue deprecations. For example, `@ember/data` cannot remove its `owner.inject` without it being a breaking change. In doing so, deprecating first helps us maintain our strict semver commitment to not completing a major version bump and removing APIs without a deprecation path. As a result, it will take us 3 phases to remove `owner.inject`.

### 1. Deprecate implicit injection on target object

Simply deprecating `owner.inject` is not sufficient because it is very difficult to detect if you are relying on implicit injection. As a result, the first step will be issuing a deprecation on the target factory object that is receiving a property. This will surface the deprecation on user's owned objects including transitively through addons like `ember-data`. This can be accomplished by installing a native getter and setter on the target.

The _first time_ the property is accessed, either through getting or setting it, we will check if the property is explicitly injected. If it isn't, we will issue a deprecation in DEBUG builds with an until, id and url value to read more about this deprecation. In production, we will not issue this deprecation and will continue assigning the property. This deprecation will go `until: 4.0.0`.

To avoid this deprecation, you will need to explicitly add the injected property to the target object.  As an example, you can add `@service store` to your route or controller to avert this deprecation resulting from `@ember/data`'s use of `owner.inject`.  Users and addons can remove implicit injections as well.

Ember.js `v4.0.0` will still be released with `owner.inject`. However, it will not doing anything. Effectively a no-op.

### 2. Deprecate `owner.inject`.

The first phase did not actually deprecate the use of `owner.inject`.  As a result, we need to deprecate it's use directly iin `v4.0.0` before removing completely in `v5.0.0`.

For users and or addons, you likely already have removed implicit injections like `owner.inject` before upgrading to Ember.js `v4.0.0`.  However, for libraries like `@ember/data`, we will look to remove sometime in `v4.0.0` to resolve this new deprecation.

### 3. Profit!

Ember.js `v5.0.0` will finally remove the ability to call `owner.inject` to inject arbitrary properties on Ember's Framework objects.

It is important to consider the timeline of these three phases.  The first step will consist of a minimum of one release cycle.  Many addons and apps will need to make minor and major changes to their codebases before `v4.0.0`.

### Impementation Constraints

An important implementation detail of stage 1 of this RFC is that while we want
to issue a deprecation when the user relies on the implicit injection, we also
_must_ ensure that the implicit injection still "wins" and is assigned to the
value on the class, clobbering the explicit injection, for the time being. This
is the current behavior, and changing it, even in development builds, would be a
breaking change.

The proposed way to implement this is when an object with implicit injections is
created, for each implicit injection:

1. If the property already contains the value, do nothing as it has been setup
   eagerly by the user
2. If the property is a service injection, check that it is the correct service
   injection and if it is, do nothing and assign the value like normal
3. If the property is a native getter/setter, wrap the native getter/setter and
   the first time the value is accessed, check to see if it is the injected
   value. If it is, do nothing, otherwise log the deprecation.
4. If the property is not defined on the object or its prototype, install a
   getter/setter pair which log the deprecation the first time they are
   activated.

This should preserve the existing semantics while logging when the user is
accessing a value that was injected implicitly.

## How we teach this

The API docs would need to be overhauld in a few spots. First, we need to remove the [docs](https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-injections) about Factory injections. Second, we need to detail explicit injection where currently relying on implicit injection.  Many examples show fetching data via `this.store` but do not specifiy how `this.store` arrived as a property on the Route. Also apparent disclaimers for people visiting the `ember-data` docs that explicit injection of `@ember-data/store` is necessary and has deviated from past behaviour is likely prudent.

The default blueprints when generating a new Ember application will not change.

### Deprecation Guides

#### Stage 1

Implicit injections are injections that are made by telling Ember to inject a
service (or another type of value) into every instance of a specific type of
object. A common example of this was the `store` property that was injected into
routes and controllers when users installed Ember Data by default.

```js
export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
```

Notice how the user can access `this.store` without having declared the store
service using the `@service` decorator. This was accomplished by using the
`owner.inject` API, usually in an initializer:

```js
export default {
  initialize(app) {
    app.inject('route', 'store', 'service:store');
    app.inject('controller', 'store', 'service:store');
  }
}
```

Implicit injections are difficult to understand, both because it's not obvious
that they exist, or where they come from.

In general, in order to migrate away from this pattern, you should use an
explicit injection instead of an implicit one. You can do this by using the
`@service` decorator wherever you are using the implicit injection currently.

Before:

```js
import { Route } from '@ember/routing/route';

export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
```

After:

```js
import { Route } from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service store;

  model() {
    return this.store.findQuery('user', 123);
  }
}
```

In some cases, you may be using an injected value which is not a service.
Injections of non-service values do not have a direct explicit-injection
equivalent. As such, to migrate away from these, you will have to rewrite the
injection to use services instead.

Before:

```js
// app/initializers/logger.js
import EmberObject from '@ember/object';

export function initialize(application) {
  let Logger = EmberObject.extend({
    log(m) {
      console.log(m);
    }
  });

  application.register('logger:main', Logger);
  application.inject('route', 'logger', 'logger:main');
}

export default {
  name: 'logger',
  initialize: initialize
};
```
```js
// app/routes/application.js
export default class ApplicationRoute extends Route {
  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
```

After:

```js
// app/services/logger.js
import Service from '@ember/service';

export class Logger extends Service {
  log(m) {
    console.log(m);
  }
}
```
```js
// app/routes/application.js
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service logger;

  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
```

In cases where it is not possible to convert a custom injection type into a
service, the value can be accessed by looking it up directly on the container
instead using the [lookup](https://api.emberjs.com/ember/3.22/classes/ApplicationInstance/methods/lookup?anchor=lookup)
method:

```js
// app/routes/application.js
import { getOwner } from '@ember/application';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  get logger() {
    if (this._logger === undefined) {
      this._logger = getOwner(this).lookup('logger:main');
    }

    return this._logger;
  }

  set logger(value) {
    this._logger = value;
  }

  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
```

You should always include a setter until the implicit injection is removed,
since the container will still attempt to pass it into the class on creation,
and it will cause errors if it attempts to overwrite a value without a setter.

### Stage 2

The `owner.inject` API would previously inject a values into every instance of a
particular type of class. For instance, you could inject the `store` service
automatically into every controller and route:


```js
export default {
  initialize(app) {
    app.inject('route', 'store', 'service:store');
    app.inject('controller', 'store', 'service:store');
  }
}
```

And in doing so, users could use the value without explicitly declaring it in
that type of object, using `@service`:

```js
import { Route } from '@ember/routing/route';

export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
```

This ability was deprecated and removed in Ember v4.0.0, so users no longer can
do this, even if you are using the `owner.inject` API. It instead does nothing,
so you can safely remove it without any other changes necessary.

## Alternatives

- Continue with use of `owner.inject` but overhaul docs and recommend explicit injection.
- Provide application level super class with a default `@ember-data/store` injection provided by `ember-data` and other common examples in the community.
- Allow injection on a specific factory with a single backing Class instead of a generic factory object (e.g. `route` vs `route.index`).

## Open Questions

- Should we simply replace the [docs](https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-injections) on Factory Injections without an alternative?

## Related links and RFCs
- [Deprecate defaultStore located at `Route.store`](https://github.com/emberjs/rfcs/issues/377)
- [Pre-RFC: Deprecate implicit injections (owner.inject)](https://github.com/emberjs/rfcs/issues/508)
- [Deprecate implicit record loading in routes](https://github.com/emberjs/rfcs/issues/557)


---

---
stage: released
start-date: 2020-11-28T00:00:00.000Z
release-date: 2021-11-15T00:00:00.000Z
release-versions:
  ember-source: v4.0.0

teams:
  - framework
  - data
  - cli
  - learning
  - typescript
  - steering
prs:
  accepted: https://github.com/emberjs/rfcs/pull/685
project-link:
---

# New Browser Support Policy

## Summary

Establishes a new browser support policy for the next major release of Ember and
Ember Data.

## Motivation

With Microsoft's recent release of the new Chromium-based Edge browser, which
has a compatibility mode for Internet Explorer built in, many frameworks, tools,
libraries, and websites have begun finally dropping support for the aging
browser. In order to unlock the latest browser features and continue improving
the framework as a whole, Ember should also drop support in the next major
release.

In dropping support for Internet Explorer, we will need a new browser support
policy. Until now Internet Explorer has been the "lowest common denominator"
for all features. It is a very old browser that no longer releases new versions,
and was not "evergreen" (e.g. constantly updating) even when it was. As such,
Ember has been very stable from release to release, as supporting any version of
Internet Explorer meant we simply could not use any new browser features.

With modern evergreen browser release cycles, where browsers release regularly
and users are generally on one of the more recent versions of a browser, this
dynamic changes. We cannot set an explicit version to support anymore, because
it would be impractical - Chrome alone releases a new version every 6 weeks.
Setting an explicit lowest-supported-version would lock us into having to
support a huge number of older browsers, many of which are entirely unused.

Conversely, however, tracking the latest release of a browser may not be enough
stability for Ember apps. If Ember were to adopt a new browser feature
immediately after its release, even though many web users were still using a
previous version, it would cause many Ember apps to either break, or be unable
to update until their users had also updated to the latest browser. Even a
rolling `N - 1` or `N - 2` support policy, where the last 1 or 2 versions are
supported, may not be enough. Many users were stuck in the recent Edgium update
for some time, for instance.

This RFC seeks to establish a new support policy that addresses these issues
with a new set of heuristics. These heuristics distinguish between two types of
browsers which are supported:

- **Evergreen browsers**, those which have adopted a continuous update policy
  and generally keep their users up-to-date automatically.
- **Non-evergreen browsers**, which have more complicated support patterns that
  may prevent users from updating regularly.

Depending on which category a browser falls into, different rules will be
applied. This will allow us to effectively support browsers which release
frequently, such as Chrome, and browsers which do not, such as Safari.

## Proposed policy

In the new support policy, Ember will support the following browsers:

- Desktop
  1. Google Chrome
  2. Mozilla Firefox
  3. Microsoft Edge
  4. Safari
- Mobile
  1. Google Chrome
  2. Mozilla Firefox
  3. Safari
- Testing
  1. Headless Chrome
  2. Headless Firefox

Any browser which is not listed here may work, but is not explicitly supported.

In addition, these browsers have been categorized into _evergreen_ and
_non-evergreen_ browsers, which have different support policies. This categories
have been chose arbitrarily, based on the current state of browsers and their
support policies.

- Evergreen
  - Desktop
    1. Google Chrome
    2. Chromium
    3. Mozilla Firefox
    4. Microsoft Edge
  - Mobile
    1. Google Chrome
    2. Mozilla Firefox
  - Testing
    1. Headless Chrome
    2. Headless Firefox

- Non-evergreen
  - Desktop
    1. Safari
  - Mobile
    1. Safari

This categorization will _not_ change without an additional RFC, even if the
browsers themselves make significant changes to their own release process or
support system.

#### Heuristics for browser categorization

As mentioned above, the evergreen and non-evergreen categorization is ultimately
arbitrary. However, there were some heuristics which were used to categorize the
supported browsers at the time this RFC was made:

1. **Evergreen browsers** are browsers that:

   - Support using the latest version on all supported platforms (e.g. you can
     use the latest Chrome an any supported version of Windows, macOS, Android,
     etc. The browser is versioned independently from the operating system).
   - Automatically update whenever a new version is available.

2. **Non-evergreen browsers** are any browsers which do not meet the
   criteria of evergreen browsers. For instance, Safari is a supported browser
   whose version is tied to the version of macOS and iOS that users use. As
   users will often wait to update their operating system, many users lag behind
   on the version of Safari they are using, so it cannot be considered
   evergreen.

### Evergreen browsers

For a given Ember and Ember Data minor release, the minimum major version
supported for a given browser is determined using the following formula.

- Whichever browser version is greater/more recent out of:
  1. The lowest/least recent version that fulfills any one of these properties
    - It is the latest version of the browser.
    - It is the latest LTS/extended support version of the browser (such as Firefox ESR).
    - It has at least **0.25%** of global marketshare usage across mobile and
      desktop, based on [statcounter](https://gs.statcounter.com/).
  2. The minimum version supported in the previous release

Within a major version of a browser, the latest patch release is the only
release that is supported.

This policy has the following attributes:

- It allows us to generally support the most recent browser versions, which
  are typically used for some time before everyone upgrades
- It allows us to support browser versions that become temporary "speedbumps"
  that take longer for users to update, such as the last non-Chromium version of
  MS Edge.
- It prevents backsliding, once a version is no longer supported, it never
  becomes supported again.

Above all else, this policy is easy to communicate - for every minor release, we
calculate the minimum supported version, and then communicate that we support
all versions >= that version.

It is important to note that this policy means that each minor release _may_
drop support for some major versions of evergreen browsers.

### Non-evergreen browsers

Ember and Ember Data will support all major versions greater than or equal to
the following version for non-evergreen browsers:

- Desktop
  - Safari: 12
- Mobile
  - Safari: 12

These versions will continue to be supported until support is explicitly dropped
via a new RFC, and dropping support for any version of these browsers will
require a new **major** release.

Within a major version of a browser, the latest patch release is the only
release that is supported.

#### Note on the versions chosen

iOS Safari 12 has a usage of ~1.5% globally as of the writing of this RFC. Given
this, and the fact that newer versions of Safari do not introduce any major
features, 12 seems like an acceptable cutoff at this time.

### What support means

This policy governs two major aspects of Ember and Ember Data:

1. When the framework adopts new browser features
2. How the framework responds to bug reports

Ember and Ember Data _may_ introduce new browser feature usage in any _minor_
version release of Ember, provided the feature is supported in all browsers that
are supported in this policy at the time the the version in released.

Ember and Ember Data _may_ introduce new browser feature usage in any _patch_
version release of Ember, provided the feature is supported in all browsers that
were supported in this policy at the time the _minor_ that the patch is applied
to was released. In other words, no breakage can or should occur due to new
browser feature usage in _any_ patch release, and if it does, it is a bug.

For bug reports, support is determined by combining our existing Ember version
support policy with the browser versions that were supported at the time an
Ember version was released. This means Ember will work as time and resourcing is
available to fix any browser specific issues that occur in:

1. The current stable and LTS releases of Ember and Ember Data
2. For browsers that were supported by those versions when they were relased

For the previous LTS release, only security bugfixes will be supported,
following the existing LTS policy.

### Future changes to the policy

This policy is not meant to be immutable. Over time, new browsers could be added
to the support matrix, and explicit exceptions could be added for "critical
internet infrastructure".

For example, it was well known that Google's search crawler used a very old
version of Google Chrome for a very long time. It no longer does and is
regularly updated, but during that time frame it was important to support that
version of Chrome. Likewise, it was very important to support IE11 for a very
long time since it had a large usage percentage, especially in corporate
environments. While none of these cases are known to exist at the time of this
writing, if one should arise it may be added explicitly via RFC.

Future RFCs may amend this policy in a strictly additive way without requiring
a major version bump in Ember. Newly supported browsers will begin being
supported in the next minor version of Ember after the updated support policy is
implemented.

Future RFCs that amend this policy to _remove_ support for a browser will
_require_ a major version of Ember to implement.

### Impact on SemVer

While this policy does result in us dropping support for versions of browsers
with each minor release, this RFC proposes that this should not have an impact
on our SemVer policy. SemVer is a communication mechanism, which is used to
communicate to users when impactful changes occur, and what those changes are in
broad categories: breaking, new features, bugfixes.

While dropping support for an evergreen browser version could be considered
breaking in the strictest technical sense, it generally is not considered one
because of the usage patterns that these browsers have in the first place. Their
users are automatically opted into updating every time they boot the browser,
which means in almost all cases users update quickly and efficiently. In fact,
it is often considered a _security issue_ if users are _not_ using the most
recent version of an evergreen browser.

As such, the fact is that in most cases, if a bug is somehow reported on an
older version of an unsupported browser, then the fix is usually to tell the
user to update the browser version, not to patch the application or framework
for that browser version. In practice, this is how Ember has operated for years,
and this policy only formalizes this process.

## Implementation

In order to support this policy while keeping all of our tooling on the same
page, Ember.js itself will add automation to calculate the current minimum
supported version of browsers on its main branch, and publish them in an
accessible format. Each time we branch a release, these versions will stop
updating, so they will effectively be locked in.

These versions will be used for a variety of use cases, such as generating
documentation and release blog posts (see below), and generating the default
`config/targets.js` for new Ember apps and addons.

### Deprecation

We will add a deprecation to Ember CLI that shows when users have any
unsupported browser in there `targets.json`, along with a guide for updating to
modern targets.

### Implementation timeline

This policy drops support for a major browser, and therefore can only be
implemented with a major version bump.

## How we teach this

This will be an ongoing process, since the minimum browser versions supported
change over time. The most important thing here is that users can easily
determine whether or not a given version of a browser is supported for a given
Ember release.

The following are the ways we will communicate this:

- For the release blog post for a minor version, we'll include a table which has
  the list of every supported browser, along with the minimum supported major
  version of that browser for the release. We will also include the underlying
  engine version.
- On the [releases page](https://emberjs.com/releases) of the Ember.js website,
  for each of the listed releases, we will include a table of the supported
  versions major browsers for that release.
- The browser support on the releases page for the Stable and LTS branches will
  be linked in the Ember.js README.

This documentation will be supported by the minimum supported versions that are
published in the Ember.js package (see above), which will allow them to be
mostly automated. The supported browser table could look like the following
(generated using today's usage stats):

### Supported Browsers

#### Desktop

| Chrome | Edge | Firefox  | Safari |
| ------ | ---- | -------- | ------ |
| 83     | 18   | 78 (ESR) | 12     |

#### Mobile

| Chrome | Firefox | Safari |
| ------ | ------- | ------ |
| 87     | 83      | 12     |

#### Headless

| Chrome | Firefox  |
| ------ | -------- |
| 87     | 78 (ESR) |

### "How we determine support" page

In addition, the technical details of the support policy should be documented on
the Ember website, in a less prominent position (e.g. a link from the supported
versions table titled "how do we determine browser support?"). This could use
the following text:

Ember supports the following major browsers:

- Desktop
  1. Google Chrome
  2. Mozilla Firefox
  3. Microsoft Edge
  4. Safari
- Mobile
  1. Google Chrome
  2. Mozilla Firefox
  3. Safari
- Testing
  1. Headless Chrome
  2. Headless Firefox

Other browsers may work with Ember.js, but are not explicitly supported. If you
would like to add support for a new browser, please [submit an RFC or RFC issue for discussion](https://github.com/emberjs/rfcs)!

We determine support on a browser-by-browser basis. Browsers are categorized as
either **evergreen** or **non-evergreen**. The categorization is as follows:

- Evergreen
  - Desktop
    1. Google Chrome
    2. Chromium
    3. Mozilla Firefox
    4. Microsoft Edge
  - Mobile
    1. Google Chrome
    2. Mozilla Firefox
  - Testing
    1. Headless Chrome
    2. Headless Firefox

- Non-evergreen
  - Desktop
    1. Safari
  - Mobile
    1. Safari

For evergreen browsers, the minimum version of the browser that we support is
determined at the time of every minor release, following this formula:

- Whichever browser version is greater/more recent out of:
  1. The lowest/least recent version that fulfills any one of these properties
    - It is the latest version of the browser.
    - It is the latest LTS/extended support version of the browser (such as Firefox ESR).
    - It has at least **0.25%** of global marketshare usage across mobile and
      desktop, based on [statcounter](https://gs.statcounter.com/).
  2. The minimum version supported in the previous release

To simplify, the supported version either moves forward or stays the same for
each release based on overall usage and LTS/current release versions.

For non-evergreen browsers, support is locked at a specific major version, and
we support all major versions above that version:

- Desktop
  - Safari: 12
- Mobile
  - Safari: 12

Within a version of a browser, we only support the most recent patch release.

## Drawbacks

- The proposed policy makes Safari the new "lowest common denominator" browser,
  replacing IE11. Since the supported versions of Safari will continue to be
  supported indefinitely, we will not be able to use any new browser features
  added afterwards without another major version. In particular, the spec for
  `WeakRef` has finally been stabilized, and this is something we'll likely want
  to make use of in the not-to-distant future.

  While this is true, it does not impact the immediate roadmap for Ember in the
  next few years. When the time comes, we can update our browser support policy
  again, and release a new major version.

## Alternatives

- Keep things as they are.
- Document the existing policy but do not change it.
- Support fewer browsers, for a shorter amount of time.
- Support more browsers, for a longer amount of time.
- Drop IE11 but not add more definition to support (keeping it as a case by case
  determination by the core teams)


---

---
stage: recommended
start-date: 2020-11-28T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/686
project-link:
---

# Deprecate Old Manager Capabilities

## Summary

Deprecate older capabilities versions from the various manager APIs.

## Motivation

In the 3.x cycle, Ember introduced a series of new low-level APIs for managing
template constructs:

- [Component managers](https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md)
- [Modifier managers](https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md)
- [Helper managers](https://github.com/emberjs/rfcs/blob/master/text/0625-helper-managers.md)

These APIs were expected to evolve more quickly than the higher level APIs they
enabled, and they have in fact done so. They do this via the `capabilities`
mechanism, where users can specify a version of capabilities that they want.
This allows Ember to change these APIs as needs evolve, as long as the prior
capabilities can still be maintained.

Maintaining the prior capabilities versions has a cost however in terms of
maintenance burden, and sometimes requires us to keep around a decent amount of
extra code or internal features. Deprecating these versions for the next major
release will help clean up code internally overall.

## Transition Path

Users should update to the most recent manager versions, which will not be
deprecated. The versions which are being deprecated include:

- Component Managers
  - 3.4
- Modifier Managers
  - 3.13

The versions that are still supported are:

- Component Managers
  - 3.13
- Modifier Managers
  - 3.22
- Helper Managers
  - 3.23

## How We Teach This

In general, the guides won't need to be updated as there isn't guide material
for these manager APIs. We should update the API docs for them to remove the
deprecated capabilities versions. In addition, we should add deprecation guides
for each of the deprecated versions.

Guides as follows.

### Component Managers

#### 3.4

Any component managers using the `3.4` capabilities should update to the most
recent component capabilities that are available, currently `3.13`. In `3.13`,
the only major change is that update hooks are no longer called by default. If
you need update hooks, use the `updateHook` capability:

```js
capabilities({
  updateHook: true,
});
```

### Modifier Managers

#### 3.13

Any modifier managers using the `3.13` capabilities should update to the most
recent modifier capabilities, currently `3.22`. In `3.22`, the major changes
are:

1. The modifier definition, associated via `setModifierManager` is passed
   directly to `create`, rather than a factory wrapper class. Previously, you
   would access the class via the `class` property on the factory wrapper:

   ```js
   // before
   class CustomModifierManager {
     capabilities = capabilities('3.13');

     createModifier(Definition, args) {
       return new Definition.class(args);
     }
   }
   ```

   This can be updated to use the definition directly:

   ```js
   // after
   class CustomModifierManager {
     capabilities = capabilities('3.22');

     createModifier(Definition, args) {
       return new Definition(args);
     }
   }
   ```

2. Args are both lazy and autotracked by default. This means that in order to
   track an argument value, you must actually use it in your modifier. If you do
   not, the modifier will not update when the value changes.

   If you still need the modifier to update whenever a value changes, even if it
   was not used, you can manually access every value in the modifiers
   `installModifier` and `updateModifier` lifecycle hooks:

   ```js
   function consumeArgs(args) {
     for (let key in args.named) {
       // consume value
       args.named[key];
     }

     for (let i = 0; i < args.positional.length; i++) {
       // consume value
       args.positional[i];
     }
   }

   class CustomModifierManager {
     capabilities = capabilities('3.22');

     installModifier(bucket, element, args) {
       consumeArgs(args);

       // ...
     }

     updateModifier(bucket, args) {
       consumeArgs(args);

       // ...
     }
   }
   ```

   In general this should be avoided, however, and users who are writing
   modifiers should instead use the value if they want it to be tracked by the
   modifier.

## Drawbacks

- There will be some minor churn in the ecosystem as managers update, but this
  is outweighed by the lowered maintenance burden in general for this
  functionality.

## Alternatives

- Maintian capabilities versions indefinitely. This is not really feasible, as
  more and more changes will likely happen over time and eventually it will
  result in a large maintenance burden.


---

---
stage: released
start-date: 2020-12-22T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/689
project-link:
---

# Deprecate `{{hasBlock}}` and `{{hasBlockParams}}` in templates

## Summary

Deprecate the `{{hasBlock}}` and `{{hasBlockParams}}` properties in templates in
favor of the `{{has-block}}` and `{{has-block-params}}` keywords.

## Motivation

`{{hasBlock}}` is a way to check if component has a default block provided to
it, and `{{hasBlockParams}}` is a way to check if that default block has block
parameters. They are effectively aliases for calling `{{has-block}}` and
`{{has-block-params}}` respectively, without providing a block name or with the
block name `"default"`. They are also not called, and acts like a template
fallback lookup instead.

```hbs
{{! hasBlock and hasBlockParams can be referenced directly }}
{{#if hasBlock}}{{/if}}

{{#if hasBlockParams}}{{/if}}


{{! has-block and has-block-params must be called }}
{{#if (has-block)}}{{/if}}

{{#if (has-block-params)}}{{/if}}
```

Having two ways of accomplishing this task is confusing, and with the property
form it is not possible to check if other blocks exist, such as named blocks. As
such, this RFC proposes that we deprecate `{{hasBlock}}` and
`{{hasBlockParams}}` and recommend that users switch to using `{{has-block}}`
and `{{has-block-params}}`.

## Transition Path

Users who are currently using `{{hasBlock}}` or `{{hasBlockParams}}` will need
to replace all of their usages with `{{has-block}}`/`{{has-block-params}}`
respectively. This is generally a very codemoddable change, so it should be
pretty straightforward to accomplish, and we will attempt to make a codemod to
help out with the transition.

## How We Teach This

Currently, `{{hasBlock}}` and `{{hasBlockParams}}` are documented in the API docs,
but `{{has-block}}` and `{{has-block-params}}` are not. The new keywords should
be thoroughly documented.

### Deprecation Guide

#### `{{hasBlock}}`

The `{{hasBlock}}` property is true if the component was given a default block,
and false otherwise. To transition away from it, you can use the `(has-block)`
helper instead.

```hbs
{{hasBlock}}

{{! becomes }}
{{has-block}}
```

Unlike `{{hasBlock}}`, the `(has-block)` helper must be called, so in nested
positions you will need to add parentheses around it:

```hbs
{{#if hasBlock}}

{{/if}}


{{! becomes }}
{{#if (has-block)}}

{{/if}}
```

You may optionally pass a name to `(has-block)`, the name of the block to check.
The name corresponding to the block that `{{hasBlock}}` represents is "default".
Calling `(has-block)` without any arguments is equivalent to calling
`(has-block "default")`.

#### `{{hasBlockParams}}`

The `{{hasBlockParams}}` property is true if the component was given a default block,
and false otherwise. To transition away from it, you can use the `(has-block-params)`
helper instead.

```hbs
{{hasBlockParams}}

{{! becomes }}
{{has-block-params}}
```

Unlike `{{hasBlockParams}}`, the `(has-block-params)` helper must be called, so in nested
positions you will need to add parentheses around it:

```hbs
{{#if hasBlockParams}}

{{/if}}


{{! becomes }}
{{#if (has-block-params)}}

{{/if}}
```

You may optionally pass a name to `(has-block-params)`, the name of the block to check.
The name corresponding to the block that `{{hasBlockParams}}` represents is "default".
Calling `(has-block-params)` without any arguments is equivalent to calling
`(has-block-params "default")`.

## Drawbacks

- Introduces some churn.

- `(has-block)` is dasherized, which is not inline with the future of strict
  mode and template imports. Dasherized strings are not valid identifiers in
  JavaScript, so helpers and modifiers will likely switch to camel case when
  that transition occurs.

  This actually makes this deprecation even more valuable. As it stands, even if
  we wanted to use `{{hasBlock "name"}}` in templates, we could not, since
  `{{hasBlock}}` already has semantics and is not callable. By deprecating this
  syntax, we can reclaim it in the future as a possible alias for the dasherized
  version.

## Alternatives

- Keep the existing syntax as an alias for `(has-block)`/`(has-block-params)`.


---

---
stage: recommended
start-date: 2020-12-22T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/690
project-link:
---

# Deprecate using `{{attrs}}` in templates

## Summary

The `{{attrs}}` object in templates is an alternative way for users to reference
named arguments directly in a template.

```hbs
{{attrs.foo}}

{{! is equivalent to }}
{{@foo}}
```

It was a legacy API that existed prior to named arguments being introduced in
Ember, and has continued to be supported via a template transform for some time.
This RFC proposes that we deprecate this functionality in favor of directly
using named arguments.

## Motivation

The `{{attrs}}` syntax was from a previous iteration of the concepts that
eventually became named argument syntax. Now that named arguments exist in the
framework, and are considered the best practice, there is no reason to continue
supporting this syntax.

## Transition Path

Users who currently rely on referencing `{{attrs}}` can convert their references
to named arguments. This should be highly codemoddable, and we will attempt to
make a codemod to help out with the transition.

## How We Teach This

### Deprecation Guide

The `{{attrs}}` object was an alternative way to reference named arguments in
templates that was introduced prior to named arguments syntax being finalized.
References to properties on `{{attrs}}` can be converted directly to named
argument syntax.

Before:

```hbs
{{attrs.foo}}
{{this.attrs.foo.bar}}
{{deeply (nested attrs.foobar.baz)}}
```

After:

```hbs
 {{@foo}}
 {{@foo.bar}}
 {{deeply (nested @foobar.baz)}}
 ```

## Drawbacks

- None


---

---
stage: recommended
start-date: 2020-12-22T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/691
project-link:
---

# Deprecate passing `classBinding` and `classNameBindings` as arguments

## Summary

In Ember today, it is possible to pass `classBinding` and `classNameBindings` as
arguments to a component when invoked with curly syntax.

```hbs
{{some-component classNameBindings="foo:truthy:falsy"}}
```

These arguments are merged into the `class` attribute on the class, regardless
of whether or not the component is a classic component which contains the
`classNameBindings` logic. It is also fully possible to accomplish with template
syntax in alternative ways, so this RFC proposes deprecating them.

## Motivation

`classBinding` and `classNameBindings` are Classic component APIs for
manipulating the class name of the element that wraps the component. These were
"merged properties" on classic components historically, which meant that rather
than overwriting the values, they would merge into the superclass when extending
a class. And for _instances_ of components this was also true, so passing it as
an argument into a component instance would _add_ the name bindings to the
class, rather than replacing them.

At some point, the ability for merging on the instance itself was removed. In
its place, a general template transform was added, which transformed the
`classBinding` and `classNameBindings` args into the `class` argument, with the
same semantics.

```hbs
{{some-component class="bar" classNameBindings="foo:truthy:falsy"}}

{{! becomes }}
{{some-component class=(concat "bar " (if this.foo "truthy" "falsy"))}}
```

Note the conversion of the `foo` string into a path in the local context,
something that is very much unexpected in modern Ember applications.

The output here is a bit cumbersome to write, which may be why the original
syntax was kept. However, with angle bracket invocation, we can now write this
in a much cleaner way:

```hbs
<SomeComponent class="bar {{if this.foo "truthy" "falsy"}}" />
```

Given these alternatives, it doesn't make sense any longer to continue
supporting this transform, _especially_ given that it also affects components
which do not even support `classNameBindings`, such as Glimmer components. Since
`class` in this case is an _argument_ and not an attribute, and since this only
affects curly components, it is unlikely that anyone is actually relying on this
behavior, but removing this incongruity seems like the best course of action.

## Transition Path

In general, users should convert to use angle bracket syntax to invoke their
component, and then use standard interpolation within the `class` attribute of
the component. In cases where this is not possible/desired, users can continue
using curly invocation with `(concat)` to pass the value.

## How We Teach This

### Deprecation Guide

`classBinding` and `classNameBindings` can currently be passed as arguments to
components that are invoked with curly invocation. These allow users to
conditionally bind values to the `class` argument using a microsyntax similar to
the one that can be defined in a Classic component's class body:

```js
import Component from '@ember/component';

export default Component.extend({
  classNameBindings: ['isValid:is-valid:is-invalid']
});
```

```hbs
{{my-component classNameBindings="isValid:is-valid:is-invalid"}}
```

Each binding is a triplet separated by colons. The first identifier in the
triplet is the value that the class name should be bound to, the second
identifier is the name of the class to add if the bound value is truthy, and the
third value is the name to bind if the value is falsy.

These bindings are additive - they add to the existing bindings that are on the
class, rather than replacing them. Multiple bindings can also be passed in by
separating them with a space:

```hbs
{{my-component
  classBinding="foo:bar"
  classNameBindings="some.boundProperty isValid:is-valid:is-invalid"
}}
```


These bindings can be converted into passing a concatenated string into the
class argument of the component, using inline `if` to reproduce the same
behavior. This is most conveniently done by converting the component to use
angle-bracket invocation at the same time.

Before:

```hbs
{{my-component
  classBinding="foo:bar"
  classNameBindings="some.boundProperty isValid:is-valid:is-invalid"
}}
```

After:

```hbs
<MyComponent
  class="
    {{if this.foo "bar"}}
    {{if this.some.boundProperty "bound-property"}}
    {{if this.isValid "is-valid" "is-invalid"}}
  "
>
```

Note that we are passing in the `class` attribute, not the `class` argument. In
most cases, this should work exactly the same as previously. If you referenced
the `class` argument inside of your component, however, you will need to pass
`@class` instead.

If you do not want to convert to angle bracket syntax for some reason, the same
thing can be accomplished with the `(concat)` helper in curly invocation.

```hbs
{{my-component
  class=(concat
    (if this.foo "bar")
    " "
    (if this.some.boundProperty "bound-property")
    " "
    (if this.isValid "is-valid" "is-invalid")
  )
}}
```

## Drawbacks

- Introduces a minor amount of churn.


---

---
stage: recommended
start-date: 2020-12-23T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/692
project-link:
---

# Deprecate Array Observers

## Summary

Deprecate array observers, and all associated APIs and events, including:

- Methods:
  - `addArrayObserver`
  - `removeArrayObserver`
  - `arrayContentWillChange`
  - `arrayContentDidChange`
- Events:
  - `@array:before`
  - `@array:change`

## Motivation

Array observers are a feature of Ember's custom array implementations. They are
implemented using a completely different system than standard observers, and
historically served different goals, namely integrating array changes with
Ember's classic push-based reactivity system. With autotracking, the reactivity
system was rewritten in a way that didn't require array observers at all, so
there is no longer a need for them internally.

In addition, array observers are fundamentally synchronous. They install
observers that run both _before_ the change has occured, and _after_. This means
that we need to trigger the before observer synchronously before we run the
change. This synchronous nature introduces overhead, and conceptually is not
inline with the future direction of the framework. With autotracking, the core
concept is that reactivity should be _lazy_. Derived state should only update
when it is accessed, meaning that if a value is updated but never used, it will
not react.

It is possible to design custom iterables that follow this paradigm, and in fact
most former users of array observers have _already_ converted to this type of
pattern. For instance, all of the custom arrays defined in Ember Data, one of
the biggest users of array observers in the past, have been rewritten to update
lazily when the values are accessed.

Projects like [tracked-built-ins](https://github.com/pzuraq/tracked-built-ins)
build on these techniques, demonstrating how modern iterables can be defined
without using any of Ember's custom enumerable/array mixins or classes. By
deprecating the synchronous observers, we can align the remaining custom
enumerables in the ecosystem with the way that modern custom iterables will
work, setting us up for a smoother transition overall.

## Transition Path

Array observers are a very flexible tool, and are possible to use in many
different ways, similar to observers. As such, each use case may have a somewhat
different solution. This RFC will outline solutions for known use cases based on
public code, and should be converted directly into the deprecation guide. If
more use cases are discovered, we will continue to add transition paths for them
to the guide.

### Deprecation Guide

Array observers are a special type of observer that can be used to synchronously
react to changes in an `EmberArray`. In general, to refactor away from them, these
reactions need to be converted from _eager_, _synchronous_ reactions into _lazy_
reactions that occur when the array in question is _used or accessed_.

For example, let's say that we had a class which wrapped an `EmberArray` and
converted its contents into strings by calling `toString()` on them. This class
could be implemented using array observers like so:

```js
class ToStringArray {
  constructor(innerArray) {
    this._inner = innerArray;

    this._content = innerArray.map((value) => value.toString());

    innerArray.addArrayObserver(this, {
      willChange: '_innerWillChange',
      didChange: '_innerDidChange',
    });
  }

  // no-op
  _innerWillChange() {}


  _innerDidChange(innerArray, changeStart, removeCount, addCount) {
    if (removeCount) {
      // if items were removed, remove them
      this._content.removeAt(changeStart, removeCount);
    } else {
      // else, find the new items, convert them, and add them to the array
      let newItems = innerArray.slice(changeStart, addCount);

      this._content.replace(changeStart, 0, newItems.map((value) => value.toString()));
    }

    // Let observers/computeds know that the value has changed
    notifyPropertyChange(this, '[]');
  }

  objectAt(index) {
    return this._content.objectAt(index);
  }
}
```

To convert this to no longer use array observers, we could instead convert the
wrapping to happen when the array is accessed in `objectAt`, using the `@cached`
decorator from [tracked-toolbox](https://github.com/pzuraq/tracked-toolbox).

```js
import { cached } from 'tracked-toolbox';

class ToStringArray {
  constructor(innerArray) {
    this._inner = innerArray;
  }

  @cached
  get _content() {
    return this._inner.map((value) => value.toString());
  }

  objectAt(index) {
    return this._content.objectAt(index);
  }
}
```

This can also be accomplished with native [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy),
allowing your users to interact with the array using standard array syntax
instead of `objectAt`:

```js
class ToStringArrayHandler {
  constructor(innerArray) {
    this._inner = innerArray;
  }

  @cached
  get _content() {
    return this._inner.map((value) => value.toString());
  }

  get(target, prop) {
    return this._content.objectAt(prop);
  }
}

function createToStringArray(innerArray) {
  return new Proxy([], new ToStringArrayHandler(innerArray));
}
```

This solution will work with autotracking in general, since users who access the
array via `objectAt` will be accessing the tracked property. However, it will
not integrate with computed property dependencies. If that is needed, then you
can instead extend Ember's built-in `ArrayProxy` class, which handles forwarding
events and dependencies itself.

```js
import ArrayProxy from '@ember/array/proxy';
import { cached } from 'tracked-toolbox';

class ToStringArray extends ArrayProxy {
  @cached
  get _content() {
    return this.content.map((value) => value.toString());
  }

  objectAtContent(index) {
    return this._content.objectAt(index);
  }
}
```

### Converting code that watches arrays for changes

Array observers and change events can be used to watch arrays and react to
changes in other ways as well. For instance, you may have a component like
`ember-collection` which used array observers to trigger a rerender and
rearrange its own representation of the array. A simplified version of this
logic looks like the following:

```js
export default Component.extend({
  layout: layout,

  init() {
    this._cells = A();
  },

  _needsRevalidate(){
    if (this.isDestroyed || this.isDestroying) {return;}
    this.rerender();
  },

  didReceiveAttrs() {
    this._super();

    this.updateItems();
  },

  updateItems(){
    var rawItems = this.get('items');

    if (this._rawItems !== rawItems) {
      if (this._items && this._items.removeArrayObserver) {
        this._items.removeArrayObserver(this, {
          willChange: noop,
          didChange: '_needsRevalidate'
        });
      }
      this._rawItems = rawItems;
      var items = A(rawItems);
      this.set('_items', items);

      if (items && items.addArrayObserver) {
        items.addArrayObserver(this, {
          willChange: noop,
          didChange: '_needsRevalidate'
        });
      }
    }
  },

  willRender() {
    this.updateCells();
  },

  updateCells() {
    // ...
  },

  actions: {
    scrollChange(scrollLeft, scrollTop) {
      // ...
      if (scrollLeft !== this._scrollLeft ||
          scrollTop !== this._scrollTop) {
        set(this, '_scrollLeft', scrollLeft);
        set(this, '_scrollTop', scrollTop);
        this._needsRevalidate();
      }
    },
    clientSizeChange(clientWidth, clientHeight) {
      if (this._clientWidth !== clientWidth ||
          this._clientHeight !== clientHeight) {
        set(this, '_clientWidth', clientWidth);
        set(this, '_clientHeight', clientHeight);
        this._needsRevalidate();
      }
    }
  }
});
```

We can refactor this to update the cells themselves when they are accessed, by
accessing them into a computed property that depends on the items array, and
which updates the cells when it is accessed:

```js
export default Component.extend({
  layout: layout,

  init() {
    this._cells = A();
  },

  cells: computed('items.[]', function() {
    this.updateCells();

    return this._cells;
  })

  updateCells() {
    // ...
  },

  actions: {
    scrollChange(scrollLeft, scrollTop) {
      // ...
      if (scrollLeft !== this._scrollLeft ||
          scrollTop !== this._scrollTop) {
        set(this, '_scrollLeft', scrollLeft);
        set(this, '_scrollTop', scrollTop);
        this.notifyPropertyChange('cells');
      }
    },
    clientSizeChange(clientWidth, clientHeight) {
      if (this._clientWidth !== clientWidth ||
          this._clientHeight !== clientHeight) {
        set(this, '_clientWidth', clientWidth);
        set(this, '_clientHeight', clientHeight);
        this.notifyPropertyChange('cells');
      }
    }
  }
});
```

Mutating untracked local state like this is generally ok as long as the state is
essentially a cached representation of computed or getter is deriving in
general. It allows you to do things like compare the previous state to the
current state during the update, and cache portions of the computation so that
you do not need to redo all of it.

It is also possible that you have some code which must run whenever the array
has changed, and must run eagerly. For instance, the array fragment from
`ember-data-model-fragments` has some logic for signalling to the parent record
that it has changed, which looks like this (simplified):

```js
const StatefulArray = ArrayProxy.extend(Copyable, {
  content: computed(function() {
    return A();
  }),

  // ...

  arrayContentDidChange() {
    this._super(...arguments);

    let record = get(this, 'owner');
    let key = get(this, 'name');

    // Any change to the size of the fragment array means a potential state change
    if (get(this, 'hasDirtyAttributes')) {
      fragmentDidDirty(record, key, this);
    } else {
      fragmentDidReset(record, key);
    }
  },
});
```

Ideally the dirty state would be converted into derived state that could read
the array it was dependent upon, but if that's not an option or would require
major refactors, it is also possible to override the mutator method of the array
and trigger the change when it is called. In EmberArray's, the primary mutator
method is the `replace()` method.

```js
const StatefulArray = ArrayProxy.extend(Copyable, {
  content: computed(function() {
    return A();
  }),

  // ...

  replace() {
    this._super(...arguments);

    let record = get(this, 'owner');
    let key = get(this, 'name');

    // Any change to the size of the fragment array means a potential state change
    if (get(this, 'hasDirtyAttributes')) {
      fragmentDidDirty(record, key, this);
    } else {
      fragmentDidReset(record, key);
    }
  },
});
```

Note that this method will work for arrays and array proxies that are mutated
directly, but will not work for array proxies which wrap other arrays and watch
changes on them. In those cases, the recommendation is to refactor such that:

1. Changes are always intercepted by the proxy, and can call the code
   synchronously when they occur.
2. The change logic is added by intercepting changes on the original array, so
   it will occur whenever it changes.
3. The API that must be called synchronously is instead driven by derived state.
   For instance, in the example above, the record's dirty state could be driven
   by the various child fragments it contains, and updated whenever the user
   accesses it, rather than by sending events such as `didDirty` and `didReset`.

### Converting code that uses the `willChange` functionality

In general, it is no longer possible to react to an array change before it
occurs except by overriding the mutation methods on the array itself. You can do
this by replacing them and calling your logic _before_ calling `super`.

```js
const ArrayWithWillChange = EmberObject.extend(MutableArray, {
  replace() {
    // Your logic here

    this._super(...arguments);
  },
});
```

In cases where this is not possible, you can instead convert to derived state,
and cache the previous value of the array to compare it the next time the state
is accessed.

## How We Teach This

Array observers and their usage in general is not part of the default Ember
learning path, so the main guides should not need to change. Eventually, we will
likely want to add some guides for developing custom iterables that work in a
lazy way, but this is a separate change that should not be tied to this specific
deprecation.

For the deprecation guide, see the transition path above.

## Drawbacks

- While array observers are not used commonly in public code, they are used by
  several commonly used addons, such as `ember-collection`,
  `ember-data-model-fragments`, and `ember-light-table`. Deprecating them will
  cause these addons to need to rewrite and release new versions, which will
  introduce some churn in the ecosystem.
- The public use cases for array observers have known solutions which are
  outlined in this deprecation guide, and which should not require refactors
  that are unreasonable in scope. However, array observers are a powerful API,
  and its possible that there are some use cases out there which are far more
  difficult to refactor and detangle. If there are, those users could be heavily
  impacted by this deprecation.

## Alternatives

- Leave array observers undeprecated. This currently prevents us from
  refactoring the internals of array proxies, and also ultimately means that the
  community will have to absorb these changes later on in more comprehensive
  refactors to native iterables.

## Unresolved questions

- What other use cases exist for array observers that are not covered in the
  guides?


---

---
stage: recommended
start-date: 2021-01-05T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/698
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Deprecate <LinkTo> Component Positional Arguments

## Summary

We propose to deprecate invoking the `<LinkTo>` component with positional
arguments, in favor of the equivalent named arguments introduced in
[RFC #459](0459-angle-bracket-built-in-components.md). We also propose to
deprecate the `(query-params)` helper, which is only needed when invoking the
`<LinkTo>` component with positional arguments.

## Motivation

In modern Ember, the idiomatic way to invoke most components is to use the
[angle bracket syntax](0311-angle-bracket-invocation.md) along with the named
arguments `@` syntax. On the other hand, curly invocations are now reserved for
"helper-like" and "control-flow" components.

The `<LinkTo>` built-in component started life as a "helper" in the early days
of Ember, even before an official components API was created. Over time, it
became clear that `<LinkTo>` is better classified as a component than a helper
in modern Ember, and the learning materials have been updated accordingly.

This historical origin meant that `<LinkTo>` was designed to accept positional
arguments exclusively, as was common with most helpers at the time. The angle
bracket syntax, on the other hand, accepts named arguments exclusively.

Another downside to the positional arguments syntax was it required the use of
the `(query-params)` helper to distinguish query params from model arguments.

Finally, the meaning of the positional arguments also changes slightly when the
component is invoked with or without a block, which made things needlessly
confusing.

To address these issues, [RFC #459](0459-angle-bracket-built-in-components.md)
introduced explicit equivalent names for the positional arguments that were
accepted by the `<LinkTo>` component. This allowed it to be invoked with the
same angle bracket syntax and avoided the other confusions mentioned above.

These features were made available since v3.10 and are the idomatic thing to do
in modern Ember codebase.

Given that the feature are now available on all currently-supported Ember
versions and the community had adequate time to make the transition, this would
be a good time to deprecate the obsolete features to reduce confusion as well
as implementation complexity.

In particular, some of the obsolete features required capabilities not usually
available to other components, such as knowing whether a block was passed or
not and relies on "AST transforms" to normalize some of the differences. These
implementation strategies introduces unnecessary complexity in the internals
that sometimes causes bugs or other surprising behaviors.

## Transition Path

```hbs
Deprecated:

{{link-to "About Us" "about"}}
          ~~~~~~~~~~~~~~~~~~

Invoking the `<LinkTo>` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`) and pass a
block for the link's content.

<LinkTo @route="about">About Us</LinkTo>
```

```hbs
Deprecated:

{{#link-to "about"}}About Us{{/link-to}}
           ~~~~~~~

Invoking the `<LinkTo>` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`).

Replacement:

<LinkTo @route="about">About Us</LinkTo>
```


```hbs
Deprecated:

{{#link-to "post" @post}}Read {{@post.title}}...{{/link-to}}
           ~~~~~~~~~~~~

Invoking the `<LinkTo>` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@model`).

Replacement:

<LinkTo @route="post" @model={{@post}}>Read {{@post.title}}...</LinkTo>
```

```hbs
Deprecated:

{{#link-to "post.comment" @comment.post @comment}}
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Comment by {{@comment.author.name}} on {{@comment.date}}
{{/link-to}}

Invoking the `<LinkTo>` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@models`).

Replacement:

<LinkTo @route="post.comment" @models={{array post comment}}>
  Comment by {{comment.author.name}} on {{comment.date}}
</LinkTo>
```

```hbs
Deprecated:

{{#link-to "posts" (query-params direction="desc" showArchived=false)}}
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Recent Posts
{{/link-to}}

Invoking the `<LinkTo>` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@query`) and the
`hash` helper.

Replacement:

<LinkTo @route="posts" @query={{hash direction="desc" showArchived=false}}>
  Recent Posts
</LinkTo>
```

These migrations can be automated using the [angle brackets codemod](https://github.com/ember-codemods/ember-angle-brackets-codemod).

## How We Teach This

The Octane learning materials have already been updated to use the latest
idioms, so no changes are necessary. The API documentation should be updated
to mark the obsolete features and the `(query-params)` helper as deprecated.

A deprecation guide will need to be written using the same examples from the
[Transition Path](#transition-path) section. The guide should also promote the
use of the codemod to automate the migration.

## Drawbacks

None.

## Alternatives

None.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2021-01-09T00:00:00.000Z
release-date: 2021-06-25T00:00:00.000Z
release-versions:
  ember-cli: v3.27.0

teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/702
project-link:
---

# Add eslint-plugin-qunit to ember-cli blueprint

## Summary

This RFC proposes adding [eslint-plugin-qunit](https://github.com/platinumazure/eslint-plugin-qunit) to the blueprints
that back `ember new` and `ember addon`.

## Motivation

Ember apps and addons already come with a number of linting plugins targeting various areas of the code:

* ember-template-lint - handlebars best practices
* eslint - general JavaScript best practices
* eslint-plugin-ember - Ember best practices
* eslint-plugin-node - Node best practices
* prettier - automatic styling (as a result of a recent [RFC](https://github.com/emberjs/rfcs/blob/master/text/0628-prettier.md))

But there's an important aspect of Ember apps that is not yet targeted by specialized linting: testing. Test code can easily make up half of the code in an Ember app, and well-written tests are of course critical to application quality.

[QUnit](https://qunitjs.com/) is the default testing framework used by Ember apps and the good news is that a popular and mature QUnit linting plugin is available for it: eslint-plugin-qunit. This plugin has been around for five years and is used in thousands of applications including many Ember applications. It has over 30 rules for enforcing best testing practices and detecting broken or incorrectly-written tests.

## Detailed design

The general idea is that we will update the `app` and `addon` blueprints to add the eslint-plugin-qunit package to the `package.json`, and update the linting configuration to extend the new presets.

### Packages

The following packages will be added to the `package.json` of both `app` and `addon` blueprints:

* [eslint-plugin-qunit](https://www.npmjs.com/package/eslint-plugin-qunit)

### Configuration Changes

The `.eslintrc.js` that is generated will be updated to extend the `qunit` linting configurations.

This change will be limited to test files only using an override, similar to how Node linting is limited to Node files only with an override. Using an override to scope linting to specific files provides additional protection against unwanted impacts (i.e. false positives or performance hits).

```js
{
  overrides: [
    ...,
    {
      files: ['tests/**/*'],
      extends: ['plugin:qunit/recommended', 'plugin:qunit/two'],
    },
  ],
}
```

## How we teach this

We do not currently discuss linting in either guides.emberjs.com or cli.emberjs.com.

Users will be able to find documentation for the new rules on the [eslint-plugin-qunit](https://github.com/platinumazure/eslint-plugin-qunit) GitHub page. Many IDEs will provide a link directly to the rule documentation on highlighted lint violations.

Any violations of the new rules will be detected by `yarn lint` and in some cases autofixed by `yarn lint:fix`.

## Drawbacks

For those introducing eslint-plugin-qunit to an existing codebase, the largest drawback is generally the initial cost of fixing linting violations. This can be mitigated by individually disabling noisy lint rules and working to fix violations overtime. But note that this RFC is more likely to impact newly-generated applications where there will be no existing lint violations to fix as opposed to existing applications.

In rare cases, users may be using an alternative testing framework like Mocha or Jest, and they can safely ignore or remove eslint-plugin-qunit.

## Alternatives

The implementation is straightforward and there are no known alternative implementations for adding more test-oriented linting.


---

---
stage: recommended
start-date: 2020-01-14T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/704
project-link:
---

# Deprecate Octane Optional Features

## Summary

Deprecate the optional features introduced in the transition to Ember Octane.
This specifically refers to the optional features which are required for an
Ember application to set the `octane` edition:

- `application-template-wrapper`
- `template-only-glimmer-components`

## Motivation

The Octane edition consisted for the most part of backwards compatible changes,
a design choice inline with the Ember philosophy of introducing new features and
changes while ensuring that there is an upgrade path. Editions are about
introducing a new programming model side-by-side with the old one, allowing
users to adopt the changes gradually. As such, enabling Octane is almost
identical to any other Ember upgrade, with one exception - required optional
features.

While most changes in the Octane programming model were backwards compatible,
there were a few small tweaks to behaviors that could not be done in a backwards
compatible way. In order to fully enable Octane, users had to both upgrade to
the minimum version of Ember, _and_ toggle these behaviors via optional
features.

The two optional features that were required for Octane are:

- `application-template-wrapper`, which must be set to `false` in Octane
- `template-only-glimmer-components`, which must be set to `true` in Octane

While there are other optional features available which Ember users should
adopt, they are not requirements for Octane specifically.

As part of the post-Octane cleanup, this RFC proposes deprecating these optional
features, so that the Octane behavior is the only supported behavior. This will
simplify user configuration, and enable cleanup of the code that supports these
optional features internally.

## Transition Path

This deprecation will be a 2 phase deprecation:

1. Deprecate the following optional feature flag settings:
  - `application-template-wrapper: true`
  - `template-only-glimmer-components: false`
2. Deprecate specifying the optional feature at all

### Phase 1

The first phase will require that all users have toggled the optional feature to
the correct position for Octane. This phase can be implemented immediately, and
will position us to be able to enter phase 2 in the next major version after
implementation (currently v4).

Since the specifying the optional feature will cause it to be set to the
incorrect value in Ember v3, users will have to specify the optional feature
explicitly.

### Phase 2

Once a major version has been released after phase 1 has been implemented, all
users will be using the same setting for these optional features, explicitly. In
the first release of Ember v4, we will be able to safely change the default
value of the optional feature flags to be the correct Octane setting. Users will
be able to drop the explicit setting at this point, and the blueprint will be
updated to drop it as well.

At this point, the default setting will be the Octane-compatible one, and
explicitly setting it to the Octane-compatible one will be allowed. Explicitly
setting it to the non-Octane setting will trigger an assertion. This means that
users can only possibly have one behavior specified, and we can deprecate
specifying the optional feature at all.

## How We Teach This

### Deprecation Guide

#### `application-template-wrapper`

Setting the `application-template-wrapper` optional feature to `true` has been
deprecated. You must set this feature to `false`, disabling the application
wrapper. For more details on this optional feature, including the changes in
behavior disabling it causes and how you can disable it, see the
[optional features section](https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_application-template-wrapper)
of the Ember guides. You can also run `npx @ember/octanify` to set this feature
to the correct value.

#### `template-only-glimmer-components`

Setting the `template-only-glimmer-components` optional feature to `false` has been
deprecated. You must set this feature to `true`, enabling the template-only
Glimmer components. For more details on this optional feature, including the
changes in behavior enabling it causes and how you can enable it, see the
[optional features section](https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_template-only-glimmer-components)
of the Ember guides. You can also run `npx @ember/octanify` to set this feature
to the correct value.

## Drawbacks

- Could cause churn in some existing applications

## Alternatives

- We could deprecate the other optional feature flags as well. While it is
  encouraged to toggle all optional feature flags, and all optional feature
  flags are toggled by default in new Ember apps, the other flags were required
  as part of Ember Octane and are conceptually separate. As such, they should be
  deprecated in a separate RFC.



---

---
stage: recommended
start-date: 2020-01-14T00:00:00.000Z
release-date: 2021-03-22T00:00:00.000Z
release-versions:
  ember-source: v3.26.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/705
project-link:
---

# Deprecate jQuery Integration Optional Feature

## Summary

Deprecate the `jquery-integration` optional feature flag.

## Motivation

jQuery integration has been a part of Ember since the beginning. When Ember was
first released, a variety of browser features had not been standardized yet, and
jQuery was a necessary tool for creating code that worked in all major browsers.
This is no longer the case, and Ember is no longer internally reliant on jQuery.

That said, jQuery is still a useful library with many plugins, and that many
developers use. Adding jQuery to an Ember application is still completely
possible, and **not deprecated by this or any other RFC**.

The `jquery-integration` optional feature is not about removing jQuery from your
Ember application. It is instead about removing the _integration_ that Ember has
with jQuery, which is left over from the days when jQuery was used by Ember for
many different basic tasks. Specifically, disabling the feature removes the
following APIs:

- `Ember.$`, which is an alias for jQuery
- `this.$`, which is an alias for a jQuery selector that is scoped to `this`.
  This is available in Classic components and tests.

Deprecating the `jquery-integration` optional feature means that users will have
to transition away from using these specific APIs, but _not_ from using jQuery
in general. This will help us to clarify that Ember is not dependent on jQuery,
and allow us to simplify Ember's internals.

## Transition Path

This deprecation will be a 2 phase deprecation:

1. Deprecate the following optional feature flag settings:
  - `jquery-integration: true`
2. Deprecate specifying the optional feature at all

### Phase 1

The first phase will require that all users have toggled the optional feature to
`false`. This phase can be implemented immediately, and will position us to be
able to enter phase 2 in the next major version after implementation (currently
v4).

Since the not specifying the optional feature will cause it to be set to the
`true` by default in Ember v3, users will have to specify the optional feature
explicitly.

### Phase 2

Once a major version has been released after phase 1 has been implemented, all
users will be using the same setting for this optional feature, explicitly. In
the first release of Ember v4, we will be able to safely change the default
value of the optional feature to `false`. Users will be able to drop the
explicit setting at this point, and the blueprint will be updated to drop it as
well.

At this point, the default setting will be `false`, and explicitly setting it to
`false` will be allowed. Explicitly setting it to `true` will trigger an
assertion. This means that users can only possibly have one behavior specified,
and we can deprecate specifying the optional feature at all.

## How We Teach This

We should update the Optional Features guide to discuss in more detail how users
can migrate away from jQuery. In general, most usages should be fairly
straightforward, and the current guides do not cover it in great detail. They
also do not mention that `@ember/jquery` can be used without the feature flag.

### Updated Optional Feature Guide

jQuery is commonly used for event handling and many popular libraries for
charting and UI components. Ember was originally built using jQuery, but has
since refactored and is no longer dependent on it. jQuery can still be used
as in independent library alongside Ember, however.

There are a few APIs that exist in Ember still that directly expose jQuery,
Disabling this optional feature disables those APIs, but does not remove jQuery
itself. jQuery is provided by the `@ember/jquery` addon, independent of the
integration APIs.

#### Migrating Away from and disabling Ember jQuery integration APIs

To disable this feature, first migrate away from the jQuery integration APIs.
Below is a list of the jQuery specific APIs in Ember, and how to migrate away
from them.

- `this.$()` in Classic Ember components. This creates a jQuery selector that
  targets the component's element. You can migrate away by using `this.element`
  instead, which is the actual DOM element for the component. If you want to
  continue using jQuery via `@ember/jquery`, you can do so with `this.element`:

  ```js
  import $ from 'jquery';
  import Component from '@ember/copmonent';

  export default class MyComponent extends Component {
    didInsertElement() {
      let el = $(this.element);

      // ...
    }
  }
  ```

- Event handlers on Classic components, such as `click()` and `mouseEnter()`.
  These APIs still work without the integrations enabled, but they no longer
  receive a jQuery event, they receive a native Event instead. You can convert
  to using native events incrementally by using the [`ember-jquery-legacy`](https://github.com/emberjs/ember-jquery-legacy) addon, which provides a function that converts a jQuery
  event into a native event safely. Once all of your event handlers have been
  converted, you can disable jQuery integration.

- `Ember.$()`, which is an alias for the global jQuery. This can either be
  replaced with alternative, non-jquery based APIs, or by installing
  `@ember/jquery` and importing it directly.

- Global acceptance test helpers like `find()` or `click()`. These can be
  replaced with the `@ember/test-helpers`, which is the default for test helpers
  now.

- `this.$()` in component tests. This can be replaced with corresponding test
  helpers from `@ember/test-helpers`.

Note that if you disable these APIs, then all addons you use must also work
without them, as they will not be available at all.

Next, follow the instructions above to install `@ember/optional-features`, and
run the following command to change `@ember/optional-features`:

```sh
ember feature:disable jquery-integration
```

#### Including jQuery without integration APIs

If you would like to include jQuery without the Ember integration APIs, you can
install `@ember/jquery`:

```sh
ember install @ember/jquery
```

This will allow you to import jQuery from `jquery`:

```js
import $ from 'jquery';
```

#### Including jQuery with integration APIs

To include jQuery in your Ember app and enable the jQuery integration APIs such
as `this.$()`, follow the instructions above to install `@ember/optional-features`.
Next, enable the feature:

```sh
ember feature:enable jquery-integration
```

Then, install the `@ember/jquery` addon:

```sh
ember install @ember/jquery
```

Now, almost anywhere in your app, you can use the various jQuery integrations.

#### Removing jQuery completely

If you are working on an application that already has jQuery installed, and
would like to remove it, follow these steps.

First, refactor your own code to not depend on jQuery. See the section above on
how to do this. Keep in mind that you will have to remove jQuery usage entirely,
you cannot use solutions that replace the integration API with jQuery
independently such as `$(this.element)`.

Next, follow the instructions above to install `@ember/optional-features`, and
run the following command to change `@ember/optional-features`:

```sh
ember feature:disable jquery-integration
```

Then, remove `@ember/jquery` from your package.json.

This will remove jQuery from your vendor.js bundle and disable any use of jQuery
in Ember itself. Now your app will be about 30KB lighter!

### Deprecation Guide

Setting the `jquery-integration` optional feature to `true` has been
deprecated. You must set this feature to `false`, disabling jQuery integration.
This only disables **integration** with Ember, jQuery can still be included and
used as an independent library via the [`@ember/jquery` addon](https://github.com/emberjs/ember-jquery).

For more details on this optional feature, including the changes in
behavior disabling it causes and how you can disable it, see the
[optional features section](https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_removing-jquery)
of the Ember guides.

## Drawbacks

- Could cause churn in some existing applications

## Alternatives

- We could continue supporting these jQuery integrations forever.



---

---
stage: recommended
start-date: 2021-02-01T00:00:00.000Z
release-date: 2021-05-03T00:00:00.000Z
release-versions:
  ember-source: v3.27.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/706
project-link:
---

# Deprecate the Ember Global

## Summary

Deprecate the Ember global, `window.Ember`, and replace it fully with
`import Ember from 'ember';`

## Motivation

The Ember global, available at `window.Ember` (or `globalThis.Ember` in all
environments) is a mostly legacy API from before Ember adopted native ES
modules. Modern Ember apps do not use the global, and in general it is mostly
used by legacy code and occasionally in examples. However, it still exists and
remains undeprecated.

The primary motivation for deprecating the global object is for _tree shaking_
purposes. Because the global object is assigned eagerly to `window.Ember`
whenever Ember is loaded, it essentially means that every Ember application
implicitly uses every single API that is exported on the global object. This
means that we cannot tree shake any of those APIs, and we must in fact load them
all eagerly and execute all of their code as soon as Ember is loaded.

While it is tempting to remove the `Ember` object altogether, there are a number
of undeprecated legacy and intimate APIs that are only available through this
object, such os `Ember.meta`. This is why this RFC proposes only deprecating
accessing `Ember` _via_ `window.Ember`/`globalThis.Ember`. Instead, users will
have to import `Ember` using standard ES module syntax if they want to use it.

```js
import Ember from 'ember';
```

This ensures there is an _explicit_ dependency if it is used, and which will
allow us to treeshake in the future if nothing imports `Ember`. In time, we will
be able to deprecate the `Ember` object altogether.

## Transition Path

When the `Ember` object is defined on the global, we will create a getter for it
that also issues a deprecation. Users who currently use the global will have to
add `import Ember from 'ember';` at the top of the files in which they use it.

## How we teach this

### Deprecation Guide

Accessing Ember on the global context (e.g. `window.Ember`, `globalThis.Ember`,
or just `Ember` without importing it) is no longer supported. Migrate to
importing Ember explicitly instead.

Before:

```js
export default class MyComponent extends Ember.Component {
  // ...
}
```

After:

```js
import Ember from 'ember';

export default class MyComponent extends Ember.Component {
  // ...
}
```

Alternatively, consider converting to use the Ember modules API equivalent to
the API you are using:

```js
import Component from '@ember/component';

export default class MyComponent extends Component {
  // ...
}
```

If there is no modules API equivalent, consider refactoring away from using that
API.

## Drawbacks

- Introduces churn in legacy codebases

- Some polyfills and addons use `Ember` in places where the modules API is not
  available, such as in `vendor` files. These are advanced use cases in general,
  and there are possible workarounds (such as using the `require` global
  function), so this shouldn't block us from removing the global.

## Alternatives

- Keep the global indefinitely.


---

---
stage: recommended
start-date: 2021-01-14T00:00:00.000Z
release-date: # FIXME
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/707
project-link:
---

# Reduce API Surface of Built-In Components

## Summary

In order to reduce the API surface of the built-in `<LinkTo>`, `<Input>` and
`<Textarea>` components, we propose to deprecate all named arguments on these
components *except* the following:

* `<LinkTo>`
  * `@route`
  * `@model`
  * `@models`
  * `@query`
  * `@replace`
  * `@disabled`
  * `@current-when`
  * `@activeClass`
  * `@loadingClass`
  * `@disabledClass`
* `<Input>`
  * `@type`
  * `@value`
  * `@checked`
  * `@insert-newline`
  * `@enter`
  * `@escape-press`
* `<Textarea>`
  * `@value`
  * `@insert-newline`
  * `@enter`
  * `@escape-press`

## Motivation

This is a follow-up to [RFC #671](./0671-modernize-built-in-components-1.md)
and shares the same high-level motivations and historical context.

## Detailed design

The following named arguments should be explicitly documented as public:

* `<LinkTo>`
  * `@route`
  * `@model`
  * `@models`
  * `@query`
  * `@replace`
  * `@disabled`
  * `@current-when`
  * `@activeClass`
  * `@loadingClass`
  * `@disabledClass`
* `<Input>`
  * `@type`
  * `@value`
  * `@checked`
  * `@insert-newline`
  * `@enter`
  * `@escape-press`
* `<Textarea>`
  * `@value`
  * `@insert-newline`
  * `@enter`
  * `@escape-press`

The arguments not enumerated above are either no longer necessary, recommended
or accidentally exposed private implementation details.

### No Longer Necessary

#### HTML Attributes

The built-in components historically accepted a varierty of named arguments for
applying certain HTML attributes to the component's HTML element. This includes
the following (may not be a complete list):

* `<LinkTo>`
  * `@id`
  * `@elementId` (alias for `@id`)
  * `@ariaRole` (maps to the `role` HTML attribute)
  * `@class`
  * `@classNames` (deprecated, expands into the `class` HTML atttribute)
  * `@classNameBindings` (deprecated, expands to the `class` HTML atttribute)
  * `@isVisible` (deprecated, expands to the `display: none` inline style)
  * `@rel`
  * `@tabindex`
  * `@target`
  * `@title`
* `<Input>`
  * `@id`
  * `@elementId` (alias for `@id`)
  * `@ariaRole` (maps to the `role` HTML attribute)
  * `@class`
  * `@classNames` (deprecated, expands into the `class` HTML atttribute)
  * `@classNameBindings` (deprecated, expands to the `class` HTML atttribute)
  * `@isVisible` (deprecated, expands to the `display: none` inline style)
  * `@accept`
  * `@autocapitalize`
  * `@autocomplete`
  * `@autocorrect`
  * `@autofocus`
  * `@autosave`
  * `@dir`
  * `@disabled`
  * `@form`
  * `@formaction`
  * `@formenctype`
  * `@formmethod`
  * `@formnovalidate`
  * `@formtarget`
  * `@height`
  * `@indeterminate`
  * `@inputmode`
  * `@lang`
  * `@list`
  * `@max`
  * `@maxlength`
  * `@min`
  * `@minlength`
  * `@multiple`
  * `@name`
  * `@pattern`
  * `@placeholder`
  * `@readonly`
  * `@required`
  * `@selectionDirection`
  * `@size`
  * `@spellcheck`
  * `@step`
  * `@tabindex`
  * `@title`
  * `@width`
* `<Textarea>`
  * `@id`
  * `@elementId` (alias for `@id`)
  * `@ariaRole` (maps to the `role` HTML attribute)
  * `@class`
  * `@classNames` (deprecated, expands into the `class` HTML atttribute)
  * `@classNameBindings` (deprecated, expands to the `class` HTML atttribute)
  * `@isVisible` (deprecated, expands to the `display: none` inline style)
  * `@autocapitalize`
  * `@autocomplete`
  * `@autocorrect`
  * `@autofocus`
  * `@cols`
  * `@dir`
  * `@disabled`
  * `@form`
  * `@lang`
  * `@maxlength`
  * `@minlength`
  * `@name`
  * `@placeholder`
  * `@readonly`
  * `@required`
  * `@rows`
  * `@selectionDirection`
  * `@selectionEnd`
  * `@selectionStart`
  * `@spellcheck`
  * `@tabindex`
  * `@title`
  * `@wrap`

These arguments are no longer necessary – with angle bracket invocations, HTML
attributes can be passed directly. An invocation passing one or more of these
named arguments shall trigger a deprecation warning similar to this:

```
<Input @placeholder="Ember.js" />
       ~~~~~~~~~~~~~~~~~~~~~~~
or

{{input placeholder="Ember.js"}}
        ~~~~~~~~~~~~~~~~~~~~~~

Passing the `@placeholder` argument to <Input> is deprecated. Instead, please
pass the attribute directly, i.e. `<Input placeholder={{...}} />` instead of
`<Input @placeholder={{...}} />` or `{{input placeholder=...}}`.
```

A notable exception when passing an argument named `@href` to the `<LinkTo>`
component. This was never intentionally supported and will trigger an error
instead of a deprecation warning.

#### DOM Events

The built-in components historically accepted a varierty of named arguments for
listening to certain DOM events on the component's HTML element. This includes
the following (may not be a complete list):

* `<LinkTo>`
  * `@change`
  * `@click`
  * `@contextMenu` (for the `contextmenu` event)
  * `@doubleClick` (for the `dblclick` event)
  * `@drag`
  * `@dragEnd` (for the `dragend` event)
  * `@dragEnter` (for the `dragenter` event)
  * `@dragLeave` (for the `dragleave` event)
  * `@dragOver` (for the `dragover` event)
  * `@dragStart` (for the `dragstart` event)
  * `@drop`
  * `@focusIn` (for the `focusin` event)
  * `@focusOut` (for the `focusout` event)
  * `@input`
  * `@keyDown` (for the `keydown` event)
  * `@keyPress` (for the `keypress` event)
  * `@keyUp` (for the `keyup` event)
  * `@mouseDown` (for the `mousedown` event)
  * `@mouseEnter` (deprecated, for the `mouseenter` event)
  * `@mouseLeave` (deprecated, for the `mouseleave` event)
  * `@mouseMove` (deprecated, for the `mousemove` event)
  * `@mouseUp` (for the `mouseup` event)
  * `@submit`
  * `@touchCancel` (for the `touchcancel` event)
  * `@touchEnd` (for the `touchend` event)
  * `@touchMove` (for the `touchmove` event)
  * `@touchStart` (for the `touchstart` event)
* `<Input>`
  * `@click`
  * `@contextMenu` (for the `contextmenu` event)
  * `@doubleClick` (for the `dblclick` event)
  * `@drag`
  * `@dragEnd` (for the `dragend` event)
  * `@dragEnter` (for the `dragenter` event)
  * `@dragLeave` (for the `dragleave` event)
  * `@dragOver` (for the `dragover` event)
  * `@dragStart` (for the `dragstart` event)
  * `@drop`
  * `@input`
  * `@mouseDown` (for the `mousedown` event)
  * `@mouseEnter` (deprecated, for the `mouseenter` event)
  * `@mouseLeave` (deprecated, for the `mouseleave` event)
  * `@mouseMove` (deprecated, for the `mousemove` event)
  * `@mouseUp` (for the `mouseup` event)
  * `@submit`
  * `@touchCancel` (for the `touchcancel` event)
  * `@touchEnd` (for the `touchend` event)
  * `@touchMove` (for the `touchmove` event)
  * `@touchStart` (for the `touchstart` event)
  * `@focus-in` (for the `focusin` event)
  * `@focus-out` (for the `focusout` event)
  * `@key-down` (for the `keydown` event)
  * `@key-press` (for the `keypress` event)
  * `@key-up` (for the `keyup` event)
* `<Textarea>`
  * `@click`
  * `@contextMenu` (for the `contextmenu` event)
  * `@doubleClick` (for the `dblclick` event)
  * `@drag`
  * `@dragEnd` (for the `dragend` event)
  * `@dragEnter` (for the `dragenter` event)
  * `@dragLeave` (for the `dragleave` event)
  * `@dragOver` (for the `dragover` event)
  * `@dragStart` (for the `dragstart` event)
  * `@drop`
  * `@input`
  * `@mouseDown` (for the `mousedown` event)
  * `@mouseEnter` (deprecated, for the `mouseenter` event)
  * `@mouseLeave` (deprecated, for the `mouseleave` event)
  * `@mouseMove` (deprecated, for the `mousemove` event)
  * `@mouseUp` (for the `mouseup` event)
  * `@submit`
  * `@touchCancel` (for the `touchcancel` event)
  * `@touchEnd` (for the `touchend` event)
  * `@touchMove` (for the `touchmove` event)
  * `@touchStart` (for the `touchstart` event)
  * `@focus-in` (for the `focusin` event)
  * `@focus-out` (for the `focusout` event)
  * `@key-down` (for the `keydown` event)
  * `@key-press` (for the `keypress` event)
  * `@key-up` (for the `keyup` event)

These arguments are no longer necessary – with angle bracket invocations, DOM
event listeners can be registered directly using the `{{on}}` modifier. An
invocation passing one or more of these named arguments shall trigger a
deprecation warning similar to this:

```
<Input @click={{this.onClick}} />
       ~~~~~~~~~~~~~~~~~~~~~~~
or

{{input click=this.onClick}}
        ~~~~~~~~~~~~~~~~~~

Passing the `@click` argument to <Input> is deprecated. Instead, please use the
{{on}} modifier, i.e. `<Input {{on "click" ...}} />` instead of
`<Input @click={{...}} />` or `{{input click=...}}`.
```

Note that these named arguments were not necessarily an intentional part of the
component's original design. Rather, these are callbacks that would have fired
on all classic components, and since classic components' arguments are set on
the component instances as properties, passing these arguments at invocation
time would have "clobbered" any callbacks with the same name defined on the
component's class/prototype, whether it was intended by the component's author
or not.

For instance, the `<Input>` and `<Textarea>` built-in components implemented
callbacks that would have been clobbered by these named arguments (may not be a
complete list):

* `@change`
* `@focusIn`
* `@focusOut`
* `@keyDown`
* `@keyPress`
* `@keyUp`

Passing these named arguments historically supressed certain behavior of the
built-in components, in some cases preventing the components from functioning
properly. This was never an intended part of the original design and should be
considered a bug.

This bug may be fixed at any time during the transition period – the supression
behavior may stop without notice and should not be relied upon. An invocation
with these named arguemnts shall trigger a deprecation warning with this
additional caveat, similar to this:

```
<Input @change={{this.onChange}} />
       ~~~~~~~~~~~~~~~~~~~~~~~~~
or

{{input change=this.onChange}}
        ~~~~~~~~~~~~~~~~~~~~

Passing the `@change` argument to <Input> is deprecated. This would have
overwritten the internal `change` method on the <Input> component and prevented
it from functioning properly. Instead, please use the {{on}} modifier, i.e.
`<Input {{on "change" ...}} />` instead of `<Input @change={{...}} />` or
`{{input change=...}}`.
```

### No Longer Recommended

#### Changing `@tagName` on `<LinkTo>`

Due to the classic component implementation heritage, the built-in components
historically accepted a `@tagName` argument that allows customizing the tag
name of the underlying HTML element.

This was once popular with the `<LinkTo>` component for adding navigation
behavior to buttons, table row and other UI elements. The current concensus is
that this is an anti-pattern and causes issues with assistive technologies.

In most cases, the `<a>` anchor HTML element should be used for navigational UI
elements and styled with CSS to fit with the design requirements. Ocasionally,
a button may be acceptable, in which case a custom event handler can be written
using the router service and attached using the `{{on}}` modifier.

Other edge cases exists, but generally those solutions can be adapted to fufill
the requirements. For example, to make a table row clickable as a convenience,
the primary column can be made into a link, while a click event handler is
attached to the table row to redispatch the click to trigger the link.

Since this feature is no longer recommended, invoking `<LinkTo>` with the
`@tagName` argument shall trigger a deprecation warning similar to this:

```
<LinkTo @tagName="div" ...>...</LinkTo>
        ~~~~~~~~~~~~~~
or

{{#link-to tagName="div" ...}}...{{/link-to}}
           ~~~~~~~~~~~~~

Passing the `@tagName` argument to <LinkTo> is deprecated. Using a <div>
element for navigation is not recommended as it creates issues with assistive
technologies. Remove this argument to use the default <a> element. In the rare
cases that calls for using a different element, refactor to use the router
service inside a custom event handler instead.
```

With the ability to modify `@tagName` being deprecated, the previously private
`@eventName` and `@preventDefault` arguments on `<LinkTo>` should be removed as
well. These arguments were ocationally useful when the element is something
other than an `<a>` element, but in the case of an `<a>` element, the default
browser action is to navigate to the `href` via a full-page refresh. If that is
not prevented, it would defeat the purpose of using the `<LinkTo>` component.

Note that while the `<Input>` and `<Textarea>` components also accepted the
`@tagName` argument, it was never supported and its behavior is undefined. This
may stop "working" at any point without warning and should not be relied upon.

### Other Unsupported Arguments

Other named arguments not explicitly mentioned above are considered private
implementation details. Due to the nature of classic components' arguments
being set on its instance, any internal properties and methods could have been
clobbered by a named argument with the same name.

Some examples include private properties like `@active` and `@loading` on
`<LinkTo>`, `@bubbles` and `@cancel` on `<Input>` and `<Textarea>`, lifecycle
hooks inherited from the classic component super class like `@didRender`,
`@willDestroy` and so on.

Clobbering these intenral properties and methods cause the components to behave
in unexpected ways. This should be considered a bug and should not be relied
upon. Any accidental difference in behavior caused by passing these unsupported
named arguments may stop at any time without warning.

## How we teach this

The implementation plan primarily relies on good deprecation messages to inform
users of the deprecated features and their migration paths. Deprecation guides
should be written based on the content and suggestions in this RFC. API docs
should be updated to mark these arguments as deprecated.

Once this migration is complete, the built-in components will be much easier to
teach, as they will have a small, well-defined API surface.

## Drawbacks

None.

## Alternatives

Instead of enumerating the supported arguments, we could attempt to enumerate
all the unsupported ones. However, this is quite difficult as any internal or
inherited properties could in theory be used as an invocation argument.

## Unresolved questions

None.


---

---
stage: released
start-date: 2021-01-23T00:00:00.000Z
release-date: 2021-12-28T00:00:00.000Z
release-versions:
  ember-source: v4.1.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/711
project-link:
---

# Deprecate AutoLocation

## Summary

Deprecate Ember.AutoLocation and related APIs. In next major version,
make history the default location (instead of auto).

## Motivation

In practice, 'auto' will almost always resolve to the 'history' location.

By removing the 'auto' location and setting 'history' as the default we're removing
some complexity around router location, with no downside for users, since they
all get it resolved to history anyway.

## Background

The Ember Router can use different mechanisms to serialize its state.
The two common ones are 'history' and 'hash'. There is also a special
location called 'auto' which does feature detection, preferring 'history'.

When the special 'auto' location was added (and made default), less than
half of browsers supported the (then) new history location API. For seamless
upgrade to history API when available, Ember created the special auto location.

These days (many years later), basically all browsers will get 'history',
since the History Location API is very widely supported, even by IE 11:
https://caniuse.com/mdn-api_history_pushstate

The check 'auto' is basically doing this:

```js
// Boosted from Modernizr: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
// The stock browser on Android 2.2 & 2.3, and 4.0.x returns positive on history support
// Unfortunately support is really buggy and there is no clean way to detect
// these bugs, so we fall back to a user agent sniff :(

// We only want Android 2 and 4.0, stock browser, and not Chrome which identifies
// itself as 'Mobile Safari' as well, nor Windows Phone.

if (
    (userAgent.indexOf('Android 2.') !== -1 || userAgent.indexOf('Android 4.0') !== -1) &&
    userAgent.indexOf('Mobile Safari') !== -1 &&
    userAgent.indexOf('Chrome') === -1 &&
    userAgent.indexOf('Windows Phone') === -1
  ) {
    return false;
  }

  return Boolean(window.history && 'pushState' in window.history);
```

## Transition Path

We'll begin with deprecating auto (explicitly or implicitly set).

In next major release we change the default to 'history'.
Since auto is default today, and almost always resolve to history,
most users can change to 'history' and it's done.

We also need to update the template in ember-cli blueprint,
so that 'history' will be the default value for `locationType`
in environment.js.

There are two groups to consider:

1. People who need auto-detection (hash/history switching) and
2. those with location set to 'auto' (this will be most people).

The first group can implement feature detection,
via e.g. Modernizr[1], like this:

```js
// app/router.js
export default class Router extends EmberRouter {
  location = (historyFeatureDetection() ? 'history' : 'hash');
  // …
}
```

For the second group, they need to replace their choice
of 'auto' for 'history' in `locationType` in environment.js (or
`location` in router.js), since history is what 'auto' mostly
resolves to anyway.

### What To Deprecate (and later remove)

- The AutoLocation class
- The method `detect` from the `Location` interface
- Explicitly setting 'auto' as the preferred location.

### Deprecated or already private (should also be removed)
- Remove the `create` method on Location (replaced by registry)
- `registerImplementation` method on `Location`
- `supportsHistory` function exported in location/utils.ts

## How We Teach This

- Remove the text about auto location from guides.
- There is already good documentation about the different
  location types (history, hash, none) and how to write your own.
- Slight adjustments needed for the guides, removing mentions of auto[2].

Overall there should be fairly little changes to how Ember is taught. Since
the vast majority of users will need to make zero code changes and will have
zero change in actual behaviour.

## Drawbacks

Anyone using an unsupported browser will need to do feature detection
in their own code base or opt everyone into using the hash location.

https://caniuse.com/mdn-api_history_pushstate

## Alternatives

Do nothing.

## Unresolved questions

There are currently no unresolved questions.

## References

[1] https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
[2] https://guides.emberjs.com/release/configuring-ember/specifying-url-type/


---

---
stage: recommended
start-date: 2021-03-11T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
  - data
  - cli
  - learning
  - steering
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/724'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/869'
  released: 'https://github.com/emberjs/rfcs/pull/948'
  recommended: 'https://github.com/emberjs/rfcs/pull/952'
project-link:
---

# Official TypeScript Support

## Summary <!-- omit in toc -->

TypeScript has become a key part of the front-end development ecosystem over the past several years, and powers many of the best developer experiences in the front-end ecosystem. Ember was a relatively early TypeScript adopter for its internals, and there is widespread usage in the ecosystem with community support from the Typed Ember team, but to date Ember has not provided “out of the box” or official support for authoring apps or addons in TypeScript.

This RFC declares our intent to officially support TypeScript as a peer to JavaScript, in a way which makes the developer experience better for *all* Ember developers. It outlines the key constraints and goals for the effort, details a roadmap for accomplishing those goals, and provides the following definition of official support (from [Detailed Design: Defining Official Support](#defining-official-support)):

> Ember officially supporting TypeScript means: _**All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions for the current edition. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.**_


### Outline <!-- omit in toc -->

- [Motivation](#motivation)
- [Detailed design](#detailed-design)
  - [Defining Official Support](#defining-official-support)
  - [Constraints](#constraints)
  - [Non-Goals](#non-goals)
  - [Roadmap](#roadmap)
    - [RFC Required](#rfc-required)
      - [Types](#types)
      - [Official documentation](#official-documentation)
      - [Authoring and Build](#authoring-and-build)
    - [Implementation Details](#implementation-details)
    - [Recommendations](#recommendations)
  - [Semantic Versioning and Supported TypeScript Versions](#semantic-versioning-and-supported-typescript-versions)
- [How we teach this](#how-we-teach-this)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
- [Unresolved questions](#unresolved-questions)

## Motivation

TypeScript is a key ingredient of contemporary front-end development. Per community surveys like [the GitHub Octoverse](https://octoverse.github.com), the [Stack Overflow Developer report](https://insights.stackoverflow.com/survey/2020), and the [State of JS survey](https://2020.stateofjs.com/en-US/), TypeScript has exploded in popularity over the last half decade, and is the rare tool which has continuously grown in both usage and satisfaction over that time. While all of these surveys should be understood to be wildly unrepresentative of the broader front-end development community in various ways, they nonetheless provide some useful signal about the state of the ecosystem, especially when combined with experience reports from major companies like Microsoft (millions of lines of Typescript, all of it adopted voluntarily), Google, AirBnB, Dropbox, Bloomberg, Slack, and many others.

Additionally, the development of the language server protocol and the widespread adoption of the TypeScript language server has led to first-class support for TypeScript across many tools, from Vim to Visual Studio. This support also powers rich developer experiences for JavaScript-only developers, as it can provide smart autocomplete, inline documentation, and more even for codebases which are written solely in JavaScript. Thus, non-TypeScript and TypeScript users alike benefit when working with a project which supplies type definitions.

Ember users have been working with TypeScript for years with community support led by the Typed Ember team, but there is one critical problem which cannot be solved without making TypeScript support official, and several key ways in which official support would substantially improve the experience of both TypeScript and JavaScript developers:

- Solving the "SemVer problem" for Ember and TypeScript:

    - The TypeScript compiler does not follow semantic versioning, meaning anyone depending on it either explicitly (as a TypeScript user) or implicitly (as a consumer of the TypeScript Language Server, including for JavaScript editor support) is subject to uncontrolled breaking changes in their experience of Ember app and addon authoring. Supplying an official TypeScript version support policy would help stabilize the ecosystem, by guaranteeing accurate and up-to-date types which work with known supported versions of TypeScript, including the versions which power language server tooling for JS users.

    - *Many* JavaScript users (everyone who uses VS Code) currently implicitly depends on the unofficially maintained types from DefinitelyTyped via VS Code's [automatic type acquisition](https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition) feature. However, DefinitelyTyped does not allow us to properly version types with the libraries they represent, especially Ember core libraries. Publishing types officially would allow us to substantially improve the stability and correctness of those types, providing a better experience for all Ember developers, and *particularly* benefiting TypeScript users, for whom there are currently no good mechanisms to insulate them from breaking changes.

- Making it *easy* for everyone to benefit from TypeScript-powered enhancements to the ecosystem. Since TS types power autocomplete, documentation, go-to-definition, etc., supplying type definitions for the whole Ember ecosystem will make all Ember developers' "developer experience" better. Additionally, TypeScript-powered tooling is our best bet for supplying richly interactive feedback in templates, for both JS and TS developers.

- Closing a key gap with other front-end frameworks: React, Vue, Svelte, and Angular all have strong support for TS, and use its tooling to improve the authoring experience for JS and TS developers. Having top-notch TypeScript support would make Ember more compelling.

For TypeScript Ember users specifically:

- Easing adoption for interested parties. Both the Typed Ember team and Ember core team members semi-regularly hear from parties interested in TypeScript adoption, but for whom the lack of official support is a concern or even a roadblack. By making it an officially-supported option, we will increase confidence for existing Ember users who are interested but worried about the current community-driven support.

- Improving coordination, for example by guaranteeing that everything from RFC completion to Edition completion includes not only docs updates but also full TypeScript support for any new features.

- A richer and better-integrated experience for TS user from the Ember CLI tools, such as the generators and blueprints, which have historically required hand-maintenance (and accordingly fallen sorely out of date).

In sum, making TypeScript an officially supported language for Ember will benefit *all* Ember users, JavaScript and TypeScript alike; it will solve many pain points for TypeScript users that cannot otherwise be addressed; and it will close a gap for Ember compared to other frameworks.


## Detailed design

The primary goal of this RFC is to add TypeScript as an officially supported language. This involves the following major elements:

- Determining whether we *should* make TypeScript a first-class language
- [Defining official support](#defining-official-support): what it does and does not entail
- Identifying the [constraints](#constraints) under which adoption can proceed
- Making explicit the [non-goals](#non-goals) of this project
- Building a [roadmap](#roadmap) for completing the effort

This RFC intentionally does *not* propose the concrete solutions for each of the problems we will need to solve to successfully adopt TypeScript. Instead, the [Roadmap](#roadmap) below lays out a series of problems which require RFCs to resolve, which we believe to represent the full set of work required to officially support the language—neither the full set of work we would like to see for TypeScript in the years ahead nor the solutions to those problems, but a definition of a good MVP.


### Defining Official Support

Ember officially supporting TypeScript means: _**All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions for the current edition. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.**_

Key implications of this commitment:

- *Not all* libraries maintained as part of "Ember Core" must ship types: only those which come in the default blueprint. (Of course, many such libraries will *choose* to ship types for the benefits they offer to consumers; this is a matter of what we *guarantee*.)

- We have considerable flexibility in opting *into* increased backwards-compatibility, but can move forward at a reasonable pace. For example, we may choose to support *additional* features beyond those for the current edition, but may also drop support for earlier editions at a major version milestone.

- The Semantic Versioning specification, including definitions of SemVer for TypeScript types and TypeScript compiler support policy, will be a key artifact of this process. Without it, we will not be able to provide the stability guarantees Ember users have come to rely on.

- Given the importance of templates in Ember and Glimmer apps, “typed templates” are a key part of the path to adopting TypeScript as a community. TypeScript-powered integration between the template layer and the JavaScript context is a key goal for the Typed Ember team already. It is not a *gating feature* for Ember packages to officially supply TypeScript. Instead: the feature can be rolled out and integrated with Ember CLI, the Ember Language Server, and other tooling whenever it is ready, decoupled from the other efforts here. However, given its importance as one of the primary API boundaries within Ember and Glimmer apps, our definition of official Ember support would be incomplete without it.

### Constraints

The following are our hard constraints in supporting TypeScript with Ember:

- We must not compromise our commitment to “stability without stagnation” and our strong Semantic Versioning guarantees.
- Using TypeScript should never be mandatory for anyone who uses Ember.
- TypeScript support must never *degrade* the experience of JavaScript users, and wherever possible it should benefit both JavaScript and TypeScript developers.
- Types are published in the packages they represent, *not* in a third-party package.


### Non-Goals

The combination of constraints and ecosystem status lead us to a key non-goal for this effort. A *non-goal* here means that it is not part of the initial road to making TypeScript available.

This RFC aims to *add* a new first-class language to the Ember support matrix. However, it does *not* recommend replacing JavaScript with TypeScript. To the contrary: this is an explicit non-goal. Per the constraints described above, adding first-class TypeScript support should be a net positive for JavaScript-only Ember developers.

Additionally, this RFC does not propose changing the *default* experience from JavaScript to TypeScript even once we have full support for TypeScript.


### Roadmap

With this definition and associated design constraints in mind, the path to full TypeScript support in Ember requires RFCs to address key blockers, as well as some implementation details which do not require RFCs but are important for successfully delivering TypeScript support to our users..


#### RFC Required

Each of the following concerns must be addressed by RFCs. (Note that some RFCs might cover more than one of these points, but the use of a heading does not imply that a single RFC must cover all of the points within it.)


##### Types

- **The set of supported types.** Specifically, should the types support the whole API surface of Ember, including both Classic and Octane features, or only Octane features? Mixins, for example, are *not* part of the Octane programming model and are a major source of complexity in Ember’s current types; should they be included at all in types shipped with Ember?

- **Migration from DefinitelyTyped.** TypeScript users in the Ember community currently rely on the types in DefinitelyTyped. We need to define a transition story for them, which is closely related to the previous point. If we drop support for features currently supported on DefinitelyTyped, or make even well-motivated changes, how will users migrate successfully to them?

- **Semantic Versioning of types and TypeScript compiler version support.** We must *create a definition for semantic versioning of TypeScript types*, since there is currently no widely-used definition in the broader front-end ecosystem. (Hopefully this effort can benefit the broader TypeScript community!). Additionally, we must *define a support policy* for TypeScript versions: do we pin to a minimum type when we release a major, do something our Node support policy, or some other approach? (See also further discussion [below](#semantic-versioning-and-supported-typescript-versions).)

- **The `@glimmer/component@2.x` Type API.** The current Glimmer component TypeScript API works well, but research efforts into “typed templates” and [component documentation](https://github.com/emberjs/rfcs/pull/678) have both exposed the importance of being able to specify more “type parameters” for components than simply its args, including its root element(s) and blocks, if any. Additionally, the types should be readily extensible if other such concerns emerge in the future. For example: we might in the future want to be able to constrain what can and what cannot be “splatted” onto an element with `...attributes`; the type signature should be able to support that addition in a backwards-compatible way.

    (This may also be a good time to remove the `isDestroying` and `isDestroyed` properties and the `willDestroy` hook from the Glimmer Component API, to making a single set of breaking changes instead of multiple sets. Note, however, that official TypeScript support in Ember is not *gated* on those further changes.)


##### Official documentation

If Ember officially supports TypeScript, it is important that we support it in all of Ember’s documentation, including guides, API docs, etc. This requires considerable design effort, including thinking through how to present JavaScript and TypeScript (side by side? toggle-able? etc.), where to introduce discussion of TypeScript support in the guides, how API docs should be presented (and whether it may make sense to switch to something like API Extractor) and so on.

The official RFC templates for new features and for deprecations will also need to be updated:

- They must include a description of how changes affect TypeScript consumers.
- They will need to formally adopt TypeScript types as normative and required for new APIs, formalizing the rough pattern already common for new API designs.


##### Authoring and Build

- **How do consumers generate TypeScript apps and addons (and blueprints more generally)?** Should we support `ember new --typescript`? How should blueprints work? This will need to identify the path forward for authoring and publishing, Ember CLI integration, and in particular integration with the Embroider v2 Package Format. (If possible, TypeScript integration should piggy-back on the Embroider v2 *Authoring* Format, but if that format is not available, this is not a blocker.)

- **Supported compilation modes.** What should the out-of-the-box settings be for compiling Ember apps and addons written in TypeScript? This will need to be written with an eye to Embroider, preferably with the v2 Package Format as the *only* supported publication format. It must also address the transition path from current ember-cli-typescript (if any). It *must* address interoperation hazards between Babel and TypeScript: for example, in the decorators implementations, use of the `isolatedModules` setting and associated lints, etc.

- **Migration from the status quo.**  Today, users install `ember-cli-typescript` to opt into using TypeScript, and there is a wholly separate (and, unfortunately, very poorly-maintained) set of blueprints for working with TypeScript.  We will need to identify a migration story from the *current* paired design of `ember-cli-babel` and `ember-cli-typescript` to the future approach suggested by the previous bullet.


#### Implementation Details

There are also a number of key implementation concerns which must be addressed, but which, as implementation details, do *not* require RFCs:

- **How are the published types generated?** While much of Ember is implemented in TypeScript, its internal types are not currently ready to be used for public API, and it will likely take some time for them to be ready (with different packages ready at different times). We will need to determine how to publish hand-authored type-definition files, implementation-derived definition files, and over time a mix of the two until we hopefully are able to publish *only* implementation-derived files.

- **Where do published type definition files live in the artifacts published to npm?** TypeScript generally assumes that types are published with packages of the same name. While there is [now](https://emberjs.github.io/rfcs/0706-deprecate-ember-global.html) a path to publishing actual packages like `"@ember/object"`, this effort should not be gated on any such effort, and there is additional work to be done. However, that work simply consists of implementation details, rather than defining new public API.

- **How do app and addon authors *consume* published types?** There are a few “gotchas” about how TypeScript supports features like autocomplete in a project, which primarily affect the very first few interactions end users have with TypeScript, which we should address via tooling. How this works is closely related to where the type definition files are generated during publication, and so will likely need to be solved in conjunction with that issue.

- **What should the final design for template-aware type checking be?** [Glint][glint] has a number of decisions which make good sense and indeed are necessary for template-aware type checking given both the design constraints of the Octane era and its own experimental status. However, we should nail these down before it becomes an officially-recommended tool!

[glint]: https://github.com/typed-ember/glint


#### Recommendations

Since the authoring and support policies we adopt for Ember itself will likely be adopted in an _ad hoc_ way, it may be useful to provide official *recommendations* for authors. These might include:

- Semantic Versioning guidelines
- tooling recommendations (in line with the defaults for the build pipeline)
- documentation guidelines

The existence of these guidelines is not a requirement for Ember's official adoption of TypeScript, but the adoption process would be a prime opportunity to generate these artifacts.


### Semantic Versioning and Supported TypeScript Versions

Ember and TypeScript have fundamentally different views on Semantic Versioning (SemVer).

Ember has a deep commitment to minimizing breaking changes in general, and to strictly following SemVer when breaking changes *are* made. (The use of lockstep versioning for Ember Data and Ember CLI complicates this commitment to a substantial degree, but that complication is outside the scope of this RFC.)

TypeScript explicitly *does not* follow SemVer. TypeScript's core team argues that *every* change to the compiler is a breaking change, and that SemVer is therefore meaningless. (We do not agree with this characterization, but are also uninterested in arguing it. This RFC takes the TypeScript team's position as a given.) Accordingly, every TypeScript point release may be a breaking change, and "major" numbers for releases signify nothing beyond having reached `x.9` in the previous cycle.

For TypeScript to be a first-class citizen of the Ember ecosystem, we need:

- a policy defining what constitutes a breaking change for consumers of a library which publishes types, including Ember’s core libraries
- tooling to detect breaking changes in types—whether from refactors, or from new TypeScript releases—and to minimize the amount of churn from breaking changes in TypeScript
- a general and widely-adopted policy for supported TypeScript versions

Once all three of those elements are adopted, end users will be able to have equally high confidence in the stability of published types as they do in their runtime code.


## How we teach this

This RFC intentionally defers most of the analysis of teaching work to an RFC dedicated to the question. At a high level, once the roadmap is complete, the Ember blog should announce support, and Ember’s docs should explicitly state that TypeScript is officially supported and show TypeScript examples alongside JavaScript examples.

It is critical that these materials (including the blog post) emphasize that TypeScript support is *additive*, not a replacement for JavaScript, as discussed above in [Non-Goals](#non-goals).


## Drawbacks

Adding TypeScript support imposes an additional maintenance burden on all contributors to Ember:

- documentation must be kept up to date in both JavaScript and TypeScript
- changes to APIs must be kept in sync with published types (when the types are not generated from the implementation)
- managing support for TypeScript versions will require additional effort and versioning coordination
- presumably, API designs will be constrained in new ways (though this may also be an upside!)


## Alternatives

TypeScript support has historically been managed by the community. We could continue with this approach, including e.g. investigating other alternatives to DefinitelyTyped for supplying types in a more robust way. This has worked reasonably well to date, though it has added friction for adopters, especially when the Typed Ember maintainers could not keep up with changes to Ember itself.


## Unresolved questions

> Optional, but suggested for first drafts. What parts of the design are still
TBD?


---

---
stage: recommended
start-date: 2021-03-13T00:42:02.085Z
release-date:
release-versions:
  dom-element-descriptors: 0.5.1
  '@ember/test-helpers': 3.3.0
  qunit-dom: 3.2.0
  fractal-page-object: 1.0.0
teams:
  - cli
  - framework
  - learning
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/726'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/992'
  released: 'https://github.com/emberjs/rfcs/pull/1004'
  recommended: 'https://github.com/emberjs/rfcs/pull/1039'
project-link:
suite:
---

# DOM Element descriptor interface for test helpers

## Summary

[@ember/test-helpers](https://github.com/emberjs/ember-test-helpers)' DOM helpers and [qunit-dom](https://github.com/simplabs/qunit-dom) accept either a selector or an `Element` as their DOM element descriptor, which is a pretty common pattern. This RFC proposes an interface that generalizes the notion of a DOM element descriptor that `@ember/test-helpers`' DOM helpers, `qunit-dom`, and other similar test support libraries in the Ember ecosystem can support, so page object implementations such as [fractal-page-object](https://github.com/bendemboski/fractal-page-object) and [ember-cli-page-object](http://ember-cli-page-object.js.org/) can implement the interface and integrate cleanly and ergonomically with these test support libraries.

## Motivation

In this RFC we'll use **DOM element descriptor** to mean a Javascript value that can be used to retrieve one or more `Element`s from a rendered DOM. Examples include a string containing a CSS selector, a direct reference to an `Element`, a function that returns an `Element` or `null`, a function that returns an array of `Element`s, etc.

In this RFC we'll use **DOM helper** to mean an API that is passed a DOM element descriptor, and performs some actions based on the element or elements the descriptor describes. Examples include `@ember/test-helpers`' DOM helper methods such as `click()` and `triggerEvent`, and `qunit-dom`'s assertion factory API, i.e. `assert.dom()`.

Ember's testing ecosystem has converged on a single set of recommended DOM helpers. `@ember/test-helpers` provides the core value of implementing DOM interactions, while `qunit-dom` provides the core value of making assertions about DOM query results. They do _not_ (nor should they) provide the core value of advanced DOM querying -- they act on DOM elements, and do the simple baseline of supporting two kinds of DOM element descriptors, CSS selector strings and `Element` references.

[Page Objects](https://martinfowler.com/bliki/PageObject.html) are a powerful and popular tool for making test code well organized, readable, and maintainable. The core value they provide is supporting the implementation of a domain-specific languange (DSL) for interacting with a rendered DOM. Such DSLs can be thought of as, among other things, providing powerful and resuable DOM element descriptors.

Supporting a clean integration of page objects (or, indeed, anything that produces DOM element descriptors that aren't CSS selectors or direct `Element` references) with DOM helpers like the ones in `@ember/test-helpers` and `qunit-dom` would keep each focused on its core value, while providing "first-class" support for page objects and other DOM element descriptors.

As a case study (and most proximate motivation for this RFC), let's consider `fractal-page-object`. Currently `fractal-page-object` integrates with `@ember/test-helpers` and `qunit-dom` by exposing an `element` property on all page objects, and that works because their APIs accept direct `Element` references. But this has three major drawbacks:

1. It only supports single elements. While this isn't an issue with the `@ember/test-helpers` DOM APIs, in `qunit-dom` that means there's no way to use the multi-element assertions, analogous to  `assert.dom(document.querySelectorAll('.list-item')).exists({ count: 3 })`.
2. It does not produce useful information when encountering an error/failure. For example, `await click('.does-not-exist')` errors with `Error: Element not found when calling click('.does-not-exist').`, while `await click(document.querySelector('.does-not-exist'))` errors with the less helpful `Error: Must pass an element or selector to 'click'` (because it doesn't have any other information to show -- all it knows is it was passed `null` instead of a selector or `Element`). Similarly, `assert.dom('.does-not-exist').exists()` produces the assertion message `Element .does-not-exist exists`, while `assert.dom(document.querySelector('.does-not-exist')).exists()` produces the less helpful `Element <not found> exists`.
3. It supports a noticeably less ergonomic integration with page objects. In `fractal-page-object`, the integrations currently look like `await click(page.listItems[2].checkbox.element)` and `assert.dom(page.listItems[2].checkbox.element).isChecked()`, rather than `await click(page.listItems[2].checkbox)` and `assert.dom(page.listItems[2].checkbox).isChecked()`. While it may look like a minor difference, in practice it's quite a stumbling block as the mental model of page objects encourages users to think of page object nodes (e.g. `page.listItems[2].checkbox`) as a proxy for the DOM element(s) they describe, so forgetting to add the `.element` is extremely common, even for the author of the library!

We can solve these by formalizing the notion of DOM element descriptors in an interface, so page object implementations and any other mechanisms for DOM access can produce objects implementing this interface and they can be passed to these test helpers without incurring any of the shortcoming described above.

## Detailed design

### New use cases

We're seeking to address two specific new use cases, although the design should be extensible to other unforeseen use cases as well.

#### Page objects

Page objects can be used as DOM element descriptors and passed directly to DOM helpers:

```js
assert.dom(pageObject.listItems).exists({ count: 4 });

await click(pageObject.listItems[2].checkbox);

assert.dom(pageObject.listItems[2].checkbox).isChecked();
```

This will enable more ergonomic integrations of libraries like `ember-cli-page-object` and `fractal-page-object` with DOM helpers.

#### Ad-hoc descriptors

DOM element descriptors can be constructed directly from `Element`s:

```ts
let element = someOtherLibrary.getGraphElement();
let descriptor = createDOMDescriptor({ element, description: 'graph element' });

await click(descriptor);

assert.dom(descriptor).hasClass('selected');
```

or from simple classes for lazy DOM lookups:

```ts
class MyDescriptorData {
  get element() {
    return document.querySelectorAll('.list-item')[2];
  }
  readonly description = 'second list item';
}
let descriptor = createDOMDescriptor(new MyDescriptorData());

assert.dom(descriptor).doesNotExist();

await click('.add-list-item');

assert.dom(descriptor).exists();
```

This will enable more flexible queries than CSS selectors support without losing descriptive debug/assertion messages.

### Namespacing constraints

The page object use case introduces a significant constraint. Page objects are necessarily extensible, allowing users to define their own properties on them, so a DOM element descriptor interface that relies on properties stored on the object implementing the interface risks conflicts with user-defined properties. For example, if a user implements an album info page object for a page that shows information on an album, it might have a `description` property exposing the rendered text of the album's description, which would mean that it could not also implement an interface that requires it to expose the DOM element descriptor's description under a `description` property.

To address this, we conceive of DOM element descriptors as arbitrary objects whose descriptor data is registered and stored in some private fashion that avoids namespace concerns (e.g. in a `WeakMap`).

### The design

This RFC proposes implementing a library that exports two core functions, and several other convenience methods to improve ergonomics.

#### Core functions

```ts
const IS_DESCRIPTOR = '__is_descriptor__';

interface IDOMElementDescriptor {
  readonly [IS_DESCRIPTOR]: any;
}

interface DescriptorData {
  readonly element?: Element | null;
  readonly elements?: Iterable<Element>;
  readonly description?: string;
}

function registerDescriptorData(descriptor: IDOMElementDescriptor, data: DescriptorData): void;
function lookupDescriptorData(descriptor: IDOMElementDescriptor): DescriptorData;
```

(the interfaces have been simplified a bit for illustrative purposes -- in particular, `DescriptorData` would need to enforce that at least one of `element` and `elements` is defined)

`IDOMElementDescriptor` is a "no-op interface" -- it has no properties or methods, and only exists to support typing. So typescript concerns aside, it can be thought of as just `object`. However since the compiler will implicitly cast anything to an empty interface, we give it a property so the compiler can help prevent accidentally passing non-descriptors to functions that accept descriptors.

`DescriptorData` is a type that contains an `element` property and/or an `elements` property, and also an optional `description` property. The `element` and `elements` properties exist to support usage in both single-element contexts (the equivalent of passing a selector to `querySelector()`) and multi-element contexts (the equivalent of passing a selector to `querySelectorAll()`). At least one of them must be defined, and both may be defined. If only the `element` property is defined, then multi-element contexts should act as if the `elements` property were defined to be either an empty iterable or a singleton iterable, depending on whether the `element` property evaluates to `null` or an `Element`. If only the `elements` property is defined, then single-element contexts should act as if `element` were defined to be the first element of the `elements` property, or `null` if the `elements` property evaluates to an empty iterable. To illustrate further, here are two possible implementations of functions to resolve descriptors to DOM elements:

```ts
function getDescriptorElement(data: DescriptorData): Element | null {
  if (data.element !== undefined) {
    return data.element;
  } else {
    return Array.from(data.elements)[0] || null;
  }
}

function getDescriptorElements(data: DescriptorData): Iterable<Element> {
  if (data.elements) {
    return data.elements;
  } else {
    let element = data.element;
    return element ? [element] : [];
  }
}
```

It would be possible to only support an `elements` property and always have single-element contexts determine their element as described above, but since the vast majority of current DOM helpers are single-element, we allow `DescriptorData` instances to define both to allow optimizations, e.g. a class implementing `element` and `elements` as getters could call `querySelector()` instead of `querySelectorAll()` when `element` is accessed.

Producers of DOM element descriptors, like page objects or test code producing ad-hoc DOM element descriptors, will use `registerDescriptorData()` to associate data with descriptors, and DOM helpers that are passed descriptors will use `lookupDescriptorData()` to retrieve the data for a given descriptor.

#### Convenience methods

The library will include a convenience function for creating ad-hoc DOM element descriptors:

```ts
function createDescriptor(data: DescriptorData): IDOMElementDescriptor
```

which would create an `IDOMElementDescriptor`, use it to register the data, then return it. No equivalent is required for page objects, as the expectation is that they will themselves be `IDOMElementDescriptors`, so they will only need to perform the registration step from their constructor.

The library will also include some functions for use by DOM helpers when using DOM element descriptors to access the DOM. They can use `lookupDescriptorData()` directly, but as mentioned above, that would involve some "boilerplate" code for resolving the data to actual DOM elements in single- or multi-element contexts, since the descriptor data might only have one of `element` or `elements` defined. So the library will implement

```ts
function resolveDOMElement(target: IDOMElementDescriptor | DescriptorData): Element | null;
function resolveDOMElements(target: IDOMElementDescriptor | DescriptorData): Iterable<Element>;
```

It may make sense to implement some kind of

```ts
function getDescription(target: IDOMElementDescriptor | DescriptorData): string;
```

function for returning the descriptor's `description` or deriving some kind of reasonable default description from the descriptors elements, but that's outside the scope of this RFC, and only mentioned here to help paint the broader picture. It may also make sense to implement additional types and helpers to streamline the boilerplate arguments-resolving logic in DOM helpers that accept `Element`s, CSS selector `string`s, and `IDOMElementDescriptors`.

## How we teach this

This is primarily taught through the API documentation of the various libraries that implement compliant DOM helpers, such as `@ember/test-helpers` and `qunit-dom`, and libraries that produce DOM element descriptors, such as `fractal-page-object`. In addition the new library proposed in this RFC would have documentation explaining the infrastructure and how to use it.

The Ember guides would not need to be updated, as the default Ember testing methodology would be unaffected -- this would be added functionality for users using page object libraries, or implementing ad-hoc element descriptors in their tests. However, if Ember's guides were ever extended to include page object testing methodologies, we would need to include a discussion of DOM element descriptors.

Also, if we were to discover any new and valuable testing methods/patterns that are unlocked by DOM element descriptors, we might want to discuss them, along with DOM element descriptors themselves, in Ember's educational materials.

## Drawbacks

* This would increase the complexity of the DOM helper and assertion APIs
* This would add a small amount of extra maintenance cost to those libraries as all new code does

## Alternatives

### Do nothing

This mainly improves developer ergonomics by allowing for better error/failure messaging and a simpler/more natural semantics when passing page objects to DOM helper/assertion methods. We could decide that the status quo is good enough, and the improved ergonomics are not worth the cost.

### Symbol for data storage

Instead of using a private data storage to associate the descriptor data with the `IDOMElementDescriptor`s, we could export a `Symbol` to solve the namespacing problem:

```ts
export const DESCRIPTOR_DATA = Symbol('descriptor data');

export interface IDOMElementDescriptor {
  [DESCRIPTOR_DATA]: DescriptorData;
}
```

This is maybe a slightly more familiar pattern to some, and might make debugging slightly easier, but doesn't seem to confer any real benefits. Moreover, the internal implementation of `registerDescriptorData` and `lookupDescriptorData` could store the state on the `IDOMElementDescriptor` object using a private `Symbol` if that were discovered to be advantageous in the future.

### One interface, three symbols

We could get rid of the `DescriptorData` type entirely and modify the `IDOMElementDescriptor` interface to store `element`, `elements`, and `description` on properties keyed by three different public `Symbol`s. This doesn't seem to confer any real benefits that aren't captured by the primary proposal or the `Symbol for data storage` alternative, and makes ad-hoc descriptors less ergonomic:

```ts
let element = someOtherLibrary.getGraphElement();
let descriptor = {
  [ELEMENT]: element,
  [DESCRIPTION]: 'graph element'
};
await click(descriptor);
assert.dom(descriptor).hasClass('selected');
```

## Unresolved questions

* What do we call the new library?


---

---
stage: recommended
start-date: 2021-03-23T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
  - steering
  - data
  - cli
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/730'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/875'
  released: 'https://github.com/emberjs/rfcs/pull/949'
  recommended: 'https://github.com/emberjs/rfcs/pull/951'
project-link:
---

# Semantic Versioning for TypeScript Types

## Note on Authoritative Source

**The living specification to which Ember is committed lives at [www.semver-ts.org](https://www.semver-ts.org).**

The text below represents the RFC as it was merged as part of Ember.js’ RFC process. However, [per the text below](#how-we-teach-this), this is not the authoritative form of this specification:

> If these recommendations are adopted, the **Detailed Design** section shall be published to a dedicated, standalone repository to ease linking to it (including by TypeScript packages beyond the Ember ecosystem, if they find it useful, as we hope they will!).

Accordingly, the text below represents the state of the specification at the time it was accepted as for Ember’s purposes, with the expectation that it will continue to evolve and be improved over time.

-----


## Summary

This RFC proposes a definition of [Semantic Versioning][semver] for managing changes to TypeScript types, including when the TypeScript compiler makes breaking changes in its type-checking and type emit across a “minor” release.(Note that this RFC addresses *only* type checking and type emit, *not* the “transpilation” mode of the TypeScript compiler.)

[semver]: https://semver.org

(While this RFC is being authored in the context of [Ember.js’ adoption of TypeScript as a first-class supported language][RFC #0724], its recommendations are intentionally general, in hopes that these recommendations can be widely adopted by the broader TypeScript community.)

[RFC #0724]: https://github.com/emberjs/rfcs/pull/724


### Design overview

This section is a non-normative short summary for easy digestion. See [**Detailed Design**](#detailed-design) below for normative text.


#### For package consumers

Things a package may do in a non-breaking way:

- widen what it accepts from you
- narrow what it provides to you
- add new exports

Things which constitute breaking changes in a package:

- narrowing what it accepts from you
- widening what it provides to you
- removing exports

Note that this summary elides *many* important details, and those details may surprise you! In particular "what it accepts" and "what it provides" have considerable depth and nuance: they include interfaces or types you can construct, function arguments, class field mutability, and more.

#### For package authors

-   Public published types are part of the SemVer contract of a package, and must be versioned accordingly, per the specification above.

-   Adding a new TypeScript version to the support matrix *may* cause breaking changes. When it does not, adding it is a normal minor release. When it *does* cause a breaking change, the package must either mitigate that breakage (so consumers are not broken) *or* the package must release a major version.

-   Removing a TypeScript version from the support matrix is a breaking change, except when it falls out of the supported version range under the “rolling support windows” policy.

-   There are two recommended support policies for TypeScript compiler versions: *simple majors* and *rolling window*.

    -   In *simple majors*, dropping support for a previously supported compiler version requires a breaking change.

    -   In *rolling window*, a package may declare a range of supported versions which moves over time, similar to supporting evergreen browsers.

        Packages using the “rolling window” policy should normally support all TypeScript versions released during the current ‘LTS’ of other core packages/runtimes/etc. they support, and drop support for them only when they drop support for that ‘LTS’, to minimize the number of major versions in the ecosystem.

-   Both the currently-supported compiler versions and the compiler version support policy must be documented.

-   Packages must be authored with the following compiler options:
    -   `strict: true`
    -   `noUncheckedIndexedAccess: true`

-   Libraries should generally be authored with the following compiler options:
    -   `esModuleInterop: false`
    -   `allowSyntheticDefaultImports: false`


### Outline <!-- omit in toc -->

- [Summary](#summary)
    - [Design overview](#design-overview)
        - [For package consumers](#for-package-consumers)
        - [For package authors](#for-package-authors)
- [Motivation](#motivation)
- [Detailed design](#detailed-design)
    - [Background: TypeScript and Semantic Versioning](#background-typescript-and-semantic-versioning)
    - [Defining breaking changes](#defining-breaking-changes)
        - [Definitions](#definitions)
        - [Reasons for Breaking Changes](#reasons-for-breaking-changes)
    - [Changes to types](#changes-to-types)
        - [Variance](#variance)
        - [Breaking Changes](#breaking-changes)
        - [Non-breaking changes](#non-breaking-changes)
        - [Bug fixes](#bug-fixes)
    - [Compiler considerations](#compiler-considerations)
    - [Conformance](#conformance)
- [How we teach this](#how-we-teach-this)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
    - [No policy](#no-policy)
    - [Decouple TypeScript support from LTS cycles](#decouple-typescript-support-from-lts-cycles)
- [Unresolved questions](#unresolved-questions)
- [Appendices](#appendices)
    - [Appendix A: Existing Implementations](#appendix-a-existing-implementations)
    - [Appendix B: Tooling](#appendix-b-tooling)
        - [Documenting supported versions and policy](#documenting-supported-versions-and-policy)
        - [Detect breaking changes in types](#detect-breaking-changes-in-types)
        - [Mitigate breaking changes](#mitigate-breaking-changes)
        - [Matching exports to public API](#matching-exports-to-public-api)
    - [Appendix C: On Variance in TypeScript](#appendix-c-on-variance-in-typescript)
        - [Inference and pervasive mutability](#inference-and-pervasive-mutability)
        - [Structural typing](#structural-typing)
        - [Higher-order type operations](#higher-order-type-operations)


## Motivation

For TypeScript packages be good citizens of the broader, semantically-versioned JavaScript ecosystem, package authors need a useful definition of SemVer for TypeScript’s type system.

This is somewhat more complicated than in other languages, even those other statically-typed languages with language-level SemVer guarantees (such as [Rust][rust-semver] and Elm), because TypeScript has an unusually flexible type system. In particular, its [structural type system][structural] means many more kinds of both breaking and non-breaking changes are possible than in languages with a [nominal type system][nominal].[^other-structural-types] Accordingly, this document proposes a definition of SemVer which accounts for the extra flexibility afforded by these features.

[rust-semver]: https://rust-lang.github.io/rfcs/1122-language-semver.html
[structural]: https://en.wikipedia.org/wiki/Structural_type_system
[nominal]: https://en.wikipedia.org/wiki/Nominal_type_system

Furthermore, unlike the rest of the JavaScript ecosystem, the TypeScript compiler explicitly *rejects* SemVer. TypeScript's core team argues that *every* change to a compiler is a breaking change, and that SemVer is therefore meaningless for TypeScript. We do not agree with this characterization, but take the TypeScript team's position as a given for the purposes of this document. Accordingly, every TypeScript non-patch release may be a breaking change, and "major" numbers for releases signify nothing beyond having reached `x.9` in the previous cycle.

This means that defining SemVer for TypeScript Types requires that we specify a definition of Semantic Versioning which can absorb breaking changes in the TypeScript compiler as well as intentional changes by package authors. As such, it also requires clearly defined TypeScript compiler version support policies.

[^other-structural-types]: Many languages include structural typing in certain contexts, including Swift's protocols, Elm's record types, and row-polymorphic types in OCaml, PureScript, etc. However, of these only Elm provides language-level guidance or tooling, and at the time of authoring there is no public specification of its behavior. Its current algorithm is [implementations-specified][elm-compat] and roughly checks for addition or removal of fields.

[elm-compat]: https://github.com/elm/compiler/blob/770071accf791e8171440709effe71e78a9ab37c/builder/src/Deps/Diff.hs#L128-L136


## Detailed design

TypeScript types should be treated with exactly the same (or even greater!) rigor as other elements of the JavaScript ecosystem, with the same level of commitment to stability, clear and accurate use of Semantic Versioning, testing, and clear policies about breaking changes.

TypeScript introduces two new concerns around breaking changes for packages which publish types.

1.  TypeScript does not adhere to the same norms around Semantic Versioning as the rest of the npm ecosystem, so it is important for package authors to understand when TypeScript versions may introduce breaking changes without any other change made to the package.

2.  The runtime behavior of the package is no longer the only source of potentially-breaking changes: types may be as well. In a well-typed package, runtime behavior and types should be well-aligned, but it is possible to introduce breaking changes to types without changing runtime behavior and vice versa.

Accordingly, we must define breaking changes precisely and carefully.


### Background: TypeScript and Semantic Versioning

TypeScript ***does not*** adhere to Semantic Versioning, but since it participates in the npm ecosystem, it uses the same format for its version numbers: `<major>.<minor>.<patch>`.

In Semantic Versioning, `<major>` would be a breaking change release, `<minor>` would be a backwards-compatible feature-addition release, and `<patch>` would be a "bug fix" release.

In TypeScript, both `<major>` and `<minor>` releases *may* introduce breaking changes of the sort that Semantic Versioning reserves for the `<major>` slot in the version number. Not all `<minor>` *or* `<major>` releases *do* introduce breaking changes in the normal Semantic Versioning sense, but either *may*. Accordingly, and for simplicity, the JavaScript ecosystem should treat *all* TypeScript `<major>.<minor>` releases as a major release.

TypeScript's use of patch releases is more in line with the rest of the ecosystem's use of patch versions. The TypeScript Wiki [currently summarizes patch releases][ts-patch-releases] as follows:

> Patch releases are periodically pushed out for any of the following:
>
> - High-priority regression fixes
> - Performance regression fixes
> - Safe fixes to the language service/editing experience
>
> These fixes are typically weighed against the cost (how hard it would be for the team to retroactively apply/release a change), the risk (how much code is changed, how understandable is the fix), as well as how feasible it would be to wait for the next version.

These three categories of fixes are well within the normally-understood range of fixes that belong in a "bug fix" release in the npm ecosystem. In these cases, a user's code may stop type-checking, but *only* if they were depending on buggy behavior. This matches users' expectations around runtime code: a SemVer patch release to a package which fixes a bug may cause packages which were depending on that bug to stop working.

By example:

-   `4.8.3` to `4.8.4`: always considered a bug fix
-   `4.8.3` to `4.9.0`: *may or may not* introduce breaking changes; equivalent to a major in the rest of the ecosystem
-   `4.9.0` to `5.0.0`: *may or may not* introduce breaking changes; equivalent to a major in the rest of the ecosystem

[ts-patch-releases]: https://github.com/microsoft/TypeScript/wiki/TypeScript's-Release-Process/e669ab1ad96edc1a7bcef5f6d9e35e24397891e5


### Defining breaking changes

Changes to the types of the public interface are subject to the same constraints as runtime code: *breaking the public published types entails a breaking change.* Not all changes to published types are *breaking*, however:

- Some changes will continue to allow user code to continue working without any issue.
- Some published types represent private API.

It is impossible to define the difference between breaking and non-breaking changes purely in the abstract. Instead, we must define exactly what changes are "backwards-compatible" and which are "breaking," and we must further define what constitutes a legitimate "bug fix" for type definitions designed to represent runtime behavior. Note that this is a *socio-technical* contract, not a purely-technical contract, and therefore (contra [Hyrum’s Law][hyrum]) a breaking change is not simply *any observable change to a system* but rather *a change to the system which violates the contract*.

[hyrum]: http://www.hyrumslaw.com

Accordingly, we propose the following specific definitions of breaking, non-breaking, and bug-fix changes for TypeScript types. Because types are designed to represent runtime behavior, we assume throughout that these changes *do* in fact correctly represent changes to runtime behavior, and that changes which *incorrectly* represent runtime behavior are *bugs*.

**Note:** The examples supplied throughout via links to the TypeScript are illustrative rather than normative. However, the distinction between "observed" and "promised" behavior in TypeScript is quite loose: there is no independent specification, so the formal behavior of the type system is implementation-specified.


#### Definitions

<dl>

<dt>Symbols</dt>
<dd>

There are two kinds of *symbols* in TypeScript: value symbols and type symbols. (Note that these are distinct from the [Symbol][symbol] object in JavaScript.)

[symbol]: http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol

Value symbols represent values present at runtime in JavaScript:

- `let`, `const`, and `var` bindings
- `function` declarations
- `class` declarations
- `enum` and `const enum` declarations
- `namespace` declarations (which produce or represent *objects* at runtime)

Type symbols represent types which are used in type checking:

- `interface` declarations
- `type` (type alias) declarations
- `function` declarations
- `class` declarations
- `enum` and `const enum` declarations

(Note that `namespace` declarations can also be present in type-only declarations, as when a type is exported from a namespace and referenced like `let val: SomeNamespace.ExportedInterface`, but the value produced by the `namespace` is not itself a type.)

</dd>

<dt>Functions</dt>
<dd>

Unless otherwise specified, "functions" always refers interchangeably to: functions in standalone scope, whether defined with either `function` or an arrow; class methods; and class constructors.

</dd>

<dt>User constructibility</dt>
<dd>

A type is user-constructible if the consumer of a package is allowed to create their own objects which match a given type structurally, that is, *without* using a function or class exported from the package which provides the type.

For example, a package may choose to export an interface to allow users to name the type returned by a function, while specifying that the only legal way to construct such an interface is via that exported function, in which case the type is *not* user-constructible.

Alternatively, a package may export an interface or type alias explicitly for users to construct objects implementing that type, in which case the type *is* user-constructible.

</dd>
<dd>

Using the type-level `typeof` operator to construct a type using the type of an exported item from a library wholly defeats the ability of authors to specify a public API. Accordingly:

1. Authors who wish to treat any given type as user-constructible should export a type definition for it under their public API contract (see the next section).
2. A type defined in terms of `typeof` which “breaks” under the rules discussed below is *not* breaking, because it was not legally user-constructible.

</dd>
<dd>

One challenge for this definition is the common scenario where code is not ordinarily user-constructible but may need to be mocked for tests. Changes to these *do not* constitute breaking changes—but library authors can also mitigate the challenge presented by this scenario. (See discussion below under [Appendix B: Tooling – Mitigate Breaking Changes – Avoiding User constructibility](#avoiding-user-constructibility).)

</dd>
<dd>

**Non-normative example:** in Ember.js today, the interface for a `Transition` is public API and consumers can rely on its stability, but only Ember is allowed to create `Transition` instances.

If a user imported the `Transition` interface and wrote a `class CustomTransition implements Transition { ... }`, this would be stepping outside the SemVer contract.

</dd>

<dt>Public API</dt>
<dd>

**Overview:** Some packages may choose to specify that the public API consists of *documented* exports, in which case no published type may be considered public API unless it is in the documentation. Other packages may choose to say the reverse: all exports are public unless explicitly defined as private (for example with the `@private` JSDoc annotation, a note in the docs, etc.).
In either case, no change to a type documented as private is a breaking change, whether or not the type is exported, where *documented as private* is defined in terms of the documentation norm of the package in question.

</dd>
<dd>

**Documentation of user constructibility:** Exported types (interfaces, type aliases, and the type side of classes) may be defined by documentation to be user-constructible or not.

</dd>
<dd>

**Documentation of subclassibility:** Exported classes may be defined by documentation to be user-subclassible or not.

</dd>

<dd>

**Re-exports:** using the `export * from` re-export syntax can in theory cause breakage by causing export conflicts: if the library being re-exported and the library doing the re-export both export the same name. For this reason, changes caused by the `export * from ...` are never breaking changes.[^re-export-antipattern]

</dd>

[^re-export-antipattern]: In general, it is an antipattern for one package to re-export another package directly like this, and the cases where it makes sense (e.g. Ember re-exporting Glimmer APIs) are cases of collaborators which can manage this.

#### Reasons for Breaking Changes

Each of the kinds of breaking changes defined below will trigger a compiler error for consumers, surfacing the error. As such, they should be easily detectable by testing infrastructure (see below under [Tooling: Detect breaking changes in types](#detect-breaking-changes-in-types)).

There are several reasons why breaking changes may occur:

1.  The author of the package may choose to change the API for whatever reason. This is no different than the situation today for packages which do not support TypeScript. This would be a major version independent of types.

2.  The author of the package may need to make changes to adapt to changes in the JavaScript ecosystem, for example to support Octane idioms in Ember.js. This is likewise identical with the situation for packages which do not support TypeScript: it would require a major version regardless.

3.  Adopting a new version of TypeScript may change the meaning of existing types. For example, in TypeScript 3.5, generic types without a specified default type changed their default value from `{}` to `unknown`. This improved type safety, but broke many existing types, as [described in detail by Google][3.5-breakage].

4.  Adopting a new version of TypeScript may change the type definitions emitted in `.d.ts` files in backwards-incompatible ways. For example, changing to use the finalized ECMAScript spec for class fields meant that [types emitted by TypeScript 3.7 were incompatible with TypeScript 3.5 and earlier][3.7-emit-change].

[3.5-breakage]: https://github.com/microsoft/TypeScript/issues/33272
[3.7-emit-change]: https://github.com/microsoft/TypeScript/pull/33470

The kinds of breaking changes represented by reasons (1) and (2) are described below under [**Changes to Types**](#changes-to-types); reasons (3) and (4) are discussed below in [**Compiler Considerations**](#compiler-considerations).

Additionally, there are some changes which we define *not* to be breaking changes because, while they will cause the compiler to produce a type error, they will do so in a way which simply allows the removal of now-defunct code.

### Changes to types

#### Variance

Virtually all of the rules around what constitutes a breaking change to types come down to *variance*.[^variance] In a real sense, everything in the discussion below is a way of showing the variance rules by example.[^thanks-to-ryan]

[^variance]: For the purposes of this discussion, I will *assume* knowledge of variance, rather than explaining it.

[^thanks-to-ryan]: Thanks to [Ryan Cavanaugh](https://github.com/RyanCavanaugh) of the TypeScript team for pointing out the various examples which motivated this discussion.

In many cases, these are the standard variance rules applicable in any and all languages with types:

- read-only types (sources) may be covariant
- write-only types (sinks) may be contravariant
- read-write (mutable) types must be invariant

These basic intuitions underlie the guidelines below. However, several factors complicate them.

First of all, notice that the vast majority of objects in JavaScript are mutable, which means they must be *invariant*. When combined with type inference, this effectively means that *any* change to an object type *can* cause breakage for consumers. (The only real counter-examples are `readonly` types.)

Additionally, TypeScript has two other features many other languages do not which complicate reasoning about variance: *structural typing*, *higher-order type operations*. The result of these additional features is a further impossibility of safely writing types which can be *guaranteed* never to stop compiling for runtime-safe changes.

Accordingly, we propose the rules below, with the caveat that (as noted in several places throughout) they will *not* prevent all possible breakage—only the majority of it, and substantially the worst of it. Most of all, they give us a workable approach which can be well-tested and well-understood, and the edge cases identified here do not prevent the rules from being generally useful or applicable.[^satisficery]

[^satisficery]: Precisely because SemVer is a *sociological* and not only a *technical* contract, the problem is tractable: We define a breaking change as above, and accept the reality that some changes are not preventable (but may in many cases be mitigated or fixed automatically). This is admittedly unsatisfying, but we believe it [satisfices](https://www.merriam-webster.com/dictionary/satisfice) our constraints.


For a more detailed explanation and analysis of the impact of variance on these rules, see [**Appendix C**](#appendix-c-on-variance-in-typescript).

#### Breaking Changes

##### Symbols

Changing a symbol is a breaking change when:

-   changing the name of an exported symbol (type or value), since users' existing imports will need to be updated. This is breaking for value exports (`let`, `const`, `class`, `function`) independent of types, but renaming exported `interface`, `type` alias, or `namespace` declarations is breaking as well.

-   removing an exported symbol, since users' existing imports will stop working. This is a breaking change for value exports (`let`, `const`, `class`, `function`) independent of types, but removing exported `interface`, `type` alias, or `namespace` declarations is breaking as well.

    This includes changing a previously type-and-value export such as `export class` to either—

    -   a type-only export, since the exported value symbol has been removed:

        ```diff
        -export class Foo {
        +class Foo {
          neato: string;
        }
        +
        +export type { Foo };
        ```

    -   a value-only export, since the exported type symbol has been removed:

        ```diff
        -export class Foo {
        +class _Foo {
          neato: string;
        }
        +
        +export let Foo: typeof _Foo;
        ```

-   changing the kind (*value* vs. *type*) of an exported symbol in any way, since users' imports and own definitions may both be broken, since imports resolve all symbols imported together if they share a name:

    -   Given a *value*-only exported symbol, including `namespace` declarations, adding a *type* export with the same name as the *value* may break users' code: they may have imported the value and safely created a type of the same name. Their existing import will now cause a re-declaration conflict. Note that this is distinct from adding an entirely new type export where there was no type or value export previously, since the user could never accidentally introduce the conflict, and could work around the conflict using the `as` import specifier when introducing the import.

    -   Given a *type*-only exported symbol, including `type`, `interface`, or `export type` for a type or value, adding a *value* export with the same name may break users' code: they may have imported the type and safely created a value of the same name. Their existing import will now cause a re-declaration conflict. Note that this is distinct from adding an entirely new value export where there was no type or value export previously, since the user could never accidentally introduce the conflict, and could work around the conflict using the `as` import specifier when introducing the import. (Type-only imports via `import type` do not change this because they still import the symbol into value space to use with `typeof`, e.g. to get a class' constructor.)

    -   Given a `namespace` export, changing it to a value-only export (that is, to an exported object) will break all nested type access, since types cannot be exported as nested members of non-`namespace` values. (`namespace` exports cannot be directly converted to type-only exports.)

-   changing an `interface` to a `type` alias will break any user code which used interface merging

-   changing a `namespace` export to any other type will break any code which used namespace merging

-   changing a `class` export to a type-only export will break any code which extended the class or constructed an instance of the class ([playground][class-to-type-only]), and changing a `class` export to a value-only export will break any code which referred to the class as a type ([playground][class-to-value-only])

[class-to-type-only]: https://www.typescriptlang.org/play?#code/PTAEEEDtQIgewE4EsDmTIEMA2NQBMBTAYywwQwBck5IAaUAdwAsCEDQKXGm4t2SMAZ0GMhoAgA8ADogoE8AOgBQhAW1ADhoAOpCAotNnzQAbwC+SpSFAAVJkhEOOXAgEcArkgBu2ApAqgcABmoBgcAJ5SBAC0NFjh4oYIAcGhGqTC9MxIREyMcO5YeKCQiAC22PFWYABG7AzIFHLQWEgA1uycDgBc1aB9AAZDfZoiuoIGMsnG5n2SUwEUkewmOvpJcsUW1kMDSqOgAPoAcnAUk0bFs0tRoKfnG8YAvEf3F9N4ANyWBwDK7jVRgAxRDvTaJZp4MbrBYzCx-AHAxBvR7FSSQkQo2FXCwqYikdRBdyQIhUGgcDAdQTjMHyAAUDBhl26awmqIAlCyvHAkF88Wp2ESSWToBRKQRBFjLgymR8WVKPpzQNzed99jRBAFGWzsaAXpACAxWbS8HT2d8iBqAqUHrr9Ya7mcTWbPkA

[class-to-value-only]: https://www.typescriptlang.org/play?#code/PTAEEEDtQIgewE4EsDmTIEMA2NQBMBTAYywwQwBck5IAaUAdwAsCEDQKXGm4t2SMAZ0GMhoAgA8ADogoE8AOgBQhAW1ADhoAOpCAotNnzQAbwC+SpSFAAVJkhEOOXAgEcArkgBu2ApAqgcABmoBigPljuBAC0NFgAnuKGCAHBoRqkwgqgAHKIALbYCaDxcO6MZVh4VmAMyHLOTgxInKAABpIyKaB8FG2g5JyszhjQbaqk6r1typoiAPp5FAZdcnimFhNk7L25cMvJawBcHPFSBGmL+ytGeADclnOgAMruAEZzAGKINynGknJIHgRLpBL81hslE9Xh9MoJvggluD-hJAcC9gdVsZzJYtuogu5IEQqDQOBgANYEQSg5F4AAUDH0h3kJxpzLwAEoTl44Eh7ipiJN2ASiSToBQKVSkeyGUysXgTtL5Vzwrz+VCaIIAoywezQABeUCQAgMHRy250jkPIiagKQa56w3G01Ki1WoA


##### Interfaces, Type Aliases, and Classes

Object types may be defined with interfaces, type aliases, or classes. Interfaces and type aliases define type symbols only. Classes define both type symbols and value symbols. The `namespace` construct defines a value symbol (as well as introducing a context in which you can name other nested type or value symbols). The additional constraints for the value symbols introduced by classes are covered above under [Breaking Changes: Symbols](#symbols).

A change to any object type (user constructible or not) is breaking when:

-   a non-`readonly` object property's type changes in any way:

    -   if it was previously `string` but now is `string | number`, some of the user's existing *reads* of the property will now be wrong ([playground][reads-of-property]). Note that this includes making a property optional.

    -   if it was previously `string | number` but now is `string`, some of the user's existing *writes* to the property will now be wrong ([playground][writes-to-property]). Note that this includes making a previously-optional property required.

        Note that at present, TypeScript cannot actually catch all variants of this error. [This playground][writes-to-property] demonstrates that there is a runtime error but no *type* error in one scenario. TypeScript's type system understands these types in terms of *assignability*, rather than local *mutability*. However, package authors should test for the catchable variant of this condition.

-   a property is removed from the type entirely, since some of the user's existing uses of the type will break, even if the property was optional ([optional][optional-removed], [required][required-removed])

A change to a user-constructible type is breaking when:

-   a required property is added to the type, since all of the user's existing constructions of the type will be incorrect ([new-required-property][required-added])

A change to a non-user-constructible object type is breaking when:

-   a `readonly` object property type becomes a *less specific ("wider") type*, for example if it was previously `string` but now is `string | string[]`—since the user's existing handling of the property will be wrong in some cases ([playground][wider-property]—the playground uses a class but an interface or type alias would have the same behavior).

    Note that this includes making a property optional, since these are equivalent for the purposes of type-checking:

    ```diff
    interface A {
    - a: string;
    + a?: string;
    }
    ```

    ```diff
    interface A {
    - a: string;
    + a: string | undefined;
    }
    ```

[reads-of-property]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOrADYfQEwiZAbwFgAoZC5OALmQGcwpQBzAbjIF8yzRJZEUAEWA5c+ImUpVaDJiGbIAPshABXALYAjaO1JdSZGKpAIwwAPYEAFnBA4MEOuixiQACgBucDKoi1n2CL4AJS0alrQEuSUUBBgqlAEXj4QAHRwqQ7yYFa6+mR4CBhwscgOYMgA7piBeCD+Na66NnYOTo1B7tUuncG6BRBFJSjlyDgirrTCop3NtvaOAa5u4zN1fWRAA

[writes-to-property]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOrADYYHJylAewHdkBvAWAChkbk4AuZAZzClAHNkAfZEAVwC2AI2gBuKgF8qVUJFiIUAEWAATXPmJkqtOo37Cxk6ZRh8QCMMAIhkRNpCYAVAuizrCRABQA3OBj4QjK44eB4AlFrUtL7+EAB0cMgAvMgA5AAWEFgEqeKUUpRUKhAIGHgoGBBgtpghGkRBte7EeXbADs7BzV5ETaHEYXlFJWVQFVXIKqrdjMpq-UR5U-P1CcnIAEQADgRgcGAEG6LIAPQnyPCYTFRtHS599Z7L3YOn50x8CEgQKkzI0IQQBACHwmBgAJ5UIA

[optional-removed]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIHU4GcDyAHMYAexDgBtkBvAWAChkHk4AuZAIyKLIjhAG46jdgH5WHLj350AvnTqhIsRClQAlCAFsiANwgATKoMYt2nbrwG1ZtOtzDISZAJ4BBVBBhEoEVhmz5CEnJkAF4qJlYwKABXFGlLO2RQBDJovX1Ud09vX0xcAmJSCjDKCOQo2IAadlZ4Miw4y1sIe0dXFxhFX3UtXQMSsorG5vtk1PS9VA6utB6dfVDwkyHqtlryBuR4oA

[required-removed]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIHU4GcBKECOArsFBACbIDeAsAFDIPJwBcyARgPYcA2EcIAbjqN2rTjz6C6AXzp1QkWIhSo8AWw4A3clWGMW7Lr35Das2nV5hkoBN0JlyqVBBgdSrDNjxESOgLxUTKxgUIQQADSiyPDcWCjSppYQ1rb2jmSoAIIwip7qWgFBBqHhUWyssfHIiUA

[required-added]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIRgeyig3gWAChkTk4AuZAI00wBsI4QBuIgXyKNElkRQEEYPZAWKkK1WgyasxJKpRABXALZVosjoSIg4KiAGcADnzQZsEAKpGAJnEgiipZAzDIEmEAbBQlCMMCelOhYOMgAvCJklD5KKGyanIS6+samgjzWdg6izq7unt6+-oEglBnQEVESsfGJhEA

[wider-property]: https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwPIwJYHMsDsoJ4BvAKHnjimAHt8IBPeABxlpZBgBdGAueMm7Z8OANxkAvmTKgkcRNFTwA6llD4QwUhSoga9Jq3ace-QcII54AHwsicAbQC6UmQDMArvjDcs9eAALKHxgCBBkTFwCIgA5WHYAdwAKADciTxABKLxCCABKAXxPAFsAIy4dSjhuTxh8eHSITIA6Ng4uXhbw0W5AiWlZcGgFcO54KGzsXKIJORGEMfgygTUNLQlg0PDI6ZiIeJgk5Kh8zZCwiJz9w+Oys7IgA


##### Functions

For functions which return or accept user-constructible types, the rules specified for [Breaking Changes: Interfaces, Type Aliases, and Classes](#interfaces-type-aliases-and-classes) hold. Otherwise, a change to the type of a function is breaking when:

-   an argument or return type changes entirely, for example if a function previously accepted `number` and now accepts `{ count: number }`, or previously returned `string` and now returns `boolean`—since the user will have to change all call sites for the function ([playground][changed-type])

-   a function (including a class constructor or methods) argument *requires a more specific ("narrower") type*, for example if it previously accepted `string | number` but now requires `string`—since the user will have to change some calls to the function ([playground][narrower-argument])

-   a function (including a class constructor or method) *returns a less specific ("wider") type*, for example if it previously returned `string` but now returns `string |`—since the user's existing handling of the return value will be wrong in some cases ([playground][wider-return]).

    This includes widening from a *type guard* to a more general check. For example:

    ```diff
    -function isString(x: string | number): x is string {
    +function isString(x: string): boolean {
      return typeof x === 'string';
    }
    ```

    This change would cause user-land code that expects narrowing to break:

    ```ts
    if (isString(value)) {
      return value.length;
    } else {
      return value;
    }
    ```

-   a function (including a class constructor or method) adds any new *required* arguments—since all user invocations of the function will now be broken ([playground][new-required-argument])

-   a function (including a class constructor or method) removes an existing argument entirely—since user invocations of the function may now fail to type-check

    -   if the argument was required, *all* invocations will fail to type-check ([playground][remove-required-argument])

    -   if the argument was optional, any invocations which used it will fail to type-check ([playground][remove-optional-argument])

-   changing a function from a `function` declaration to an arrow function declaration, since it changes the type of `this`, the effect of calling `bind` or `call` on the function, and requires parameters to be contravariant instead of allowing bivariance

[changed-type]: https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0NigkBqBbJyoAPKY8AjknGZyoMUubIj0OPChLPSMNNK2nPYAFIEE0HqIbJAARlgAlHoAbhrwgeFyDtGx8Ymo5JS0DKgAwviIloGFJaXlldUMdQ12yK3teub0GmW6oF29WKAOg6AjYxNTctm5SFwAdIdkPUqI0WgBGABMAGZ+hM1tANshAgDakDjk1TpCYeEgA

[narrower-argument]: https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEs9Iw00rac9gAUgQTQesLZiLCgAD7JbJAARlgAlHoAbhrwgeFyDtGx8YmoKdR0jKAA6jOSyIEFxSVlFVUMtfV2yC1tHThdsOOgUzNzCwpgQlig9BqxclkckguAA6c7IOpUBrNACMACYAMyjOaA3Kg8GQ6HXTwYbgaTzIuQ7WIoQJgmoQy6Na7wpFzYl7MkYqnNHHIPEE8JAA

[wider-return]: https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEWVrac9gAUAJR6wtmIsOFyDtGx8YmoKdR0jKAA6vCxKIEFxSVlFVWWNnbITS04bbCgAD7JbNyd3QpgQlig9Bqxcs6l5ZWI6NCIgZzIAErU+zj1AG4r65tGjNith2JgHn86sgAHSvdp4Q7RfDPV4fKhfepZHJILjQpa1BqNRqdZEvd6fTjfcaTZCBPE1FZNYlyIA

[new-required-argument]: https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwEo7ictgBuAKFCRYCFOmx54yAsCgYQwanQZNWAGngAjOqmQBbTSBgd4XHgP4QQGeFHgBeQiTJUA5ARwY5OV2wFWbTQcpGTkFSndPb19eIA

[remove-required-argument]: https://www.typescriptlang.org/play/?ssl=2&ssc=35&pln=2&pc=47#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjO1ZAW04gYASjrEcWYAG4AUKEiwEKdNjzxkBYFAwhg1OgyatR8cZNkyIIDPCjwAvIRJkqAcgI4M2nK44BGACZhWSsbTgd1TW1dSndPb194QOCgA

[remove-optional-argument]: https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjAfjtWQC2nEDACUdYjizAA3AChQkWAhTpseeMgLAoGEMGp0GTVuPiTp8uRBAZ4UeAF5CJMlQDkBHBl053HAEYAJlF5GztOJ01tXX1KT29ff3hg0OtbeDAoohBSHAp4rx8MPzTw+GAorR09AwTi0vkgA


#### Non-breaking changes

In each of these cases, some user code becomes *superfluous*, but it neither fails to type-check nor causes any runtime errors.


##### Symbols

A change to an exported symbol is *not* breaking when:

-   a symbol is exported which was not previously exported and which does not share a name with another symbol which was previously exported


##### Interfaces, Type Aliases, and Classes

Any change to a non-user-constructible type is *not* breaking when:

-   a new optional property is added to the type, since all existing code will continue working ([playground][new-optional-prop])

-   a `readonly` object property on the type becomes a *more specific ("narrower") type*, for example if it was previously `string | string[]` and now is always `string[]`—since all user code will continue working and type-checking ([playground][narrower-property]). Note that this includes a previously-optional property becoming required.[^nit-on-comparability]

-   a new required property is added to the object—since its presence does not require the consuming code to use the property at a type level ([playground][new-required-prop])[^variance-in-discriminating]

[new-optional-prop]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPJWAc1HANsgbwFgAoZc5OALmQGcwMRMBuUgX1NNElkRQFUADgBM4kYYVIVKNeoxZSKAIwD8NEAFcAtkuisSHEqWEQEuOFBQwNIBGGAB7EMktgNUELXRYcuABQAlDTe2CB4+iZmFlY2do7Oru6eQqLigTQpYhDC+sam5pbI1rb2TshgcADWEF4YoXh+AB7Bdb5ByABuDsA5eVGFxXFlFdW0mWnNyOPZ7V09uSRhWjWCfMgAQhAwDpbTkmQUAPSHyAhOchpDIIrkuBBgMmitYfgAvISPAEQAFhC4uA5Psg2AtpMcXPcktlkEoAJ7IXDAJRQCywm4I+4wlo+F7Id6JDy1HENAKgo4nBB4cxKYCIsBog7kEY1EK+PxwUno5lE+r+AhfX7-QHAgLsTiLODLWirJDIACCMB4e2IjOQ4LOngYl1K11Vdwe1CmIiyEne-MNPz+AKBIPFYJOBJA0LhCKRKKgDOk+qxT2JbwhbkJ02EgTJ5HVVLgNLpnoo3NZL3ZnNV3ODSf00njzwaSmTmaqNTTuYzcYLY2NaXNNEtQptooMpCAA

[narrower-property]: https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEkoGdnwPIwJYHMsDsoJ4BvAKHngAcYB7KkGAFwE8AueZJ7fHeAH07cCOANoBdANxkAvmTKgkcRNFTwAcrDoB3EMFIVqdBs3ZCeOWfIBmAV3xgmWWvngALKPmAQQyTLgIiTRgdAAoANyJbEA5-PEIIAEoOfFsAWwAjRgNKOCZbGFdIiGiAOhp6RlZSn14mN2k5BXBoZR8meChY7HiiaUVWhHb4DI5gnT1pDy8fPx7AiHHabVCoRKnPb184haWVjPWyIA

[new-required-prop]: https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPJWAc1HANsgbwFgAoZc5OALmQGcwMRMBuUgX1NNElkRQFUADgBM4kYYVIVKNeoxZSKAIxogArgFsl0ViQ4lSwiAlxwoKGGpAIwwAPYhk5sGqgha6LDlwAKAJQ0ntggeLpGJmYWVjb2js6u7kKi4v40SWIQwrqGxqbmyJbWtg7IYHAA1hAeGMF4PgAegTXeAcgAbnbAWTkR+YUxJWWVtOkpjcijma0dXdkkIRpVgnzIAEIQMHbmk5JkFAD0+04QLm6ZyEoAnsi4wEpQZpeK5LgnMmjNIfgAvMen7kFvP5dNJXmBkKAYNBzBJfvE3NUvF9gZw9uRDsgEHhTEpgLcwNcAO7AMAACz+CUyz1KFSqgORcD8IIoQzpnzqkOhU10+lICyWKwAgjAeDtiGjkBj4SBzlcbncHlAnhKMQBhUlwJigTClUkoYAaQRbcHAWiYrbmGwXYxwNS0fWOMkocx4drQWixZB2GC600AGmpGMudjUyEJIdwEm0yGEnSYyAABgajVBwQRkABlOyLACS4Gg8CQyDYBSg2eQAHJaNmIABaW73R4V5gJgMqo6aiRO5BqEQZCTcAsrcNqSPIDVtFDd2hwRbIfl+uh2XUoCD1QS3BAkwMd2gezAgRbgMMRiT0PH4ZZ75A+OBmteCYziPzIABUndfNwyUB79ohIB3c183qMAzUJUlgAQclzAARzUYB8m7QQy0fVMiVPShcGra1fzgJRXjDElSRDMBAI0OxhGAGBILEWJqTBd5JlhCkESY4FJSOc9cHwO99xCfCIHot5OSgGFkDhE4EhGPsUiZVFpAxLFuLwvESSJIiWJlYRqVZRFal8RlmXIXT6Q5EAoVE7kdNpaTkkyW85IlXS2JEmFHP0IA


[^nit-on-comparability]: Strictly speaking, one value may stop being comparable to another value in this scenario. However, this is both a rare edge case and fits under the standard rule where changes which simply let users delete now-defunct code are allowed.

[comparable-narrowing]: https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEYD2A7AzgF3kmBLA5rilBAFzyZ4r7wA+FGV+A2gLoCwAUKJLAsuizIAtgAdYUAEYQQ5SkRr0UAV2GSQMLj2hxEqTPGWjgUDCGBzGCtly64AZvAAUOAkRLwAvN71iJ0kABKeABvAF87RycjEzNgLx8RcRgpGWDwriA

[^variance-in-discriminating]: Mostly, anyway—see [Appendix C: On Variance in TypeScript – Higher-order type operations](#higher-order-type-operations) below for a discussion of how the `in` operator (or similar operations discriminating between unions) makes this cause breakage in some cases. These are rare enough, and easily-enough solved, that the rule remains workable.


##### Functions

For functions which return or accept user-constructible types, the rules specified for [Non-breaking Changes: Interfaces, Type Aliases, and Classes](#interfaces-type-aliases-and-classes-1) hold. Otherwise, a change to a function declaration is *not* breaking when:

-   a function (including a class method or constructor) *accepts a less specific ("wider") type*, for example if it previously accepted only a `boolean` but now accepts `boolean | undefined`—since all existing user code will continue working and type-checking ([playground][wider-argument])

-   a function (including a class method) which *returns a more specific ("narrower") type*, for example if it previously returned `number | undefined` and now always returns `number`—since all user code will continue working and type-checking ([playground][narrower-return])

-   a function (including a class constructor or method) makes a previously-required argument optional—since all existing user code will continue to work with it ([playground][optional-argument])

-   changing a function from an arrow function declaration to `function` declaration, since it allows the caller to use `bind` or `call` meaningfully where they could not before. (Note that at the time of authoring, current TypeScript version 4.3, such a change introduces parameter bivariance. This is not breaking, but may be undesirable.)

[wider-argument]: https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEs9Iw00rac9gAUgQTQegBGGhqcyNCIAJR6AG4a8IHhcg7RsfGJqCnUdIygAOrjksiBBcUlZRVVDLX1dsgtbZ3dvf2gAD6gpbHOSFtDoKPjk9MKYEJYoPQNLE5FkckguAA6I7IOpUBrNHCYewDSag3KQ6Gw+FnZxcCQouTrWIoQJQmowk6NM6I5GTImbUmYynNXGcfHhIA

[narrower-return]: https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEWVrac9gAUAJR6wtmIsKAAPsls3OFyDtGx8YmoKdR0jKAAcoluAO7IgQXFJWUVVZY2dshNLThtsP2DCmBCWKD0GrFyzqXllYjo0IiBnMgAStS9OPUAbjt9ocuj1uM0epAAEYXUyFYrYdiYJ4AurIAD8ADp3u08KA0WjQAAGY7RfCvd5fKg-epZHJILgYra1BqNRr9MlvT7fTi-WaYBZLRk1HZNNlyIA

[optional-argument]: https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjO1ZAW04gYASjrEcWYAG4AUKEiwEKdNjzxkBYFAwhg1OgyasOnAPw9+gkWInSZMiCAzwo8ALyESZKgHICODG0cHw4ARgAmYVlHZ053dU1tXUo-AKCQ+AiooA


#### Bug fixes

As with runtime code, types may have bugs. We define a ‘bug' here as a mismatch between types and runtime code. That is: if the types allow code which will cause a runtime type error, or if they forbid code which is allowed at runtime, the types are buggy. Types may be buggy by being inappropriately *wider* or *narrower* than runtime.

For example (noting that this list is illustrative, not exhaustive):

-   If a function is typed as accepting `any` but actually requires a `string`, this will cause an error at runtime, and is a bug.

-   If a function is typed as returning `string | number` but is intended to return only `string`, this is a bug. Note that this is distinct from the runtime behavior: a package author may intentionally specify the type as wider than the current implementation with the expectation of future changes. This will not cause an error at runtime, since consumers must "narrow" the type to use it, and narrowing the type would not even be a breaking change.

-   If an interface is defined as having a property which is *not* part of the public API of the runtime object, or if an interface is defined as *missing* a property which the public API of the runtime object does have, this is a bug.

As with runtime bugs, authors are free to fix type bugs in a patch release. As with runtime code, this may break consumers who were relying on the buggy behavior. However, as with runtime bugs, this is well-understood to be part of the sociotechnical contract of semantic versioning.

In practice, this suggests two key considerations around type bugs:

1.  It is essential that types be well-tested! See discussion below under [**Tooling**](#tooling).

2.  If a given type bug has existed for long enough, an author may choose to treat it as ["intimate API"][intimate] and change the *runtime* behavior to match the types rather than vice versa.

[intimate]: https://twitter.com/wycats/status/918644693759488005

### Compiler considerations

To reiterate, Semantic Versioning is a matter of adherence to a specified contract. This is particularly important when dealing with transitive or peer dependencies, especially at the level of ecosystem dependencies—including Node versions, browsers, compilers, and frameworks (such as Ember, React, Vue, Svelte, etc.). Accordingly, the specification of breaking changes as described below is further defined in terms of the TypeScript compiler support version adopted by any given package as well as specific settings.


##### Supported compiler versions

Conforming packages must adopt and clearly specify one of two support policies: *simple majors* or *rolling support windows*.


###### Simple majors

In “simple majors” pattern, dropping a previously-supported TypeScript version constitutes a breaking change, because it has the same kind of impact on users of the package as dropping support for a previously-supported version of Node: they must upgrade a *different* dependency to guarantee their code continues to work. Thus, whenever dropping a previously-supported TypeScript release, packages using “simple majors” should publish a new major version.

However, bug fix/patch releases to TypeScript (as described above under [Bug fixes](#bug-fixes)) qualify for bug fix releases for packages using the “simple majors” policy. For example, if a package initially publishes support for TypeScript 4.5.0, but a critical bug is discovered and fixed in 4.5.1, the package may drop support for 4.5.0 without a major release. Dropping support for a bad version does not require publishing a new release, only documenting the change.

In this case, packages should generally couple dropping support for previously-supported TypeScript versions with dropping support for other ecosystem-level dependencies, such as previously-supported Node.js LTS versions, Ember LTS releases, React major versions, etc. (This is not a requirement for conformance, but makes for a generally healthier ecosystem.)

This pattern is recommended for “normal” packages, where major versions do not themselves have ecosystem-wide implications. For example, a package like [True Myth][true-myth] (maintained by the primary author of this RFC) is small and not presently foundational to any broader ecosystem. It is safely using the “simple majors” approach today for both Node and TypeScript versions.

[true-myth]: https://true-myth.js.org


###### Rolling support windows

The “rolling support windows” policy decouples compiler version support from major breaking changes, by specifying a rolling window of supported versions. For example, Ember and Ember CLI [specify][ember-cli-node] that any change landing on `master` must work on the [Current, Active LTS, and Maintenance LTS Node versions][node-versions] at the time the change lands, and that when the Node Working Group drops support for an LTS, Ember and Ember CLI do so as well *without a breaking change*. This allows the CLI to use new Node features as part of its public API over time, rather than being fixed at the set of features available at the time of the latest release of the CLI (e.g. Node 8 for the Ember CLI 3.x series).

[ember-cli-node]: https://github.com/ember-cli/ember-cli/blob/master/docs/node-support.md
[node-versions]: https://nodejs.org/en/about/releases/

Following this pattern, core ecosystem components (hypothetically including examples such `ember-source`, `react`, `@vue/cli`, etc.) could adopt a similar policy for supported TypeScript compiler versions, allowing the component to adopt new TypeScript features which impact the published types (e.g. in type emit, type system features such as conditional types, etc.) rather than being coupled to the features available at the time of release. Conforming projects which adopt this may choose any rolling support window they choose, except that if they have an LTS release schedule, upgrading to a new LTS shall not require upgrading to a new version of TypeScript.

Bug fix/patch releases to TypeScript (as described above under [Bug fixes](#bug-fixes)) qualify for bug fix releases for packages using the “rolling support windows” policy. For example, if a package initially publishes support for TypeScript 4.5.0, but a critical bug is discovered and fixed in 4.5.1, the package may drop support for 4.5.0 without a major release. Dropping support for a bad version does not require publishing a new release, only documenting the change.


##### Strictness

Type-checking in TypeScript behaves differently under different “strictness” settings, and the compiler adds more strictness settings over time. Changes to types which are not breaking under looser compiler settings may be breaking under stricter compiler settings.

For example: a package with `strictNullChecks: false` could make a function return typeable without the compiler reporting it within the package or the package’s type tests. However, as described above, this is a breaking change for consumers which have `strictNullChecks: true`. (By contrast, a *consumer* may disable strictness settings safely: code which type-checks under a stricter setting also type-checks under a less strict setting.) Likewise, with `noUncheckedIndexedAccess: false`, an author could change a type `SomeObj` from `{ a: string }` to `{ [key: string]: string }` and accessing `someObj.a.length` would now error.

Accordingly, conforming packages must use `strict: true` in their compiler settings. Additionally, communities may define further strictness settings to which they commit to conform which include “pedantic” strictness settings like `noUncheckedIndexedAccess`. For example, the Ember community might commit to a set of *additional* strictness flags it supports for its own types for any LTS release, published in Ember’s own TypeScript documentation.

**Note:** While the TypeScript compiler may include new strictness flags under `strict: true` in any release, this is simply a special case of TypeScript’s policy on breaking changes.


##### Module interop

The two flags `esModuleInterop` and `allowSyntheticDefaultImports` smooth the interoperation between ES Modules and CommonJS, AMD, and UMD modules for *emit* from TypeScript and *type resolution* by TypeScript respectively. The options are viral: enabling them in a package requires all downstream consumers to enable them as well (even if this is not desirable for whatever reasons). The reasons for this are details of how CommonJS and ES Modules interoperate for bundlers (Webpack, Parcel, etc.), and are beyond the scope of this document.

Here, it is enough to note that changing from `esModuleInterop: true` to `esModuleInterop: false` on a package which emits *is a breaking change*:

-   with `esModuleInterop: true`: [playground][emi-true]
-   with `esModuleInterop: false`: [playground][emi-false]

[emi-true]: https://www.typescriptlang.org/play?target=7#code/CYUwxgNghgTiAEBbA9sArhBByAzsxIAtGgA44AucUihEAlgEYywCeW8A3gLABQ8-8MMgB2FeADNkyAFzwAFAEp4AXgB88CjDrCA5gG5eA+CAAeJZDHIqJUgzwC+vXqEiwEKdJnhZELWo2YYNk5DATpEc0sbZAkYfG88AmIyShBqfyZWLDtQ-lNIqyFRK18AFQALbR1Zbj4jAUkZeHIWEhBkcWi7eoEGWFlFFXVhNEQGEBhugUcHIA
[emi-false]: https://www.typescriptlang.org/play?esModuleInterop=false&target=7#code/CYUwxgNghgTiAEBbA9sArhBByAzsxIAtGgA44AucUihEAlgEYywCeW8A3gLABQ8-8MMgB2FeADNkyAFzwAFAEp4AXgB88CjDrCA5gG5eA+CAAeJZDHIqJUgzwC+vXqEiwEKdJnhZELWo2YYNk5DATpEc0sbZAkYfG88AmIyShBqfyZWLDtQ-lNIqyFRK18AFQALbR1Zbj4jAUkZeHIWEhBkcWi7eoEGWFlFFXVhNEQGEBhugUcHIA

Accordingly, library authors should set both `allowSyntheticDefaultImports` and `esModuleInterop` to `false`. This allows consumers to opt into these semantics, but does not *require* them to do so. Consumers can always safely use alternative import syntaxes (including falling back to `require()` and `import()`), or can enable these flags and opt into this behavior themselves.

(If the Node ecosystem migrates fully to ES modules over the next few years, this problem will be substantially mitigated.)


### Conformance

To conform to this standard, a package must:

- link to the final published version of this specification
- specify the compiler support policy
- specify the currently-supported versions of TypeScript
- specify the definition of “public API” used by the library (e.g. “only documented types” vs. “all published types” etc.)
- author and publish its types with `strict: true` and `noUncheckedIndexedAccess: true` in its compiler configuration


## How we teach this

If these recommendations are adopted, the [**Detailed Design**](#detailed-design) section shall be published to a dedicated, standalone repository to ease linking to it (including by TypeScript packages beyond the Ember ecosystem, if they find it useful, as we hope they will!).

When any Ember package begins publishing types, it shall follow the rules specified in [**Conformance**](#conformance). In the case of Ember, Ember CLI, and Ember Data, the link to the published spec shall be added alongside the existing links to the Node SemVer support policies. Additionally, Ember should publish a table showing supported versions in the same format as the Node version support table.

Other official Ember packages which publish types must publish their supported TypeScript versions and compiler version policy, but may do so in whatever form is appropriate for the package, for example badges in the README linking to the published specification text and to CI.


## Drawbacks

- The definition of breaking changes above, while precise, may prove difficult to maintain without investment in specific supporting tooling to identify and mitigate breakage (which this RFC does not require, though see [**Appendix B: Tooling**](#appendix-b-tooling) for some recommendations).

- Providing the “rolling support window” option means that consumers still have to deal with some potentially-breaking changes to supported TypeScript versions during a single major version of a package. While this allows more flexibility for authors of packages which publish types, it does decrease the strength of the stability guarantees for those types.

- Adopting *any* policy constricts the options available to packages which publish types.


## Alternatives

### No policy

Currently, no frameworks and few packages in the broader TypeScript ecosystem have any specific TypeScript support policy. Instead, they just roughly track the latest TypeScript version and expect downstream consumers of the types to absorb the changes. This strategy *could* work if libraries were honest about the SemVer implications of this and cut major releases any time a new TypeScript version resulted in breaking changes. Notably, the Ember TypeScript ecosystem has largely operated in this mode to date, and it has worked all right so far—though not without some challenges.

However, there are three major problems with this approach.

-   First, it does not scale well. While many packages are using TypeScript today, as the community of TypeScript users grows and especially as it increasingly includes packages used extensively throughout the community (e.g. frameworks or core libraries), the cost of breaking changes grows in an unbounded fashion, with all of that cost being borne by the consumers of those changes, and worst of all *there is no signal about these breaking changes*.

-   Second, and closely related, the more central a package is to the ecosystem, the worse the impact is—especially when combined with any attempts to enforce “Highlander” rules for web bundling (e.g. Ember CLI will only resolve a single major version of an Ember package). Without a strategy for specifying breaking changes and therefore opportunities to mitigate them, core packages could easily end up fragmenting the ecosystem.

-   Third, in the absence of a specific policy, each package ends up developing its own _ad hoc_ support policy. Many parts of the TypeScript ecosystem would benefit from adopting a shared solution and improving stability—preferring to avoid churn and risk through policies and definitions such as those outlined in this RFC. Accordingly, a policy which aligns TypeScript support with existing community norms around supported versions would make TypeScript adoption more palatable both at the community level in general and specifically to large/enterprise engineering organizations with a lower appetite for risk.

[ember-modifier]: https://github.com/ember-modifier/ember-modifier


### Decouple TypeScript support from LTS cycles

The “rolling support window” policy could be decoupled from LTS requirements. Similarly, the “simple majors” policy could drop the recommendation to combine dropping Node versions, TypeScript versions, and other LTS packages. This would simplify the rule for adopting packages. However, it comes with the previously mentioned challenges when multiple major versions of a package exist in a given ecosystem. While a strategy for resolving those challenges at the ecosystem level would be nice, it is far beyond the scope of *this* RFC and indeed is a general challenge for package-rich ecosystems like Node’s.


## Unresolved questions

-   What policy should this RFC adopt for compiler settings which behave in both lint-like and strictness-checking-like ways, but which cannot cause type breakage for consumers, such as `noUncheckedIndexAccess`?

    The semantics of this check is that it effectively exposes `| undefined` in more places, but authors of types cannot construct a type which *avoids* emitting `T | undefined` if the consumer enables `noUncheckedIndexAccess` and `strictNullChecks`. That is: if an author publishes `function foo(): Array<string>` *or* `function foo(): Array<string | undefined>`, then *whether or not* the author has `noUncheckedIndexedAccess` enabled, the semantics are the same for downstream consumers, and is dependent on *their* setting. The only safety improvement would be to publish types as `SafeArray<string>` where:

    ```ts
    type SafeArray<T> = Array<T | undefined>;
    ```

-   Are there any type system edge cases not covered by this policy?

-   Are there any compiler version change scenarios not covered by this policy?

-   Is the recommended compiler version support policy appropriate? There are other options available, like Typed Ember's current commitment to support the latest two (<i>N−1</i>) versions in the types. (In practice, the Typed Ember team did not bump most of the Ember types' minimum version from TypeScript 2.8 until the release of TypeScript 3.9, at which time they bumped minimum supported TypeScript version to 3.7.)

-   How should transitive dependencies be expected to be handled? Should package authors be expected to absorb any upstream differences in SemVer handling?


## Appendices

These sections are non-normative.


### Appendix A: Existing Implementations

The recommendations in this RFC have been fully implemented in [`ember-modifier`][ember-modifier], [True Myth][true-myth], and [ember-async-data][ember-async-data]; and partly implemented in [`ember-concurrency`][ember-concurrency]. `ember-modifier`, `ember-async-data`, and `true-myth` all publish types generated from implementation code. `ember-concurrency` supplies a standalone, hand-written type definition file. Since adopting this policy in these implementations (beginning in early summer 2020), no known issues have emerged, and the experience of implementing earlier versions of the recommendations from this RFC were incorporated into the final form of this RFC.

There are, to the best of our knowledge, no other major adopters of these recommendations, and no similar such recommendations in the TypeScript ecosystem at large.

[ember-modifier]: https://github.com/ember-modifier/ember-modifier
[ember-async-data]: https://github.com/chriskrycho/ember-async-data
[ember-concurrency]: https://github.com/machty/ember-concurrency


### Appendix B: Tooling

To successfully adopt this RFC’s recommendations, package authors need to be able to *detect* breaking changes (whether from their own changes or from TypeScript itself) and to *mitigate* them. Package *consumers* need to know the support policy for the library.


#### Documenting supported versions and policy

In line with ecosystem norms, badges linking to CI status

- An example supported versions badge (which could link to CI config):

    ![supported TypeScript versions: 4.1, 4.2 and next](https://img.shields.io/badge/TS%20Versions-4.1%20%7C%204.2%20%7C%20next-blue)

- Example support policy badges (which could link to the published recommendation from this RFC):

    ![TypeScript support policy](https://img.shields.io/badge/TS%20Support-Rolling%20Window-purple) ![TypeScript support policy](https://img.shields.io/badge/TS%20Support-Simple%20Majors-purple)


#### Detect breaking changes in types

As with runtime code, it is essential to prevent unintentional changes to the API of types supplied by a package. We can accomplish this using *type tests*: tests which assert that the types exposed by the public API of the package are stable.

Package authors publishing types can use whatever tools they find easiest to use and integrate, within the constraint that the tools must be capable of catching all the kinds of breaking changes outlined above. Additionally, they must be able to run against multiple supported versions of TypeScript, so that users can detect and account for breaking changes in TypeScript.

The current options include:

-   [`dtslint`][dtslint]—used to support the DefinitelyTyped ecosystem, so it is well-tested and fairly robust. It uses the TypeScript compiler API directly, and is maintained by the TypeScript team directly. Accordingly, it is very unlikely to stop working against the versions of TypeScript it supports. However, there are several significant downsides as well:

    -   The tool checks against string representations of types, which makes it relatively fragile: it can be disturbed by changes to the representation of a type, even when those changes would not impact type-checking.

    -   As its name suggests, it is currently powered by [tslint][tslint], which is deprecated in favor of [eslint][eslint]. While there is [initial interest][eslint-migration] in migrating to eslint, there is no active effort to accomplish this task.

    -   The developer experience of authoring assertions with dtslint is poor, with no editor-powered feedback or indication of whether you've actually written the test correctly at all. For example, if a user types `ExpectType` instead of `$ExpectType`, the assertion will simply be silently ignored.

- [`tsd`][tsd]—a full solution for testing types by writing `.test-d.ts` files with a small family of assertions and using the `tsd` command to validate all `.test-d.ts` files. Authoring has robust editor integration, since the type assertions are normal TS imports, and the type assertions are specific enough to catch all the kinds of breakage identified above. It is implemented using the TS compiler version directly, which makes its assertions fairly robust. Risks and downsides:

    -   The tool uses a patched version of the TypeScript compiler, which increases the risk of errors and the risk that at some points it will simply be unable to support a new version of TypeScript.

    -   Because the assertions are implemented as type definitions, the library is subject to the same risk of compiler breakage as the types it is testing.

    -   **BLOCKER:**  currently only supports a single version of TypeScript at a time. While the author is [interested][tsd-versions] in supporting multiple versions, it is not currently possible.

- [`expect-type`][expect-type]—a library with a variety of type assertions, inspired by Jest's matchers but tailored to types and with no runtime implementation. Like `tsd`, it is implemented as a series of function types which can be imported, and accordingly it has excellent editor integration. However, unlike `tsd`, it does *not* use the compiler API. Instead,  It is robust enough to catch all the varieties of breaking type changes. The risks with expect-type are:

    -   It currently has a single maintainer, and relatively few users.

    -   It is relatively young, having been created only about a year ago, and therefore having existed for only 5 TypeScript releases. While its track record is good so far, there is not yet evidence of how it would deal with serious breaking changes like those introduced in TypeScript 3.5.

    -   Because the assertions are implemented as type definitions, the library is subject to the same risk of compiler breakage as the types it is testing.

At present, `expect-type` seems to be the best option, and several libraries both in the Ember ecosystem and elsewhere in the TS community are already using `expect-type` successfully (see [**Appendix A**](#appendix-a-existing-implementations) above). However, for the purposes of *this* RFC, we do not make a specific recommendation about which library to use. The tradeoffs above are offered to help authors make an informed choice in this space.

Users should add one of these libraries and generate a set of tests corresponding to their public API. These tests should be written is such a way as to test the imported API as consumers will consume the library. For example, type tests should not import using relative paths, but using the absolute paths at which the types should resolve, just as consumers would.

These type tests should be specific and precise. It is important, for example, to guarantee that an API element never *accidentally* becomes `any`, thereby making many things allowable which should not be in the case of function arguments, and "infecting" the caller's code by eliminating type safety on the result in the case of function return values. For example, the `expect-type` library's `.toEqualTypeOf` assertion is robust against precisely this scenario; package authors are also encouraged to use its `.not` modifier and `.toBeAny()` method where appropriate to prevent this failure mode.

To be safe, these tests should be placed in a directory which does not emit runtime code—either colocated with the library's runtime tests, or in a dedicated `type-tests` directory. Additionally, type tests should *never* export any code.

[dtslint]: https://github.com/microsoft/dtslint
[tslint]: https://github.com/palantir/tslint
[eslint]: https://github.com/eslint/eslint
[eslint-migration]: https://github.com/microsoft/dtslint/issues/300
[tsd]: https://github.com/SamVerschueren/tsd
[tsd-versions]: https://github.com/SamVerschueren/tsd/issues/47
[expect-type]: https://github.com/mmkal/ts/tree/master/packages/expect-type#readme

In addition to *writing* these tests, package authors should make sure to run the tests (as appropriate to the testing tool chosen) in their continuous integration configuration, so that any changes made to the library are validated to make sure the API has not been changed accidentally.

Further, just as packages are encouraged to test against a matrix of Ember versions which includes the current stable release, the currently active Ember LTS release, and the canary and beta releases, packages should test the types against all versions of TypeScript supported by the package (see the [suggested policy for version support](#policy-for-supported-typescript-versions) below) as well as the upcoming version (the `next` tag for the `typescript` package on npm).

Type tests can run as normal [ember-try] variations or similar CI. Typed Ember will document a conventional setup for ember-try configurations, so that correct integration into CI setups will be straightforward for package authors.

[ember-try]: https://github.com/ember-cli/ember-try


#### Mitigate breaking changes

It is insufficient merely to be *aware* of breaking changes. It is also important to *mitigate* them, to minimize churn and breakage for package users.


##### Avoiding user constructibility

For types where it is useful to publish an interface for end users, but where users should not construct the interface themselves, authors have a number of options (noting that this list is not exhaustive):

-   The type can simply be documented as non-user-constructible. This is the easiest, and allows an escape hatch for scenarios like testing, where users will recognize that if the public interface changes, they will necessarily need to update their test mocks to match. This can further be mitigated by providing a sanctioned test helper to construct test versions of the types.

-   Export a nominal-like version of the type, using `export type` with a class with a private field:

    <details>

    <summary>implementation of a nominal-like class in TS</summary>

    ```ts
    class Person {
      // 1.  The private brand means this cannot be constructed other than the
      //     class's own constructor, because other approaches cannot add the
      //     private field. Even if you write a class yourself with a matching
      //     private field, TS will treat them as distinct.
      // 2.  Using `declare` means this marker has no runtime over head: it will
      //     not be emitted by TypeScript or Babel.
      // 3.  Because the class itself is declared but not exported, the only way
      //     to construct it is using the function exported lower in the module.
      declare private __brand: void;

      name: string;
      age: number;

      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }

    // This exports only the *type* side of `Person`, not the *value* side, so
    // users can neither call `new Person(...)` nor subclass it. Per the note
    // above, they also cannot *implement* their own version of `Person`, since
    // they do not have the ability to add the private field.
    export type { Person };

    // This is the controlled way of building a person: users can only get a
    // `Person` by calling this function, even though they can *name* the type
    // by doing `import type { Person} from '...';`.
    export function buildPerson(name: string, age: number): Person {
      return new Person(name, age);
    }
    ```

    </details>

    This *cannot* be constructed outside the module. Note that it may be useful to provide corresponding test helpers for scenarios like this, since users cannot safely provide their own mocks.

-   Document that users can create their own local aliases for these types, while *not* exporting the types in a public way. This has one of the same upsides as the use of the classes with a private brand: the type is not constructible other than via the module. It also shares the upside of being able to create your own instance of it for test code. However, it has ergonomic downsides, requiring the use of the `ReturnType` utility class and requiring all consumers to generate that utility type for themselves.

-   Provide sanctioned mocks for testing purposes. Since these live alongside, and therefore can be tested with and kept in sync with the package they are mocks for, they can also be provided with the exact same versioning stability guarantees as the package code itself.

Each of these leaves this module in control of the construction of `Person`s, which allows more flexibility for evolving the API, since non-user-constructible types are subject to fewer breaking change constraints than user-constructible types. Whichever is chosen for a given type, authors should document it clearly.


##### Updating types to maintain compatibility

Sometimes, it is possible when TypeScript makes a breaking change to update the types so they are backwards compatible, without impacting consumers at all. For example, [TypeScript 3.5][3.5-breakage] changed the default resolution of an otherwise-unspecified generic type from the empty object `{}` to `unknown`. This change was an improvement in the robustness of the type system, but it meant that any code which happened to rely on the previous behavior broke.

This example from [Google's writeup on the TS 3.5 changes][3.5-breakage] illustrates the point. Given this function:

```ts
function dontCarePromise() {
  return new Promise((resolve) => {
    resolve();
  });
}
```

In TypeScript versions before 3.5, the return type of this function was inferred to be `Promise<{}>`. From 3.5 forward, it became `Promise<unknown>`. If a user ever wrote down this type somewhere, like so:

```ts
const myPromise: Promise<{}> = dontCarePromise();
```

…then it broke on TS 3.5, with the compiler reporting an error ([playground][3.5-breakage-plaground]):

> Type 'Promise<unknown>' is not assignable to type 'Promise<{}>'.
>   Type 'unknown' is not assignable to type '{}'.

This change could be mitigated by supplying a default type argument equal to the original value ([playground][3.5-mitigation-playground]):

```ts
function dontCarePromise(): Promise<{}> {
  return new Promise((resolve) => {
    resolve();
  });
}
```

This is a totally-backwards compatible bugfix-style change, and should be released in a bugfix/point release. Users can then just upgrade to the bugfix release *before* upgrading their own TypeScript version—and will experience *zero* impact from the breaking TypeScript change.

Later, the default type argument `Promise<{}>` could be dropped and defaulted to the new value for a major release of the library when desired (per the policy [outlined below](#policy-for-supported-type-script-versions), giving it the new semantics. (Also see [<b>Opt-in future types</b>](#opt-in-future-types) below for a means to allow users to *opt in* to these changes before the major version.)

[3.3-pre-breakage-playground]: https://www.typescriptlang.org/play/?ts=3.3.3&ssl=1&ssc=27&pln=1&pc=40#code/GYVwdgxgLglg9mABAEwVAwgQwE4FMAK2cAtjAM64AUAlIgN4CwAUIonlCNkmLgO6KES5KpTxk4AGwBuuWgF4AfPWatWYyTJoBuFYgC+1HUz3NmEBGSiJiAT0GkKALgFEHuADx09SuSjRY8e2FtIA
[3.5-breakage-plaground]: https://www.typescriptlang.org/play/?ts=3.5.1&ssl=1&ssc=27&pln=1&pc=40#code/GYVwdgxgLglg9mABAEwVAwgQwE4FMAK2cAtjAM64AUAlIgN4CwAUIonlCNkmLgO6KES5KpTxk4AGwBuuWgF4AfPWatWYyTJoBuFYgC+1HUz3NmEBGSiJiAT0GkKALgFEHuADx09SuSjRY8e2FtIA
[3.5-mitigation-playground]: https://www.typescriptlang.org/play/?ts=3.5.1#code/GYVwdgxgLglg9mABAEwVAwgQwE4FMAK2cAtjAM64AUAlAFyKEnm4A8A3gL4B8ibAsAChEiPFBDYkYXAHcGRUhUqU8ZOABsAbrmqIAvD35DhI3Ks1VqAbkHCOVwR0GCICMlETEAnowW56P5nZuPRQ0LDwAxSsgA


##### "Downleveling" types

When a new version of TypeScript includes a backwards-incompatible change to *emitted type definitions*, as they did in [3.7][3.7-emit-change], the strategy of changing the types directly may not work. However, it is still possible to provide backwards-compatible types, using the combination of [downlevel-dts] and [typesVersions]. (In some cases, this may also require some manual tweaking of types, but this should be rare for most packages.)

- The [`downlevel-dts`][downlevel-dts] tool allows you to take a `.d.ts` file which is not valid for an earlier version of TypeScript (e.g. the changes to class field emit mentioned in [<b>Breaking Changes</b>](#breaking-changes)), and emit a version which *is* compatible with that version. It supports targeting all TypeScript versions later than 3.4.

- TypeScript supports using the [`typesVersions`][typesVersions] key in a `package.json` file to specify a specific set of type definitions (which may consist of one or more `.d.ts` files) which correspond to a specific TypeScript version.

[downlevel-dts]: https://github.com/sandersn/downlevel-dts
[typesVersions]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#version-selection-with-typesversions

The recommended flow would be as follows:

1.  Add `downlevel-dts`, `npm-run-all`, and `rimraf`  to your dev dependencies:

    ```sh
    npm install --save-dev downlevel-dts npm-run-all rimraf
    ```

    or

    ```sh
    yarn add --dev downlevel-dts npm-run-all rimraf
    ```

2.  Create a script to downlevel the types to all supported TypeScript versions:

    ```sh
    # scripts/downlevel.sh
    npm run downlevel-dts . --to 3.7 ts3.7
    npm run downlevel-dts . --to 3.8 ts3.8
    npm run downlevel-dts . --to 3.9 ts3.9
    npm run downlevel-dts . --to 4.0 ts4.0
    ```

3.  Update the `scripts` key in `package.json`  to generate downleveled types generated by running `downlevel-dts` on the output from `tsc`, and to clean up the results after publication. For example, using `ember-cli-typescript`’s tooling:

    ```diff
    {
      "scripts": {
    -   "prepublishOnly": "ember ts:precompile",
    +   "prepublish:types": "ember ts:precompile",
    +   "prepublish:downlevel": "./scripts/downlevel.sh",
    +   "prepublishOnly": "run-s prepublish:types prepublish:downlevel",
    -   "postpublish": "ember ts:clean",
    +   "clean:ts": "ember ts:clean",
    +   "clean:downlevel": "rimraf ./ts3.7 ./ts3.8 ./ts3.9 ./ts4.0",
    +   "clean": "npm-run-all --aggregate-output --parallel clean:*",
    +   "postpublish": "npm run clean",
      }
    }
    ```

4.  Add a `typesVersions` key to `package.json`, with the following contents:

    ```json
    {
      "types": "index.d.ts",
      "typesVersions": {
        "3.7": { "*": ["ts3.7/*"] },
        "3.8": { "*": ["ts3.8/*"] },
        "3.9": { "*": ["ts3.9/*"] },
        "4.0": { "*": ["ts4.0/*"] },
      }
    }
    ```

    This will tell TypeScript how to use the types generated by this process. Note that we explicitly include the `types` key so TypeScript will fall back to the defaults for 3.9 and higher.

5.  If using the `files` key in `package.json` to specify files to include (unusual but not impossible for TypeScript-authored packages), add each of the output directories (`ts3.7`, `ts3.8`, `ts3.9`, `ts4.0`) to the list of entries.

Now consumers using older versions of TypeScript will be buffered from the breaking changes in type definition emit.

If the community adopts this practice broadly we will want to invest in tooling to automate support for managing dependencies, downleveling, and type tests. However, the core constraints of this RFC do not depend on such tooling existing, and the exact requirements of those tools will emerge organically as the community begins implementing this RFC's recommendations.


##### Opt-in future types

In the case of significant breaking changes to *only* the types—whether because the package author wants to make a change, or because of TypeScript version changes—packages may supply *future* types, which users may opt into *before* the library ships a breaking change. (We expect this use case will be rare, but important.)

In this case, package authors will need to *hand-author* the types for the future version of the types, and supply them at a specific location which users can then import directly in their `types/my-app.d.ts` file—which will override the normal types location, while not requiring the user to modify the `paths` key in their `tsconfig.json`.

This approach is a variant on [**Updating types to maintain compatibility**](#updating-types-to-maintain-compatibility). Using that same example, a package author who wanted to provide opt-in future types instead (or in addition) would follow this procedure:

1.  Backwards-compatibly *fix* the types by explicitly setting the return type on `dontCarePromise`, just as discussed above:

    ```diff
    - function dontCarePromise() {
    + function dontCarePromise(): Promise<{}> {
    ```

2.  Create a new directory, named something like `ts3.5`.

3.  Generate the type definition files for the package by running `ember ts:precompile`.

4.  Manually move the generated type definition files into `ts3.5`.

5.  In the `ts3.5` directory, either *remove* or *change* the explicit return type, so that the default from TypeScript 3.5 is restored:

    ```diff
    - function dontCarePromise(): Promise<{}> {
    + function dontCarePromise(): Promise<unknown> {
    ```

6.  Wrap each module file in the generated definition with a `declare module` specifying the *canonical* module name. For example, if our `dontCarePromise` definition were from a module at `my-library/sub-package`, we would have the following structure:

    ```
    my-library/
      ts3.5/
        index.d.ts
        sub-package.d.ts
    ```

    —and the contents of `sub-package.d.ts` would be:

    ```ts
    declare module 'my-library/sub-package' {
      export function dontCarePromise(): Promise<unknown>;
    }
    ```

7.  Explicitly include each such sub-module in the import graph available from `ts3.5/index.d.ts`—either via direct import in that file or via imports in the other modules. (Note that these imports can simply be of the form `import 'some-module';`, rather than importing specific types or values from the modules.)

7.  Commit the `ts3.5` directory, since it now needs to be maintained manually until a breaking change of the library is released which opts into the new behavior.

8.  Cut a release which includes the new fixes. With that release:

    -   Inform users about the incoming breaking change.

    -   Tell users to add `import 'fancy-package/ts3.5';` to the entry point of their package or a similar location. For example, in Ember, users would add the import to the top of their `types/my-app.d.ts` or `types/my-package.d.ts` file (which are generated by `ember-cli-typescript`).

9.  At a later point, cut a breaking change which opts into the TypeScript 3.5 behavior.

    -   Remove the `ts3.5` directory from the repository.

    -   Note in the release notes that users who did not previously opt into the changes will need to do so now.

    -   Note in the release notes that users who *did* previously opt into the changes should remove the `import 'fancy-package/ts3.5';` import from `types/my-app.d.ts` or `types/my-package.d.ts`.

#### Matching exports to public API

Another optional tool for managing public API is [API Extractor][api-extractor]. Authors can mark their exports as `@public`, `@protected`, `@private`, `@alpha`, `@beta`, etc. and use the tool to generate type definitions accordingly. For example, for mitigating a future TypeScript version change, or experimenting on a new API, authors can use `@alpha` or `@beta` and use `typesVersions` to publish to a dedicated directory. Similarly, authors can make an export public for use through the package or even a set of related packages in a moinorepo, but mark it as `@private` and use API Extractor to generate types which exclude it when publishing to npm.

[api-extractor]: https://api-extractor.com


### Appendix C: On Variance in TypeScript

As alluded to in [Changes to Types: Variance](#variance), there are several complicating factors for the discussion of variance in TypeScript:

- the combination of inference with pervasive mutability
- structural typing
- what I will describe here as *higher-order type operations*

#### Inference and pervasive mutability

For example, by the classic rules, `Array<T>` should be invariant: it is a read-write (i.e. mutable) type. That means that a very simple change, otherwise apparently safe for consumers, can break it. Start with a library function which returns `string | number`:

```ts
declare function example(): string | number;
```

A consumer might use this code in the construction of an array, and then having leaned on inference, push both `string`s and `number`s into it:

```ts
const myArray = [example()]; // Array<string | number>
myArray.push(123);           // ✅
myArray.push("hello");       // ✅
```

The author of the library might later update `example` to return only `string`s:

```ts
declare function example(): string;
```

This would be safe under the rule for write-only types, which is the intuition underlying many of the definitions below—but for our array example, it is *not* safe: `.push()`-ing in a `number` is now illegal.

```ts
const myArray = [example()]; // Array<string>
myArray.push(123);           // ❌ number not assignable to string
myArray.push("hello");       // ✅
```

What's more, we don't need an object like an array to trigger this kind of behavior. Using a `let` binding instead of a `const` binding will produce exactly the same issue. Under the original definition of `example`, this would be perfectly legal:

```ts
let value = example(); // string | number
value = 123;           // ✅
value = "hello";       // ✅
```

But it stops being valid as soon as `example` is narrowed:

```ts
let value = example(); // string
value = 123;           // ❌ number not assignable to string
value = "hello";       // ✅
```

While lint guidelines preferring `const` may *help* mitigate the latter, they are controversial[^const-controversy] and they do not and cannot help with the `Array` example or others like it. Nor is it feasible to require a “functional” immutable-update style, given that JavaScript lacks robust immutable data structures, which would allow for recommending that approach.

In this case, cautious users may work around this by explicitly annotating their types to match the return type of the:

```ts
const myArray: Array<string | number> = [example()];
let value: string | number = example();
```

We do not expect this to be common, however: the cost of this is much higher than the cost of changing one's code in the cases where it may be broken.

[^const-controversy]: Rightly so, in my opinion!

#### Structural typing

Most programming languages where programmers must deal with variance have *nominal* type systems, and and subtyping relations can be straightforwardly specified in terms of the relations between the types—particular via subclassing (as in Java, C++, and C#) or between interfaces (as in Rust’s `trait` system). In TypeScript, however, subtyping relationships include both subclassing and interface-based subtypes and also *structural subtyping*.

Given types `A` and `B`, `B` is a subtype of `A` for the purposes of assignability (e.g. in function calls) when it is a *superset* of `A`. Most simply:

```ts
type A = {
  a: number;
}

type B = {
  a: number;
  b: string;
}

type C = {
  a?: number;
  b: string;
}

declare function takesA(a: A): void;

declare let a: A;
declare let b: B;
declare let c: C;
takesA(a); // ✅
takesA(b); // ✅
takesA(c); // ❌
```

Notice that this is *unlike* the dynamics in nominal type systems, where unless `B` explicitly declared a relationship to `A` (e.g. `class B extends A { }` or `interface B : A { }` or similar), the two are unrelated, regardless of their structural relationships. Similar dynamics play out for other kinds of types.

#### Higher-order type operations

The second factor which makes dealing with TypeScript types difficult is its support for *type-level mutation*. Consider the type of `x` at points 1–4 in the following simple, but relatively idiomatic, TypeScript function definition:

```ts
function describe(x: string | number | undefined) {
  switch (typeof x) {                 // 1
    case 'string':
      return `x is the string ${x}`;  // 2
    case 'number':
      return `x is the number ${x}`;  // 3
    default:
      return `x is "undefined"`;      // 4
  }
}
```

1. The type is `string | number | undefined`.
2. The type is `string`.
3. The type is `number`.
4. The type is `undefined`.

While this quickly becomes second-nature to TypeScript developers and we don’t give it a second thought, it’s important to take a step back and consider what is actually happening here: the type of `x` is a variable—a *type-level* variable—whose value changes over the body of the function. That is, it is a *mutable type-level variable*. While it is possible to construct values whose types in TypeScript are *not* mutable (e.g. with `never` or a boolean or numeric literal value), *most* values constructed in an ordinary TypeScript program have mutable types.

What’s more, this combines with TypeScript’s use of structural typing and inference mean that many cases which would intuitively be “safe” to make changes around can in fact create compiler errors. For example, consider a function which today returns `string | number`:

```ts
declare function a(): string | number;
```

Using this function to create a value `x` will give us the type `x: string | number` as we would expect. Then we might *narrow* the type later:

```ts
const x = a(); // string | number
const y = typeof x === 'string' ? x.length : x;  // ✅
```

In general by the rules of variance, we would expect that narrowing the return type of `a` to always return `number` would be fine. This is in a “write-only” position, and so we would expect that we should allow contravariance: a narrower type is permissible. From a runtime perspective, that is true, because all existing code will continue to work (even if there are some unnecessary branches). However, TypeScript will produce a type error here, because the type of `x` no longer includes `string`, and so the `typeof x === 'string'` check can be statically known to be.

Practically speaking, this is an annoyance rather than a meaningful breaking change. It can, however, result in significant work across a code base! What is more, it is not possible to work around this merely with an explicit type definition today. Naïvely, we might expect explicit type declarations to allow us to dodge this problem in places we actually care about it:

```ts
const x: string | number = a();
const y = typeof x === 'string' ? x.length : x;  // ❌
```

In practice, however, TypeScript today (up through 4.5) will first check that the type returned by `a()` is a subtype of the declared type of `x`, and then if `a()` returns a *narrower* type than that declared for `x`, it will actually set `x`'s type to the narrower type returned by `a()` instead of the explicitly-declared type. Thus, a user who wishes to avoid this problem must *everywhere* annotate their code with explicit type casts:

```ts
const x = a() as string | number;
const y = typeof x === 'string' ? x.length : x;
```

This is very annoying; worse, it is also easy to break. TypeScript today silently allows an unsafe cast here, which can in turn produce runtime errors:

```ts
declare function a(): string | number;
const x = a() as string; // 👎🏼
const y = x.length;  // possible runtime error!
```

Thus, for the thoroughly pragmatic reason that no one would ever want to write these kinds of casts and the more principled reason that these kinds of casts as readily undermine as support the kinds of type safety TypeScript aims to provide *and* the versioning guarantees this RFC aims to provide, we simply acknowledge that from a practical standpoint, the pervasiveness of type-level mutation makes it impossible to provide a definition of breaking changes which forbids the introduction of compiler errors by even apparently-safe changes.

The problem runs the other direction, too: while this example shows now-extraneous code which can be deleted, the same underlying issue can also require *adding* code, e.g. when adding a field to a library type which was previously being used to discriminate two objects.

Given this starting code:

```ts
// provided by the library
type LibType = {
  a: boolean;
}

type MyType = {
  b: string;
}

function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
      // narrowed obj to `MyType`
    console.log(obj.b.substring(0));
  }
}
```

If the library adds a field `b` which is of any type but `string`—

```ts
type LibType = {
  a: boolean;
  b: number;
}
```

—then we have a type error in `takesEither()` because the `in` operator no longer successfully discriminates between `LibType` and `MyType`:

```ts
function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
    // `obj` is still `LibType | MyType` so `b` is now `string | number`
    console.log(obj.b.substring(0)); // ❌
  }
}
```

The compiler will dutifully report:

> Property 'substring' does not exist on type 'string | number'.

In sum, just as pervasive runtime mutability and inference made it impossible to fully specify an approach which prevents users from experiencing breaking changes.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2021-04-23T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/738
project-link:
---

# EmberData | Deprecate Model Reopen

## Summary

Deprecates using `reopen` to alter clases extending `@ember-data/model`.

## Motivation

`reopen` restricts the ability of EmberData to design better primitives that maintain
compatibility with `@ember-data/model`, and is a footgun that leads to confusing incorrect
states for users that utilize it.

## Detailed design

The static `reopen` method on `Model` will be overwritten to provide a deprecation which
once resolved or after the deprecation lifecycle completes will result in `reopen` throwing
an error when used in dev and silently no-oping in production. This deprecation will target
`5.0` and not be `enabled` sooner than `4.1` though it may come available before that.

## How we teach this

This is best taught through a deprecation guide. Users using `reopen` to test multiple
configurations in their test suite should instead extend and register a new model each time.

Users using `reopen` to modify a class immediately after creating it should also refactor
to `extend` instead.

Users using `reopen` to modify a class dynamically at runtime should refactor to either register
new model types or (better) utilize a megamorphic solution such as ember-m3 to achieve their needs.

In all cases, using `reopen` after a class instance for a record has already been created has *always*
resulted in at least minor and potentially major errors in application state.

## Drawbacks

Test suites, including EmberData's own, that make use of `reopen` are often "order dependent" in order
for the test suite to pass, and refactoring them can sometimes be a difficult exercise in determining
which tests had modified the class to achieve the model shape needed by another test. In general though
the drawbacks here are small given the widespread adoption of class syntax and growing adoption of octane
paradigms.

## Alternatives

- Don't deprecate `reopen` and wait to replace `@ember-data/model` in it's entirety. This alternative would prevent us from providing custom decorators not extending from `computed` and limit potential build tools allowing users to optimize existing usage of EmberData.

- Wait for `ember` to deprecate `reopen`. Because we cannot build custom decorators and support `reopen` without asking for `ember` to make available to use private APIs I do not think we should wait for Ember here. This RFC does not preclude or force Ember to deprecate reopen more broadly.


---

---
stage: recommended
start-date: 2021-04-23T00:00:00.000Z
release-date: 2022-09-06T00:00:00.000Z
release-versions:
  ember-data: v4.7.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/739'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/909'
  released: 'https://github.com/emberjs/rfcs/pull/924'
project-link:
---

# EmberData | Deprecate Non Strict Relationships

## Summary

Deprecates various shorthands for defining a `belongsTo` or `hasMany`
relationship that create ambiguity, cause expensive runtime lookups,
or hinder static analysis.

## Motivation

Deprecating these shorthands allows us to provide better tooling, remove the bulky
and expensive code necessary to determine the outcomes of these shorthands at
runtime, and in the process clarify and simplify relationship behaviors in the
documentation. Further, it allows us to align our own internal usage of
"relationship meta" with the API put forward in [RFC#487 Custom Model Classes](https://github.com/emberjs/rfcs/blob/master/text/0487-custom-model-classes.md#exposing-schema-information).

## Detailed design

Three shorthands are proposed to be deprecated, with the deprecation targeting `5.0`
and being `enabled` no-sooner than `4.1`. It may be `available` sooner.

- Deprecates the relationship shorthand that does not provide the related type as the first argument.

This deprecation is related to deprecating `non-strict` types as it requires us to
normalize the property name into a type string in a manner which may not be correct.

*Before*

```./before.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

export default class Comment extends Model {
  @belongsTo()
  author;

  @hasMany({ async: true, inverse: null })
  likes;
}
```

*After*

```./after.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

export default class Comment extends Model {
  @belongsTo('author')
  author;
  @hasMany('like', { async: true, inverse: null })
  likes;
}
```

- Deprecates not explicitly setting the relationship inverse property (or `null`).

The current default when not specified is to attempt to find a property on the
related model that either explicity or implicitly points back, resolving to `null`
if no such relationship is found and erring if more than one potential inverse was
discovered.

*Before*

```./before.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user')
  author;

  @hasMany('like')
  likes;
}

class User extends Model {
  @hasMany('comment')
  comments;
}

class Like extends Model {
  @belongsTo('user')
  author;
}
```

*After*

```./after.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { inverse: 'comments' })
  author;

  @hasMany('like', { inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { inverse: null })
  author;
}
```

- Deprecates not explicitly setting `async` to `true|false`.

The current default when not specified is `true`.

*Before*

```./before.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { inverse: 'comments' })
  author;

  @hasMany('like', { inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { inverse: null })
  author;
}
```

*After*

```./after.js
import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { async: true, inverse: 'comments' })
  author;

  @hasMany('like', { async: true, inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { async: true, inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { async: true, inverse: null })
  author;
}
```

## Codemod

A codemod should be provided. This codemod would analyze a user's relationships
and wherever possible format the provided options with the now deprecated missing
information. Note: For the related type and inverse property name when
mixin-based polymorphism is present codemods may not be practical.

## How we teach this

Generally these changes improve our ability to document and explain relationship
APIs as confusing behaviors (such as undefined `async` defaulting to `true`) and
inverse determination are no longer magical resolutions but explicit declarations.
API documentation will be updated and any examples in the guides should be as well.

## Drawbacks

Some churn, but via codemod we can make this quick and seamless for most apps.

## Alternatives

Provide new decorators that replace these. Leave these alone. While we may introduce
new decorator primitives in the near future, iterating on the existing decorators to
make them stricter in largely painless ways will allow more teams to migrate to a full
replacement in the future with greater ease.


---

---
stage: recommended
start-date: 2021-04-23T00:00:00.000Z
release-date: 2023-09-19T00:00:00.000Z
release-versions:
  ember-data: 5.3.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/740'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/910'
  released: 'https://github.com/emberjs/rfcs/pull/967'
  recommended: 'https://github.com/emberjs/rfcs/pull/972'
project-link:
---

# EmberData | Deprecate Non Strict Types

## Summary

Deprecates when the `type` for a record provided by a user differs from the resolved
type, thereby removing the need to configure `ember-inflector` to treat `types` as `uncountable`
in order to use plural model names, and removing the dasherization constraint.

## Motivation

Today, `ember-data` normalizes user supplied `type` or `modelName` anywhere it is encountered
so that it will match the `type` we expect to provide to ember's resolver to lookup and create
instances of `Model`/`Adapter`/`Serializer`.

In practice, this resulted in a convention of singularized, dasherized modelName arguments and
`type` fields in payloads. However, this convention is unimportant to how EmberData operates and
we feel that users should be able to name their models however they like provided that (1) they
use their format consistently and (2) that format matches what ember's resolver needs to resolve
any necessary modules (such as models).

Today, if you wanted to name a model `posts`, you could achieve this by

- explicitly definining the inverse type on all relationships pointing at `posts`
- using `posts` as the type in all payloads provided to the store
- naming your model on disk as `models/posts.js`
- configuring `ember-inflector` to treat `posts` as either uncountable or as it's own singular/plural.

While the first three items here are strict conventions, we would like to do away with the necessity of
configuring `ember-inflector` in this manner.

Similarly, if you want to name your models with camelCase or SnakeCase types instead of dasherized types
we see no reason to enforce that you do otherwise.

In this sense the name of this RFC may at first feel in opposition to the motivation: we are proposing
deprecating non-strict usage of types so that we can loosen restrictions on type usage.

By removing support for non-strict we *strictly* mean removing support for using types in a way that
depends upon our normalization in order for resolver lookups to succeed.

## Detailed design

We would print a deprecation whenever our normalization results in a different string than the string originally
received. This deprecation would target `5.0` and become `enabled` no-sooner than `4.1` although it may be made
`available` before then.

To resolve issues with `dasherization`, users would need to dasherize in advance of providing data or arguments
to `store` methods (generally this is done in the serializer's normalization hooks for payloads and at
call-sights for method args that take `modelName`).

To resolve issues with `singularization`, users would need either to configure `ember-inflector` to return the
desired form for their string if the supplied string is the desired singular/plural, or singularize the string
in advance.

Once a user has resolved this deprecation and marked their app as compatible with the version of `ember-data`
in which this deprecation became enabled all support for ember-data's normalization will be removed at build
time and users may supply types in any format so long as their usage is (1) consistent and (2) resolveable.

## How we teach this

Generally these changes remove a thing to be taught (that all types anywhere in a payload or as args should
be normalized to the singular+dasherized form) in favor of teaching that usage of a `type` should be consistent
and that the name of the `model` should match what is being used as `type`.

## Drawbacks

Potentially some churn if it turns out that lots of users rely on the dasherization aspect. We already stopped
singularizing on our own some time ago except in the case of hasMany relationship definitions. We can mitigate
this to a good degree by making sure that the default serializers dasherize their output if they do not already.

## Alternatives

Continue to enforce dasherized-singular types and pay the cost of requiring use of `ember-inflector` if using
`ember-data`.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2021-04-23T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/741
project-link:
---

# EmberData | Deprecate Accessing Static Fields On Model Prior To Lookup

## Summary

Deprecates when a user directly imports a model extending `@ember-data/model` and
attempts to access one of the static fields containing schema information about
attributes or relationships.

## Motivation

Schema descriptors on classes extending `@ember-data/model` require walking the prototype
chain to collect inherited attributes and relationships. This isn't possible until an
`EmberObject`'s private `proto` method has been invoked.

Externally, we feel accessing schema information in this manner is a bad practice that should
be avoided. Schema information is exposed at runtime via `store.modelFor` in pre-
[custom-model-class](https://github.com/emberjs/rfcs/blob/master/text/0487-custom-model-classes.md#custom-model-class-rfc)
versions and via the schema definition service and store-wrapper in post- custom-model-class
versions (3.28+).

Internally, the EmberData team wishes to explore removing our dependence on `computed`
properties and `eachComputedProperty` which make use of invoking `proto` for defining
schema (`attr|belongsTo|hasMany` currently utilize these APIs to build out the schema information).

## Detailed design

If we detect that an access has been made on a class not provided by a factory (the result of
calling `modelFor`) we would print a deprecation targeting `5.0` that would become `enabled`
no-sooner than `4.1` (although it may be made `available` before then).

Most usages of this pattern occur when a user imports a model for a unit test. In these cases
the appropriate refactor to look it up via the store like so:

```js
test('my test', async function(assert) {
  const UserSchema = this.owner.lookup('service:store').modelFor('user');
  let { attributes } = UserSchema; // access the map of attributes
});
```

Or if defining the model in the test file, first register the model like so:

```js
test('my test', async function(assert) {
  class User extends Model {
    @attr name;
  }
  this.owner.register('model:user', User);

  const UserSchema = this.owner.lookup('service:store').modelFor('user');
  let { attributes } = UserSchema; // access the map of attributes
});
```

## How we teach this

Generally this pattern has not been widely observed, though we should make sure that api-docs,
guides, and blueprints are all updated to show the preferred pattern.

## Drawbacks

Potentially some churn if it turns out that lots of users rely on this sort of access, though
generally this is just another clear step away from `EmberObject` and it better prepares these
users for accessing schema on models not built off of `@ember-data/model`.

## Alternatives

Ignore that this pattern exists, which seems risky given our momentum towards custom model
classes and potentially a different default model than `@ember-data/model`.


---

---
stage: accepted
start-date: 2021-04-23T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/742
project-link:
---

# EmberData | Deprecate Helper Functions

## Summary

Deprecates the exported util functions `errorsHashToArray` `errorsArrayToHash`
and `normalizeModelName` that were recommended for deprecation by the [RFC#395 packages](https://github.com/emberjs/rfcs/blob/master/text/0395-ember-data-packages.md)

## Motivation

These utils are a legacy remnant of when parts of the codebase were shared with each other
by a `DS` global. Over time their utility has shrunk and today they no longer align with
the direction of [error management](https://github.com/emberjs/rfcs/blob/master/text/0465-record-data-errors.md) or [type constraints](https://github.com/emberjs/rfcs/pull/740).

## Detailed design

Users would receive a build-time deprecation when importing these methods using the paths
specified in [RFC#395 packages](https://github.com/emberjs/rfcs/blob/master/text/0395-ember-data-packages.md).

They would receive a run-time deprecation when using these methods via the `DS` global.

The deprecation would target `5.0` and would become `enabled` no-sooner than `4.1` (although
it may be made `available` before then).

Users making use of these methods can trivially copy them into their own codebase to continue
using them, though we recommend refactoring to a more direct conversion into the expected errors
format. For refactoring `normalizeModelName` we also recommend following [RFC#740 Deprecate Non-Strict Types](https://github.com/emberjs/rfcs/pull/740).

## How we teach this

Generally usage has not been widely observed and these are not methods commonly shown in
examples or docs. We should make sure to audit for usages and remove them if they exist.

## Drawbacks

A trivial amount of churn for users that did utilize them.

## Alternatives

Leave them to waste away.


---

---
stage: recommended 
start-date: 2021-04-23T00:00:00.000Z
release-date: 2023-09-18T00:00:00.000Z
release-versions:
  ember-data: v5.3.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/743'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/947'
  released: 'https://github.com/emberjs/rfcs/pull/969'
  recommended: 'https://github.com/emberjs/rfcs/pull/979'
---

# EmberData | Deprecate Legacy Imports

## Summary

Deprecates `import DS from "ember-data";` and individual imports within the `ember-data` 
package in favor of the imports provided by [RFC#395 packages](https://github.com/emberjs/rfcs/blob/master/text/0395-ember-data-packages.md)

## Motivation

These imports are just a legacy remnant we no longer need.

## Detailed design

Lint rules and a codemod already exist to migrate users to using packages, and have been 
available now for over a year.

The ember-data-packages plugin for ember-cli-babel would be updated so that users would
receive a deprecation when importing from the legacy paths. If required for legacy global
or DS import a runtime deprecation would be added as well.

To resolve, users would need only to run the codemod to convert to using packages.

The deprecation would target `5.0` and would become `enabled` no-sooner than `4.1` (although
it may be made `available` before then).

## How we teach this

Users have already been encouraged to migrate, documentation has already been updated to reflect
the package based imports, and lint rules and codemods already exist. Deprecating and removal at
this point is just a formality as the last stage of fading out the old world.

## Drawbacks

Someone somewhere probably is doing something bad.

## Alternatives

Leave them to waste away.


---

---
stage: accepted
start-date: 2021-04-23T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/745
project-link:
---

# EmberData | Modernize PromiseManyArray

## Summary

Deprecates reading, mutating or operating on an async `hasMany` relationship before
resolving it's value in the application's Javascript code. Rendering an async `hasMany`
in a template will continue to work as expected.

## Motivation

`PromiseManyArray` is a promisified `ArrayProxy` that serves as a fetch wrapper when
a user either implicitly or explicitly defines a `hasMany` relationship as async. It
is the synchronous return value when a user access the async relationship on a record instance.

For instance, given the following `Post` model.

```js
class Post extends Model {
  @hasMany('comment' { inverse: null, async: true })
  comments
}
```

A user today might access and map over the comments for a post in the following manner.

```js
const commentProxy = post.comments;
const commentIds = commentProxy.map(comment => comment.id);
```

This often works because any `resolved` data for the relationship is immediately accessible
via the `ArrayProxy`. However, if the network request initiated by accessing the comments
relationship results in changes to what records are available, those changes would not be
reflected in the `commentIds`. More often, users will `await` the relationship to ensure the
data is fully ready for use.

```js
const comments = await post.comments;
const commentIds = comments.map(comment => comment.id);
```

As the language and framework have evolved, better features have become available that
negate the value of many of the methods that exist on `PromiseManyArray`. This RFC seeks
to better align the way folks interact with an async relationship with the `Octane` paradigm,
`tracked` properties, and `async/await`. Doing so allows us to take a major first step towards
simplifying the use of array-like proxies throughout EmberData.

## Detailed design

This RFC will reduce the API surface area of PromiseManyArray to just those methods needed to
serve it's primary functions.

- as a thenable/awaitable value (with promise state flags)
- as a custom enumerable that for-convenience can be directly iterated by templates.

All other methods and properties on PromiseManyArray would be deprecated. Additionally,
the methods `addArrayObserver` and `removeArrayObserver` on `ManyArray` will be deprecated.

Code examples, guides, and documentation should encourage users to resolve the relationship
before operating on it, including avoiding the use of the remaining iterable APIs (which will
be marked private).

This deprecation would target `5.0` and would become `enabled` no-sooner than `4.1` (although
it may be made `available` before then).

We will keep the following properties and methods previously supplied by the `PromiseProxyMixin`

- the public promise state flag `isSettled`
- the public promise state flag `isPending`
- the public promise state flag `isRejected`
- the public promise state flag `isFulfilled`
- the private property `promise`
- the method `then`
- the method `catch`
- the method `finally`

But we will eliminate the private property `reason`.

We will keep the following property we had supplied on our own

- the public property `links`
- the method `reload`

While deprecating the following methods which delegated to the ManyArray

- `createRecord`

As `PromiseManyArray` historically extended `ArrayProxy`, it inherited a large API surface from
`MutableArray` `EmberArray` and `EmberObject` the totality of which will be deprecated *except* for:

- the private property `content`
- the property `length`
- the public property `isDestroyed`
- the iterator method `objectAt` (but which will now be marked private)


### Finalized API of PromiseManyArray

Remaining API surface

- `content` (private)
- `length`
- `isDestroyed`
- `objectAt` (private)
- `links`
- `reload`
- `promise`  (private)
- `isSettled`
- `isPending`
- `isFulfilled`
- `isRejected`
- `then`
- `catch`
- `finally`

Deprecated API surface

- `reason`
- `createRecord`
- `firstObject`
- `lastObject`
- `addObserver`
- `cacheFor`
- `decrementProperty`
- `get`
- `getProperties`
- `incrementProperty`
- `notifyPropertyChange`
- `removeObserver`
- `set`
- `setProperties`
- `toggleProperty`
- `addArrayObserver`
- `addObject`
- `addObjects`
- `any`
- `arrayContentDidChange`
- `arrayContentWillChange`
- `clear`
- `compact`
- `every`
- `filter`
- `filterBy`
- `find`
- `findBy`
- `forEach`
- `getEach`
- `includes`
- `indexOf`
- `insertAt`
- `invoke`
- `isAny`
- `isEvery`
- `lastIndexOf`
- `map`
- `mapBy`
- `objectsAt`
- `popObject`
- `pushObject`
- `pushObjects`
- `reduce`
- `reject`
- `rejectBy`
- `removeArrayObserver`
- `removeAt`
- `removeObject`
- `removeObjects`
- `replace`
- `reverseObjects`
- `setEach`
- `setObjects`
- `shiftObject`
- `slice`
- `sortBy`
- `toArray`
- `uniq`
- `uniqBy`
- `unshiftObject`
- `unshiftObjects`
- `without`

## How we teach this

As this deprecation targets 4.x, users would need to have upgraded to Octane paradigms before
they could encounter the deprecations listed here. This means for *most* apps this should be as
trivial as adding an `await` where necessary.

## Drawbacks

It has become fairly common to interact with async hasMany relationships as if they are
synchronous, and it is not easy to programmatically codemod a conversion. This may result in
a sizeable amount of "find the missing await" for some applications.

## Alternatives

Deprecate array-like APIs on ManyArray simultaneously. Why not? While this is something we seek to do as a follow up, that migration is a more difficult one than this which *only* pushes users to resolve async before interacting with the value. As the ManyArray has all these same methods in a non-deprecated state, existing code will continue to run as expected and without deprecation so long as that resolution is done. This is a first step which will make that deprecation easier when
the time comes.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2021-05-13T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/748
project-link:
---

## Summary <!-- omit in toc -->

In TypeScript, the `@glimmer/component` base class currently has a single `Args` type parameter. This parameter declares the names and types of the arguments the component expects to receive.

This RFC proposes a change to that type parameter to become `Signature`, capturing more complete information about how components can be used in a template, including their expected **arguments**, the **blocks** they accept, and what type of **element(s)** they apply any received attributes and modifiers to.

This RFC is based in large part on prior work by [@gossi] and on learnings from [Glint].

[@gossi]: https://github.com/gossi
[Glint]: https://github.com/typed-ember/glint


### Outline <!-- omit in toc -->

- [Motivation](#motivation)
- [Detailed design](#detailed-design)
  - [`InvokableComponentSignature`](#invokablecomponentsignature)
  - [`GlimmerComponentSignature`](#glimmercomponentsignature)
  - [Updated type for Glimmer `Component`](#updated-type-for-glimmer-component)
  - [Example](#example)
  - [`Args`](#args)
  - [`Blocks`](#blocks)
  - [`Element`](#element)
    - [Components With Multiple or Varying Elements](#components-with-multiple-or-varying-elements)
- [How we teach this](#how-we-teach-this)
  - [Documentation](#documentation)
  - [Migration](#migration)
    - [Codemods](#codemods)
    - [Deprecation Warnings/Linting](#deprecation-warningslinting)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
  - [Additional Positional Type Parameters](#additional-positional-type-parameters)
  - [Only `Args`](#only-args)
  - [Naming](#naming)
    - [`Args`](#args-1)
    - [`Element`](#element-1)
    - [`Blocks`](#blocks-1)

## Motivation

When a developer goes to invoke a component in a template, there are a variety of questions about its interface they need to be able to answer in order to determine how to use it correctly.

1. What arguments does this component accept?
   - Which arguments are required and which are optional?
   - What does each argument do?
   - What types of values am I expected to pass for a given argument?
2. How can I nest content within this component?
   - Does it accept a default block? Named blocks?
   - In what context will my block content appear in the component's output?
   - For any blocks I write, what parameters does the component expose to them?
3. In what ways can I treat this component like a regular HTML/SVG element?
   - Can I pass attributes to it?
   - If I apply a modifier, what kind(s) of DOM `Element` object will the modifier see?

In the Glimmer `Component` base class today, a TypeScript component author can answer the first bucket of questions above by defining an `Args` type for the component class. Using this structured documentation, developer tooling can surface information about a component's arguments to consumers without requiring them to go read either ad-hoc prose or the implementation itself to determine the component's intended usage.

For the second and third sets of questions, however, there is no such affordance for providing structured answers.

The goal of this change is to enable tooling to provide a more complete picture for developers of the ways in which Glimmer components can be used. The word "tooling" here is used in broad terms, including:

 - API/design system documentation generators, like [Storybook] or [Hokulea]
 - Language servers that provide hover information, go-to-definition, etc. like [TypeScript] or [uELS]
 - Template-aware static analysis and typechecking systems, like [Glint] or [`els-addon-typed-templates`]

[Storybook]: https://storybook.js.org/
[Hokulea]: https://github.com/hokulea/hokulea
[TypeScript]: https://www.typescriptlang.org/
[uELS]: https://github.com/lifeart/ember-language-server
[Glint]: https://github.com/typed-ember/glint
[`els-addon-typed-templates`]: https://github.com/lifeart/els-addon-typed-templates


## Detailed design

This RFC proposes two new TypeScript APIs:

1. A fully general `InvokableComponentSignature` type which can capture *all* the relevant details of components in the Glimmer VM, with
2. A user-facing Glimmer Component `Signature` type that enables authors to answer the questions outlined above about their Glimmer components in a more concise and convenient way.

Throughout, these new interfaces intentionally use `PascalCase` for names representing *types*, including types nested in interfaces:

- to match the general TypeScript ecosystem norm that types are named in `PascalCase`
- to thereby distinguish clearly between type- and value- names in contexts which might otherwise be ambiguous
- ***to enable adopting this in a backwards-compatible way with the existing Glimmer Component type definition***

The third of these is the most critical, and much more strongly motivates the others.

These interfaces are *not* importable, because importing them does not give any value to consumers: use of `extends` does not add any constraints (because of the optional-ity discussed below).


### `InvokableComponentSignature`

The base `InvokableComponentSignature` type is an intentionally-verbose form, which end users will not *normally* write, but it is legal to do so.

Two points to notice about the signature:

1. All of the fields for what users author are optional. They are resolved into the appropriate *non*-optional representations by type machinery in Glint. For example, in a Glimmer component the `args` is never undefined; it is minimally an empty object.
2. This provides the foundation for further extensions of each of these as needed. For example, if we were to add support for named block params (in addition to today’s support for positional arguments), they could be added as a `Named` field in the interface, just like the `Positional` field present today.

```ts
// A base signature type which represents items which can be invoked with
// arguments, and could be reused for helpers, modifiers, etc.
interface InvokableSignature {
  Args?: {
    Named?: {
      [argName: string]: unknown;
    };
    Positional?: unknown[];
  };
}

interface InvokableComponentSignature extends InvokableSignature {
  // The `null` means "this does not use ...attributes"
  Element?: Element | null;
  Blocks?: {
    [blockName: string]: {
      Params?: {
        Positional?: unknown[];
      };
    }
  }
}

interface InvokableGlimmerComponentSignature extends InvokableComponentSignature {
  Args?: {
    Named?: {
      [argName: string]: unknown;
    };
    // empty tuple here means it does not allow *any* positional params
    Positional?: [];
  }
}
```

As suggested by this lattermost form, specific component implementations may also represent a *subset* of the full signature. Future component implementations may take advantage of this just as future extensions to the system may take advantage of the ability to add more information into the signature.


### `GlimmerComponentSignature`

Since the fully-expanded form is quite verbose, we also provide a much smaller interface users can write, which we expand “under the hood” into the full signature as well as onto the class body for `args`. Users are *allowed* to supply the fully-expanded form; they just do not *have* to.

```ts
interface GlimmerComponentSignature {
  Args?: {
    [argName: string]: unknown;
  };
  Blocks?: {
    [blockName: string]: unknown[];
  };
  Element?: Element | null;
}
```

As with the `InvokableComponentSignature`, the type that authors *must* write is simply empty: all the fields are optional. Once the type is attached to the component, it is resolved to the appropriate default value. For example, a component’s `args` property is *always* an object, but it may be empty. If `Args` is not supplied, it is defaulted the empty object. We cover the details of this defaulting behavior for each field below.


### Updated type for Glimmer `Component`

With these signature types defined, we can update the type for the Glimmer `Component` class in a backwards-compatible way:

- adding support for the new expanded type signature
- continuing to support all *current* uses of the type signature
- dropping the `extends` constraint, which provides little-to-no actual constraining value

Previously:

```ts
declare class Component<Args extends {} = {}> {
  readonly args: Args;

  constructor(owner: Owner, args: Args);
}
```

Updated:

```ts
declare class Component<Signature> {
  readonly args: ComponentArgs<Signature>;

  constructor(owner: Owner, args: ComponentArgs<Signature>);
}
```

Here, the `ComponentArgs` type will be a type utility which can resolve the named arguments to the component (the exact mechanics are an implementation detail, but you can see one possible design in [this playground][fully-working]). Users may pass any of:

- an arguments-only definition, as has been recommended up till now in the Glimmer Component v1 era
- the `GlimmerComponentSignature` short-hand form
- the expanded `InvokableGlimmerComponentSignature` form
- the fully-expanded `InvokableComponentSignature` form

[fully-working]: https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgUwB5mQYxgFQJ4YDyAZnAL5zFQQhwDkaG2AtDAcnQNwBQ3AJlgA2AQyjI4mCADsAzvACi4NgC44AVynAAjmvEy8IAEYRBPNhjiKwbQoYBWWeAF5EcANpW2AXQD8qmFC65Dzc5uIA4sgwhFDygjLIADy2dgA0cADS6QBiwoKChsKYANYAfHAuGSioMMhSfDJwxch4EKQpcD5wKW4ZXnCqufmFJSFhcACCUADmMtnQiQDK5S7NraSL1bX1jQBEU7O7cAA+cLtxyCB1MEenuwBCghAlMkcA9G9wAJKNMAAWwEawjgMmA0ykwhgajEPm4cE6ZwOry2dQaTRabTgmw+cAAIhBkL8AY1QeDIdDxH9hAA3cQAAyRdLgAmIwCkyD4sPh8K6izc+xmr36aG2aKQADlhFdOaoIPZHJw4AAFCCgmDAaR5PzqKTFKQQADuUjc-QoOKm4n+LTgTyk0yp9TgeTEwj4eC53J5rkl0tUkWisXiST5AsOXnSdB9HLo6U8eBSjlKipVao1EMEfqiMTiCSW-KRu3D9BTwHVmsEMfcXnKZDhnoG3qlHNUIYLXmTqtLabyqhN5Dr8NUEqbfFUcYT2A7qfLvdNdaHcCjo6xU67M6rwV4bwAVNu4OFgLSpE6pHgnflDRyQX9oP9hI7iNBaJjgaSIVCxOkBDI1NNRI1SzgGAIDgUtGmINR8mqMB7wEPggPYOBtzeUJEPkdBYMWMF3wpRIcBWRA6wuK4pBgVRzkES5riOEVUUaNZMRwBEcH5YjqP6VQpEg0w6yRVQkXmKA8KTOtHmeYoZHIsSXhomo6PRdY4BwAcEQQFTPTcaTilA48GNIFiHieGSvC8VQDK0oVNKM4phTknYdT1Q1jS8dT6y6JASzLdMzP5CzCys8S53resfMM8TLK09tXNrT0xyUeN5UnbgyBCHEAAFpkEUArigN5JHAaRrjgABGAA6AAGbg2VqKBiCKcRCEEPhFkwG8TCRQj4UfCBVDkKA2WmHha24HFdmENR-mgAbKCfSEjghaVmFEWZmGkQQ8Cq0jkFq+qsRvWAHT4JFCCkdbOsmQUFxU7reoCAaeHhWthpxWkoGMBJ0kMCabWQGlpogb7GCyzBAM87tBE2mq6swcQl2O06zzU+E+PO+ElyHVybpBO67Qe7kYv7Z7Ple97xAWjklsFVaEbgAAKOl0Jg+osLJD9kCZGQb0g+DDHEYF9QgMA4GkIDiQASkh7bofEbJuPhs6kYu2YMc9MH1xNPG0ZHFX6yxvr7pUgmUqIyiSLIuAuPyPGLLi6wEocJLhsYRx8CIYhEkZzDsPJMRkialq2sEJFSlKWmxdK4D5B0PJXeQEhEll-J5bwUOxZ4Z3sFj+PPeZ722aWfa73qZOQ7DiOICjtQY-YePE6DwUTvW1P0-QF2a-dnPmrz3C4YbhHS-DyPo8ELP3brkuw5bphcHbj2MNz1ncPHvum9T8vK+rt2E7lleU8nrdPjGib9umx8oBAObmWQOrIPgQxrOFhHJZ2mG9tvQ6LMbxHROsyTUavm+ghzZuCuDIGQwhpjIFuv1O0UVHrJQPnAEmqpxAsnGkAuA99xKPzOvTTuLMcJiA5lzJqmC+YWwgILR+otAQS2qlLXaddP400VmxUinFuJ4xRsOX0lh4oThgKuLyPYqyKmNvCG2-80G3x1qrTswiMzuD1jjaYcD8Z1mNk7VumdZ74O7r7RYhcP6-y-gPdew9R7b3yMwpu+8M4zy3noxevsmEmP7mvIeVcR6z1ceFUx+8RqH3GpNGB0wZrn0vsgU2RU1obXoS-cQhj36wTYdEFhJsqLsLgAACRwAAWQADIAGF7zUmEDIVJQ1EHIISCgaJpEcFnjwfPLuzj2bXgBqQ3mToKFUJFv8Whz9pZwDrqkr+51JHjkSoI3il1Gy8KmQ7QRyp5Hg1nJueEqTVC5MKSUqQZSKn1JmVo6elinGEODEYlJRzTEeIrhYnx3Exn9zsdohxccO4tIIT7JIoybnuLLp4zeHyrGCGebYtOiCIL5DPJAMAkFIQcnSNCs6jBYJXjfD8umDMvn6PaZzTpPNyECyFv08WQzdryFengAZdp7gQKiedbhKl0auGUaEjZ3I1beXcKWS4HCjDbTUeIywRztn5OKaU8plSf7hVkQA9B5tFZyOnDytwZTBC6F6gYYwggXKeiNgg7g9izm4raR7altLpj0sgYIMxQLvGOMtQCOlDK7UBPGEUmgkB2SkSREsAiAkFjLDcJGEcdAor8CEKIcQmARBgLgF6gqvqYABvOi6PgsSnRzKDUJENYbpQRqNXG8pjRGrNTYJRFE9kk0+uuH7ZqrVKH11mOURWkD4DdTDv-MQH5jwDJkKVZag7up4yerwEtCbxTIANIsSt4haI1u9YVUiBdknF13m2usHaZoQG7cquAvboT9uJEOwUpVR0aOSkAA


### Example

Given a component with this template:

```hbs
<div class="notice notice-{{@kind}}" ...attributes>
  {{yield this.dismiss}}
</div>
```

A TypeScript backing class currently written like this:

```ts
import Component from '@glimmer/component';

export interface NoticeArgs {
  /** The kind of message displayed in this notice. Defaults to `info`. */
  kind?: 'error' | 'warning' | 'info' | 'success';
}

export default class Notice extends Component<NoticeArgs> {
  // ...
}
```

Would instead, if fully typed, be written like this:

```ts
import Component from '@glimmer/component';

export interface NoticeSignature {
  Element: HTMLDivElement;
  Args: {
    /** The kind of message displayed in this notice. Defaults to `info`. */
    kind?: 'error' | 'warning' | 'info' | 'success';
  };
  /**
   * Any default block content will be displayed in the body of the notice.
   * This block receives a single `dismiss` parameter, which is an action
   * that can be used to dismiss the notice.
   */
  Blocks: {
    default: [dismiss: () => void];
  };
}

export default class Notice extends Component<NoticeSignature> {
  // ...
}
```

By nesting the existing `Args` type under a top-level _signature_ type, we create a place to provide additional type information for other aspects of a component's behavior. This, along with the fully-expanded/desugared form, is the key element of this design which enables future evolution of the signature, as including additional keys with new meaning won't be a breaking change.


### `Args`

The `Args` signature member works exactly as the top-level `Args` type parameter does in `@glimmer/component@1.x` prior to this RFC. That is, it determines the type of `this.args` in the component backing class, as well as acting as an anchor for human-readable documentation for specific arguments.

**A signature with no `Args` indicates that its component does not accept any arguments. The type of the `args` field on a Glimmer component class is an empty object.**


### `Blocks`

The `Blocks` member dictates what blocks a component accepts and specifies what parameters, if any, it provides to those blocks. All blocks must named explicitly.[^blocks-sugar] When the component only yields to the default block, simply name the `default` block:

```ts
Blocks: {
  default: [name: string];
}
```

```hbs
{{yield "Tomster"}}
```

When there are multiple blocks, each is named to indicate what parameters a component's named blocks provide:

```ts
Blocks: {
  header: [];
  body: [item: T; index: number]
}
```

```hbs
{{yield to="header"}}

{{#each items as |item index|}}
  {{yield item index to="body"}}
{{/each}}
```

This means that if a component also accepts both a default block _and_ other named blocks, it can specify the default block by name (`default: [...]`) in its `Blocks` in exactly the same way a consumer of the component might use `<:default>` to pass a default block alongside named ones when invoking a component.

**A signature with no `Blocks` indicates that its component never yields to any blocks.**

The [yieldable named blocks RFC] and recent versions of the [Component guides] discuss blocks in some depth, but since named blocks in particular are relatively new to the community, brief definitions based on those in [RFC 678] are included here for clarity.

[yieldable named blocks RFC]: https://github.com/emberjs/rfcs/blob/master/text/0460-yieldable-named-blocks.md
[Component guides]: https://guides.emberjs.com/release/components/block-content/
[RFC 678]: https://github.com/emberjs/rfcs/pull/678

<details>
  <summary>Blocks, Block Parameters and Yielding</summary>

  - **Block**

    A block is a section of content that a template author provides to a component when invoking it. Many components accept a _default_ block, and components invoked using curly braces may also accept an _else_ block.

    ```hbs
    <Modal>
      This is a default block.
    </Modal>

    {{#if-a-coin-flip-is-heads}}
      This is also a default block.
    {{else}}
      This is an else block.
    {{/if-a-coin-flip-is-heads}}
    ```

    For angle-bracket components, the above example with an _implicit_ default block could also be written with an _explicit_ one:

    ```hbs
    <Modal>
      <:default>This is another default block.</:default>
    </Modal>
    ```

    This syntax, using `<:identifier>` to delimit block contents, allows authors to provide one or more _named blocks_ to a component:

    ```hbs
    <Modal>
      <:header>
        This is the header block.
      </:header>
      <:body>
        This is the body block.
      </:body>
    </Modal>
    ```

  - **Block Parameters**

    Blocks may also receive _parameters_ from the component that they're provided to, using `as |identifier ...|` syntax.

    For an implicit default block, the parameters are exposed from the top level component:

    ```hbs
    <Modal as |close|>
      <button {{on "click" close}}>Close</button>
    </Modal>
    ```

    For named blocks, different parameters may be exposed individually to each block:

    ```hbs
    <Modal>
      <:header>Close me</:header>
      <:body as |close|>
        <button {{on "click" close}}>Click!</button>
      </:body>
    </Modal>
    ```

  - **Yield**

    Yielding is how a component invokes a provided block, optionally exposing block parameters. An example from [RFC 460](https://emberjs.github.io/rfcs/0460-yieldable-named-blocks.html#block-parameters):

     ```hbs
     <article>
       <header>{{yield @article.title to='header'}}</header>
       <section>{{yield @article.body to='body'}}</section>
     </article>
     ```
</details>

The `Blocks` type maps the block names a component accepts to a tuple type representing the parameters those blocks will receive.

As a concrete example, the `BlogPost` component in the [Block Parameters section] of the Ember guides looks like this:

[Block Parameters section]: https://guides.emberjs.com/release/components/block-content/#toc_block-parameters

```hbs
{{yield @post.title @post.author @post.body}}
```

```hbs
<!-- usage -->
<BlogPost @post={{@blogPost}} as |postTitle postAuthor postBody|>
  <img alt="" role="presentation" src="./blog-logo.png">

  {{postTitle}}

  {{postBody}}

  <AuthorBio @author={{postAuthor}} />
</BlogPost>
```

The signature for this component might look like:

```ts
export interface BlogPostSignature {
  Args: { post: Post };
  Blocks: {
    default: [postTitle: string, postAuthor: string, postBody: string];
  };
}
```

Block parameters may also depend on the types of args a component receives. For example, for a fancy table component:

```hbs
<FancyTable @items={{this.people}}>
  <:header>
    <td>Name</td>
    <td>Age</td>
  </:header>

  <:row as |person|>
    <td>{{person.name}}</td>
    <td>{{person.age}}</td>
  </:row>
</FancyTable>
```

The backing class and signature might look something like:

```ts
export interface FancyTableSignature<T> {
  Args: {
    /** The items to be displayed in the fancy table, each corresponding to one row. */
    items: Array<T>
  };
  Blocks: {
    /** Any header contents for the table, broken into cells. */
    header: [];

    /** Content to be rendered for each row, receiving the corresponding item and its index. */
    row: [item: T, index: number];
  };
}

export default class FancyTable<T> extends Component<FancyTableSignature<T>> {
  // ...
}
```

While the runtime design of named blocks currently only permits components to yield parameters out to them, community members have suggested possible ways of making blocks more akin to components themselves, potentially accepting `@args` or attributes, or even themselves accepting further nested blocks. Should such a design ever become reality, the shape of a signature might evolve to become more recursive. Today, however, there are many open questions about how such functionality would actually work for authors, and so we keep the proposed format here simple.

[^blocks-sugar]: We recognize that it might be desirable to have a shorthand for the very common case of having a single default block. However, none of the designs we have seen so far are satisfactory across the board in terms of teaching and mental model, so we are using this expanded form which *does* satisfy those constraints. Over time, we hope to come up with a nice bit of “sugar” that works there, but we are not *blocked* on finding that sugar.


### `Element`

The `Element` member of the signature declares what type of DOM element(s), if any, this component may be treated as encapsulating. That is, setting a non-`null` type for this member declares that this component may have HTML attributes applied to it, and that type reflects the type of DOM `Element` object any modifiers applied to the component will receive when they execute.

**A signature with no `Element` or with `Element: null` indicates that its component does not accept HTML attributes and modifiers at all.** While applying attributes or modifiers to such a component wouldn't produce a runtime error, it still likely constitutes a mistake on the author's part, similar to [passing an unknown key in an object literal][ecp].

For example, [`{{animated-if}}`] would omit `Element` from its signature, as it emits no DOM content. Even if you invoked it with angle-bracket syntax, any attributes or modifiers you applied wouldn't go anywhere.

On the other hand, [`<ResponsiveImage>`] would set `Element: HTMLImageElement`, as the element in its template that it ultimately spreads `...attributes` on to is an `<img>`.

[`{{animated-if}}`]: https://ember-animation.github.io/ember-animated/docs/api/components/animated-if
[`<ResponsiveImage>`]: https://github.com/kaliber5/ember-responsive-image#the-responsiveimage-component

The `Element` member is of particular relevance for the modifiers that consumers can apply to a component. In a system using this information to provide typechecking, any modifiers applied to its component must be declared to accept the component's `Element` type (or a broader type) as its first parameter, or else produce a type error.

- A component with `Element: Element` can only be used with modifiers that accept _any_ DOM element. Many existing modifiers in the ecosystem, such as `{{on}}` and everything in `ember-render-modifiers`, fall into this bucket.

- A component with e.g. `Element: HTMLCanvasElement`, may be used with any general-purpose modifiers as described above _as well as_ any modifiers that specifically expect to be attached to a `<canvas>`.

- A component whose `Element` type is a [union of multiple possible elements](#components-with-multiple-or-varying-elements) can only be used with a modifier that is declared to accept _all_ of those element types. This behavior is, in fact, the point—modifiers are essentially callbacks that receive the element they're attached to, and so the [normal considerations][variance] for typing callback parameters apply.

[ecp]: https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks
[variance]: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)

#### Components With Multiple or Varying Elements

While it's not common, occasionally components might forward `...attributes` to different types of elements in their template:

```hbs
{{#if @destination}}
  <a ...attributes href={{@destination}}>{{yield}}</a>
{{else}}
  <span ...attributes>{{yield}}</span>
{{/if}}
```

For such cases, components can use a union type for their `Element`. In the case of the template above, the signature would have `Element: HTMLAnchorElement | HTMLSpanElement`. Correspondingly, any modifiers used with such components would need to accept any of the possible types of DOM elements declared.

Similarly, a component that may use `...attributes` on an `<a>` element or may not spread them at all might write: `Element: HTMLAnchorElement | null`. In such cases, ecosystem tooling consuming this type information should treat it as legal to use any modifiers that accept an `HTMLAnchorElement`, since they wouldn't ever be invoked for the `null` scenario.

In cases where the distinction between possible elements is key to the functionality of the component and can be statically known based on the arguments passed in, the component author may choose to capture this as part of the signature at the expense of additional type-level bookkeeping.

<details><summary>Gritty details</summary>

The particular shape/value of arguments is something that varies from instance to instance of the component, and the standard tool in TypeScript for handling these cases is to introduce a _type parameter_ on the type(s) in question.

For the `{{#if @destination}}` example above, the implementation might look like this:

```ts
interface MaybeLinkSignature<Destination extends string | undefined> {
  Args: {
    destination: Destination;
    target?: string;
  };
  Blocks: {
    default: []
  };
  Element: Destination extends string
    ? HTMLAnchorElement
    : HTMLSpanElement;
}

export default class MaybeLink<Destination extends string | undefined>
  extends Component<MaybeLinkSignature<Destination>> {
  // ...
}
```

This would allow consumers to use a modifier that requires an `HTMLAnchorElement` on a `MaybeLink` if and only if the `@destination` arg they pass is definitely a string.

Note, still, that general-purpose modifiers like `{{on}}` or `{{did-insert}}` would be usable with this component regardless of the type of `@destination`, or even if the author had simply typed `Element` as `HTMLAnchorElement | HTMLSpanElement` without the extra song-and-dance of explicitly capturing the `Destination` type.

Finally, template analysis tools can provide escape hatches in the same vein as TypeScript's `@ts-ignore` and `@ts-expect-error` for these or any cases where consumers have information that library authors haven't encoded in the type system.
</details>


## How we teach this

### Documentation

Ember is [in the midst](https://github.com/emberjs/rfcs/pull/724) of [adding official supported for TypeScript](https://github.com/emberjs/rfcs/pull/800), and as such none of the framework guides or API documentation mention the existing `Args` type parameter today. The upshot of this is that, while the `Args` type parameter is well known by the portion of the Ember community that works with TypeScript, there's no official documentation to be updated.

The [`ember-cli-typescript` website], however, does have a section on working with components in TypeScript that deals almost exclusively with the `Args` parameter and `this.args` on the backing class. We should update and expand this documentation to cover the other concepts included in the `Signature` type.

[`ember-cli-typescript` website]: https://docs.ember-cli-typescript.com/ember/components#understanding-args

When we add sections documenting the use of TypeScript to the official guides, add type information to the API docs, and and so on, we will migrate that discussion from the `ember-cli-typescript` documentation into the main site documentation.

Glint and its current documentation currently use earlier names and structures for the basic ideas in this signature, and will be updated to match this spec.


### Migration

As noted in [**Detailed Design**](#detailed-design), we can implement this change in `@glimmer/component` 1.x in a backwards compatible way, allowing for a deprecation period before moving exclusively to the signature approach in 2.0. Because capitalized arg names are currently illegal, any valid signature will not represent valid arg names, so the backing class can [accept both formats](https://tsplay.dev/Nr2rzN) and distinguish which was intended.

Ideally we'll be able to encourage authors to migrate their usage of `Args` in the same ways they're used to being nudged to move away from other deprecated APIs in the Ember ecosystem.


#### Codemods

A simple codemod to turn `Component<MyArgs>` into `Component<{ Args: MyArgs }>` would be straightforward, but it may also be feasible to migrate more completely by inferring information like block names and where `...splattributes` are used from colocated templates. The richness we pursue here will likely depend on the appetite of the community to explore what's possible.


#### Deprecation Warnings/Linting

While type-only deprecations aren't something the Ember ecosystem has dealt with much previously, it's a muscle we may want to begin building as [official TypeScript support] is under consideration.

The `@typescript-eslint` suite of packages supports writing [type-aware rules] in projects that provide appropriate configuration in their `eslintrc`, so one option available to use would be to use that functionality to allow users to lint for components that haven't yet been migrated to use a signature type. We could expose this as part of a standalone ESLint plugin, or perhaps make it available on an opt-in basis in `eslint-plugin-ember`.

[official TypeScript support]: https://github.com/emberjs/rfcs/pull/724
[type-aware rules]: https://github.com/typescript-eslint/typescript-eslint#can-we-write-rules-which-leverage-type-information


## Drawbacks

As with any change that deprecates supported behavior, there's an inherent cost associated with migrating the user base over to new patterns. One goal of this change, however, is to ease such migrations in the future: as the templating system evolves and new information becomes relevant to capture and document, the `Signature` type provides a place for that information to live without disrupting existing code.

The other potential drawback to this approach is that it introduces TypeScript type information that has no visible effect on the component using out-of-the-box tooling. Without a template-aware system like Glint or `els-addon-typed-templates` for validating components, nothing enforces that the signature declared is actually accurate. See the "Only `Args`" section under Alternatives below for further discussion of this point.


## Alternatives

### Additional Positional Type Parameters

Rather than wrapping the information we're interested in capturing in a `Signature` type, we could instead introduce further type parameters to the `Component` base class:

```ts
class Component<Args = {}, Blocks = {}, Element = null> {
  // ...
}
```

This has the advantage of not requiring current users of the `Args` parameter to change their code, but suffers many of the same ergonomic issues as regular functions do when they begin to accrue many positional parameters. Authors need to remember which parameters appear in which order when using the `Component` type, and they need to be aware of the appropriate default values for earlier parameters to fill in when they only want to specify a later one.


### Only `Args`

One of the drawbacks mentioned above is that the `Element` and `Blocks` signature members described in this RFC are functionally inert in a vanilla TypeScript project. This leaves them with about the same status as comments: potentially helpful when left by a well-meaning author, but without any checks to ensure that they're accurate and that they stay up-to-date as the implementation changes.

An alternative would be to still introduce the `Signature` type in `@glimmer/component` but _only_ formalize the `Args` member, leaving other tooling to define the semantics of any additional signature members they might be interested in. While this would simplify the overall proposal somewhat, what a component `{{yield}}`s and what it does with its `...attributes` are core enough to a component's public interface that we believe they should be considered first-class rather than having individual tools reinvent them, potentially in mutually-incompatible ways.


### Naming

The `Signature` concept itself has been [used in Glint] and broadly well received and understood, but the naming of each of the three member elements has received some discussion. While the names proposed above are what we currently believe to be best suited from both pedagogical and API-consistency perspectives, there are alternatives we could choose (and have explored).

[used in Glint]: https://github.com/typed-ember/glint#component-signatures


#### `Args`

Early discussions have largely been on board with `Args` as it stands, though the non-abbreviated option `Arguments` has been suggested as an alternative. Since `Args` aligns better with `this.args` on the backing class (as well as the way in which people often colloquially discuss `@arg` values), we're continuing to propose `Args` here.


#### `Element`

Among early adopters of Glint there has been some confusion as to what the purpose of this key is. Generally "it's the concrete place your `...attributes` ultimately land after being passed down through components" has worked as an explainer, but the fact that an explainer is needed may indicate that `Element` isn't a clear name on its own.

That said, even among those who were initially unclear what the purpose of `Element` was, no one has been able to come up with an alternative proposal. Attempts at more explicit formulations like `UltimateSplattributesTarget` don't quite roll off the tongue 🙂


#### `Blocks`

This key has easily been the largest topic of discussion among the three `Signature` members. Currently Glint uses `Yields` for this concept, but developers have given consistent feedback that that doesn't fit with `Args` and `Element` in their mental model. Moreover, the Framework team noted that it also doesn’t match with hoped-for iterations on the mental model after Polaris, where the notion of “yielding” (largely a holdover from Ember’s roots with many of its designers coming from the Ruby world) is less prominent or removed entirely in favor of new language/concepts.

An earlier draft also used `BlockParams`, but that was not readily extensible to capture future information about blocks. Since Blocks are the chunks of content passed _in_ to a component by the author invoking it, while this signature member captures what parameters (if any) the component will pass _out_ to those blocks, we also did not want to support a shorthand like `Blocks: []`, which could very easily be misread as “there are no blocks” instead of “there is a default block which yields no params”.


---

---
stage: recommended
start-date: 2021-05-26T00:00:00.000Z
release-date: 2021-11-15T00:00:00.000Z
release-versions:
  ember-source: v4.0.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/750
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Deprecate Ember.assign

## Summary

Now that Ember is dropping support for IE11, we no longer need `Ember.assign` as a polyfill since `Object.assign`
is available in all browsers that Ember v4.x supports ([CanIUse](https://caniuse.com/mdn-javascript_builtins_object_assign), [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#browser_compatibility)).

## Motivation

The polyfill is no longer necessary, as well as being another Emberism that can be removed. Apps and addons can use `Object.assign` or object destructuring depending on their browser support targets.

## Transition Path

The transition path is relatively simple: apps that use Ember 4.x will replace `Ember.assign` with `Object.assign`, and apps and addons that use or support Ember 3.x can continue to use the polyfill if needed.

ex:
```
import { assign as emberAssign } from '@ember/polyfills';

const assign = Object.assign || emberAssign;
```

## How We Teach This

A descriptive deprecation message alerting a developer that `Ember.assign` is deprecated and can be replaced with `Object.assign`.

## Drawbacks

The only drawback is replacing the polyfill assign with the native assign, but there is minimal effort to do this.

## Alternatives

Doing nothing.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2021-06-10T00:00:00.000Z
release-date: 2021-12-28T00:00:00.000Z
release-versions:
  ember-source: v4.1.0

teams:
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/752
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Rename `inject` import to `service`

## Summary

Currently, in order to use a service in any framework class you can do it like this:

```js
import { inject } from '@ember/service';

export class MyComponent extends Component {
  @inject router;
}
```

However, it is very common to actually alias this import to `service`, like this:

```js
import { inject as service } from '@ember/service';

export class MyComponent extends Component {
  @service router;
}
```

This RFC proposes to actually provide this as a `service` import directly.


## Motivation

You cannot properly/easily use editor autocompletion to import `@service`.

Even in the guides, `inject` is aliased to `service` (see: https://guides.emberjs.com/release/services/#toc_accessing-services)

Finally, there is also an `inject` export from `@ember/controller`, which is also a possible source of confusion.

By exporting this directly as `service`, this would be streamlined:

```js
import { service } from '@ember/service';

export class MyComponent extends Component {
  @service router;
}
```

## Detailed design

We add an export `service` from the `@ember/service` package with the semantics
of `inject`.

Import of `inject` itself will be deprecated targeting Ember 5.0 for removal,
and the app blueprint will be updated as soon as possible to the new API.

Addons will likely want to support the legacy API for a long time, especially
if the legacy API is not deprecated in Ember 4.0.0. The addon blueprint and
best practice should be to:

```js
import * as ES from '@ember/service';
const service = ES.service ?? ES.inject;
```

Then use `service` for injections.

## How we teach this

The docs should be updated to directly import `import { service } from '@ember/service';`.

## Drawbacks

It might be considered churn. However, we could probably provide a codemod to
automatically rename the imports, lessening the churn.

Addons will need to live with a degraded injection API for a long time, if they
want to support both versions.

## Alternatives

We could leave the import as it is, continuing to suggest people rename the import to `service`.

Or we could stop suggesting the import and push for the community to simply use `@inject myService`.

We could also choose a different name for the import (e.g. `injectService` or something like this).

## Unresolved questions


---

---
stage: recommended
start-date: 2021-05-17T00:00:00.000Z
release-date: 2022-05-13T00:00:00.000Z
release-versions:
  ember-source: v4.5.0
teams:
  - framework
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/756'
  recommended: 'https://github.com/emberjs/rfcs/pull/866'
project-link:
---

# Default Helper Manager

## Summary

Anything that can be in a template has its lifecycle managed by the manager pattern.
Today, we have known managers for `@glimmer/component`, `@ember/helper`, etc.
But what happens when the VM encounters an object for which there is no manager?,
such as a plain function? This RFC proposes a default behavior for
those unknown scenarios when it comes to _helpers_.

## Motivation

The addon, [ember-could-get-used-to-this](https://github.com/pzuraq/ember-could-get-used-to-this)
demonstrated that it's possible to use plain functions for helpers and modifiers.
And since Ember 3.25, helpers can be invoked directly from value references, this opened
a whole new world of ergonomics improvements where a dev could define a function in a
component class and use that function **as** a helper, thanks to
ember-could-get-used-to-this implementing a Helper Manager that knew what to do with plain functions.

This has the impact of greatly reducing mental overhead around helpers for app and addon authors, in that,
folks no longer need to jump over to the app/addon helpers directory to create a helper
"just to do this one simple thing". It's all now `{{this.myHelper}}` or `{{this.myModifier}}`.

The introduction of a plain-function helper-manager is important because over the past several years,
we've seen on numerous occasion, folks new to Ember inherently expect that plain functions work in templates.

Example:

```js
import Component from '@glimmer/component';
import { setComponentTemplate } from '@ember/component';
import { hbs } from 'ember-cli-htmlbars';

export default class Example extends Component {
  double = num => num * 2;
}
```
```hbs
{{this.double 2}} => prints 4
<SomeComponent @foo={{this.double 2}} /> => @foo === 4
```


A default modifier manager will be covered in a different RFC.

## Detailed design

_A Default Manager is not something that can be chosen by the user, but is baked in to the framework
as a default so that a user doesn't have to build something to use a non-framework-specific variant
of the three constructs: Helpers, Modifiers, and Components._

The desired usage of a plain function in a template should be:
 - convenient
 - reduce boilerplate
 - be easily portable to JS for developers' mental model of how template and JS interact
 - support normal JavaScript idioms and existing JavaScript functions (from lodash, etc).

Which results in:
 - default to positional parameters
 - all named arguments are grouped into an "options object" as the last parameter.
   this happens to align with the _syntax_ of helper invocation where named arguments may not appear
   before the last positional argument.
 - if no named arguments are passed in the template, no "options object" is passed to the JS call.

#### Example with mixed params

```hbs
{{this.calculate 1 2 op="add"}}
```
would be an example invocation of a function with the following signature
expressed as TypeScript for clarity:
```ts
type Options = { op: 'add' | 'subtract' }
class A {
  calculate(first: number, second: number, options: Options) {
    // ...
  }
}
```
for unknown amounts of parameters, the [typescript can be awkward](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMJwDYIK4bpAeQAcxgB7EAZ2QG8AoZR5MogLmQHI4ATbj5AD6dK2AEYcA3HQC+dMAE8iKdFlz4IAQSgBzagF5kAbQB0pkNgC2o6IYC6AGjSYceQiXJVbUujGwgEpBTICM5qkAAUpsZwOpTsKi7qWroAlLQMyBgQYMzuFPrIMbrGRCzhaXDUCWEQxIFUUoxZOeYWBUXUlcit1lB23owI+WRZxhhk2uE0ufWUjq3U0ilSsj5+AR7Boa4QAEyRph3x20mxafRN2UYss45RUBAAbtCUENy2yAYdxg-PUK-lRqZK4LT7IX4vN4-J6QwF0DJDKgjCBjCZTGYeObdSyLZYyeHwoA),

but there is a [TC39 proposal: proposal-deiter](https://github.com/tc39/proposal-deiter) that could make
destructuring simpler and inlined to
```ts
  calculate(...numbers: number[], options: Options) {
```

#### Example with only positional parameters

```hbs
{{this.add 1 2 3 4}}
```
Because there are no named arguments passed in, the method signature can be simple:
```js
class A {
  add(...numbers: number[]) {
    // ...
  }
}
```

#### Example with consuming tracked data defined outside of the helper

This works with the `helper` and `Helper` from `@ember/component/helper`, as well as plain functions.

```hbs
<output>{{this.multiply 4}}</output>

<button {{on 'click' this.increment}}>Increment</button>
```
```js
class A {
  @tracked multiplicand = 5;

  multiply = (passed) => passed * this.multiplicand;

  increment = () => this.multiplicand++;
}
```
When the button is clicked, the text in `<output>` will update, even though the `multiplicand` is not passed to the helper.

#### Example Default Helper Implementation

The implementation for the this function-handling helper-manager could look like this:
```ts
import {
  setHelperManager,
  capabilities as helperCapabilities,
} from '@ember/helper';
import { assert } from '@ember/debug';

class FunctionHelperManager {
  capabilities = helperCapabilities('3.23', {
    hasValue: true,
  });

  createHelper(fn, args) {
    return { fn, args };
  }

  getValue({ fn, args }) {
    let argsForFn = args.positional;

    if (Object.keys(args.named).length > 0) {
      argsForFn.push(args.named);
    }

    return fn(...argsForFn);
  }

  getDebugName(fn) {
    return fn.name || '(anonymous function)';
  }
}

const DEFAULT_HELPER_MANAGER = new FunctionHelperManager();

// side-effect -- this file needs to be imported for the helper manager to be installed
setHelperManager(() => DEFAULT_HELPER_MANAGER, Function.prototype);
```

- when the "helper" is created, the function is not invoked
- when `getValue` is invoked,
  - the function is invoked with the named arguments all grouped into an object in the last arg ("options object")
  - ~~if no named arguments are given, an empty object is used instead to allow less nullish checking in userland~~ (see notes below)
  - if no named are passed, the "options object" argument is omitted
- to register this helper manager, it should occur during app boot so developers do not need to import anything to
  trigger the `setHelperManager` call

##### Notes regarding the "options object" argument

An earlier version of this RFC initially proposed an "options object" with always be passed
as the argument, even when no-named arguments are passed. During [implementation](https://github.com/glimmerjs/glimmer-vm/pull/1348)
this was observed to be problematic.

For instance, given the following JavaScript function:

```js
function sum(...values) {
  let total = 0;

  for (let value of values) {
    total += value;
  }

  return total;
}
```

In the original proposal, an invocation like `{{sum 1 2 3}}` would result in the JS call
`sum(1, 2, 3, {})`, which would yield surprising and incorrect result.

Another case where this matters is with default arguments:

```js
function formatDate(date, formatString = "DD MM YYYY hh:mm:ss") {
  return ...;
}
```

In the original proposal, an invocation like `{{formatDate this.now}}` would result in the
JS call `formatDate(this.now, {})`, which has the effect of overriding the default argument
`formatString` with an empty object, also leading to surprising and incorrect behavior.

Given the goal of the RFC is to support normal JavaScript idioms and the ability to use a
large variety of existing JavaScript functions (from packages like lodash) directly in the
template, the proposal is updated to only pass the "options object" when necessary.

This has the drawback of an arguably less consistent signature. However, in practice, this
did not appear to be a issue. Base on the semantics and idioms of JavaScript, it is quite
rare for functions to mix-and-match variable positional arguments or defaulting of positional
arguments together with "named arguments" ("option object") in a way that would conflict with
what the updated proposal. Notably, JavaScript does not support `myFunc(...args, options)` in
the syntax, and functions with these kind of signatures already needs to manually introspect
the arguments carefully, in ways that should be compatible with the current proposal.

### Updating highlevel manager choosing algorithm

This is the existing manager chooser algorithm, but with extra additions required by this RFC (notated by `-->`).

- if inside element space
    - use `getModifierManager`
- if inside document body space using curly invocation
    1. attempt lookup via `getComponentManager` and invoke it
    2. attempt lookup via `getHelperManager` and invoke it
    3. `-->` if function, fallback to this RFC's default manager
    4. render, e.g.: `[Object object]`, for objects
- if inside document body space using angle invocation
    - attempt to lookup via `getComponentManager` and invoke it
- if inside of a subexpression's "head" (e.g. `PathExpression`) position
    1. attempt to lookup via `getHelperManager` and invoke it
    2. `-->` if function, fallback to this RFC's default manager
    3. error
- if inside of a subexpression arguments
    - pass the value

### How a template syntax plays in to this behavior

In the current state of templates there is some ambiguity in syntax around helper/component invocation invocation.
Below is a list exploring the various syntaxes and how the code implemented in the framework for this RFC
will react to various passed value/function/etc types. All of this is current behavior and this RFC is not proposing
a syntax change. In template strict mode, there is no ambiguity to worry about.

- `{{val}}`
  - `typeof val === 'function'`: Helper, invoked
    - presently, it's possible to have curly components use this syntax as well. By defining this as a helper,
      there is a possibility of confusion as the manager choosing algorithm will select a component before it selects a helper
      when using curlies.
    - because angle-bracket invocation is the generally accepted way to invoke a component,
      this may be an acceptable trade-off
  - `typeof val === 'object'`: Value, rendered
  - `val instanceof AnyClass`: Value, rendered
    - Today, classes are `.toString()`'d, but it's feasible that one could define their own
      custom helper manager or component manager to do something different.
- `{{ (val) }}`
  - `typeof val === 'function'`: Helper, existing behavior
  - `typeof val === 'object'`: Expected Helper error, no manager found
  - `val instanceof AnyClass`: Expected Helper, no manager found
- `{{val arg}}`
  - `typeof val === 'function'`: Helper, existing behavior
    - Similar to `{{val}}`, it is possible today to define a component manager that takes positional args that
      would be invoked with this syntax.
  - `typeof val === 'object'`: Expected Helper error
  - `val instanceof AnyClass`: Expected Helper, no manager found
- `<Component @arg={{val arg}} />`
  - `typeof val === 'function'`: Helper, existing behavior
  - `typeof val === 'object'`: Expected Helper error
  - `val instanceof AnyClass`: Expected Helper, no manager found
- `<Component @arg={{val}} />`
  - `typeof val === 'function'`: Value
    - if this were to evaluate as a helper it would break existing behavior where you may be
      passing an event handler to the component
    - another consequence of evaluating `val` as a helper and invoking it is that it would be
      more likely to cause an infinite revalidation assertion, which at present, would be hard
      to track down the source of, but may be an option if the VM one day has an equivalent to
      React's ErrorBoundary
    - if someone wanted to invoke `val` as a helper when passed as an argument, they would need to
      add surrounding `()`, example: `<Component @arg={{ (val) }}` />
  - `typeof val === 'object'`: Passed as argument to the component
  - `val instanceof AnyClass`: Passed as argument to the component
- `<Component @arg={{val 1}} />`
  - `typeof val === 'function'`: Helper, existing behavior
    - another consequence of evaluating `val` as a helper and invoking it is that it would be
      more likely to cause an infinite revalidation assertion, which at present, would be hard
      to track down the source of, but may be an option if the VM one day has an equivalent to
      React's ErrorBoundary
  - `typeof val === 'object'`: Expected Helper error
  - `val instanceof AnyClass`: Expected Helper, no manager found
- `<Component @arg={{ (val 1) }} />`
  - `typeof val === 'function'`: Helper, existing behavior
  - `typeof val === 'object'`: Expected Helper error
  - `val instanceof AnyClass`: Expected Helper, no manager found

## How we teach this

On the [Helper Functions](https://guides.emberjs.com/v3.26.0/components/helper-functions/) page,
We'll want to insert a section early on about how helpers can be "local" to or defined on
components and controllers. Then, once there have been examples of the local/private helper,
the existing content can continue to talk about the "global helper" -- explicitly differentiating
between the local/private helper, rather then retaining the general "Helper Function" title as
"Helper Functions" are all of these, rather than just the globally defines ones.

Existing users of Ember should be made aware of these capabilities, once implemented, via
the release blog post, with some examples -- but folks watching developments in the ecosystem
will likely be aware of ember-could-get-used-to-this, which implement
some parts of this RFC, so the migration path for users of ember-could-get-used-to-this should
be straight-forward.  That addon _may_ want to deprecate their similar functionality after
the proposed behavior here lands -- though, this RFC suggests implementation such that developers
may still use ember-could-get-used-to-this without disruption.


## Drawbacks

There would no longer be a possibility of using functions as components when invoked with curlies.
Angle bracket function components would still be possible.

There could be some awkwardness around the last argument passed to the function, as the
type signature may not match how the call-site expects the signature to be.
Projects like [Glint](https://github.com/typed-ember/glint#readme) would be essential for
helping with clarity here.

The difference between `<Component @handler={{this.handler}} />` and `<Component @handler={{this.handler 1}} />`
could awkward for folks, as the syntax says that a value _always_ passes
a value, _unless_ there are arguments added within the curly braces, in which `this.handler` is invoked
and the return value is instead passed as `@handler`. This could lead to infinite revalidation assertions,
which, without an ErrorBoundary (from React) and Error messages that show the location in the template
where an error originates from, would be fairly hard to track down. The problem goes away entirely in
template strict mode, so it may not be something we want to worry about in the short-term (outside of
documenting the possibility and what to do when the situation occurs)

## Alternatives

Class-based default helpers would allow greater flexibility for creating helpers, but would also
perpetuate the current problem of most surprise when trying to invoke functions from defined outside
of ember within templates (such as XState's state.matches function).

## Unresolved questions

TBD


---

---
stage: accepted
start-date: 2021-08-13T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/763
project-link:
suite:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->



# Asset Import Spec

## Summary

This RFC defines standard semantics for what it means to depend on files that are not JavaScript or CSS, like images, fonts, and other media. It proposes that when your code needs to refer to an asset, you use `import.meta.resolve` which returns a string that can be used to fetch the asset.

```js
class extends Component {
  myImage = import.meta.resolve('./hello.png');
}
```
```hbs
<img src={{this.myImage}} />
```

## Motivation

Apps and addons often need to refer to images, fonts, etc from within their JS, HBS, CSS, or HTML files. These references need to remain correct even as both the referring file and the referred-to file go through a build that might include fingerprinting and optimization.

Today, the ecosystem mostly relies on [broccoli-asset-rev](https://github.com/ember-cli/broccoli-asset-rev). But broccoli-asset-rev has some major architectural problems and it doesn't take advantage of the newer capabilities we have in ember-auto-import and embroider.

The biggest problem with broccoli-asset-rev is that it cannot achieve full correctness because it tries to detect inter-file references within arbitrary source code that is not statically analyzable. It's easy to accidentally refactor working code into code that works in development and test and then fails in production! For example, assuming broccoli-asset-rev is configured to fingerprint PNG assets, this refactor will look correct until you get into production and then have broken images:

```diff
class extends Component {
-  iconURL = "/icons/happy.png"
+  get iconURL() {
+    return `/icons/${this.args.emotion}.png`
+  }
}
```

The regular expressions that broccoli-asset-rev uses to do reference rewriting are effectively un-editable at this point. Any possible change you'd make to them breaks somebody's app.

Another problem with broccoli-asset-rev is that it's "push based", meaning it handles files because they exist, rather than handling files because somebody is actually consuming them. It can't detect unused assets and it can't detect missing assets at build time. It exposes the underlying implementation of how assets get delivered, making it hard to change later without breaking app code.

And because broccoli-asset-rev exposes assumptions about the exact layout of the final build output, it's not compatible with Embroider. Embroider allows different JavaScript packagers to optimize the app delivery in any spec-compliant way. For example, small images might get inlined as `data:` URIs, CSS `@import()` might get inlined or not, etc. All these concerns really need to be integrated into the JavaScript packager, because asset handling affects app-wide hashing & fingerprinting.

In contrast, a pull-based design that lets code declare what assets it needs and then not worry about how those assets will get delivered is safer and easier to change in the future.

## Detailed design

Inter-file references take many forms. Here is a guide to inter-file references organized by which kind of file is doing the referring ("From Type") and which type of file it's referring to ("To Type"). Only the row containing **Proposed** is new in this RFC:

From Type | To Type | Example Syntax | Semantics
--------------------|-----------------------|--------|---
JS | JS | `import { stuff } from 'thing';`| ECMA with NodeJS resolving rules
JS | CSS | `import 'thing/style.css';` | [Embroider Spec CSS Rule](https://github.com/emberjs/rfcs/blob/master/text/0507-embroider-v2-package-format.md#css) (1)
JS| Any Asset | `import.meta.resolve('thing/icon.png');`| **Proposed** URL Rule (2)
CSS | CSS | `@import("thing/style.css")` | [W3C](https://drafts.csswg.org/css-cascade/#at-import) plus NodeJS resolving rules
CSS | Other | `url("thing/icon.png");` | W3C plus NodeJS resolving rules
HTML | JS | `<script src="./thing.js"></script>` | W3C
HTML | CSS | `<link rel="stylesheet" href="./thing.css"/>` | W3C
HTML | Other | `<img src="./thing.png" />` | W3C


1. Importing a file with an explicit `.css` extension guarantees that the given CSS will be loaded into the DOM before your module executes. We do not define any exported values, this is purely for side-effect. This rule is not part of the present RFC, it was already in [RFC 507](https://github.com/emberjs/rfcs/blob/master/text/0507-embroider-v2-package-format.md).

2. Calling `import.meta.resolve` with the path to any file gives you back a string containing a valid URL for that file.

### `import.meta.resolve(moduleName)`

`import.meta.resolve(moduleName)`[^1] is a function built-in to browsers that takes a `moduleName` and "returns a string corresponding to the path that would be imported if the argument were passed to import()." [^2]

The build system will handle uses of `import.meta.resolve` when called with assets other than `.js` or .css` (see above).

The argument `moduleName` supports a subset of dynamicism as defined [here](https://github.com/emberjs/rfcs/blob/master/text/0507-embroider-v2-package-format.md#supported-subset-of-dynamic-import-syntax).

The argument `moduleName` must explicitly include the extension.

For example, the following is valid as the build system can determine the files that possibly match the interpolation:

```js
class extends Component {
  get iconURL() {
    return import.meta.resolve(`../icons/${this.args.locale}.png`)
  }
}
```

Calling `import.meta.resolve` with an asset that does not exist will cause a build error. You cannot fail to notice if you accidentally delete an asset that is still in use somewhere in your app.

#### Isn't it risky to "take over" a browser API?

No. This [original proposal for this feature to WHATWG](https://github.com/whatwg/html/issues/3871#issue-346547968) envisioned build tools rewriting the expressions to provide asset optimizations. 

The built-in function can only resolve modules relative to the active script; by using Ember's build tools developers have no guarantee of where modules build to and the feature effectively cannot be used without those build tools understanding `import.meta.resolve`.

[^1]: https://html.spec.whatwg.org/#integration-with-the-javascript-module-system
[^2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve

### What about references from HBS?

This RFC doesn't treat HBS separately because as far as the module system is concerned, HBS files are just JS files. They're transpiled into JS before any module traversal can happen. This RFC doesn't define any static syntax for use in templates because we should use whatever syntax is designed to go with [Strict Mode](https://github.com/emberjs/rfcs/blob/master/text/0496-handlebars-strict-mode.md). For example, in GJS you could say:

```js
const myImageURL = import.meta.resolve('./my-image.png');
<template>
  <img src={{myImageURL}} />
</template>
```

Today, the recommendation should be to use the JS part of a component to obtain the reference to assets and pass the resulting URLs to the HBS part of the component.

Using only Ember public API, it would also be possible to write an optional preprocessor that allows you to experiment with any authoring format you like for accessing assets from HBS. For example, you could rewrite this:

```hbs
{{!-- for illustration purposes only, this
      hypothetical "import-asset" helper is
      not being proposed by this RFC, it's
      just something you could layer on top. --}}
<img src={{import-asset "./thing.png"}} />
```

To this:
```js
// this line is the only thing in this file that is newly proposed by this RFC
const url0 = import.meta.resolve('./thing.png');

// all the rest of this is existing low-level API from other merged RFCS:
import { setComponentTemplate } from '@ember/component';
import { precompileTemplate } from '@ember/template-compilation';
import templateOnlyComponent from '@ember/component/template-only';
export default setComponentTemplate(
  precompileTemplate('<img src={{url0}} />', { scope: () => ({ url0 }) }),
  templateOnlyComponent()
);
```

### Addons

This feature provides the capability for addons to reference assets relative to their own modules.

Addon authors should ideally run any preprocessing before publishing. If they want apps to also do some preprocessing, they should provide explicit instructions & utilities for app authors to configure preprocessing in their particular build tool. They should not try to automatically rewrite the app's build system configuration, because that way lies madness and ecosystem-wide lock-in.

### Asset file location compatibility

Under the Embroider v2 spec, there are no implementation restrictions on where you could put assets in your package. You can access them via relative imports regardless, and consumers of your package can access them under your package name, following Node's standard rules (including the `exports` key in package.json).

But in today's v1 addons and apps, there are some compatibility issues with assets and their paths. Your module namespace is rooted not at the root of your package, but at the `/app` folder. So importing "your-app/logo.png" logically means "/app/logo.png". You cannot address anything in the traditional "/public" folder.

This is actually fine: anything in `/public` is still "push-based", meaning it will end up in your final build regardless of whether it's consumed by anything, and we really *guarantee* that it will be there. Whereas any assets you import following this new spec are only included when they're used, and their actual final URL is not guaranteed to take any particular form (they may even be `data:` URIs with no real file in the build output). So we don't want these new-style assets to be under `/public`.

My recommendation is that any asset file that is used by a single component should be co-located beside that component. And assets that are shared throughout the app can go into directories like `/app/images`, etc. As long as you keep everything under `/app` it will all work as expected.

### Upgrade path

This proposal can be implemented with relatively small changes to ember-auto-import. Once you upgrade to a version of ember-auto-import with these features, you can begin using `import.meta.resolve` and getting valid URLs for them. None of this breaks traditional asset handling including broccoli-asset-rev, so a gradual conversion is possible.

This RFC does not suggest removing broccoli-asset-rev from the app blueprint, because it would still be responsible for fingerprinting all the classic build output files (app.js, vendor.js, etc). Since these files are not referenced from arbitrary code, the problematic aspects of broccoli-asset-rev don't apply to them.

### Engines

Engines have some complicated interactions with asset handling today. Under the current system the URL of each asset is exposed as public API, which means that assets from different packages can potentially fight over namespace. So extra care is needed to keep them apart and give them each a view of their own assets that is namespaced properly into the app-wide namespace of URLs.

This problem doesn't exist for assets under this new proposal, because assets' precise runtime URLs are not public API. In fact, the build system would be free to notice if identical assets were included by more than one engine and deduplicate them as desired, without ever allowing an accidental collision.

### Deliberately undefined behavior

We deliberately do not define how inter-file references will be implemented. All we guarantee is that we will preserve inter-file reference semantics.

Examples:
  - build systems are free to replace any asset URL with a `data:` URI or even a blob at runtime.
  - build systems are free to rewrite CSS `@import` to inline the contents (which happens to be today's default behavior)
  - build systems can rewrite graphs of ES modules to single ES modules with the same semantics.

The exceptions where you can guarantee control over the URLs of assets are:

  - Files in `/public` are guaranteed to get URLs you can control (and manipulate with the traditional `fingerprint` options).
  - The traditional `index.html`, `app.js` and `vendor.js` files (plus their test equivalents) continue to get URLs you can control in the usual way.

## How we teach this

ember-auto-import is already part of the default app blueprint, so newly-generated apps would gain these capabilities with no changes to their configuration or dependencies. That means tutorials & guides can show examples of, for example, how to include an image in a component.

The [Assets and Dependencies docs](https://cli.emberjs.com/release/basic-use/assets-and-dependencies/) would change to show an example of using `import.meta.resolve` for an asset, in addition to mentioning that `/public` can be used for standalone assets that need their own URL.

The [Asset Compilation docs](https://cli.emberjs.com/release/advanced-use/asset-compilation/) would change to explain that `/public` is for files that must live at particular URLs in your final app, whereas if you just need to make sure an asset is available to your code, you should keep it within `/app` and reference it with `import.meta.resolve` where it's used. The fingerprinting section can stay as it is for now, though people should be aware that it doesn't apply anymore under embroider, so as we approach enabling embroider by default there will be a future RFC that causes that whole section to go away.

## Drawbacks

One footgun is that the module namespace of today's Ember apps doesn't match the on-disk package layout. It would be natural to think that `/app/app.js` could `import.meta.resolve('../public/thing.png')`, but this doesn't work because nothing above `/app` is addressable as a module. We should think about ways to provide helpful feedback if people try this. A lint rule against relative paths passed to `import.meta.resolve` that reach above "/app" would be one possibility.

## Alternatives

We could choose to let apps each configure asset importing in their own way. This is easier to design because we avoid responsibility, but it pushes more complexity onto app authors and it makes life harder for addon authors who want to have some supported thing they can rely on across all apps.

It would be possible to replace broccoli-asset-rev's unsafe reference rewriting with a runtime API, like a service plus helpers. This requires no build-time features and it would avoid assigning new semantics to ECMA `import`, but it wouldn't have the ability to analyze the asset dependency graph at build time.

We could address the confusing module namespacing of the `/app` folder by making apps configure the `exports` key in package.json. This would also give them the option of putting importable assets in other locations that are not under `/app`, by extending the `exports` configuration. And while it is relatively simple to make ember-auto-import and Embroider respect `exports`, I don't think it would be easy to make the classic build respect `exports`. So that could introduce new sources of confusion.


---

---
stage: recommended
start-date: 2021-10-21T00:00:00.000Z
release-date: 2022-03-21T00:00:00.000Z
release-versions:
  ember-cli: v4.3.0

teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/772
project-link:
---

# Deprecate Bower Support

## Summary

This RFC proposes to deprecate the following Bower APIs:

- [Blueprint::addBowerPackageToProject](https://ember-cli.com/api/classes/blueprint#method_addBowerPackageToProject)
- [Blueprint::addBowerPackagesToProject](https://ember-cli.com/api/classes/blueprint#method_addBowerPackagesToProject)
- [Project::bowerDependencies](https://ember-cli.com/api/classes/project#method_bowerDependencies) (not public, but used in several addons)
- [Project::bowerDirectory](https://github.com/ember-cli/ember-cli/blob/master/lib/models/project.js#L127) (not public, but used in several addons)

This RFC also proposes to deprecate building Bower packages, coming from
`/bower_components` by default.

## Motivation

While [Bower](https://bower.io/) is still maintained, it's recommended to use an
alternative package manager instead ([npm](https://www.npmjs.com/), [Yarn](https://yarnpkg.com/), [pnpm](https://pnpm.io/), ...). This is also [the official recommendation](https://github.com/bower/bower/blob/master/README.md?plain=1#L7) of the Bower team. Additionally,
Ember CLI stopped emitting a `bower.json` file since [v2.13.0](https://github.com/ember-cli/ember-cli/blob/master/CHANGELOG.md#2130-beta1) and the Ember Guides recommend to
not use Bower anymore as well in the [Compiling Assets](https://guides.emberjs.com/release/addons-and-dependencies/#toc_compiling-assets) section. Lastly, most addons have
dropped support for Bower as well.

Putting this all together, deprecating (and later on removing) Bower support
seems like the best path forward.

## Transition Path

### `Blueprint::addBowerPackageToProject`

Adds a Bower package to the project's `bower.json` file.

When used, a deprecation message will be triggered suggesting to use
[Blueprint::addPackageToProject](https://ember-cli.com/api/classes/blueprint#method_addPackageToProject) instead:

```
`addBowerPackageToProject` has been deprecated. If the package is also available
on the npm registry, please use `addPackageToProject` instead. If not, please
suggest your users to install the Bower package manually by running:
`bower install <package-name> --save`.
```

**Deprecation details:**

| Key     | Value                                                |
| ------- | ---------------------------------------------------- |
| `for`   | `'ember-cli'`                                        |
| `id`    | `'ember-cli.blueprint.add-bower-package-to-project'` |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }`           |
| `until` | `'5.0.0'`                                            |

### `Blueprint::addBowerPackagesToProject`

Adds multiple Bower packages to the project's `bower.json` file.

When used, a deprecation message will be triggered suggesting to use
[Blueprint::addPackagesToProject](https://ember-cli.com/api/classes/blueprint#method_addPackagesToProject) instead:

```
`addBowerPackagesToProject` has been deprecated. If the packages are also available
on the npm registry, please use `addPackagesToProject` instead. If not, please
suggest your users to install the Bower packages manually by running:
`bower install <package-name> <package-name> --save`.
```

**Deprecation details:**

| Key     | Value                                                 |
| ------- | ----------------------------------------------------- |
| `for`   | `'ember-cli'`                                         |
| `id`    | `'ember-cli.blueprint.add-bower-packages-to-project'` |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }`            |
| `until` | `'5.0.0'`                                             |

### `Project::bowerDependencies`

Returns the Bower dependencies (including the development dependencies) for the
project.

Addons that use this method, mostly do so to check the presence of a
specific Bower package in order to suggest users to use the npm equivalent
instead.

When used, the following deprecation message will be triggered:

```
`bowerDependencies` has been deprecated. If you still need access to the
project's Bower dependencies, you will have to manually resolve the project's
`bower.json` file instead.
```

**Deprecation details:**

| Key     | Value                                      |
| ------- | ------------------------------------------ |
| `for`   | `'ember-cli'`                              |
| `id`    | `'ember-cli.project.bower-dependencies'`   |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }` |
| `until` | `'5.0.0'`                                  |

### `Project::bowerDirectory`

Returns the project's Bower directory.

When used, the following deprecation message will be triggered:

```
`bowerDirectory` has been deprecated. If you still need access to the
project's Bower directory, you will have to manually resolve the project's
`.bowerrc` file and read the `directory` property instead.
```

**Deprecation details:**

| Key     | Value                                      |
| ------- | ------------------------------------------ |
| `for`   | `'ember-cli'`                              |
| `id`    | `'ember-cli.project.bower-directory'`      |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }` |
| `until` | `'5.0.0'`                                  |

### Building Bower Packages

If Ember CLI detects that the project contains a Bower directory, it will try to
build a Broccoli tree with Bower packages.

When a Bower directory is detected, the following deprecation message will be
triggered:

```
Building Bower packages has been deprecated. You have Bower packages in
`<bower-directory>`.
```

The deprecation message should be triggered when the [`packageBower`](https://github.com/ember-cli/ember-cli/blob/e747ac4c21a8e4a37e158a226dfa8ac048541b1f/lib/broccoli/default-packager.js#L630)
method is called.

**Deprecation details:**

| Key     | Value                                      |
| ------- | ------------------------------------------ |
| `for`   | `'ember-cli'`                              |
| `id`    | `'ember-cli.building-bower-packages'`      |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }` |
| `until` | `'5.0.0'`                                  |

### Additional Tasks

- Remove all Bower references from the `app` and `addon` blueprints

## Deprecation Guide

### `Blueprint::addBowerPackageToProject`

`addBowerPackageToProject` has been deprecated. If the package is also available
on the npm registry, please use `addPackageToProject` instead. If not, please
suggest your users to install the Bower package manually by running:

```
bower install <package-name> --save
```

### `Blueprint::addBowerPackagesToProject`

`addBowerPackagesToProject` has been deprecated. If the packages are also available
on the npm registry, please use `addPackagesToProject` instead. If not, please
suggest your users to install the Bower packages manually by running:

```
bower install <package-name> <package-name> --save
```

### `Project::bowerDependencies`

`bowerDependencies` has been deprecated. If you still need access to the
project's Bower dependencies, you will have to manually resolve the project's
`bower.json` file instead:

```js
'use strict';

const fs = require('fs-extra');
const path = require('path');

module.exports = {
  name: require('./package').name,

  included() {
    this._super.included.apply(this, arguments);

    let bowerPath = path.join(this.project.root, 'bower.json');
    let bowerJson = fs.existsSync(bowerPath) ? require(bowerPath) : {};
    let bowerDependencies = {
      ...bowerJson.dependencies,
      ...bowerJson.devDependencies,
    };

    // Do something with `bowerDependencies`.
  },
};
```

### `Project::bowerDirectory`

`bowerDirectory` has been deprecated. If you still need access to the
project's Bower directory, you will have to manually resolve the project's
`.bowerrc` file and read the `directory` property instead:

```js
'use strict';

const fs = require('fs-extra');
const path = require('path');

module.exports = {
  name: require('./package').name,

  included() {
    this._super.included.apply(this, arguments);

    let bowerConfigPath = path.join(this.project.root, '.bowerrc');
    let bowerConfigJson = fs.existsSync(bowerConfigPath) ? fs.readJsonSync(bowerConfigPath) : {};
    let bowerDirectory = bowerConfigJson.directory || 'bower_components';

    // Do something with `bowerDirectory`.
  },
};
```

### Building Bower Packages

Building Bower packages has been deprecated.

Please consider one of the following alternatives:

1. Install the package via the npm registry and use `ember-auto-import` to
import the package into your project
2. If alternative 1 is not an option, you could copy the contents of the Bower
package into the `/vendor` folder and use `app.import` to import the package
into your project

## How We Teach This

The following references to Bower in the Ember Guides should be removed:

- [Compiling Assets](https://guides.emberjs.com/release/addons-and-dependencies/#toc_compiling-assets)

The following references to Bower in the Ember CLI Guides should be removed:

- [Where Should Assets and Dependencies Go?](https://cli.emberjs.com/release/basic-use/assets-and-dependencies/#whereshouldassetsanddependenciesgo)
- [Assets and Dependencies](https://cli.emberjs.com/release/advanced-use/debugging/#assetsanddependencies)
- [ember addon](https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#emberaddon)
- [ember init](https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#emberinit)
- [ember new](https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#embernew)
- [Blueprint Hooks](https://cli.emberjs.com/release/writing-addons/addon-blueprints/#blueprinthooks)
- [WebStorm](https://cli.emberjs.com/release/appendix/dev-tools/#webstorm)

We should also make sure to remove all references to Bower in the
[Ember CLI API documentation](https://ember-cli.com/api/).

_NOTE: It's possible that some references are not included in the lists above._

## Drawbacks

- Addons that still rely on a Bower package which does not yet have an npm
equivalent would need to suggest their users to manually install said package
- Addons that still require access to the project's Bower dependencies, will
have to manually resolve the project's `bower.json` file instead
- Addons that still require access to the project's Bower directory, will
have to manually resolve the project's `.bowerrc` file and read the `directory`
property instead
- Projects that still import Bower packages will need to use one of the
suggested alternatives in the [Building Bower Packages](#building-bower-packages-1)
deprecation guide

## Alternatives

- Keep supporting Bower indefinitely

## Unresolved questions

- Should a deprecation warning be displayed when the `--skip-bower` CLI flag is
used?


---

---
stage: recommended
start-date: 2021-11-14T00:00:00.000Z
release-date: 2024-03-04T00:00:00.00Z
release-versions:
  ember-source: v5.7.0
  ember-cli: v5.7.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/774'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/900'
  released: 'https://github.com/emberjs/rfcs/pull/955'
  recommended: 'https://github.com/emberjs/rfcs/pull/970'
---

# Deprecate Implicit Record Loading in Routes

## Summary

This RFC seeks to deprecate and remove the default record loading behaviour on Ember's Route. By consequence, this will also deprecate and remove the default store on every Route.  This behaviour is likely something you either know you have or do not know but it may be occuring in your app.

```js
export default class PostRoute extends Route {
  beforeModel() {
    // do stuff
  }

  afterModel() {
    // do stuff
  }
}
```

In this example, the `model` hook is not defined.  However, Ember will attempt to try a few things before rendering this route's template.

1. If there is a `store` property on your route, it will attempt to call it's `find` method.  Assuming you have `ember-data` installed, you may be expecting this. The arguments will be extracted from the params.
  a. For example, if a dynamic segment is `:post_id`, there exists logic to split on the underscore and find a record of type `post`.  

2. As a fallback, it will attempt to define a `find` method and use your `Model` instance's find method to fetch.  If a `Model` cannot be found or if the found `Model` does not have a `find` method, an assertion is thrown.

## Motivation

If a user does not define a `model` hook, a side effect of going to the network has long confused developers.  Users have come to associate `Route.model()` with a hook that returns `ember-data` models in the absense of explicit injection. While this can be true, it is not wholly true. New patterns of data loading are becoming accepted in the community including opting to fetch data in a Component or using different libraries.

By removing this behaviour, we will encourage developers to explicitly define what data is being fetched and from where.

## Detailed design

We will issue a deprecation to [`findModel`](https://github.com/emberjs/ember.js/blob/017b11e2f58880869a5b8c647bf7f3199fc07f26/packages/%40ember/-internals/routing/lib/system/route.ts#L1376) notifying the user that if they want to continue this behaviour of attempting to fetch a resource implicitly, they should try and replicate with their own explicitly defined `model` hook. 

In addition, we will include an [optional feature](https://github.com/emberjs/ember-optional-features) to disable this feature and clear the deprecation. This optional feature will be enabled in the blueprint because we want new apps to get this behaviour by default.

In v6.0.0, we will remove `findModel` and logic to determine arguments for this method.  This will not remove returning the `transition` context when no `model` hook is defined. The optional feature will also be removed.

## How we teach this

Most of this behaviour is lightly documented.  Developers often come to this by mistake after some difficult searching. First, we will have to remove this sentence from the [docs](https://guides.emberjs.com/release/routing/defining-your-routes/#toc_dynamic-segments).

> The first reason is that Routes know how to fetch the right model by default, if you follow the convention.

A direct one to one replacement might look like this.

```js
import { inject as service } from '@ember/service';

export default class PostRoute extends Route {
  // assuming you have ember-data installed
  @service store;

  beforeModel() {
    // do stuff
  }

  model({ post_id }) {
    return this.store.findRecord('post', post_id);
  }

  afterModel() {
    // do stuff
  }
}
```

## Alternatives

- Continue to provide fallback fetching behaviour but ensure no `assert` is called for users that have neither a store nor a `Model` with a `find` method.

## Open Questions

## Related links and RFCs
- [Deprecate defaultStore located at `Route.store`](https://github.com/emberjs/rfcs/issues/377)
- [Pre-RFC: Deprecate implicit injections (owner.inject)](https://github.com/emberjs/rfcs/issues/508)
- [Deprecate implicit record loading in routes](https://github.com/emberjs/rfcs/issues/557)


---

---
stage: recommended
start-date: 2021-11-11T00:00:00.000Z
release-date: 2022-12-08T00:00:00.000Z
release-versions:
  ember-cli: v4.9.0
  ember-source: v4.9.0
teams:
  - cli
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/776'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/873'
  released: 'https://github.com/emberjs/rfcs/pull/911'
  recommended: 'https://github.com/emberjs/rfcs/pull/912'
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Author Built-In Blueprints in TypeScript

## Summary

In order to support both TypeScript and JavaScript as official languages in Ember, we should enable blueprints to be written in TypeScript and (optionally) transformed to JavaScript. We should also convert all of the existing built-in blueprints to TypeScript to take advantage of this new functionality and lay the groundwork for future TypeScript inclusion efforts.

## Motivation

Ember CLI's generators are a foundational part of Ember itself. They are one of the first elements of the developer experience that Ember prides itself on, and continue to be an essential part of the ecosystem by virtue of the fact that both apps and addons can generate their own custom blueprints. For many years, the `ember-cli-typescript` addon has provided its own set of TypeScript-flavored built-in blueprints that essentially act as drop-in replacement for the built-in blueprints that provide with Ember today. However, these blueprints have proven very difficult to maintain as it involves keeping them all up to date with every single change made to Ember itself, so much so that the current TypeScript blueprints have diverged to the point there is currently not a TypeScript blueprint for components at all.

As part of the larger effort to [make Typescript an officially supported language in Ember](https://github.com/emberjs/rfcs/pull/724), Ember should provide a single set of blueprints that will support both JavaScript and TypeScript. These new blueprints would be written in TypeScript, and would provide exactly the same JavaScript experience that today's users enjoy, while also providing several benefits over the current system:

1. Remove the disconnect between TypeScript and JavaScript blueprints discussed above, as the Typed Ember team would no longer be responsible for maintaining an entirely independent set of blueprints.
1. Allow for multiple versions of TypeScript blueprints to exist (since they'd belong to each version of Ember), rather than today where there is no way to tie standalone TypeScript blueprints to individual versions of Ember (e.g. there's no LTS version of the TypeScript blueprints today).
1. Enable TypeScript blueprint generation in any Ember app or addon right out of the box via a `--typescript` flag.
1. Enable addon authors to better support TypeScript users by allowing them to publish their own TypeScript blueprints without concern for also supporting JavaScript users.

Note that this does **not** mean that we should generate TypeScript by default, but rather that the blueprints themselves should _begin_ as TypeScript before actually being reified as actual code. By default, all of the Ember generators would still behave exactly as they do today: by generating JavaScript files. This RFC is primarily concerned with TypeScript as an _implementation detail_ for the existing blueprints, rather than being prescriptive about whether or not users should adopt TypeScript themselves.

## Detailed design

tl;dr: Blueprints will be handled exactly the same as before, with the one exception that any blueprint file written in TypeScript will be run through Babel's [`@babel/plugin-transform-typescript`](https://babeljs.io/docs/en/babel-plugin-transform-typescript) to strip out all the TypeScript syntax unless the user actually wants TypeScript output. Please read on for a more detailed explanation.

In the current generator system, new files are created from templates that reside in the `files` directory of the blueprint that corresponds to the generator that was invoked. When a user runs `ember generate service foo`, Ember CLI will locate the template at `blueprints/service/files/__root__/__path__/__name__.js`, load it into memory, perform a text replacement on all of the EJS-style tags (e.g. `class <%= classifiedModuleName => extends Service` becomes `class Foo extends Service`), and then writes the entire string out to a file at the correct path inside the parent app or addon. Notably, there is no evaluation of the code itself, as the entire process of blueprint generation is simple text replacement.

In the new version of Ember's blueprint system, this template would instead be named `__name__.ts`. The generator process would run identically (locate the template, read into memory, perform text replacement) up until it is actually time to _write_ the file. Before that occurs, the (now fully populated) in-memory version of the newly generated file would be run through Babel's [`@babel/plugin-transform-typescript`](https://babeljs.io/docs/en/babel-plugin-transform-typescript). This would strip the file of all TypeScript-related syntax, resulting in a completely valid JavaScript file with no evidence that it had begun as TypeScript file. In this way, we're able to ensure that the built-in generators would continue to perform as exactly as they have previously.

Furthermore, blueprints would have to explicitly opt-in to this behavior by adding a `shouldTransformTypeScript: true` flag to the blueprint's `index.js` file. This will make the automatic TypeScript transform behavior purely opt-in, thereby preventing any conflicts with existing projects that may already have their own custom TypeScript blueprints.

In addition to the per-blueprint flag, there will also be a new `isTypeScriptProject` flag added to `.ember-cli` that will allow users to mark an entire Ember app or addon as a TypeScript-first project. The presence of this flag would indicate that blueprints should output TypeScript by default, rather than JavaScript as they normally would. Flags specified in `.ember-cli` are automatically merged into the blueprint options when invoked, so this flag would be readily accessible to all blueprints. We'd also add a step to the `init` hook for `ember-cli-typescript` that would check for the presence of this flag in `.ember-cli` and warn if it's not set. In the future, we'd be able to set this flag as part of a `ember new --typescript` flag.

There are a few details worth calling out about this change to the generation process:

1. While the TypeScript files are parsed and transformed, they are _not_ type-checked in any way. The Babel plugin is concerned solely with the transformation of TypeScript syntax into JavaScript syntax and does not pay any attention to what the types actually are. This is a good thing, as it minimizes any performance cost during the generation process and we'd expect any actual type-checking to happen at compilation time in the user's app, using their own `tsconfig` rather than one we'd have to supply (and maintain).
   1. In the future, we DO also need the ability to test the actual TypeScript parts of the blueprints (i.e. do the blueprints output TS files that actually type-check?), but that functionality will be covered in a later RFC that is more concerned with enabling TypeScript support in Ember.
1. By default, the generators would behave exactly as they did before. However, we would also add a `--typescript` flag to the `generate` command that tells the generator to simply bypass the Babel transform and instead output TypeScript directly. Since TypeScript is a superset of JavaScript, we're able to easily accomodate both sets of users with a single blueprint file by starting out with the "higher-fidelity" TypeScript and down-leveling it JavaScript when needed.
1. Addon authors would be able to provide blueprints written in TypeScript that would "just work" in the same way that the built-in blueprints would, e.g. they'd get support for both JavaScript and TypeScript versions of their blueprints with no additional effort or maintenance.
1. No one is _required_ to write their blueprints in TypeScript. Any blueprint written in JavaScript would be handled in the exact same way that they are today.

To sum up, the changes would be as follows:

- Rewrite Ember's existing blueprints in TypeScript.
- Add a `--typescript` flag to `ember generate` that will force the command to output TypeScript instead of JavaScript (assuming a TypeScript blueprint exists).
- Add a `shouldTransformTypeScript` flag to the `Blueprint` base class that opts the blueprint in to the down-leveling behavior.
  - This defaults to `false`.
  - This flag exists so that blueprint authors can choose whether they want the auto-transform behavior in case there are already apps/addons that have custom blueprints they expect to always result in TypeScript files.
- Add a `isTypeScriptProject` flag to `.ember-cli` that can be used to determine whether to generate TypeScript or JavaScript by default.
  - This flag defaults to `false`.
  - If `isTypeScriptProject` is `true`, `ember g component foo` would generate a TypeScript file, otherwise it will generate a JavaScript file.
  - Users can override this default behavior by passing the `--typescript` flag (mentioned above), which will force the blueprint to output TypeScript as long as a TypeScript blueprint is available.

## How we teach this

For most users, there isn't much to teach here since their default experience with Ember's blueprints won't change at all. However, we should document the typescript-related behaviors in the [documentation for creating custom blueprints.](https://cli.emberjs.com/release/advanced-use/blueprints/) More specifically, we'd need to mention the 3 new flags being added (`shouldTransformTypeScript`, `isTypeScriptProject`, and `--typescript`) and explain their usage.

## Drawbacks

There should be little to no impact on the end-user as a result of the changes proposed in the RFC. The one drawback worth mentioning is that this change does introduce additional memory and performance overhead as a result of running the files through Babel transforms when converting from TypeScript to JavaScript.

That said, Ember (and most of the front-end world) already relies heavily on Babel, so this change would simply be extending a dependency that already exists. Furthermore, while there _is_ a cost to running a Babel transform as part of a generator, it will be extremely trivial given that generators only ever create a handful of files at a time, and a newly-generated Ember app runs _far_ more files through many more Babel transforms without issue. Finally, we'd be running the transform on the in-memory version of the file, so there'd be no additional I/O cost incurred.

## Alternatives

We could continue to maintain a wholly independent set of blueprint files, a la [`ember-cli-typescript-blueprints`](https://github.com/typed-ember/ember-cli-typescript-blueprints). However, this would leave us with the same challenges that exist today, and would also make it harder to provide official support for TypeScript in Ember itself.

## Unresolved questions

> Optional, but suggested for first drafts. What parts of the design are still
> TBD?


---

---
stage: released
start-date: 2021-12-03T00:00:00.000Z
release-date:
release-versions:
  ember-template-imports: 4.0.0
  ember-source: 3.28.0
teams:
  - framework
  - learning
  - cli
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/779'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/871'
  released: 'https://github.com/emberjs/rfcs/pull/1050'
project-link:
---


# First-Class Component Templates


## Summary

Adopt `<template>` tags as a format for making component templates first-class participants in JavaScript and TypeScript with [strict mode][rfc-0496] template semantics. In support of the new syntax, adopt new custom JavaScript and TypeScript files with the extensions `.gjs` and `.gts` respectively.

First-class component templates address a number of pain points in today’s component authoring world, and provide a number of new capabilities to Ember and Glimmer users:

- accessing local JavaScript values with no ceremony and no backing class, enabling much easier use of existing JavaScript ecosystem tools, including especially styling libraries—standard [CSS Modules][css-modules] will “just work,” for example

- authoring more than one component in a single file, where colocation makes sense—and thereby providing more control over a component’s public API

- likewise authoring locally-scoped helpers, modifiers, and other JavaScript functionality

First-class component templates offer these new capabilities while not only maintaining but *improving* Ember’s long-standing commitment to integrated testing, in that it allows app and test code to share a single authoring paradigm—substantially simplifying our teaching story. Similarly, it preserves Ember’s long-standing commitment to treating JavaScript and HTML (and CSS!) as distinctive concerns which, however closely related, are not the *same*.

<details><summary>Full-fledged example showing how this might work in practice</summary>

Two notes:

- For this and all the examples in the RFC, I assume [RFC #0757: Default Modifier Manager][rfc-0757] for simplicity, but it does not meaningfully change *this* proposal.

- The syntax highlighting here is a mess… but that's because GitHub still doesn't have good highlighting for *decorators*. Samples which have `<template>` but *not* `@tracked` actually already highlight decently well.

[rfc-0757]: https://github.com/emberjs/rfcs/pull/757

```js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

const Greet = <template>
  <p>Hello, {{@name}}!</p>
</template>

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) => {
    this.name = value;
  }

  saveName = (submitEvent) => {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  <template>
    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
  </template>
}

function replaceLocation(el, { with: newUrl }) {
  el.contentWindow.location.replace(newUrl);
}

export default class GenerateAvatar extends Component {
  @tracked name = "";

  get previewUrl() {
    return `http://www.example.com/avatars/${name}`;
  }

  updateName = (newName) => {
    this.name = newName;
  };

  <template>
    <Greet @name={{this.name}} />
    <SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    />

    {{#if (gt 0 this.name.length)}}
      <iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      >
    {{/if}}
  </template>
}
```

</details>


### Contents <!-- omit in toc -->

- [Summary](#summary)
- [Motivation](#motivation)
  - [Namespaces and Modules](#namespaces-and-modules)
  - [Scope](#scope)
  - [Ecosystem integration](#ecosystem-integration)
  - [Testing](#testing)
  - [The solution](#the-solution)
  - [Constraints](#constraints)
- [Detailed design](#detailed-design)
  - [Compilation](#compilation)
    - [Standalone](#standalone)
    - [Bound to a name](#bound-to-a-name)
    - [Class body](#class-body)
  - [Performance](#performance)
  - [Interop](#interop)
    - [Named exports](#named-exports)
    - [Non-colocated templates](#non-colocated-templates)
  - [The “prelude”](#the-prelude)
  - [Tooling](#tooling)
    - [Syntax highlighting](#syntax-highlighting)
    - [Blueprints](#blueprints)
    - [Linting and formatting](#linting-and-formatting)
    - [Language server support](#language-server-support)
    - [Codemod](#codemod)
  - [TypeScript](#typescript)
  - [Custom file extension](#custom-file-extension)
  - [Spec](#spec)
- [Transition path](#transition-path)
- [How we teach this](#how-we-teach-this)
  - [Guides](#guides)
    - [Tutorial](#tutorial)
    - [Core Concepts: Components](#core-concepts-components)
  - [API Docs](#api-docs)
  - [Existing Ember users](#existing-ember-users)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
  - [TypeScript signature](#typescript-signature)
  - [Distinguishing class-backed and template-only components](#distinguishing-class-backed-and-template-only-components)
  - [Alternative syntaxes](#alternative-syntaxes)
    - [Imports-only](#imports-only)
    - [SFCs](#sfcs)
    - [Template literals (`hbs`)](#template-literals-hbs)
- [Unresolved questions](#unresolved-questions)


## Motivation

Today, authors of Ember and Glimmer apps and libraries must author their templates and JavaScript in separate `.hbs` and `.js` files, and the templates exist in a “resolution” mode where every component, helper, and modifier exists in a single global namespace. This has a number of significant downsides. What’s more, there are significant new capabilities for Ember and Glimmer authors made available by embracing JavaScript scope—while keeping our commitments to testing and separation of concerns.[^original-primitives-rfc]

[^original-primitives-rfc]: See also [the SFC & Template Import Primitives RFC](https://github.com/emberjs/rfcs/blob/tomdale/template-primitives/text/000-sfc-and-template-import-primitives.md), which described the motivation for implementing the primitives on which this proposal will build.


### Namespaces and Modules

First, because of the global namespace, name conflicts are common, and avoiding them requires either manually namespacing components or using (now-deprecated) experimental tools like [`ember-holy-futuristic-template-namespacing-batman`](https://github.com/rwjblue/ember-holy-futuristic-template-namespacing-batman). But:

- Manually namespacing is clunky and does not actually *guarantee* there won't be conflicts. Combined with the way addons typically supply their components, helpers, and modifiers into the app namespace, name conflicts are sometimes unavoidable.

- Even the workaround via `ember-holy-futuristic-template-namespacing-batman` requires using different names for modules in Ember than their Node package name when the Node package uses [npm scopes][scopes]. (This was one of the original motivations for exploring a design which leverages JavaScript modules, in fact!) Since our resolution modes must ultimately deal in JavaScript terms, we are in the position of always potentially being one ecosystem shift away from another syntax conflict with template-language-only designs for managing scope.

- It requires our tooling to understand Ember's resolution rules, and our tooling cannot take advantage of existing ecosystem tooling. Our language servers, for example, have to more or less re-implement Ember’s resolver themselves.

- There is a substantial performance cost to dynamically resolving components by name at runtime. This can be mitigated by using the combination of something like `ember-holy-futuristic-template-namespacing-batman` with the [strict resolver][strict-resolver], but the strict resolver is not standard—and really cannot be without something like this proposal.[^strict-resolver-rfc]

- It is extremely unpleasant (though, strictly speaking, *possible* as of Ember 3.25[^verbose-local]) to introduce a component, helper, or modifier which is not in the global namespace. See the next section, [**Scope**](#scope), for further on this.

The global namespace also comes with overhead for our teaching story by introducing a layer of “magic”: people just have to memorize that a file with a default export in a given location *automagically* is available with a given name. This is just a “bare fact”: there is nothing to connect it to in terms of a developers’ existing JavaScript or HTML knowledge.

[strict-resolver]: https://github.com/stefanpenner/ember-strict-resolver

These problems are all well-solved already, using the JavaScript modules spec (or "ESM", for ECMAScript Modules). Today, however Ember developers cannot take advantage of those or the tooling which understands them!

[^strict-resolver-rfc]: See the still-open [RFC #0683][rfc-0683] for a discussion of the full set of concerns involved in resolution, which include but are not limited to the template concerns addressed here.

[rfc-0683]: https://github.com/emberjs/rfcs/pull/683

[^verbose-local]: In all cases, doing so requires introducing a backing class to make the value available to the template *or* writing Ember's strict mode template syntax manually (which is error-prone and extremely verbose: it is designed as an output format, not an authoring format).


### Scope

Second, and closely related to the global namespace problem: there is presently no good way for users to introduce or use locally-scoped code. Every component, helper, and modifier must live in its own file, and be globally available—even if it is meant to be used privately. Where JavaScript modules provide users to control their public APIs in terms of `export`s, Ember apps largely cannot take advantage of exports for anything which interacts with the template layer.

In practice, this has a number of knock-on effects for Ember code.

First, components tend to grow without bound, because the equivalent of the "extract method" or "extract into new class" refactors (which we commonly use on the JS side) end up with two downsides:

- they make the newly-extracted components available to the whole app, even if the concern is private to that component
- the require an entirely new file, which is friction both for the creation and the use/understanding of a given view

Second, users also often introduce classes with actions or getters where a simple [function-based helper][rfc-0756] would do, because that is the only way to provide a non-global function. (I show this by example in [**How We Teach This: Guides: Tutorial: Reusable Components**](#reusable-components) below.)

Third, it likewise incentivizes the use of the ember-render-modifiers with backing classes, rather than custom modifiers, because the behavior can then be scoped to that module—whereas, again, a custom modifier would be in global scope. This in turn makes it easy for users to miss the helpful separation of concerns which custom modifiers enable.

[rfc-0756]: https://github.com/emberjs/rfcs/pull/756

Over time, these all lead to a proliferation of backing classes which are only present to work around the fact that we have no *other* way to provide non-global scope for our components. These classes in turn tend to act as “state attractors,” leading to an unnecessary proliferation of state throughout an app or addon.

[scopes]: https://docs.npmjs.com/cli/v8/using-npm/scope


### Ecosystem integration

Tools which assume they will be used in JavaScript contexts more or less don’t work with our templates today, because the templates have no way to access them. Think of CSS tools like [CSS Modules][css-modules], which is widely used in the Ember ecosystem via [Ember CSS Modules][e-css-m]: our current implementation has to jump through many hoops and do many hacks to work at all. These problems are fundamental to the current model. A format which makes JavaScript values available in template scope would let us drop *all* of that special sauce—and this goes for *all* such JavaScript-side tooling.[^other-css-tools]

[css-modules]: https://github.com/css-modules/css-modules
[e-css-m]: https://github.com/salsify/ember-css-modules

[^other-css-tools]: The same applies to all other similar tools, e.g. [Emotion][emotion], [Styled Components][styled-components], [vanilla-extract][vanilla-extract]: none of them work out of the box with our current design. Whatever anyone’s personal opinions on these specific, they’re potentially-valuable tools which are barely or not at all usable in Ember today.

[emotion]: https://emotion.sh/docs/@emotion/css
[styled-components]: https://styled-components.com
[vanilla-extract]: https://vanilla-extract.style


### Testing

Finally, the authoring format for tests and the authoring format for app code today is completely different. A test can render a component by calling the `render()` function from `@ember/test-helpers` and passing it a Handlebars string.[^testing-rfc] App code *cannot* do this or anything like it. This has teaching overhead: we both *can* do things in tests we *cannot* do in app code, raising the obvious “but why not?”; and we also *must* do things in tests we do not *need* to do in app code.

Additionally, introducing test-only components is quite painful, requiring use of the `this.owner.register()` functionality, and therefore requiring users to understand at least some of Ember’s custom runtime resolution (as well as learning a microsyntax for it[^microsyntax]). What's more, authoring a *template* for a test-only component is undocumented and is also entirely unlike the story for authoring templates for app components.

[^testing-rfc]: The test helper `render()` also does not actually render components today—but the *mental model* is that it does. See [RFC #0785][rfc-0785] which will allow `render` to work not only with templates (the _status quo_) but also with components. This will be an independent change which helps eliminate a number of quirks in the testing infrastructure today as well as make it more TypeScript friendly, but it complements *this* RFC by allowing local definition of tests.

[^microsyntax]: made that much more bespoke since [RFC #0585](https://emberjs.github.io/rfcs/0585-improved-ember-registry-apis.html) is accepted but not yet implemented

[rfc-0785]: https://github.com/emberjs/rfcs/pull/785


### The solution

To address these problems, the Ember community [proposed primitives][rfc-0454] which unlocked experimentation in this space and [defined the semantics of “strict” templates which use those primitives][rfc-0496] and [made modifers and helpers first-class citizens of templates][rfc-0432]. Now, with a history of having done that experimentation—with [GlimmerX][glimmerx] and [ember-template-imports][eti]—and having had *many* discussions about the trade-offs over the years, it’s time to ship a proposal which resolves these questions: **first-class component templates**.

[rfc-0454]: https://github.com/emberjs/rfcs/pull/454
[rfc-0496]: https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html
[rfc-0432]: https://emberjs.github.io/rfcs/0432-contextual-helpers.html
[glimmerx]: https://glimmerjs.github.io/glimmer-experimental/
[eti]: https://github.com/ember-template-imports/ember-template-imports

In this new world, templates are authored in JavaScript files with a `<template>` tag. Templates defined this way have normal Glimmer template semantics, but instead of using a runtime resolution strategy, they have access to values in JavaScript scope, which means they can just use normal JavaScript imports. What's more, they can define other local components, helpers, or modifiers and export them or not as makes sense. They can do the same kind of extraction refactors they do with JavaScript or CSS. And other tools from the JavaScript ecosystem “just work”—from custom CSS tooling to GraphQL queries authored with [Apollo Client’s `graphql` template strings][graphql] and anything else the ecosystem comes up with.

[graphql]: https://www.apollographql.com/docs/react/data/queries/

At the same time, since the body of a template defined with a `<template>` tag has all the same rules as Glimmer templates do today, this new authoring format keeps all the goodness of today’s clear separation of concerns between HTML and JavaScript and CSS. That means it continues to empower developers who are HTML and CSS experts and reach for JavaScript only secondarily. Indeed, the design goes out of its way to make HTML/Handlebars-only files feel like first-class citizens.

Finally, introducing `<template>` completely unifies the story between app and test code: in this new world, introducing a test-only component is as simple as introducing any other component in the same file as an existing component.

In sum, `<template>` resolves each problem outlined above, and introduces new capabilities to boot.


### Constraints

There are a number of solutions which could address these needs and add these capabilities. This RFC proposes `<template>` out of all the possible options because I take the following constraints as guiding the design decision (and the ordering here is purposeful—items earlier in the list I judge to be more important than items later in the list):

1. Our choice of design **must not regress our ability to write tests**, and if it is possible to *improve* our testing story, we should take the opportunity to do so.

2. In the absence of hard technical constraints forbidding it, we should **prefer the solution which has the best story for teaching**—at all levels, including beginners but also supporting advanced users. In particular, this means that we should value both *progressive disclosure of complexity* and the *principle of least surprise*, and that we may need to weight them against each other, but that we should pay particular attention when they agree.

3. This design must cleanly interoperate with existing Ember code bases. That is, adopting this **must not require users to migrate their entire code base at once**.

4. We should **prefer a design which provides more flexibility** to end users over a design which provides less.

While it is certainly possible to differ with these constraints *a priori*—reevaluating constraints is, in a very real sense, [how we got to this very RFC](https://github.com/emberjs/rfcs/pull/367#issuecomment-423839940)—we also run the risk of paralysis if we *continually* reevaluate from first principles. More challenging is inevitable disagreement about how we *weight* these constraints. On that front, there is no possibility of *final* agreement, but we should commit to some ordering for the purposes of this design so that the rest of it can proceed on the same terms.


## Detailed design

Introduce a new high-level syntax, the `<template>` tag, which is syntactical sugar for `setComponentTemplate` and `precompileTemplate`, in conjunction with the existing Ember and Glimmer `Component` classes and the special template-only component class returned by the `templateOnlyComponent` default export from `@ember/component/template-only`.

There are three distinct, legal forms for this compilation:

- a standalone `<template>` at the top level of a module
- a `<template>` bound to a name
- in the body of a component class

For a discussion of the `setComponentTemplate` and `templateOnlyComponent` primitives, see [RFC #0481][rfc-0481]; for discussion of the `precompileTemplate` primitive, see [RFC #0496][rfc-0496]. This discussion will *assume* rather than *define* those. Additionally, I leave aside here the further build-time passes which transform `precompileTemplate` invocations into a precompiled template in “wire format” ready for use by the Glimmer VM, as that is not affected by the authoring format.

[rfc-0481]: https://emberjs.github.io/rfcs/0481-component-templates-co-location.html


### Compilation

The value produced by authoring a `<template>` is a *JavaScript value*, and accordingly may be exported, bound to other values, passed as an argument to a function or set as a value on a class, and so on. However, that value is not *dynamic*. Instead, it is compiled statically to a format targeting the Glimmer VM at compile time, such that even the `precompileTemplate` invocations are removed in favor of the wire format, which itself may be further optimized or changed in the future.

Therefore, in normal app or addon code, it is nonsensical to reassign it when bound with a `let` binding: changing the value bound to the `let` will *not* result in Ember’s reevaluating anything which *uses* that value: the “scope” of a template is only ever computed once, for performance reasons.

A function may of course return different components based on its arguments, etc.; but such a function will not be “automatically” re-executed unless the function consumes tracked properties. (This is just applying the standard auto-tracking semantics to functions which return components, which is possible *today*.) I discuss below the performance pitfalls of doing this inline, and the corresponding guidance we should provide.

Apps or addons which want to compile arbitrary components at runtime are the exception to static component definition as described here. Most apps and addons will *not* want to do this, because it is expensive and slow and also a security risk in that it allows arbitrary code execution within your app. However, there *are* good use cases, e.g. dynamic online environments like the [GlimmerX playground][glimmerx-playground] or the [Limber Editor][limber], or documentation tooling like [Storybook][storybook].

These kinds of apps and integrations can integrate the template compiler as a runtime dependency and build new templates on the fly. However, the details of doing that are unrelated to providing first-class component templates and do not change as a result of this RFC. The scope remains static for any given `<template>` declaration after compilation; the difference there is that they are intentionally re-executing the compilation step itself.

[glimmerx-playground]: https://glimmerjs.github.io/glimmer-experimental/
[limber]: https://limber.glimdown.com/
[storybook]: https://storybook.js.org


#### Standalone

The compiled output for a top-level `<template>` tag is a default export. This means that the very common case of having a simple template-only component looks basically just like HTML, wrapped in `<template>`, helping us provide a strong *progressive disclosure of complexity* flow to our design and our pedagogy. It also means that the basic code Ember developers use today changes very little for the most basic version of the new format. Given this input:

```js
<template>
  <p>Hello, {{@name}}!</p>
</template>
```

The compiled output is:

```js
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

export default setComponentTemplate(
  precompileTemplate(`
  <p>Hello, {{@name}}!</p>
  `,
    {
      strictMode: true,
    }
  ),
  templateOnlyComponent()
);
```

If the `<template>` references values in scope, they will be included in an object with a `scope` argument (shown here using the current implementation of the underlying primitives). Thus, this definition—

```js
function isBirthday(dateOfBirth) {
  const today = new Date();
  return (
    today.getMonth() === dateOfBirth.getMonth() &&
    today.getDate() === dateOfBirth.getDate()
  );
}

<template>
  <p>Hello, {{@name}}!</p>
  {{#if (isBirthday @dateOfBirth)}}
    <p>Happy birthday! 🎈</p>
  {{/if}}
</template>
```

—compiles to this output:

```js
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

function isBirthday(dateOfBirth) {
  const today = new Date();
  return (
    today.getMonth() === dateOfBirth.getMonth() &&
    today.getDate() === dateOfBirth.getDate()
  );
}

export default setComponentTemplate(
  precompileTemplate(`
  <p>Hello, {{@name}}!</p>
  {{#if (isBirthday @dateOfBirth)}}
    <p>Happy birthday! 🎈</p>
  {{/if}}
  `,
    {
      strictMode: true,
      scope: () => ({ isBirthday }),
    }
  ),
  templateOnlyComponent()
);
```

Since the values in scope use normal JavaScript semantics, this means that imports also “just work”. Thus, if we extracted `isBirthday` into a separate file for reuse elsewhere, we could import and use it like this:

```js
import { isBirthday } from '../utils/user';

<template>
  <p>Hello, {{@name}}!</p>
  {{#if (isBirthday @dateOfBirth)}}
    <p>Happy birthday! 🎈</p>
  {{/if}}
</template>
```

The compiled output would be just the same as before, save using the imported value:

```js
import { isBirthday } from '../utils/user';
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

export default setComponentTemplate(
  precompileTemplate(`
  <p>Hello, {{@name}}!</p>
  {{#if (isBirthday @dateOfBirth)}}
    <p>Happy birthday! 🎈</p>
  {{/if}}
  `,
    {
      strictMode: true,
      scope: () => ({ isBirthday }),
    }
  ),
  templateOnlyComponent()
);
```

Since the compiled output is a default export, it is a static error to have multiple top-level (i.e. not bound to a name) `<template>`s in a file—because it is a static error to have multiple `export default` statements in a JavaScript file. We should provide a lint rule to error on this case, rather than letting it fail at build or runtime.


#### Bound to a name

A standalone first-class template can also be bound to a name in the module. This allows users to provide locally-scoped modules as well as a single default export, as well as to use modules as a way of grouping related functionality or hiding private functionality while still being able to refactor and extract common code. Given this input:

```js
const Greet = <template>
  <p>Hello, {{@name}}!</p>
</template>
```

The compiled output is:

```js
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

const Greet = setComponentTemplate(
  precompileTemplate(`
  <p>Hello, {{@name}}!</p>
  `,
    {
      strictMode: true
    }
  ),
  templateOnlyComponent()
);
```

Values referenced from the surrounding scope are included in exactly the same way as with the standalone top-level declaration.

Notice that this allows for a host of convenient (and likely common!) new ways of providing a group of related components. For example:

- Genuinely private components could be authored within a file which does not export them, and only exports the public API.
- Components can be authored in their own files as default exports, and then importing them and re-exporting them as a namespace from an entry-point module.
- A namespace export allows an library to supply both a default export as its primary entry point and a series of related components within the same module.

No doubt there are many other such useful patterns which will emerge organically here as they have across the broader JS ecosystem.

Users *should* never reassign the result of binding a template, because Ember will never reevaluate if the name is re-bound later. (Even if we wanted to do that, it would be difficult at best: nothing would notify Ember that it *should* re-evaluate that value!) We should introduce a lint rule forbidding reassignment of a `<template>` to a binding to prevent that confusion.


#### Class body

The compilation output with a class-backed component is similar, but instead of using `templateOnlyComponent`, it uses the backing class. Given this component:

```js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) => {
    this.name = value;
  }

  saveName = (submitEvent) => {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  <template>
    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
  </template>
}
```

The compiled output is:

```js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) => {
    this.name = value;
  }

  saveName = (submitEvent) => {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };
}

setComponentTemplate(
  precompileTemplate(`
    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
  `,
    {
      strictMode: true,
    }
  ),
  SetUsername
)
```

##### Private class fields

In the present design of the template compilation primitives, a template cannot access private fields from the backing class. That is, the following *will not work*:

```js
import Component from '@glimmer/component';

class Example extends Component {
  #aField = true;

  <template>
    <p>The value of the field is: {{this.#aField}}</p>
  </template>
}
```

That is because the compilation output does *not* embed the template in the class' body in any way, but instead associates it *externally* to the class—but private class fields are only accessible within the body of the class itself, per the ECMAScript spec. While we could invest time to change the implementation to avoid this, it is not generally a problem. The only way to get direct access a component instance is to `{{yield this}}` in a component template. For managing privacy, developers should choose to `yield` public API instead (e.g. via a getter, or using `hash` or using a set of positional parameters).

This is a real gap, which we could address in a future RFC. Notably, however, it is *not specific to this proposal*, but applies to *all* proposals built on the current primitives.


### Performance

In normal app code, authors should not *generally* introduce component definitions `<template>`s in contexts where they will be “re-executed,” e.g. in a function body. It is technically possible to create components from a function, like so:

```js
function conditionalComponent(predicate) {
  if (predicate) {
    return <template><p>Cool</p></template>
  } else {
    return <template><p>Lame</p></template>
  }
}
```

However, doing so will have a fairly high costs at runtime. It’s worth remembering what the resulting output is:

```js
function conditionalComponent(predicate) {
  if (predicate) {
    return setComponentTemplate(
      precompileTemplate(`<p>Cool</p>`, { strictMode: true }),
      templateOnly()
    );
  } else {
    return setComponentTemplate(
      precompileTemplate(`<p>Lame</p>`, { strictMode: true }),
      templateOnly()
    );
  }
}
```

The problem here is that this requires re-running both the creation of the template-only empty backing instance which has `null` for `this`, and the association between the two. As described above, the template precompilation also happens during the build, which eliminates some but not all of the apparent cost here; but the other parts are needlessly dynamic and expensive.

In this scenario, users can accomplish the same thing by manually hoisting the component definitions to module scope:

```js
const Cool = <template><p>Cool</p></template>;
const Lame = <template><p>Lame</p></template>;

function conditionalComponent(predicate) {
  if (predicate) {
    return Cool;
  } else {
    return Lame;
  }
}
```

This is not a hard error because there *are* legitimate use cases for this, including taking advantage of values which are only in scope within the body of a function. (Test modules alone provide good motivation here; but there are many such examples in app code as well.) Notice that this is no different than any other concern around other costly operations needlessly happening in a function body repeatedly.

See further discussion below under [**How We Teach This**](#how-we-teach-this).


### Interop

Since all existing components already work using the same low-level primitives the new system uses, strict-mode components using `<template>` can import and invoke components authored in Ember’s loose mode format. Similarly, since loose mode components are resolved to a component which is the default export of a module in the correct/conventional location on disk, components authored in strict mode with `<template>` and exported as the default export in that conventional location will be resolve-able by loose mode components as well.

There are two qualifications to the interop story: a minor one around named exports and a more significant one around non-colocated templates.


#### Named exports

Components exported as *named* exports will not be available in loose mode: resolution only evaluates default exports. This is a temporary incoherence which will be resolved as the ecosystem migrates to strict mode. There are also a number of workarounds for this issue, including yielding components from a default export component and creating reexport-only modules to allow loose-mode access.

For an example of the reexport-only pattern, consider a module `app/components/named-only.js` with two named export components:

```js
export const Greet = <template>
  <p>Hello, {{@name}}!</p>
</template>

export const Farewell = <template>
  <p>Goodbye, {{@name}}!</p>
</template>
```

A user wishing to make these available to loose mode could introduce two new modules:

- `app/components/named-only/greet.js`:

    ```js
    export { Greet as default } from '../named-only';
    ```

- `app/components/named-only/farewell.js`:

    ```js
    export { Farewell as default } from '../named-only';
    ```

Then a loose-mode component could invoke them like `<NamedOnly::Greet @name="Chris">` and `<NamedOnly::Farewell @name="Krycho" />`. Note that this pattern is not at all *necessary* for migration, but may be useful.


#### Non-colocated templates

Since the same time as the Ember Octane release, Ember has supported “colocated templates,” where the template file for a component can live next to it in the `app/components` or `addon/components` directory, instead of in the `app/templates/components` or `addon/templates/components` directory:

```
my-ember-app/
  app/
    components/
      example.js
      example.hbs
```

Although this appears to be merely a user-facing convenience, there is a real and important difference at the implementation level which currently prevents first-class component templates from using classic, non-colocated templates:

Colocated templates are merged into the sibling JavaScript module at build time and set as the template for the component using `setComponentTemplate`: the same primitive used by first-class component templates. This includes template-only components, for which Ember's build synthesizes a JavaScript module and uses `templateOnlyComponent()`—again, just as `<template>` does.

By contrast, classic/non-colocated templates are *not* merged into the associated JavaScript module (if any). They remain as their own distinct module at runtime. Those template modules can be looked up via the AMD module system or Ember's DI registry, and Ember connects them to components via the same system it always did before the introduction of the `setComponentTemplate` primitive (and the same way it continues to connect the route-controller-template triplet). Critically, this means that as of today, Ember does *not* connect non-colocated templates to the associated class (whether backing class or `templateOnlyComponent()`-generated) using `setComponentTemplate`. This means that the corresponding `getComponentTemplate()` lookup used when resolving those components does not work. First-class component templates which reference non-colocated component templates will build successfully, but *do not render anything for them*.

This is a fairly serious developer experience problem, because it fails *invisibly* (see [this demo repository][non-colo-failure] to see this failure mode in practice).

[non-colo-failure]: https://github.com/chriskrycho/fcct-interop-demo

We can address in one of two ways:

- Introduce support into Ember to associated non-colocated templates with their associated classes.
- Introduce debug output which informs users that they must first migrate the referenced component to use colocation.

Of these, the second option is preferable.[^deprecated-non-colo] It has significantly lower risk of introducing bugs in the framework along the way, because it only requires adding some debug alerting and does *not* require changing the semantics or implementation of long-standing Ember features. It is [straightforward to codemod][colo-codemod] to colocation.

[^deprecated-non-colo]: We may additionally wish to entirely deprecate non-colocated component templates as part of Polaris. However, even if we do so, we still *must* provide that debug output for the sake of the transition period, not least since that deprecation can only target Ember 5 at the earliest.


### The “prelude”

While all values used in templates must be explicitly in scope, Ember[^glimmer-prelude] will provide some via a “prelude”.[^prelude] These are always in scope and do not need to be imported. See [RFC #0496: Handlebars Strict Mode: Keywords][rfc-0496-keyword] for a detailed list of keywords and imports.

[rfc-0496-keyword]: https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html#keywords

[^glimmer-prelude]: Glimmer.js may provide its own prelude. While long-term the two should likely align, this RFC simply takes the _status quo_ as a given

[^prelude]: “Prelude” is the conventional name for this functionality in programming language design. See e.g. the discussion from [Rust’s `std::prelude` docs](https://doc.rust-lang.org/std/prelude/index.html).


### Tooling

To support the new format, we need to update tooling across the ecosystem to understand the format.


#### Syntax highlighting

First, we need syntax highlighting support across the ecosystem. Support already exists [for VS Code][vsc-highlighting], which represents the single largest group of web developers; as well as for any tool which can use [a tree-sitter grammar][tree-sitter-highlighting] (e.g. Neovim).

We will also need to implement support in [Linguist](https://github.com/github/linguist) for GitHub syntax highlighting.

Beyond that, we should encourage the community to add support for other editors (IntelliJ, Atom, Emacs, etc.) as well as for tools like [Rouge](https://rubygems.org/gems/rouge) (which powers GitLab syntax highlighting) and other highlighters, but need not treat those as *blocking* adoption of first-class component templates.

[vsc-highlighting]: https://marketplace.visualstudio.com/items?itemName=chiragpat.vscode-glimmer
[tree-sitter-highlighting]: https://github.com/alexlafroscia/tree-sitter-glimmer


#### Blueprints

Component and component test blueprints will need to be updated to support generating the new format. (See [RFC #0785][rfc-0785] for updates to testing to support this more robustly.) During the transition period, we should allow generating both. The rollout will follow the example of the rollout of Glimmer components with Octane:

1. Introduce the ability to author components in the new format with a new `--strict` flag, but leave the default today’s loose mode format. Introduce `--loose` as an explicit flag for using today’s loose mode format.

2. When Ember Polaris[^polaris] is released, change the default to the new format for apps and addons which set `"edition": "polaris"`, while leaving loose mode available via `--loose`, and preserving `--strict` as an explicit flag for the new default.

3. If or when loose mode templates are deprecated, the supporting blueprint infrastructure can be removed, including the `--loose` flag.

The current blueprints support generating a backing class for any existing component template which does not already have a backing class with the `component-class` format. We have two choices about the behavior of that blueprint for strict mode templates:

1. Do not support it. Adding a backing class is simply a matter of adding an import and adding a class.

2. Re-implement the blueprint using an AST transform (which we have prior art for: route generation uses that approach), to add a backing class for an existing default export in the module.

(We should do (1). The community can of course implement (2) if interested.)

We should also update the name of the class generated for a component class. The default behavior of today's blueprint when generating a component is to suffix the class name with `Component`. Thus, running `ember generate component greeting --component-class=@glimmer/component` will produce a class named `GreetingComponent`.[^ts-component-name]

There was room for debate about whether this made sense for naming component classes up till now, since the invocation name was based on the file name (using Ember's resolution rules) and *not* the class name. Now, though, it *will* be based on the imported name, and the standard behavior of auto-import tooling is to import classes by their full name—whether the item is a named export or a default export. When a user goes to auto-complete `Greeting` (e.g. in [Glint][glint]), they will end up with `GreetingComponent`, leading to this sort of thing if they don’t rename it:

```js
import GreetingComponent from './greeting';

<template>
  <GreetingComponent @name={{@user.name}} />
</template>
```

This is obviously undesirable, but avoiding this will mean mean renaming locally after the auto-complete works. That renaming operation is a needless paper cut in the best case of importing a default export. It rises to the level of a significant annoyance when using named imports:

```js
import {
  ButtonComponent as UIButton,
  FormComponent as UIForm,
  InputComponent as UIInput,
} from './ui';

<template>
  <UIForm @onSubmit={{@saveName}}>
    <UIInput @label="Name" @value={{@name}} @onUpdate={{@updateName}} />
    <UIButton @label="Save" type="submit" />
  </UIForm>
</template>
```

And it makes namespace-style imports basically unusable: to invoke *without* `Component` everywhere, you have to rebind all the imports you use!

```js
import * as _UI from './ui';
const UI = {
  Form: _UI.FormComponent,
  Button: _UI.ButtonComponent,
  Input: _UI.InputComponent
}

<template>
  <UI.Form @onSubmit={{@saveName}}>
    <UI.Input @label="Name" @value={{@name}} @onUpdate={{@updateName}} />
    <UI.Button @label="Save" type="submit" />
  </UI.Form>
</template>
```

Accordingly, we should switch to generating *without* a class name: `ember generate component greeting --component-class=@glimmer/component` should produce a class named `Greeting`, *not* `GreetingComponent`. The generated names for routes, services, and controllers can remain as they are, since they are never invoked this way.

[^polaris]: Polaris was announced as planned at EmberConf 2021. This plan assumes we ship Polaris before Ember 5. If we ship Ember 5 first, the dynamics would be much the same, but with the major version as the point when we switch the default instead.

[^ts-component-name]: In TypeScript, this also extends to `GreetingComponentArgs` (or, with [RFC #0748][rfc-0748], something like `GreetingComponentSignature`), which gets *really* unwieldy!


#### Linting and formatting

As with syntax highlighting, we need to support the new format with linting and formatting integration.

For linting, we need to make two changes:

1. Create an ESLint processor which uses the same Babel transform as the core behavior itself (as provided currently by [ember-template-imports][eti]) to make normal ESLint rules (e.g. unused imports and values) work with the template scope.

2. Going the other direction, make it possible to use the existing `ember-template-lint` rules in `.gjs`/`.gts` files. This likely means integrating `ember-template-lint` directly into ESLint, in much the same way that other sub-language integration is done (in the same way that e.g. [eslint-plugin-svelte3][eslint-svelte] integrates Svelte’s custom language).

[eslint-svelte]: https://github.com/sveltejs/eslint-plugin-svelte3

For formatting, we need to implement a custom parser plugin and language which will make Prettier able to format both the host JavaScript files and the embedded templates. This will need to present a view of the non-template parts of the file to Prettier so that it formats the JavaScript correctly without updating the template contents, and vice versa. The primary work here is to make it so that we can leverage Prettier’s existing support for JavaScript/TypeScript and Handlebars in a `.gjs`/`.gts` file (rather than simply ending up with a parse error, as happens when you try to treat those files as pure JS or TS).


#### Language server support

The final piece of tooling we need for supporting this is *language server support*. Language servers using the [Language Server Protocol][lsp] allow a variety of different editors (including e.g. Vim, Visual Studio Code, Emacs, Atom, Sublime Text, IntelliJ, and others) to use a single language server Currently, for uninteresting historical reasons, there are a handful of language servers floating around which Ember developers use. Most important for our purposes are the [Unstable Ember Language Server][uels] and [Glint][glint].

**Neither of these is technically a hard blocker for adopting first-class component templates, but we expect there to be significant community demand for support.** However, the existing support in these tools for the `hbs` experiment means that supporting `<template>` is relatively straightforward: the work needs to be done, but is not especially large. In particular, the same Babel transform which makes `<template>` work and can power ESLint and Prettier integration should provide the necessary information for language servers as well, which can then leverage their own interpretations of templates (e.g. Glint's mapping from a Handlebars template to a TypeScript representation) to provide richer feedback, auto-completion, go-to-definition, documentation hovers, etc.

[lsp]: https://microsoft.github.io/language-server-protocol/
[uels]: https://marketplace.visualstudio.com/items?itemName=lifeart.vscode-ember-unstable
[glint]: https://github.com/typed-ember/glint


#### Codemod

While providing a codemod is not a *hard* necessity, it is much like language server support: there will be high community demand.

Such a codemod will automate the fairly mechanical work of providing a wrapping `<template>` for template-only components and moving the content of an `.hbs` file into a `<template>` on the backing class for class-backed components. To do that, however, there are two major pieces such a codemod will need to address:

- **Identifying where a given component or item came from**. This is not *trivial*, since in most apps the items are all in one big global namespace. This is definitely *tractable*, though. A codemod could start by walking the graph of Ember addons any given library depends on and identifying all names it exports in terms of Ember's standard layout. Then that can be fed into each template module being converted.

    There will definitely be occasional conflicts here, for example when developers have *intentionally* overridden something supplied by an addon. In that case of conflict, the codemod can bail and report it to the end user. (We could use a telemetry-powered codemod like we did for the native classes codemod with Octane, but that's a much higher lift and my own judgment is that the cost-benefit ratio is low enough not to be worth it in *this* case. People generally either work around those or have done it on purpose.)

- **Handling non-colocated templates.** As discussed above in [**Detailed Design: Interop**](#interop), strict mode templates cannot *currently* resolve components where the template is still located in `templates/components` rather than next to a backing class, if any, in `components`. If we do not change this behavior at the framework level, we will need to recommend people start by migrating to colocated templates (which already has [a reliable codemod][colo-codemod]).

[colo-codemod]: https://github.com/ember-codemods/ember-component-template-colocation-migrator


### TypeScript

The type of a component is not affected by this proposal. However, it is worth seeing *how* a component defined using `<template>` works with types, at least for the purpose of documentation (and for integration with the current DefinitelyTyped definitions).

For a class-backed component, there is no change to the *types* of the component when using `<template>`. As described above in the discussion of language servers, tools like Glint will need to provide an interpretation of the body of a `<template>` which correctly understands the scope in which it is embedded, i.e. correctly providing `this` to it.

For a template-only component, defining the type will require a type import to represent that there is a component with no `this` context, etc. Glint already supplies such a type, albeit with the types updated for [RFC #0748][rfc-0748]. For today’s purposes, we can simply augment the [existing types on DefinitelyTyped][DT-toc] with `Args`.

[rfc-0748]: https://github.com/emberjs/rfcs/pull/748
[DT-toc]: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/54d540ab4deb2588c0eff39dadf370cbf0a2dee4/types/ember__component/template-only.d.ts

<details><summary>updated signature on DT</summary>

```ts
declare const A: unique symbol;

// This class is not intended to be directly constructable.
declare class _TemplateOnlyComponent<Args extends {}> {
    // Type brand to simulate a nominal type.
    declare private brand: 'TemplateOnlyComponent';
    // Host to make args "used"
    declare private [A]: Args;
    toString(): string;
}

// Export an interface instead to prevent construction.
// tslint:disable-next-line:no-empty-interface
export interface TemplateOnlyComponent<Args extends {} = {}> extends _TemplateOnlyComponent<Args> {}
type TC<Args extends {} = {}> = TemplateOnlyComponent<Args>

declare function templateOnly(moduleName?: string): TemplateOnlyComponent;

export default templateOnly;

// Shut off automatic exporting.
export {};
```

</details>

Users can then define a named template-only component like this:

```ts
import type { TemplateOnlyComponent } from '@glimmer/component';

const Greet: TemplateOnlyComponent<{ name: string }> = <template>
  <p>Hello, {{@name}}!</p>
</template>
```

(While this empty interface is currently more or less useless from a type-checking perspective—we will need something like Glint to support it—it suffices to provide a hook for documentation tooling such as [TypeDoc][typedoc] or [API Extractor][api-extractor], and thus suffices for the level of support we have for TypeScript today.)

[typedoc]: https://typedoc.org
[api-extractor]: https://api-extractor.com

However, since the top-level `<template>` syntax is sugar for an anonymous default export, there is nowhere to put a type declaration like this. This is a limitation of default exports in JavaScript: functions and classes have names as part of their declarations, but other items do not, so they cannot be both named *and* part of the default export of a module.

Accordingly, we propose an extension to `<template>`, available only in `.gts` files, which uses the following syntax designed to mirror type parameterization in TypeScript but in a way that is straightforward to parse into the desired target format:

```ts
export interface GreetingArgs {
  name: string;
}

<template[GreetingArgs]>
  <p>Hello, {{@name}}!</p>
</template>
```

This syntax for generics has prior art in other programming languages, including Scala, Go, and Ruby’s Sorbet type checker (a cousin of TypeScript, as it were!). It clearly associates the `Args` with the `template`, while *not* putting it in a value space which could conflict with future extensions to `<template>` with “attributes” in the value space.[^emblem-etc]

Given this design, we can also simplify the definition of named components (both forms will of course be legal):

```ts
export interface GreetingArgs {
  name: string;
}

export const Greeting = <template[GreetingArgs]>
  <p>Hello, {{@name}}!</p>
</template>
```

There are two key restrictions here:

1. As mentioned above, this is illegal in the context of a class-backed component, because the component class itself is the host for the signature (and must be to make `this.args` type check correctly).

2. The only thing allowed within the `[...]` is a type available in the local scope. *It is not legal to provide an inline type definition.* However, given the relative verbosity of even today’s component signature, still less the revised version from [RFC #0748][rfc-0748], inline signatures are unlikely to be attractive anyway.

From an implementation perspective, this requires our language parser to handle this variant of the tag, and for the transforms supplied for compilation to properly ignore this for build output but to supply it in an appropriate place for TypeScript-aware tools like Glint to be able to take advantage of it.


### Custom file extension

These tooling considerations together provide the motivation for a custom file extension (`.gjs` and `.gts`). In the case of TypeScript in particular, it is not possible to *remove* errors using a TypeScript language server plugin, which means that in a pure `.js` or `.ts` file, a user would get conflicting reports from TypeScript and (e.g.) Glint. Thus, today, Glint recommends that GlimmerX users *disable TypeScript in their projects*, and rely on only Glint. Taking a lesson from Vue and Svelte, however, introducing a custom file extension allows us to provide a default type for `.gjs`/`.gts` files which makes TypeScript happy in `.js` and `.ts` files, and on top of which tools like Glint can safely add *more* information.[^hbs-custom-syntax]

While both Prettier and ESLint *can* work with `.js` or `.ts`, introducing the new file extension also simplifies the tooling implementation for them. It does mean that tools like GitHub’s Linguist will not work without implementing support, but we need to do that work anyway.

[^hbs-custom-syntax]: Note that this also applies to the `hbs` syntax discussed in [**Alternatives: Template literals (`hbs`)**](#template-literals-hbs).


### Spec

During implementation—before this is the default for Ember apps, and before it advances to **Recommended** if [the Stages RFC](https://emberjs.github.io/rfcs/0617-rfc-stages.html) is implemented before this implementation is finished—we will create a spec for the format we propose here, generalizing it to account for similar potential future extensions:

- to make it easy for tooling authors to know when they have implemented the support correctly, including answering questions about nested invocation, escaping, handling closing tags within comments, etc.

- to enable future design moves in this space—for example, `<style>` blocks for scoped CSS or `<query>` blocks for languages like GraphQL, etc.

- to enable other parts of the JS ecosystem to adopt this—in the same way that JSX is not a React-only syntax but a [spec](https://facebook.github.io/jsx/) which can also be used by e.g. [Solid](https://www.solidjs.com)—since it could be valuable authoring format for Svelte, Vue, and other template-focused/HTML-first frameworks


## Transition path

We will transition to using first-class component templates by default as part of Ember Polaris. To do that successfully, we must:

- implement the features as described in [**Detailed design**](#detailed-design), migrating in the implementation from `ember-template-imports`
- update the [tooling](#tooling):
  - [syntax highlighting](#syntax-highlighting)
  - [blueprints](#blueprints)
  - [linting and formatting](#linting-and-formatting)
  - [language servers](#language-server-support)
- update all [the teaching materials](#how-we-teach-this)

Additionally, an optimal transition will include changes to [language server implementations](#language-server-support) and supply a [codemod](#codemod) from loose to strict mode. (We may be *able* to release this as part of Polaris without those, but the transition will be much more successful with them.)

In terms of rollout, we should deliver features incrementally, allowing users to opt into them via command line flags for Ember CLI (`--strict` and `--loose` for `ember generate component`) and possibly also optional features (e.g. a `"strict-components": true` in `optional-features.json`). Once Polaris arrives, setting `"edition": "polaris"` will opt users into those as new defaults, while allowing use of command line flags to opt into loose mode for a given component. (Later deprecations may remove that, but that is something to resolve at a later time.)

Finally, the Glimmer.js (and thus [GlimmerX][glimmerx]) implementation should update to match this, further decreasing the delta between standalone Glimmer and Ember.


## How we teach this

We describe a `<template>` as representing the *template* for a *component*. When there is no backing class, that’s all there is to the component. When there *is* a backing class, the component also has associated state and behavior. (Notably, this shift already began with Octane, where we generate template-only components by default.)

This explanatory model provides a helpful opportunity, when first introducing the idea of a backing class, to link to deeper-dive materials which let people who want to understand more deeply. In particular, it allows us a place to point out that mechanically, there *is* in fact always an associated component instance (generated via `templateOnlyComponent()`), but it’s just a way for this `<template>` to be hooked into the broader system, rather than a home for state.

**Note:** This is complicated by the need to introduce route templates as well as component templates. The text here assumes that we will, in parallel with this work, resolve the design questions addressed by [RFC #0731][rfc-0731] in something like the design proposed there. Accordingly, it also assumes we will update the generators and the relevant text accordingly. Fundamentally, we *should not* update the guides until we have a resolution for that design space, so they can be updated in a coherent way.


### Guides

Once `<template>` is implemented and tooling is sufficiently stable, we will update the guides with changes along the following lines:


#### Tutorial

One cross-cutting change here will be updating the output from generators, including correct new file extensions. The following discussion of the current sections of the guide *assumes* that change, and addresses concrete *pedagogical* changes we need to make. If a section is not included here, it (a) needs little or no other change beyond the minimum or (b) is dependent on the results of [RFC #0731][rfc-0731] to flesh out the details.


##### Orientation

Here we will need to update the prose to describe that `<template>` marks this as Ember/Glimmer’s special superset of HTML, with prose long the lines of:

> Note that all you need to do to have a working Ember component is to wrap your HTML in `<template>`.


##### Component Basics

Introducing components will see a lot of changes, unsurprisingly:

1. The introduction to components in updated guides will depend on the specific design choices we make in [RFC #0731][rfc-0731]. One possible approach here will be to note that we have already seen components in practice, if the decision in that space is that routes simply invoke a component template. Otherwise we may indicated that components are similar to route templates, but are self-contained.

2. The use of `<CapitalizedComponents />` is no longer required, but remains a *helpful convention*.[^resolver-capitalized-components] If someone does `const foo = <template>...</template>`, they will be able to invoke that as `<foo />` elsewhere. The notes in this section as well as about `LinkTo` will need to be updated to describe it accordingly.

3. After introducing `<Jumbo />` with updated use of a wrapping `<template>`, discuss *importing it* into the route (component) template which uses it. This is a good place to describe how `.gjs` can use JS features, and hint that we’ll see more of this later; it is also a good opportunity to note that we *could* have defined `<Jumbo />` locally, but that we moved it to a separate file because we’re sharing it across multiple different components.

4. Our discussion of the testing will need to be updated to include importing the components under test, and to use `<template>` rather than `hbs` strings for the `render` calls.[^testing-rfc]

[^resolver-capitalized-components]: Historically users *had* to use this convention, but only because that was the decision for how the resolver would work.


##### More About Components

We can simply *remove* the discussion of namespaced components, in favor of simply describing the use of normal JS imports to accomplish the same goal. However, here we can also note that JavaScript modules are a great way to organize groups of related components, and show how we might use namespace-style imports (`import * as Rental from '';` and then `<Rental.Image />` within a `<template>`) for this kind of organization.[^namespace-deprecation]

[^namespace-deprecation]: Attentive readers will likely have noticed that this makes the namespace sigil a candidate for later deprecation, since it will be entirely redundant once the ecosystem moves fully to strict mode and template imports. However, that question is best left to a potential future RFC deprecating loose mode.


##### Interactive Components

The discussion of adding behavior to components will need to be updated to account for the design *and* the new possibilities in the space:

1. Show that when we generate a class for an existing component, it  adds the `Component` import, creates a wrapping class, and moves the template into the body of that class. Here, teach the mental model that a `<template>` which is part of a class body has access to the instance properties on the backing class.

2. When discussing use of values from `ENV`, instead of providing a getter on a backing class, start by creating a `TOKEN` constant in module scope, and show that it is available to access in the template. In the following section, which shows args being used in the template, simply use that `TOKEN` value in the template directly, `access_token={{TOKEN}}`.


##### Reusable Components

This section provides us an opportunity to show how useful it can be to introduce local functions. The code samples here currently use a backing class, but they only do so to provide a home for getters which provide an encoded URI for the Mapbox token and derive the `src` from the arguments.

(I will provide this example in full here in part because it shows powerfully the pedagogical value of this RFC!)

The Mapbox token value is not reactive and therefore the computation has no reason to exist on a backing class *at all*. It is only there today because *without* first-class component templates, it requires introducing the heavier notion of helpers off in a separate file. (The more so given that the guides currently assume classic, i.e. pre-[RFC #0756][rfc-0756] helpers using the `helper` function and not a standalone function!) With `<template>`, it can simply become a constant value defined in local scope:

```js
import ENV from 'super-rentals/config/environment';

const TOKEN = encodeURIComponent(ENV.MAPBOX_ACCESS_TOKEN)

<template>
  <div class="map">
    <img
      alt="Map image at coordinates {{@lat}},{{@lng}}"
      ...attributes
      src="https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/{{@lng}},{{@lat}},{{@zoom}}/{{@width}}x{{@height}}@2x?access_token={{TOKEN}}"
      width={{@width}} height={{@height}}
    >
  </div>
</template>
```

Similarly, while `src` *is* computed from reactive data, there is once again no reason to compute it *in a class* if we are not going to use the class to store state. We can just write a local function and use it (and use that to note that we handle named arguments, too):

```js
import ENV from 'super-rentals/config/environment';

const TOKEN = encodeURIComponent(ENV.MAPBOX_ACCESS_TOKEN)
const MAPBOX_API = 'https://api.mapbox.com/styles/v1/mapbox/streets-v11/static';

function source({ lng, lat, width, height, zoom }) {
  let coordinates = `${lng},${lat},${zoom}`;
  let dimensions = `${width}x${height}`;
  let accessToken = `access_token=${TOKEN}`;

  return `${MAPBOX_API}/${coordinates}/${dimensions}@2x?${accessToken}`;
}

<template>
  <div class="map">
    <img
      alt="Map image at coordinates {{@lat}},{{@lng}}"
      ...attributes
      src={{source lng=@lng lat=@lat width=@width zoom=@zoom}}
      width={{@width}} height={{@height}}
    >
  </div>
</template>
```

Notice the results of this pedagogically:

- We have asked people to write *less code*: fewer imports, and less overall syntax.
- The code they *do* write feels much more HTML-first. The template can stay almost exactly as it was, with no shift to a backing class.
- For developers who have experience with other frameworks, this feels familiar, but with an Ember twist.

At this point we could *additionally* show that we could introduce a backing class, and discuss the trade-offs of introducing a class when we don't have any other local state. This also allows us to encourage just using functions unless you *do* need local state.

The section “Getting JavaScript Values into the Test Context” will also be possible to simplify: we will simply be able to introduce tracked state locally and update it directly, without special testing helpers. That will dramatically reduce the number of bespoke ideas we have to cover here. Much of the related work will be addressed in other RFCs, but being able to use the *same* primitives to bring values into scope for tests as we do in apps (immediately above!) will be very helpful in reducing what we have to cover in this section.


#### Core Concepts: Components

This entire section will also need to be substantially reworked. Once again, I am here summarizing the changes rather than trying to rewrite the guide in place. Each section represents a page to be changed; if a section is not mentioned, it needs no substantive changes—likely only switching over to using the `<template>` wrapper.

At some point in the course of this discussion, we should call out (e.g. with a “Zoey says” block) that users should treat `<template>` the same way they treat a costly function which produces a result for the life of the whole app, and should therefore avoiding using `<template>` in function bodies rather than hoisting them, etc. This cannot be a hard and fast rule about where `<template>` definitions live, because there are plenty of ways to do it safely, and what’s more we *need* to do it in test modules. The point is simply to align people’s mental model for `<template>` with *other* costly operations, since these concerns are not specific to component creation.


##### Introducing Components

Unsurprisingly, this is the section which will see the most sweeping changes.

- As described in the tutorial, our introduction will depend on the design chosen for route templates. We will either note that we’ve already seen our first component, if the application template *was* a component, or note the similarities and differences between route templates and components otherwise.

- We can continue to show breaking the component out into separate files, with a top-level `<template>` (serving, so far implicitly, as a default export).

- Then, back in the application file, we can show using `import` to refer to it.

- As in the tutorial, the discussion around naming will need to be updated to indicate that we capitalize by *convention*: it will no longer be a hard requirement. Likewise, the “Zoey says...” will go away because we will no longer be using resolution to get imports.

- After showing the other extraction-style refactors, we can show how components which don't need to be exported can just be defined locally with a `const` declaration, and explain that the standalone `<template>` tag is sugar for a default export. This will also provide the first hook for defining helpers etc. locally in following sections.

- We will entirely drop the folder namespace syntax (`::`) discussion, in favor of showing how normal JS imports handle that concern—including showing how the combination of named exports and namespace-style imports handle those. (This will necessitate reworking the example, which currently uses that namespacing as a means of scoping.)


##### Helper functions

Instead of introducing `app/helpers` and the resolution-based lookup, we can introduce the helper as a local function in the component which needs it. This will be the first place where this guide explicitly calls out that components have access to values in their surrounding scope, just like normal JavaScript. This will be a good point to call out the power and versatility this affords.

Additionally, instead of the *next* section being the place where we first identify that JS is needed to make our UI dynamic, we will address that here. The next section can then build on that by showing how classes make certain patterns *easier*.


##### Component State and Actions

Here, the content will need to shift in two ways:

1. The motivation for introducing a backing class shifts slightly: we have the ability to have state at the module level already, including via class-backed helpers. What we need is a way to have state that is for *each component instance*. A class is JavaScript’s first-class way of doing that, so we have a version of first-class component templates which supports it!

2. Having made the motivation clear, we can show the `<template>` in the body of the class and explain that it is exactly the same as a standalone template component, except that it now has access to the backing class for local state, "actions", etc.


##### Template Lifecycle, DOM, and Modifiers

Once again, many of the changes here will be mechanical: just using the new syntax. However, this also provides another opportunity to discuss (and demonstrate) the value of local-only vs. exported functionality. Both of the main custom modifier examples here currently show highly-reusable examples of modifiers which *should* be exported and should indeed probably live in their own modules. Accordingly, we might find an example which shows the value of having a locally-scoped modifier—e.g. something which manages the private details of an `iframe`.


### API Docs

There is presently no API for `<template>` itself, as proposed in this RFC, though it leaves room for future RFCs to do so.[^emblem-etc] Since there is no import location, we should cover it under the `@glimmer/component` module documentation. This will be a natural home for it, since we will always discuss it in the context of components.

[^emblem-etc]: Historically, for example, many Ember apps used [Emblem][emblem] as a templating language—and it is still possible to do so today! In the future, that could be supported with `<template lang="emblem">`. This would also be an easy home for experiments with a Svelte-like syntax with e.g. `<template lang="svelte">` etc.

[emblem]: http://emblemjs.com


### Existing Ember users

The Ember community has long experience with the idea that we can only have *one* component per file, and that component templates and the backing class must always be in separate files. The name of this feature, *first-class component templates*, is designed to help explain how it relates to that historical experience. In the past, templates in many ways were second-class citizens of the overall experience of authoring an Ember app—especially for template-only components. Adding even a small amount of functionality to a template came with a lot of friction and other downsides: switching to a class-backed component, or introducing a globally-available helper. Now, adding a local helper utility is no different for a template-only component than it is anywhere else: write a function!

As a result, we can teach this to existing Ember users as taking everything they already know about how templates work, while making it faster, easier, and lighter-weight to solve common problems. The one significant new concept here is the `<template>` tag. We can describe that to existing features as the one addition which raises templates up to being a first-class tool in your app or addon. For this audience, we can explicitly connect standalone `<template>` to “template-only components,” a long-standing concept. (I did *not* use this verbiage in the overall discussion because this design, even more than Octane, helps make template-only components the *default* kind of component, with class-backed components the exception and thing to treat as a special case.)

A blog post can introduce the feature along these lines when the feature ships, with examples showing how it simplifies existing patterns and enables new capabilities. For simplifying existing patterns, we might pull the same Mapbox example from the guides shown above. For enabling new capabilities, we could show how it enables using native CSS Modules with none of the hacks required by Ember CSS Modules.


## Drawbacks

- Since there is no notional import for `<template>`, there also isn’t a notional home for API documentation for it other than components.

- We must build a custom tooling integration with Prettier for the file format to *parse*. (As discussed below, we must build custom tooling to *use* Prettier for other options, but Prettier can *parse* them without custom tooling.)

- Developers may put an unreasonable number of components, helpers, modifiers, etc. in a single file, degrading the maintainability of that module. However, the counterpoint here is that large files are already common in many code bases, with or without this tool. Indeed, that happens in non-UI and UI code bases alike!

    Moreover, experience from frameworks which restrict component authoring formats to a single component per file, including Ember’s loose mode templates as well as Vue and Svelte SFCs, is that those components themselves tend to balloon in size. Sometimes that’s because everything in those components is notionally related or because much of it should be treated as "private API" for that component (even if it would be helpful to refactor small local components). Sometimes it is just because of the annoying overhead of needing to create a separate file to break the huge component into smaller pieces, and then import them all (or make them globally available, in Ember loose mode template!).

    The analogy here would be if a JavaScript module could only have a single function or class in it, or a CSS file could only have a single declaration in it, regardless of what actually made sense for that particular module.

- The syntax offered here, `<template>`, overlaps with [a platform built-in][platform-template], and would look very strange if a user *did*  want to use the built-in form. This may provoke some degree of confusion for users if they are familiar with it. However, there are several reasons to think this drawback is not significant:

    - In practice `<template>` is very-little used, and only in the context of progressive enhancement with vanilla JS—not with frameworks.

    - Although it looks a little odd, the platform-native `<template>` can still be nested *within* a `<template>` tag as defined here.

    - Other frameworks (most notably Vue) have used `<template>` in much the same way we are here with no major confusion on the part of developers.

    - Most importantly, there is no *actual* conflict with the platform built-in, since `<template>` is not *JavaScript* syntax, which is where we are using it.

    As a bonus: in a certain sense, the use of `<template>` here “rhymes” with the version from the platform: it represents the dynamic HTML content associated with some JavaScript functionality.

- Some developers prefer to keep a hard file-level separation between JavaScript and HTML. This proposal allows that to continue for loose mode components, but not for strict mode components, and strongly suggests a future where it is *not* possible (if we deprecate loose mode in the future).

[platform-template]: http://developer.mozilla.org/en-US/docs/Web/HTML/Element/template


## Alternatives

Within the major strokes of this design proposal, we could tweak the invocation for the template space to clarify that it does *not* overlap with the built-in `<template>` tag.

- Use `<Template>` or `<Glimmer>` or similar. This would disambiguate it from the built-in `<template>`, but would introduce ambiguity with component invocation.
- Use a new sigil—much as we use `<:main>...</:main>` for named blocks, we could do `<[template]>...</[template]>` or something similar. While verbose and not especially pretty, this avoids overloading the platform tag.

There are also alternative possibilities for defining the type of a non-class-backed `<template>`, for the choice of consistency of `<template>` between class-backed and non-class-backed components, and for the syntax for *some* sort of strict mode templates.


### TypeScript signature

Instead of adding the generic position to `<template>`, we can simply recommend that TypeScript users always create a named `<template>` with a `const` binding, and then `export default` that named export:

```js
import type { TC } from '@glimmer/component';

const Greet: TC<{ name: string }> = <template>
  <p>Hello, {{@name}}!</p>
</template>

export default Greet;
```

(Users may also be tempted use an `as` cast after the `<template>`—but this is unsafe: it allows users to unsafely provide a narrower type than the item actually provides, whereas assignment only allows *widening* of the types.)

This works, and it simplifies the burden of the tooling implementation, but it comes with the significant downside of making a *much* worse authoring experience for TypeScript users than for JavaScript users.


### Distinguishing class-backed and template-only components

There is a small pedagogical difficulty, suggested by some of the language above, about the fact that we use `<template>` here to represent both the entirety of a component, when it is free-standing; and also the template portion of a component, when it is embedded in a class. Similarly, the proposed syntax for a TypeScript type signature must forbid the type parameter in class-backed components, because the correct home for the type parameter is on the backing class itself.

We could instead introduce `<component>` and `<template>` as separate constructs, where `<template>` provides a template definition for the class it is embedded in, and `<component>` defines a standalone component. In this approach, `<component>` could *not* be used within the body of a class, nor `<template>` in a standalone form.[^route-template]

The major downside here is that the transformation of adding a backing class becomes a bit more involved: not just moving a `<template>` definition into the new class body, but moving a `<component>` into the new class body and then changing it from `<component>` to `<template>`. Notice, however, that the move for TS users *already* involves some further transformation, even if we chose not to ship the `<template[Signature]>` form, because type parameters have to move. The same goes for any documentation attached to a `<template>` declaration when moved to a backing class: it has to go on the class itself instead.

**This is a reasonable alternative and *we should strongly consider adopting it*.** I did not propose it here because I think just using `<template>` is more or less comparable to having both `<template>` and `<component>` on balance, and having *only* `<template>` feels a little nicer. That is, however, a purely subjective judgment and I would be perfectly happy with a solution using both `<component>` and `<template>`.

[^route-template]: One other *possible* upside is that we could then in theory use `<template>` in the context of routes—but it is not clear that that is preferable to the direction suggested by [RFC #0731][rfc-0731]. My own judgment is that using `<template>` that way would be a mistake.


### Alternative syntaxes

Additionally, there are three major alternatives which Ember community members have proposed in the design space:

- **imports-only:** a design which uses “front-matter” to add imports, and only imports, to templates, while maintaining everything else in today’s system
- **single-file components (SFCs)**: a design which follows the example of Svelte and Vue and make HTML the basis of a component, and use a `<script>` tag to host JavaScript functionality
- **`hbs` template literals**: a design which mirrors the `<template>` design quite closely, but uses `hbs` template literals similar to those we use in tests today

I discuss each of these briefly below; for a *much* longer and more thorough discussion, please see the \~16,000-word series of blog posts I wrote as a deep dive: [**Ember Template Imports**](https://v5.chriskrycho.com/journal/ember-template-imports/). Notably, as I alluded to above, *all* of them require custom parsing implementation for tooling, especially including Prettier and language servers.


#### Imports-only

The imports-only design borrows the idea of “front-matter” from many text authoring formats, using something like `---`-delimiters to introduce a new, non-Handlebars area at the top of a template which allows exactly and only *imports* to appear. As with all strict-mode designs, all non-built-in values must be imported here. Thus, the *template* for the final component shown in the motivating example might appear like this:

<details><summary>motivating example shown with imports-only</summary>

- `greet.hbs`:

    ```hbs
    <p>Hello, {{@name}}!</p>
    ```

- `set-username.js`:

    ```js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';

    export default class SetUsername extends Component {
      @tracked name = '';

      updateName = ({ target: { value } }) => {
        this.name = value;
      }

      saveName = (submitEvent) => {
        submitEvent.preventDefault();
        this.args.onSaveName(this.name);
      };
    }
    ```

- `set-username.hbs`:

    ```hbs
    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
    ```

- `replace-location.js`:

    ```js
    export default function replaceLocation(el, { with: newUrl }) {
        el.contentWindow.location.replace(newUrl);
    });
    ```

- `generate-avatar.js`:

    ```js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';
    import Greet from './greet.glimmer';
    import SetUsername from './set-username.glimmer';

    export default class GenerateAvatar extends Component {
      @tracked name = "";

      get previewUrl() {
        return `http://www.example.com/avatars/${name}`;
      }

      updateName = (newName) => {
        this.name = newName;
      };
    }
    ```

- `generate-avatar.hbs`:

    ```hbs
    ---
    import Greet from './greet';
    import SetUsername from './set-username';
    import replaceLocation from '../modifiers/replace-location';
    ---

    <Greet @name={{this.name}} />
    <SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    />

    {{#if (gt 0 this.name.length)}}
      <iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      >
    {{/if}}
    ```

</details>

The major upside to this is that it is the smallest possible delta over today’s implementation. It also allows users who appreciate the separation between JavaScript and template files to maintain that. However, it has a number of significant downsides which render it much worse than the first-class component templates proposal, and in some cases worse than the _status quo_.

First, as with today’s _status quo_, it does not allow locally-scoped JavaScript values (including helpers and modifiers but also ecosystem tooling like GraphQL values, CSS-in-JS tooling, etc.) even when that is a perfectly reasonable design decision.

Second, it substantially complicates the implementation of tooling for language servers, which have to do extra work to detect the presence of a backing class and “stitch together” the backing class and the template if a backing class does exist.

Third, Since there are separate files for a template and its backing class, users may be tempted try to implement JavaScript functionality in the module for the backing class, and import it in the template:

```js
import Component from '@glimmer/component';

export function isBirthday() {/*...*/}

export default class MyComponent extends Component { /*...*/ }
```

```hbs
---
import { isBirthday } from './my-component';
---
{{#if (isBirthday @user.name)}}
  <p>Happy birthday, {{@user.name}}!</p>
{{/if}}
```

While a colocated template (the default since Octane) is part of the same module as the backing class, this does technically work![^recursive-module] However, it’s the kind of extremely surprising and weird thing we would generally try to avoid pedagogically—it requires us to explain that these two separate files (`.js` and `.hbs`) are combined into a single module at build time… and that we have nonetheless kept them separate at authoring time, requiring these kinds of workarounds.[^recursive-import-perf]

Perhaps most critically, this is **much worse than the _status quo_ for tests**.

If we support strict mode for tests, then out of the box we require people’s test authoring format to become *massively* more verbose and less useful, with imports in every single test `hbs` string, to support strict mode for tests:

```js
import { module, test } from 'qunit';
import { hbs } from 'ember-cli-htmlbars';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';

module('demonstrates the problem', function (hooks) {
  setupRenderingTest(hooks);

  test('by rendering an imported component', async function (assert) {
    await render(hbs`
      ---
      import ComponentToTest from 'my-app/components/component-to-test';
      ---

      <ComponentToTest />
    `);
  });

  test('then again with an argument', async function (assert) {
    await render(hbs`
      ---
      import ComponentToTest from 'my-app/components/component-to-test';
      ---

      <ComponentToTest @anArg={{123}} />
    `);
  });
});
```

There are two major problems to notice here:

1. There is no way to import `ComponentToTest` here just once. This overhead will multiply across the number of items to reference in a given test—every component, every helper, every modifier!—as well as across the number of tests. This is a *large* increase in the burden of testing compared to today.

2. This also requires us to maintain, *and to teach*, the `hbs` handling for tests (or to design some replacement for it), on top of the “regular” template handling for components. This is the same situation as in Ember apps today—but since first-class component templates allow us to *improve* the consistency between app code and test code, this counts as a negative by comparison!

To get around this, we could continue to support a completely separate design for testing than for app code. In that case, though, if we want to support strict mode templates in tests, we need a separate authoring format for tests from app code. In fact, it basically requires that we fully implement something like the first-class component templates design!

[^recursive-module]: To see this for yourself, follow the instructions in [this gist](https://gist.github.com/chriskrycho/dc5adabd80c04d405c7a4894c0ffb99e). I had to test this out myself, and while it’s actually *very good* that modules work this way, I was initially surprised by it! If you’re curious: imports and exports are *static* and so are analyzed before the module is executed.

[^recursive-import-perf]: Without additional post-processing, this would also introduce extra runtime overhead in terms of the imports!


#### SFCs

Single File Components (hereafter SFCs) start with an HTML baseline and layer on functionality in a `<script>` tag, modeled on HTML’s own design, but with extra semantics supporting imports and making an `export default class extends Component` statement provide the `this` for the template context. It can, however, define modifiers and helpers local to the component. You can think of this as a fairly natural (and HTML-like) extension to the imports-only design.

<details><summary>motivating example shown with SFCs</summary>

- `greet.glimmer`:

    ```hbs
    <p>Hello, {{@name}}!</p>
    ```

- `set-username.glimmer`:

    ```hbs
    <script>
      import Component from '@glimmer/component';
      import { tracked } from '@glimmer/tracking';

      export default class SetUsername extends Component {
        @tracked name = '';

        updateName = ({ target: { value } }) => {
          this.name = value;
        }

        saveName = (submitEvent) => {
          submitEvent.preventDefault();
          this.args.onSaveName(this.name);
        };
      }
    </script>

    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
    ```

- `generate-avatar.glimmer`:

    ```hbs
    <script>
      import Component from '@glimmer/component';
      import { tracked } from '@glimmer/tracking';
      import Greet from './greet.glimmer';
      import SetUsername from './set-username.glimmer';

      function replaceLocation(el, { with: newUrl }) {
        el.contentWindow.location.replace(newUrl);
      }

      export default class GenerateAvatar extends Component {
        @tracked name = "";

        get previewUrl() {
          return `http://www.example.com/avatars/${name}`;
        }

        updateName = (newName) => {
          this.name = newName;
        };
      }
    </script>

    <Greet @name={{this.name}} />
    <SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    />

    {{#if (gt 0 this.name.length)}}
      <iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      >
    {{/if}}
    ```

</details>

This is very attractive in some ways, but it comes with three downsides:

First, SFCs do not allow multiple components to be defined in a single file. This has been an ongoing sticking point with the Vue and Svelte designs, such that there is even an [RFC for Svelte for supporting at least a subset of this functionality](https://github.com/sveltejs/rfcs/blob/inline-components/text/0000-inline-components.md).

Second, the scope handling for the default export is unusual and requires additional teaching.

Third, and again most critically: as with the imports-only design, **the SFC design requires that we continue to support a completely separate design for testing than for app code or use an incredibly verbose test authoring format.** If we maintain the same authoring format, we end up with the same problems as in the imports-only proposal:

```js
import { module, test } from 'qunit';
import { hbs } from 'ember-cli-htmlbars';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';

module('demonstrates the problem', function (hooks) {
  setupRenderingTest(hooks);

  test('by rendering an imported component', async function (assert) {
    await render(hbs`
      <script>
        import ComponentToTest from 'my-app/components/component-to-test';
      </script>

      <ComponentToTest />
    `);
  });

  test('then again with an argument', async function (assert) {
    await render(hbs`
      <script>
        import ComponentToTest from 'my-app/components/component-to-test';
      </script>

      <ComponentToTest @anArg={{123}} />
    `);
  });
});
```

Besides having all the same problems as the imports-only approach does, notice that this also substantially increases the cost of tooling even at the level of syntax highlighting, because now we need multiple nested layers of syntax highlighting: `hbs` strings include both HTML and JavaScript! While some syntax highlighters support this, it is a much higher lift for those which do not.

And, once again, avoiding those problems more or less requires that we fully implement first-class component templates to avoid this!


#### Template literals (`hbs`)

The “template literals” design takes as its starting point the `hbs` template strings Ember has used for testing since the 1.x era. It is relatively similar to the `<template>` design, in that it uses JavaScript/TypeScript files as the basis for its design. Unlike `template`, it uses an explicit `hbs` import, presumably from `@glimmer/component`. For components with a backing class, the template is defined as a static class field.

<details><summary>Motivating example shown with <code>hbs</code></summary>

```js
import Component, { hbs } from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

const Greet = hbs`
  <p>Hello, {{@name}}!</p>
`;

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) => {
    this.name = value;
  }

  saveName = (submitEvent) => {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  static template = hbs`
    <form {{on "submit" this.saveName}}>
      <label for='name'>Set username:</label>
      <input
        id='name'
        value={{this.value}}
        {{on "input" this.updateName}}
      />
      <button type='submit' disabled={{eq this.value.length 0}}>
        Generate
      </button>
    </form>
  `;
}

function replaceLocation(el, { with: newUrl }) {
  el.contentWindow.location.replace(newUrl);
}

export default class GenerateAvatar extends Component {
  @tracked name = "";

  get previewUrl() {
    return `http://www.example.com/avatars/${name}`;
  }

  updateName = (newName) => {
    this.name = newName;
  };

  static template = hbs`
    <Greet @name={{this.name}} />
    <SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    />

    {{#if (gt 0 this.name.length)}}
      <iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      >
    {{/if}}
  `;
}
```

</details>

This has a few significant advantages!

First, unlike with the `<template>` proposal, Prettier can *parse* a file using `hbs` string with no further changes. (It cannot *format* them, however: it treats the contents of the string opaquely.) This is a small, but significant, decrease in the cost of supporting the format both up front and over time.

Second, it feels familiar to developers in the Ember ecosystem used to using `hbs` strings with their tests.

Third, the broader JavaScript ecosystem makes use of a number of template string syntaxes, e.g. with `css` from [Emotion][emotion] or [`graphql` from Apollo][graphql], so it has familiarity for people coming from *outside* the Ember ecosystem as well.

Fourth, we do not need to introduce custom syntax for providing types: we can type `hbs` as a function which accepts the args/signature as a type parameter, and teach people to perform.

Finally, it shares many of the other strongly-positive properties of the `<template>` design, including that it works exactly the same way for testing and app code.

These advantages are strong enough that this is *absolutely* the second-best move in the design space for us, and given a choice between maintaining the status quo and using `hbs` (i.e. if `<template>` were off the table), ***we should absolutely choose `hbs`***.

Those positives notwithstanding, **it also has some significant disadvantages compared to `<template>`**.

First, the design re-purposes JavaScript syntax and gives it totally different semantics—like `<template>` does with HTML, but with *zero* signal from the context that it is doing something special.

- `hbs` is *not* actually a template string literal; it is a compile-time macro. Attempting to use it like a template string literal (e.g. by using `${...}` string interpolation) is a build-time error. This substantially undercuts the familiarity of the design: `css` and `graphql` and similar are *actual* string templates, not compile-time macros, and accordingly developers can use normal JavaScript semantics with them.

- The use of `static template = ...` has the wrong semantics: static class fields do not have access to an instance’s `this`—but templates quite expressly *do*. The whole point of a component with a backing class is to provide a normal JavaScript `this`, so this is a significant mismatch, which has consequences for both teaching and tooling.

Second, the learning path is *much* less gradual: the simplest possible component requires showing and at least minimally explaining JavaScript import and export semantics and template literals *and* that it isn’t a normal template literal as described above.

Third, explaining what exactly `hbs` invocations produce is also strange: they aren’t actually JavaScript expressions, but they *appear* to be. In a template-only context, “invoking” `hbs` produces a component; in a class, it produces the *template* for that component. This is the same as with the `<template>` proposal, but it has the additional quirk of using JavaScript syntax to do it, rather than shifting languages.

Fourth, while supplying a type definition which allows `hbs` to receive a type parameter initially appears nicer than the custom syntax for `<template>`, that form *appears* like an unsafe type cast in TypeScript, the same as writing `as TC<Signature>` after the definition. In terms of how we implement the transform, it would actually be safe in practice (the compiled output would be the same as with `<template[Signature]>`, and therefore would constrain the body of the template in the same way)—but only because the thing passed to `hbs` is *not* a template string. People can therefore not rely on any of their intuitions on the TypeScript side, either.

Net, while there are some nice features to the `hbs` proposal, it comes out significantly worse than `<template>` in most ways we care about. The decreased tooling costs are real, but they are much smaller than the other downsides of the format.


## Unresolved questions

- Introducing a new file extension also provides an easy opportunity to change the default component manager for class-backed components in, and only in, the new file type—eliminating the need to subclass from Glimmer's `Component`. From the motivating example:

    ```js
    class SetUsername {
      @tracked name = '';

      updateName = ({ target: { value } }) => {
        this.name = value;
      }

      saveName = (submitEvent) => {
        submitEvent.preventDefault();
        this.args.onSaveName(this.name);
      };

      <template>
        <form {{on "submit" this.saveName}}>
          <label for='name'>Set username:</label>
          <input
            id='name'
            value={{this.value}}
            {{on "input" this.updateName}}
          />
          <button type='submit' disabled={{eq this.value.length 0}}>
            Generate
          </button>
        </form>
      </template>
    }
    ```

    However, this is, at present, not yet well-motivated: it’s not clear what the actual advantage it provides over an explicit inheritance-driven interface. Additionally, has unresolved complexities around providing the types needed for Glint, which requires a home for the information about the element(s) and yield(s) for the component. Today, Glint uses type-only declarations on Glimmer `Component`, which cannot be straightforwardly translated to this mode. This is likely tractable, and a future RFC may introduce it (including for defaulting `.gjs` and `.gts` into it automatically), but it is large enough that it is probably worth addressing separately.

- Does the possible confusion with the platform `<template>` warrant adopting an alternative syntax, whether component-like (`<Template>`) or using an additional sigil (`<[template]>`, `<% ... %>`, `<$ ... $>` etc.)? If so, what design? Here we must keep in mind that the design should not be ambiguous with “dynamic” behavior (e.g. `<{template}>` which is suggestive of the Svelte and React expression marker, and which we might find attractive for future iterations of template language ourselves).

- Are `.gjs` and `.gts` the best file extensions?

- How does this relate to the currently un-merged [RFC #0731: Add `setRouteComponent` API][rfc-0731]? That is: can we merge this and proceed with authoring components while there is an unresolved design problem for the related issue of routes, controllers, and their host components? Or should we see this as a helpful part of resolving *that* design question? (I believe we can move forward in parallel.)

    The primary challenge here is that, as things stand, our guides would have some fairly substantial incoherence until we solve the problems which #0731 is addressing: route templates would be totally different from component templates in their semantics and behavior. This points to the ongoing and increasing divergence of the `Route` and `Controller` design from the rest of the framework, but it’s directly connected to *this* RFC pedagogically.

- Should we include a plan for a staged rollout of deprecating namespace resolution in this RFC, rather than tackling it in a later RFC?

[rfc-0731]: https://github.com/emberjs/rfcs/pull/731


---

---
stage: released # FIXME: This may be recommended
start-date: 2021-11-30T00:00:00.000Z
release-date: 2022-06-13T00:00:00.000Z
release-versions:
  ember-source: v4.5.0

teams:
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/785
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Introduce new test helpers for rendering (and re-rendering) that obviate the need for `get` and `set`

## Summary

Introduce new testing utilities that remove the need for the use of `this.get`/`this.set` in test contexts. This will make rendering tests behave more like application code, and also greatly simplify the process of writing rendering tests in TypeScript since it will remove the need to append type information to `this` as properties are set.

## Motivation

Current rendering tests require developers to set values on `this` in order for them to actually be present in the template that gets rendered as part of the test. For example, if we're testing that a component correctly displays a value that gets passed in as an argument, we'd do something like:

```js
this.set('name', 'foo');

await render(hbs`<MyComponent @name={{this.name}} />`);

assert.dom('[data-test-name]').hasText(this.get('name'));

this.set('name', 'FOO');

assert.dom('[data-test-name]').hasText(this.get('name'));
```

This approach has three main issues:

1. It's not consistent with any other programming model in Ember
1. It synchronously flushes the DOM
1. It makes writing tests in TypeScript a huge pain

On the first point: `this.set` is essentially irrelevant everywhere else in Ember. In a post-Octane world, we no longer need to `get` or `set`, and it is, in fact, frequently discouraged as an unnecessary complication. Additonally, the value of `this` inside of a test is extremely murky. The fact that `this` is both the test context _and_ a sort of ersatz scope for the surrounding "template" of the rendering test is not exactly intuitive or easy to teach.

On the second point: `this.set` is actually [run-wrapped when called in tests](https://github.com/emberjs/ember-test-helpers/blob/master/addon-test-support/@ember/test-helpers/setup-context.ts#L412-L423), which means that every time someone calls `this.set`, they are actually synchronously flushing the entirety of the DOM and triggering a re-render of the entire test template. This _in no way_ resembles the relationship between data updates and re-renders in application code. In application code, changes to the underlying data in template are coalesced into a single DOM update, which, in turn, re-renders only the parts of the DOM that are affected by the changed data. As a result, rendering tests end up essentially testing a version of rendering that isn't even used in the application being tested.

On the third point: having to set properties on `this` leads to a whole bunch of papercuts when writing tests in TypeScript. [As discussed in the `ember-cli-typescript` docs](https://docs.ember-cli-typescript.com/ember/testing#the-testcontext), rendering tests require developers to arbitrarily add (and change) properties on `this`. Developers thus have to define (and re-define) the interface for `this` to accommodate _all_ of those properties to prevent TypeScript from complaining that each of the values that were set don't exist on the `TestContext` type. Beyond simply being annoying, this actually makes it impossible to write safe and useful types spanning multiple tests: properties declared for one test appear to be available in all of the tests in a module (and get autocompleted accordingly), whether or not they actually _are_ available.

The goal of this RFC, then, is to greatly simplify the testing model by removing the need for `get` and `set` in rendering tests, thereby reducing the reliance on `this`.

## Detailed design

We will introduce two new/refactored utilities for use in rendering tests:

1. Update the `render` helper to accept either a component or a template snippet.
1. A new `rerender` function that would be used after the initial `render` call to wait for DOM updates

These additions, used in concert with [First Class Component Templates](https://github.com/emberjs/rfcs/blob/master/text/0779-first-class-component-templates.md), should significantly improve the DX of writing component tests in Ember.

### Updated `render` helper

Rendering tests currently work by rendering a template that is bound to the `this` of the surrounding test. This is why developers have to call `this.set` in the first place, since the value of `this` in a given test is doing double duty as both the actual test context AND the backing object for the template that eventually gets rendered. Since we want to move away from this very behavior, we need a version of `render` that can alternatively accept a fully-formed component, since components have their own context and are self-contained.

The updated version of `render` would be imported from `@ember/test-helpers` and have the following signature:

```ts
function render(template: TemplateFactory | Component, options?: RenderOptions): Promise<void>;
```

Since this new version of `render` will need to differentiate between components and templates, we'll also add an `isComponent` utility to the `@glimmer/runtime` package. This addition will significantly reduce the amount of private API that would be required when implementing the new `render` function.

Additionally, since passing a component to `render` also precludes the user from being able to access the text context via `this` (since components will use their own local context rather than the test's), we'll display a warning message if someone passes a component to `render` while also using `this.set` in the same test. This will help avoid confusion in the case that they opt in to the new component-based testing model but then copy an example from the guides or an older writeup that uses `this.set`.

### `rerender`

Finally, we need to handle cases where you want to update the backing data and assert against the resulting changes in the rendered output. In the current testing paradigm, we'd _usually_ just update the values using `this.set`, which immediately triggers a rerender. In more complex cases, e.g. where there is some async operation involved, we would wait for the state we want to assert against, likely using either `settled` or `waitFor`. This works, but has the downside of either waiting for _everything_ to finish (in the case of `settled`), or waiting for a single thing to finish (in the case of `waitFor`).

Instead, we propose adding a new `rerender` function to `@ember/test-helpers` that exclusively waits on pending render operations, but ignores all other [settledness metrics](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#issettled):

```ts
rerender(): Promise<void>
```

In order to implement `rerender`, we would also expose the work done by @rwjblue on [`renderSettled`](https://github.com/emberjs/ember.js/blob/703b9ca2653a6b479a762b30dca1a33eaa13d8ab/packages/%40ember/-internals/glimmer/lib/renderer.ts#L219-L240) as public API in a new `@ember/renderer` module so that it could then be imported and used by `@ember/test-helpers` without issuue.

When combined with [tracked state](https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_autotracking-basics), this new `rerender` function allows developers to make updates to their component state and `await` the newly rendered version of their component _without_ having to also wait for other pending timers or run loops. In other words, they can still assert against changes in the DOM, but would also be able to assert against things like loading states without having to use `waitFor` since `rerender` would not wait for things like async operations to complete.

Continuing the example from above, here's what we'd expect an update and re-render to look like:

```js
import { render, rerender } from '@ember/test-helpers';
import { tracked } from '@glimmer/tracking';

// setup elided
test('it works', async function (assert) {
  const somePerson = new class {
    @tracked name = 'Zoey',
    @tracked age = 5,
  };

  const component = <template>
    <ProfileCard @name={{somePerson.name}} @age={{somePerson.age}} />
  </template>;

  await render(component);

  assert.dom(this.element).hasText(somePerson.name);

  somePerson.name = 'Zoeyyyyyyyyyyyyy';

  await rerender();

  assert.dom(this.element).hasText(somePerson.name);
});
```

It's worth noting that rendering tests without `get`/`set` are actually possible today using a combination of the `precompileTemplate` function from `@ember/template-compilation`, a scope object containing all of the relevant values referenced in the template, and the `settled` function from `@ember/test-helpers`. Accordingly, the implementation of this RFC would largely involve exposing these existing APIs in a way that is both more user-friendly and better-suited to both [First-Class Component Templates](https://github.com/emberjs/rfcs/pull/779) and [TypeScript](https://github.com/emberjs/rfcs/pull/724), rather than introducing a significant amount of new internal functionality.

## How we teach this

We'd need to add a new TypeScript-specific section to the [testing components](https://guides.emberjs.com/release/testing/testing-components/) section of the official guides to document this new approach for TypeScript users.

We expect there will be a future RFC that introduces a form which also allows passing arguments into the invoking component, in addition to the approach described in this RFC that requires a backing class in order to mark primitives as tracked. As a result, for the time being, we'll only teach this new approach in a TypeScript-specific subsection of the guides on testing components until that followup RFC has been written and merged. We believe that the benefits to the TypeScript community (namely, no longer needing to fight with the type checker over the type of `this` in each test) still significantly outweigh the costs of the slightly awkward method of passing arguments.

We'd also need to update the [API docs for @ember/test-helpers](https://github.com/emberjs/ember-test-helpers/blob/master/API.md) for the new version of `render` as well as the newly introduced `rerender` function.

API documentation for the two new functions are included below:

### render

```ts
/**
  Renders the provided template or component and appends it to the DOM, overwriting any previously-rendered template or component.
  @public
  @param {CompiledTemplate|Component} template the template or component to render
  @param {RenderOptions} options options hash containing engine owner ({ owner: engineOwner })
  @returns {Promise<void>} resolves when settled
*/
render(template: CompiledTemplate | Component, options?: RenderOptions): Promise<void>;
```

### rerender

```ts
/**
  Returns a promise that resolves when rendering has settled.  Settled in this context is defined as when all of the
  tags in use are "current". When this is checked at the _end_ of the run loop, this essentially guarantees that all
  rendering is completed.
  @public
  @returns {Promise<void>} resolves when settled
*/
rerender(): Promise<void>
```

All things considered, the changes in this RFC should result in a component testing model that is ultimately _more_ intuitive. We could also introduce a configuration option to `@ember/test-helpers` that would allow users to turn on an assertion that prevents rendering tests from being written using the old method to help codebases migrate.

## Drawbacks

Ember's testing setup is one its most valuable features, and this RFC would introduce changes to a testing model that already works fine. These changes would be introduced alongside the existing rendering test models, so they would not constitute a breaking change, but would introduce additional overhead in terms of "old vs. new", similar to the overhead of Octane, or the Grand Testing Unification RFCs.

## Alternatives

- Leave things as they are.
- Encourage people to use `precompileTemplate` along with the current version of `render`.

## Unresolved questions

> Optional, but suggested for first drafts. What parts of the design are still
> TBD?


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2021-01-11T00:00:00.000Z
release-date:
release-versions:
teams:
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/786
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Ember cookbook proposal

## Summary

Adding a cookbook section to our learning resources will help Ember developers to learn maintainable, accessible patterns for common tasks.

## Motivation

Ember docs in its current state are missing [how-to guides](https://documentation.divio.com/how-to-guides/) that would provide goal-oriented answers / patterns to common problems Ember developers face on a daily basis. For example, if someone wants to learn how to handle a form submission, they would have to look at blog posts.
Additionally, many Ember users over the years have requested a cookbook-like resource. Early versions of Ember had a [resource like this](https://guides.emberjs.com/v1.12.0/cookbook/), but it was removed in 1.13.


## Detailed design

### Creation
Ember-cookbook will be a repo under [ember learn](https://github.com/ember-learn). We start by introducing an Ember Cookbook section in the ember docs dropdown.

Currently, there is a lot of material out there in the form of blogs, stackoverflow answers and efforts like Ember Atlas. The challenge is to make sure they are discoverable.
An official Ember cookbook will be a great way to officially endorse patterns, since not all patterns found on all blogs can be trusted.

Sourcing information for the cookbook can be done a few ways:
Officially endorsing existing articles and blogs
Monitoring most asked questions on stackoverflow
Create entries for [really good explanations](https://discuss.emberjs.com/t/adding-a-delete-row-button-from-a-table/18623) from the ember forum.
Create sections that would make it easier for the developer to navigate through the different guides. Ember-data's adapter/serializer cookbook articles can go under a specific section called "Ember Data" within the cookbook.

For the MVP we can include the following articles and topics, or similar content.
[How to create a grid/table with Ember Data and creating a CRUD form with Ember data](https://discuss.emberjs.com/t/looking-for-an-example-of-a-grid-and-form/18490)
[Show or Hiding content based on current Route](https://discuss.emberjs.com/t/show-or-hiding-content-based-on-current-route/18567)
[Synchronising query parameters with a component](https://discuss.emberjs.com/t/synchronising-query-parameters-with-a-component/18084)
[Ember without Ember Data](https://stackoverflow.com/questions/24408892/ember-without-ember-data)
[Updating entries from previous cookbook](https://guides.emberjs.com/v1.12.0/cookbook/)

### Contributing & Maintaining
The Ember learn team will manage this repository and will guide what goes into the cookbook.
In addition, we could have a set of volunteers sign up to add content to the cookbook regularly. Some of the tasks to maintain the cookbook would include,
Monitoring stack overflow and other forums to come up with most-asked questions
Work closely with the Ember Core team on upgrades to add, modify or delete information from Ember Guides.

A cookbook template will be used to keep all the entries uniform. The template would contain the following sections,

#### Title
  This is an intro section that lets someone know what they will learn by the time they are done reading.
#### The challenge
  Lay out the example and the problem you are trying to solve
#### Steps
  The steps someone should take to get to the end result.
  Use headings to describe steps and not numbers.
#### Results
  When you are finished, here's how it should work
#### Resources
  Links to Guides and API go here.
  Also include ways that someone could build upon this knowledge.
#### Tags

After reading this recipe you should now know what is a cookbook and what is the templete that Ember recipes follow.

#### Learn more

### Launch strategy
The cookbook articles will be drafted in markdown format. Once there is a critical mass of 5 articles, they can be published. The cookbook will be hosted at cookbook.emberjs.com
The cookbook will use Guidemaker, similar to cli.emberjs.com
We will mention it in the Ember Newsletter.
To Evangelize it further, we can share the links on social media and as answers to stackoverflow questions.

### Versioning
We can show a single version of the recipe and have a “last updated at” and a field that shows the range of versions that it is applicable to. This would make it easier to maintain.


What kinds of content belong in the Cookbook?
One challenge for the cookbook is determining where content belongs.

Today, Ember has the following key learning resources:
The Super Rentals Tutorial
The Ember Guides
The CLI Guides
The API docs
Community-maintained learning resources like blogs, videos, and livestreams

We know that something may belong in the cookbook if we answer yes to the following questions:

- The concept can be explained in an article that would take less than 10 mins to read
- The concept is not already shown in the Super Rentals tutorial
- The article helps show how to put together multiple Ember features to achieve a goal.
- The article is trying to demonstrate a pattern, not teach a concept. For example, if we are showing how to use a model hook to accomplish something, we are not explaining what a model hook is.
- [It is narrowly tailored to solve a single problem](https://guides.emberjs.com/v1.12.0/cookbook/contributing/deciding_if_a_recipe_is_a_good_fit/#toc_solution)
- It shows how to solve a problem that Ember apps may commonly face. For example, managing a dropdown menu or creating a form are common. Integrating WebRTC is not.
- The article goal can be accomplished without installing new addons, with the exception of addons mentioned in the Guides.

Removal of recipes
If a topic becomes obsolete for any reason, we could add a warning at the top. An archived section for outdated things would help with this. This way the links stay forever but hidden in a section. This way it will serve as an example of which pattern is deprecated.

## Drawbacks

We will need to maintain the cookbooks as we have major Ember version upgrades.

### Language support

The Ember documentation serves a global community. The cookbook aims to be a resource that could be translated into multiple languages after the initial content settles. The translations would be found under the same domain, `cookbook.emberjs.com`




---

---
stage: discontinued
start-date: 2022-01-29T00:00:00.000Z
release-date: Unreleased
release_versions:
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/790'
  discontinued: 'https://github.com/emberjs/rfcs/pull/887'
project-link:
suite:
---

# EmberData | Deprecate ajax requests

## Summary

Deprecates use of `ajax` methods in favor of `fetch` to request API data.

## Motivation

Currently, `ember-data` maintains two methods for users to fetch data from their backend - fetching with `jQuery.ajax` and `fetch`.  Confusion further exists in the adapters if users implement functionality to change out of the box behaviour. They can override [`ajax`](https://github.com/emberjs/data/blob/e076e0ae71ae6426ca53ad3c5501a0af7ceca883/packages/adapter/addon/rest.ts#L1091-L1126) methods but without a clean interface to operate with, what they really may be doing is overriding how fetch works.

With Ember 4.0 dropping jQuery, we should take a hard stance on dropping the use of `ajax` in the next major release.

## Detailed design

The first step is putting in place a deprecation if an adapter uses `ajax` to make a request. Since `ember-data` switched the default behaviour to use fetch in 4.0, this deprecation will only apply to those who have overrided the default with `useFetch = true` in their adapters.

Second, we will expose fetch related methods on the adapters that are equivalent in use and flexibility as the current `ajax` options.  Note the [`minimum-adapter-interface`](https://github.com/emberjs/data/blob/master/packages/store/addon/-private/ts-interfaces/minimum-adapter-interface.ts) does not assert the method by which a request is made. As a result, how we design and implement these methods should not have an effect on those users who have implemented their own adapter.

In 5.0, all `ajax` methods and supporting infrastructure will be removed. The list of affected methods includes:

- ajax
- _ajaxRequest
- _ajax
- ajaxOptions
- _ajaxUrl

Moreover, we may rename methods not part of the minimum-adapter-interface. Moreover, we expect to implement the following methods with [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch), although could be changed in the actual implementation.

- fetch
- fetchOptions
- fetchSuccess
- fetchError
- fetchUrl

## How we teach this

This is best taught through a deprecation guide. Users using `ajax` will need to install `ember-fetch` or rely on the default global `fetch` API provided by the browser.  This has some implications, for example, with how query params are serialized.  Users will have to be careful to ensure the behaviour of their API changes with any changes that result from switching to fetch.

## Drawbacks

Some user's technology stacks may be entirely dependent on `ajax` for requesting API data.  This isn't necessarily an easy switch and may require multiple improvements to various layers to use `fetch`. For those users, we can document how they can still implement their own adapter to use `ajax`.  This will involve overriding the existing `fetch` methods.  For example, if your API still needs to be serviced with `ajax` to perhaps take advantage of [ajax options](https://api.jquery.com/jquery.ajax/#jQuery-ajax-url-settings) or [ajaxPrefilter](https://api.jquery.com/jquery.ajaxprefilter/), simply override the existing `fetch` methods.  The goal of this refactor would be to ensure users who still need to use `ajax` has a happy path to doing so.

## Alternatives

- Continue providing and exposing public-ish adapters methods as `ajax`.
- Provide both `fetch` and `ajax` methods together in the adapters.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2022-02-11T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/793
project-link:
---

<!---
Directions for above:

Stage: Leave as is
Start Date: 2022-02-11
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/793
-->

# EmberData | Polymorphic Relationship Support

## Summary

1. Allow setting polymorphic relationships without inheritance and mixins.
2. Deprecate using inheritance and mixins for polymorphic relationships. Target version: 5.0.

## Motivation

Currently, although undocumented and not explicitly supported, you can set polymorphic
relationships using two mechanisms: inheritance and mixins. This RFC seeks to lay out
an explicitly supported path for polymorphic relationships that composes well with
native class usage, eliminates the dependency on instanceof checks and prototype chain
walking, and is compatible with the schema service introduced in [RFC #487](https://github.com/emberjs/rfcs/blob/master/text/0487-custom-model-classes.md#exposing-schema-information)

**Example Using Inheritance**

```js
import Model, { belongsTo, hasMany } from '@ember-data/model';

class TagModel extends Model {
  @belongsTo('taggable', { polymorphic: true }) taggable;
}

// not a model, just a way to make relations work
class TaggableModel extends Model {
  @hasMany('tag', { inverse: 'taggable' }) tags;
}

// real models with tags
class CommentModel extends TaggableModel {}
class PostModel extends TaggableModel {}
```

**Example via Mixins**

Consider that this same post and comment class also both need to be "viewable", and that "viewable" is a trait also shared by other models that are not "taggable". Today this is only achievable via mixins.

```js
import Model, { belongsTo, hasMany } from '@ember-data/model';
import Mixin from "@ember/object/mixin";

class TaggableMixin extends Mixin {
  @belongsTo('taggable', { polymorphic: true }) taggable;
}

class ViewableMixin extends Mixin {
  @belongsTo('viewable', { polymorphic: true }) viewable;
}

class CommentModel extends Model.extends(TaggableMixin, ViewableMixin) {
  @hasMany('tag', { inverse: 'taggable' }) tags;
  @hasMany('views', { inverse: 'viewable' }) views;
}

```

## Detailed design

This RFC proposes to allow explicitly declaring polymorphic traits similar to [rails conventions](https://guides.rubyonrails.org/association_basics.html#polymorphic-associations).

### API

The polymorphic relationship **MUST** explicitly declare itself as polymorphic and **MUST** explicitly declare it's inverse as either a key or `null`. All records that satisfy the polymorphic type must declare a matching inverse via that key.

Polymorphic relationships take the form:

```ts
hasMany(abstractType: string, options: { async: boolean, polymorphic: true, inverse: string | null })
belongsTo(abstractType: string, options: { async: boolean, polymorphic: true, inverse: string | null })
```

Concrete Relationships which fulfill polymorphic relationships take the form below where the string supplied to `as` should be the same `abstractType` supplied to the polymorphic definition above.

```ts
hasMany(recordWithPolymorphicRelationship: string, options: { async: boolean, inverse: string, as: string })
belongsTo(recordWithPolymorphicRelationship: string, options: { async: boolean, inverse: string, as: string })
```

So for instance, given a field named "tagged" that is a polymorphic hasMany with baseType "taggable", and inverse key "tags" the following would be the polymorphic relationship and concrete relationship.

```ts
// polymorphic relationship
class Tag extends Model {
   @hasMany("taggable", { async: false, polymorphic: true, inverse: "tags" }) tagged;
}
// an inverse concrete relationship
class Post extends Model {
   @hasMany("tag", { async: false, inverse: "tagged", as: "taggable" }) tags;
}
```

### Polymorphic Relationships without Inverses

- polymorphic relationships need not have an inverse, in which case they must specify `inverse: null`.

### Abstract Types

Every polymorphic relationship has an implicit "abstract type" that represents the entity on the other side of the relationship.

In the below example, the polymporphic relationship implies the existence of the `abstract type` "taggable".

```ts
class Tag extends Model {
  @hasMany("taggable", { async: false, inverse: "tags", polymorphic: true }) taggables;
}
```

It is only required that your app implement a model (or if using instantiateRecord and the schema service implement handling for that type) if your API will return entities whose type is the abstract type. If the abstract type is never directly interacted with, it is not required to implement a Model or other associated support.

### Polymorphic to Polymorphic Relationships

A Polymorphic to Polymorphic Relationship can be declared by both sides of the relationship declaring both `polymorphic: true` and `as: <abstract-type>`. For instance taggables that could also be editables might be implemented like below:

```ts
class Tag extends Model {
   @hasMany('taggable', { async: false, polymorphic: true, inverse: 'tags', as: 'editable' }) tagged;
}

class Post extends Model {
   @hasMany('editable', { async: false, polymorphic: true, inverse: 'tagged', as: 'taggable' }) tags;
}
```

### Schemas for Abstract Types

When no model exists for the abstract type EmberData has no mechanism for validating whether the
 associated relationship is single-resource relationship (belongsTo) or a collection relationship (hasMany). The simpest way when using `@ember-data/model` to ensure this information is available is to implement the abstract model as well; however, this is not the *best* mechanism.

The best way to inform the store of the shape of the relationship on the abstract type is to supply
 the information via the `SchemaDefinitionService`. When not using `@ember-data/model` this service is always supplied by the app or by another addon (for instance `ember-m3`). That implementation should be designed such that it responds to queries for schema for the abstract type with the appropriate information.

When using `@ember-data/model`, you can use the delegator pattern to achieve this. Below we show the `taggable` and `editable` abstract types from our last example above being handled in this way.

```ts
import Store from '@ember-data/store';

// Relationship Schemas for the abstract types
// An app could hard code this, import it, or load it as needed
// via their API.
const AbstractSchemas = new Map([
  [
    'taggable',
    {
      tags: {
        kind: 'hasMany',
        type: 'editable',
        name: 'tags',
        options: {
          async: false,
          polymorphic: true,
          inverse: 'tagged',
          as: 'taggable'
        }
      }
    }
  ],
  [
    'editable',
    {
      tagged: {
        kind: 'hasMany',
        type: 'taggable',
        name: 'tagged',
        options: {
          async: false,
          polymorphic: true,
          inverse: 'tags',
          as: 'editable'
        }
      }
    }
  ],
]);

class SchemaDelegator {
  constructor(schema) {
    this._schema = schema;
  }

  doesTypeExist(type: string): boolean {
    if (AbstractSchemas.has(type)) {
      return false; // some apps may want `true`
    }
    return this._schema.doesTypeExist(type);
  }

  attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesSchema {
    return this._schema.attributesDefinitionFor(identifier);
  }

  relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsSchema {
    const schema = AbstractSchemas.get(identifier.type);
    return schema || this._schema.relationshipsDefinitionFor(identifier);
  }
}

export default class extends Store {
  constructor(...args) {
    super(...args);

    const schema = this.getSchemaDefinitionService();
    this.registerSchemaDefinitionService(new SchemaDelegator(schema));
  }
}
```

### Deprecation Design

Situations in which polymorphism is not configured by the above mechanism but in which EmberData would have previously detected and attempted to do the right thing will be deprecated. This means effectively that mixin based and inheritance based polymorphism will print a deprecation *only when* the corresponding relationships are not also configured for polymorphism correctly. By this means users are free to continue using mixins and inheritance if they so choose.

## How we teach this

> Would the acceptance of this proposal mean the Ember guides must be
re-organized or altered? Does it change how Ember is taught to new users
at any level?

Polymorphism was never explicitly documented or supported by EmberData. With this RFC, we would add an official declaration of support and add a section on polymorphism to both the docs for model, docs for the schema service and to the guides.

## Drawbacks

None

## Alternatives

We could require a more explicit API that declares the full-intent and full-resolvability on one or even both sides. The advantage of both sides is both less work to do on the part of the ember-data to determine validity and increased clarity to the reader in that both sides show the config.

However, This can have some drawbacks in that as an API grows to have more entities that satisfy a polymorphic relationship the config becomes increasingly and unnecessarily large and prevents runtime additions to the schema.

## Questions

None


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2022-02-12T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/794
project-link:
---

# Simplify Schema Definition Service methods in Ember Data

## Summary

This RFC is an amendment to the Custom Model Classes RFC (https://github.com/emberjs/rfcs/pull/487).
Based on implementation feedback, we discovered we could simplify the arguments to
`attributesDefinitionFor` and `relationshipsDefinitionFor` to drop the string argument and always
pass in an object.


## Motivation

When implementing a schema service, code ends up easier and cleaner if it does not have to deal with
both a raw string and an object.

## Detailed design

The original RFC proposed the following interface:

```typescript
interface SchemaDefinitionService {
  // Following the existing RD implementation
  attributesDefinitionFor(identifier: RecordIdentifier | type: string): AttributesDefinition

  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | type: string): RelationshipsDefinition
  doesTypeExist(type: string): boolean
}
```

We can simplify `attributesDefinitionFor` and `relationshipsDefinitionFor` methods to always accept an object.

```typescript
interface SchemaDefinitionService {
  // Following the existing RD implementation
  attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesDefinition

  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsDefinition

  doesTypeExist(type: string): boolean
}
```

## How we teach this

It simplifies the types passed in, so should be easier to teach.


## Drawbacks


## Alternatives

Keeping the existing design per the original RFC.


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2022-02-13T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/795
project-link:
---

# Return a Promise from Model.save()

## Summary

Model.save() will return a Promise instead of a [`PromiseProxyMixin`](https://api.emberjs.com/ember/release/classes/PromiseProxyMixin), otherwise referred to as a PromiseObject from here on out.

## Motivation

* The API documentation already documents the return value as a Promise.
* Remove dependency on promise proxies
* Async Consistency - The PromiseObject encourages a usage pattern of sometimes-async, sometimes-sync behavior. We want to [reduce zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).
* API consistency - While the PromiseObject proxies properties, the PromiseObject does not proxy methods on the underlying model. For instance, if you try to call a method like destroyRecord on the model, you will get a “not a function” error because the method is called on the Proxy and not the underlying model. This encourages users for Ember Data to reach into private implementation details of the promise proxy, such as using proxy.get('content') to call methods.
* Enable new functionality in Ember Data while making backwards compatibility with older versions of Ember easier.
* The documentation of using PromiseObject APIs have been replaced over time in the guides and API documentation to use more typical JavaScript usage of Promises, such as async/await, instead of PromiseProxies.

## Detailed design

Introduce a new feature flag, `DS_MODEL_SAVE_PROMISE`, Model.save() will return an a Promise that resolves with the model if the save was successful, or rejects with an error if the save fails.  When disabled, a PromiseObject will be returned to keep today's behavior, but accessing properties on the PromiseObject or calling non-Promise functions (.then, .finally, .catch) on the PromiseObject will issue a deprecation warning.

Deprecation Plan:

The deprecations can be implemented by adding deprecations around the existing PromiseObject. However, we can't include the deprecations in the actual PromiseObject class because [it is the base class for the relationship proxies](https://github.com/emberjs/data/blob/master/addon/-legacy-private/system/promise-proxies.js#L85). Instead, we can create and use a new DeprecatedPromiseObject for the DS.Model.save() function. It functions like a PromiseObject but deprecates the following behavior:

    * Accessing properties on the PromiseObject returned from DS.Model.save()
        * Use deprecateProperty from Ember to deprecate all the properties that the PromiseProxy Mixin provides. The list of properties can be found here: https://github.com/emberjs/ember.js/blob/master/packages/ember-runtime/lib/mixins/promise_proxy.js
        * Deprecate accessing any unknown properties. For instance, someone might try to grab the value of an attr or computed property from a model, e.g. proxy.get('email').
    * Calling functions that are not available on Promises
        * Not Safe (issue deprecation): .get/.set/anything else really
        * Safe (do not issue a deprecation): .then, .catch, .finally

The implementation follows the standard feature-flagging process in Ember and Ember Data. The final implementation will look something like:

```
  save(options) {
    const savePromise = this._internalModel.save(options).then(() => this);

    if (DS_MODEL_SAVE_PROMISE) {
      return savePromise;
    } else {
      return DeprecatedPromiseObject.create({
        promise: savePromise
      });
    }
  },
```

## How we teach this

We do not believe this requires any update to the Ember curriculum. API documentation does not need to be updated as it is already documented as returning a promise. This behavior of accessing properties through the PromiseProxyMixin specifically for DS.Model.save() is not documented in the guides.

## Drawbacks

For users relying on this behavior, they will have to refactor their code to either use patterns like async/await, ember-concurrency, or ember-promise-helpers. Alternatively, if all they want to access are properties on the model, they can use the model instead.

## Alternatives

- The impact of not doing this prevents further changes in Ember Data.
- Return a promise but also exposing a template/js helper in a new package that wraps any promise exposing isResolved and isRejected flags. This helps maintain similar behaviour to the existing implementation.

## Unresolved questions


---

---
stage: accepted
start-date: 2022-02-20T00:00:00.000Z
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/796
project-link:
---

# Deprecate `RSVP.Promise` for native Promise

## Summary

All methods currently returning an `RSVP.Promise` will return a native Promise. In addition, all documentation will be updated accordingly.

## Motivation

With the removal of IE11 from our build infrastructure and browser requirements, we can now safely remove `RSVP.Promise`. From the [docs](https://github.com/tildeio/rsvp.js/):

> Specifically, it is a tiny implementation of Promises/A+. It works in node and the browser (IE9+, all the popular evergreen ones).

RSVP was Ember's polyfill since an early v1.0.0 version during a time when native Promises didn't exist in any browser.  In addition, Promises have been supported since Node 0.12.

By removing `RSVP.Promise` in favor of native Promises, we can drop an unnecessary dependency for both client side and server side fetching of data.

According to [bundlephobia](https://bundlephobia.com/package/rsvp@4.8.5), this would allow us to remove a significant chunk of dependency weight.

## Detailed design

Two steps will be required to fulfill deprecating `RSVP.Promise`.

First, we will issue a deprecation `DEPRECATE_RSVP_PROMISE` to async callbacks that might be relying on a convenient feature of `RSVP.Promise`.  Namely, an `RSVP.Promise` may still be hanging by the time the underlying model instance or store has been destroyed.  This will help users surface instances where their test suite or code is dealing with dangling promises.  After the removal of this deprecation, this will throw an Error.

- `id: ember-data:rsvp-unresolved-async`

Second, we will also utilize the deprecation to replace all instances of `RSVP.Promise` with native Promises.

The final implementation will look something like:

```js
  ajax(options) {
    if (DEPRECATE_RSVP_PROMISE) {
      return new Promise((resolve, reject) => {
        ...
      });
    } else {
      return new RSVPPromise((resolve, reject) => {
        ...
      });
    }
  },
```

## How we teach this

We do not believe this requires any update to the Ember curriculum. API documentation may be needed to remove traces of `RSVP.Promise`.

See the informal [docs](https://github.com/emberjs/data/blob/fa18fd148e9881a860343eabf0ba15b6f048c3ea/packages/private-build-infra/addon/current-deprecations.ts) on how to configure your compatibility with ember-data deprecations.

## Drawbacks

For users relying on `RSVP.onerror`, they will have to either refactor their code to set the global Promise to RSVP or configure [onunhandledrejection](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection) appropriately.

If users continue to use `rsvp` after it is dropped from ember-data, users can add `rsvp` to their package.json explicitly if they were depending on it transitively.

Lastly, RSVP gives meaningful labels so that the promise can be debugged easily. We may need to take this into account with a native Promise wrapper, especially how it interacts with the Ember Inspector.

## Alternatives

Continue resolving async paths with `RSVP.Promise` will allowing users a convenient override to use native Promises.

## Unresolved questions

- What level of an abstraction should we provide over native Promise. Derived state for `isPending`, `isResolved`, and `isRejected` seem like probable derived state we want to expose to users to avoid significant churn in their codebase.
- Consideration of Ember's continued use of RSVP.
- After scanning the codebase, the non native equivalent methods we use from RSVP is `defer` in test files.  This is an implementation detail that doesn't need to be flushed out here.


---

---
stage: recommended
start-date: 2022-02-24T00:00:00.000Z
release-date:
release-versions:
teams:
  - framework
  - data
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/800'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/868'
  released: 'https://github.com/emberjs/rfcs/pull/950'
  recommended: 'https://github.com/emberjs/rfcs/pull/953'
project-link:
---


# TypeScript Adoption Plan

## Summary <!-- omit in toc -->

[RFC #0724][rfc-0724] commits Ember to officially supporting TypeScript and articulates an overall philosophy for what official support means. This RFC defines a detailed implementation plan for officially supporting TypeScript in Ember, including:

- the SemVer policies Ember packages should adopt, following [RFC #0730][rfc-0730]:
  - supported TypeScript versions
  - the "breaking change" policy
- an Edition support policy
- how we will migrate users from depending on the `@types` definitions on DefinitelyTyped to Ember packages
- test infrastructure to catch regressions early
- updates to Ember CLI to support TypeScript
- release "channel" testing analogous to Ember's existing feature flag system for runtime code
- a basic communication plan for the rollout
- updates to our guides, API docs, and even the version release blog post announcement

…and more!

[rfc-0724]: https://github.com/emberjs/rfcs/pull/724
[rfc-0730]: https://github.com/emberjs/rfcs/pull/730


### Outline <!-- omit in toc -->

- [Motivation](#motivation)
- [Detailed design](#detailed-design)
  - [Semantic Versioning](#semantic-versioning)
    - [Strictness](#strictness)
    - [Primary packages](#primary-packages)
    - [Secondary packages](#secondary-packages)
  - [Edition support policy](#edition-support-policy)
  - [RFC process updates](#rfc-process-updates)
  - [Migration from DefinitelyTyped](#migration-from-definitelytyped)
    - [Classic features](#classic-features)
    - [Ember internals](#ember-internals)
    - [Type Registries](#type-registries)
  - [CLI Integration](#cli-integration)
  - [Test Infrastructure](#test-infrastructure)
  - [Publishing types](#publishing-types)
    - [Implementation](#implementation)
    - [Release channels](#release-channels)
- [How we teach this](#how-we-teach-this)
  - [Publicizing](#publicizing)
  - [Documenting SemVer](#documenting-semver)
  - [Ember’s documentation](#embers-documentation)
    - [Guides](#guides)
    - [API documentation](#api-documentation)
  - [Migration docs](#migration-docs)
    - [General migration guide](#general-migration-guide)
    - [Ember Classic features](#ember-classic-features)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
  - [Documentation](#documentation)
  - [Classic features](#classic-features-1)
  - [Semantic versioning options](#semantic-versioning-options)
  - [Documentation](#documentation-1)
- [Unresolved questions](#unresolved-questions)


## Motivation

The overall motivation for this work is the same as that in [RFC #0724][rfc-0724]:

> In sum, making TypeScript an officially supported language for Ember will benefit all Ember users, JavaScript and TypeScript alike; it will solve many pain points for TypeScript users that cannot otherwise be addressed; and it will close a gap for Ember compared to other frameworks.

Where that RFC was concerned with *whether* we should pursue those goals, this RFC is concerned with *how* we accomplish them. The specific approach described here aims to roll out TypeScript support in a way that:

- maintains Ember’s strong stability guarantees
- allows us to make steady incremental progress
- communicates progress clearly to the community
- minimizes the migration costs for existing Ember TypeScript users


## Detailed design

To fully support TypeScript across the Ember ecosystem, we need:

- a Semantic Versioning policy which can absorb breaking changes in TypeScript itself *without* imposing breaking changes on Ember developers
- an edition support policy which tells us what our types *must* support (as distinct from what they *may* support)
- a plan for migrating existing Ember TypeScript users from DefinitelyTyped to using Ember’s own core types
- a plan for CLI integration (e.g. `ember new --typescript`)
- test infrastructure for Ember’s types, both to prevent regressions and to catch breaking changes from TypeScript early so they can be mitigated
- release infrastructure to allow us to handle pre-release testing, feature flags, and alpha and beta releases
- updates to our documentation to include TypeScript as a first-class citizen of the ecosystem

While we need full template-aware type checking to complete our support for TypeScript, this RFC intentionally defers that consideration to a dedicated RFC to hammer out the remaining design questions around [Glint][glint].


### Semantic Versioning

Ember packages which publish types will adhere to the [Semantic Versioning for TypeScript Types][rfc-0730] proposal. See that RFC for details on strategies for mitigating breaking changes from TypeScript, and see [**How We Teach This: Documenting SemVer**](#documenting-semver) below for discussion of how we will document this at the framework level.

The 10,000-foot summary of our treatment of SemVer for TypeScript is:

> Code which type checks at any given point in a major release of Ember packages will continue to type check throughout that Ember major release for consumers who use supported TypeScript versions.

This is **the “no new red squiggles rule”:** if you use supported TypeScript versions, you will not see new “red squiggles” for type errors in your editor for Ember minor version upgrades.

The only exceptions to the “no new red squiggles” rule are:

- *Bug fixes to the types*: where we previously allowed code we should not have and which could produce runtime errors, the introduction of those red squiggles is making your code safer.
- *Rare cases involving inferred types*: very rarely, we may make a change to the types which is safe for your code at runtime, and which allows TypeScript to detect new unused code paths or similar. These will introduce “red squiggles” in your editor, but in a way which will simply allow you to clean up code you didn’t need.

    <details><summary>example of this kind of change</summary>

    Assume a library provides a function, `idFor`, which gives back the `id` for a given item. Maybe it finds an `id` field on the object and hands it back if it exists, or generates a UUID otherwise, or similar—the details are unimportant, as we only care about the type signature.

    In v1.0 of the library, it specifies that it always returns a `string` or  a `number`:

    ```ts
    declare function idFor(obj: unknown): string | number;
    ```

    In our own code, we need IDs to always be `string`s, so we do something like this:

    ```ts
    const id = idFor({ cool: 'story' });
    const usableId = typeof id === 'number' ? id.toString() : id;
    ```

    Then let’s say that the authors of `idFor` recognize that returning `string | number` is kind of annoying, and they update their API to always return `string`:

    ```ts
    function idFor(obj: unknown): string;
    ```

    This is perfectly safe from a runtime perspective. Any code which worked before will work now. However, TypeScript is smart enough to see that the `typeof` check is dead code:

    ```ts
    const id = idFor({ cool: 'story' });
    const usableId = typeof id === 'number' ? id.toString() : id;
    //                                           ^^^^^^^^❌
    ```

    TypeScript will now report `"Property 'toString' does not exist on type 'never'."` on the `id.toString()` call, because it determines that `id` can never be a `number`, which makes that entire branch dead code ([playground][id-play]). The "cleanup" work here is that you can simply *get rid of* that code, though!

    For further examples and a discussion of why we cannot work around this (e.g. with lint rules), see [**Appendix C**](https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#appendix-c-on-variance-in-typescript) in the Semantic Versioning for TypeScript Types RFC.

    </details>

[id-play]: https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEBbA9sArhBA1AjPA3gFDwnwgAeADsjAC7wBmaAdmLQJbLPzvABiNABTIARgCsAXPBYBrZsgDuzAJRSAzrRjtmAc3gAfeMzSIRIGAG5S8QgF9ChUJFgIU6TPCwAmAsVIVqOkYWNk5uXgEYYXEpWXklVXgNLV0LOwcmVg4ueAA3HEFlX2swLg0eYHgAXk8cADoIoXx4UuQIKQByDRoATw74W2U0krL6NDUoEUwASUqa2h7KEGQGCuqqmo7jU3N+gH4KutpkAGVNbR1C+CleNPtCTNCc3K8rohHmct5qzy8G-iaLWQbU63RgfQGQz8JFKnzGEymIFmPwWSxWaw2m22Zhg+0OxzOKUuRRuwDuhCAA


For details on both of these, see [Semantic Versioning for TypeScript Types RFC][rfc-0730], which explains these in detail and provides justification for especially the second case.

[rfc-0730]: https://github.com/emberjs/rfcs/pull/730


#### Strictness

In line with the [Semantic Versioning for TypeScript Types RFC][rfc-0730], both Ember projects and the blueprints generated by Ember using the new `--typescript` flag will set the following compiler options:

- `strict: true`
- `noUncheckedIndexedAccess: true`
- `esModuleInterop: false`
- `allowSyntheticDefaultImports: false`

(See discussion below under [**CLI Integration**](#cli-integration) for further details on the new `--typescript` flag`.)

Beyond this, we *may* define a set of *additional* “lint”-type strictness flags over time taking advantage of TypeScript and/or ESLint, an `ember-ultra-strict` mode, and provide tooling to expose that.

A consequence of adopting `strict: true` as a behavior is that we will be progressively catching *more* type safety issues over time. Since these changes are not gated on TypeScript major versions (that is, they may appear in *any* TypeScript release), they make cause “red squiggles” during any TypeScript upgrade. However, we still believe this is an appropriate default, for the following reasons:

1. Because of the guidelines under which the TypeScript team admits new strictness settings, errors caught by a new strictness flag will *always* represent real type safety features. Features do *not* rise to this bar instead go under a set of “lint”-style rules, which today include checks like `noUncheckedIndexedAccess`, which we *will* enable, and also `noPropertyAccessFromIndexSignature`, which we will by default *not*.

2. Because of the support policy described throughout, Ember’s *own* types will always have to check with these settings enabled, including its test suite, including its *type* test suite (as described under [**Test Infrastructure**](#test-infrastructure)). This means that users will *always* be able to update to a version of TypeScript supported by the Ember version they are using and be guaranteed that one of the following is true:

    - there *are* no new errors related to their use of Ember code

    **OR**

    - any errors which *do* appear represent real possible bugs in your *use* of Ember code

This maximizes the value offered by TypeScript for consumers of Ember’s types (as well as maximizing the benefit to Ember itself internally). Developers who want to  take advantage of the strictest type checking options available to prevent runtime errors will always be able to do so. Accordingly, we do *not* guarantee that code will type check in looser modes, especially when `strictNullChecks` is disabled. *Most* code will still work correctly, but advanced types features used in Ember sometimes rely on the ability to distinguish between `null` or `undefined` and other types, and we do not commit to avoiding those—not least because there is otherwise an exponential explosion of possible strictness combinations we would have to test.

<details><summary>On including <code>noUncheckedIndexedAccess</code></summary>

We include the `noUncheckedIndexedAccess` setting in our recommended settings because it catches one of the most significant holes in the TypeScript type system prior to its introduction: not accounting for the fact that "index"-style access to objects and arrays *always* allows arbitrary access to any index (numeric or string), whether or not it is defined. For example, consider this type (not recommended for *other* reasons, but legal):

```ts
type Anything {
  [key: string]: string;
}

function describe(anything: Anything) {
  let email = person['email'];
}
```

Here, `email` would be typed as `string`, and so TypeScript would not complain if you did something like `email.length`. But you can *call* this with an object which does *not* have an `email` field on it:

```ts
describe({ noEmailsHere: 'bwahahaha' });
```

This will cause a runtime error instead of a type error. However, TypeScript is (as of recent releases) smart enough to understand that if you *check* for `"email"` it can be *known* to be present:

```ts
function describe(anything: Anything) {
  if (anything['email']) {
    let email = anything['email']
    email.length
  }
}
```

Accordingly, we include this as part of Ember’s own strictness settings and defaults generated for users.[^should-be-strict]

</details>

[^should-be-strict]: The Typed Ember team thinks TypeScript *should* have included this under `strict: true`!


#### Primary packages

The primary packages in the ecosystem, `ember-source`, `ember-data`, and `ember-cli`, will adopt the [rolling window](https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#rolling-support-windows) policy:

> In *rolling window*, a package may declare a range of supported versions which moves over time, similar to supporting evergreen browsers.
>
> Packages using the “rolling window” policy should normally support all TypeScript versions released during the current ‘LTS’ of other core packages/runtimes/etc. they support, and drop support for them only when they drop support for that ‘LTS’, to minimize the number of major versions in the ecosystem.

This aligns the support policy for these packages with the existing policy for Node and browser versions, both of which already operate on exactly this model.

Additionally, primary packages must ensure that the rolling windows *always* overlap across LTS versions, so that upgrading a primary Ember packages does not require a *simultaneous* TypeScript upgrade. That is: Ember users should always be able to upgrade to the latest supported TypeScript version for one Ember LTS, then upgrade the Ember LTS *without* changing their TypeScript version—a “laddering up” strategy.

This “laddering up” strategy means that Ember major releases do not need a special release from the constraints about what TypeScript versions they support. Instead, the requirement that users be able to upgrade across LTS releases without also requiring a simultaneous TypeScript upgrade holds: a user should be able to upgrade from the final Ember 4.x LTS to Ember 5.4 LTS by first upgrading to the latest supported TS version on the 4.x LTS and then upgrading to Ember 5.4 LTS *without* changing their TS version.

Given the release cadences, this should not be burdensome: at most there is a nine month delay between the release of a TypeScript feature and its being able to be used in Ember.

At each minor release, Ember primary packages should add any newly-released TypeScript versions to their support matrix (just as we aim to do for Node and browsers). If there is a critical bug in TS (affecting correctness or performance) which is not fixed in the time that TS version is current, Ember can choose *not* to support it.[^precedent] This is a last resort, for bugs which TS itself later resolves. If a TS minor version introduces a breaking change, Ember will update the types to absorb the breakage.[^mechanisms] In some cases, this *may* include bug fix releases to the types for LTS versions of Ember, even if they would not be in the supported range otherwise. (This is not required, but as with runtime bugs, fixes are normally backported where possible.) Bug fixes to TypeScript types for supported versions will be treated exactly as they are for runtime code:

- Stable releases will receive bug fixes for types for the six weeks they are the current stable release.
- LTS releases will receive bug fixes for types for the roughly 6 months (4 releases) they are the current active LTS.

LTS releases do *not* automatically add TypeScript versions released during their support window to their supported versions list (just as they do not for Node versions).

Ember primary packages should display the currently supported TypeScript versions prominently in their READMEs as well as in their documentation.

Finally, as long as the Ember primary packages maintain a lockstep release cadence, they must support the *same* matrix of supported TypeScript versions.[^lockstep]

[^precedent]: This has happened in the past, though rarely: once late in the TS 2.x series and once early in the 3.x series, there were significant regressions around performance and correctness which meant a given minor release could not be supported by Ember’s types on DefinitelyTyped.

[^mechanisms]: There are a variety of mechanisms by which this can be supported, ranging from simple changes to the types in most cases to occasional need for the TypeScript `typesVersions` tooling.

[^lockstep]: If Ember primary packages ever stop using a lockstep release cadence, they must continue to use the same rolling support strategy, but would need to additionally consider the intersection of their TypeScript version support as well as their support for the other core packages. However, there is no current proposal to make such a change, and it would be the responsibility of the RFC making such a proposal to account for this.


##### Example

If Ember were to begin publishing types with Ember 4.4, the flow might look something like this, given the following assumptions:

- Ember starts out supporting TypeScript 4.5 and 4.6
- TypeScript 4.6 introduces a feature not in 4.5 which Ember wants to use
- TypeScript 4.8 has a significant regression, fixed in TypeScript 4.9, which means TS 4.8 is never supported
- TypeScript 4.9 introduces a feature not in 4.6 which Ember wants to use

| Ember version  |   Supported TypeScript versions   |
| -------------- | --------------------------------- |
| **4.4 (LTS)**  | **4.5, 4.6**                      |
| 4.5            | 4.5, 4.6                          |
| 4.6            | 4.5, 4.6, 4.7                     |
| 4.7            | 4.5, 4.6, 4.7                     |
| **4.8 (LTS)**  | **4.6, 4.7**                      |
| 4.9            | 4.6, 4.7                          |
| 4.10           | 4.6, 4.7, 4.9                     |
| 4.11           | 4.6, 4.7, 4.9                     |
| **4.12 (LTS)** | **4.6, 4.7, 4.9, 5.0**[^counting] |
| 4.13           | 4.6, 4.7, 4.9, 5.0                |
| 4.14           | 4.6, 4.7, 4.9, 5.0, 5.1           |
| 4.15           | 4.6, 4.7, 4.9, 5.0, 5.1           |
| **4.16 (LTS)** | **4.9, 5.0, 5.1, 5.2**            |

The key points to notice in this upgrade cycle:

- Regular minor versions may add support for new TS versions, if one has been released.

- Ember may also choose not to support a given TS version if it cannot reasonably do so.

- LTS versions *may* drop support for old TS versions, but are not *required* to. In this example:

    - Ember 4.8 LTS *does* drop TS 4.5.
    - Ember 4.12 LTS does *not* drop TS 4.6.
    - Ember 4.16 LTS *does* drop all versions before TS 4.9.

In this example, a team upgrading from Ember 4.4 LTS to Ember 4.8 LTS can upgrade to TypeScript 4.6, then upgrade to Ember 4.8 LTS separately. They would not need to upgrade TS at all to upgrade to Ember 4.12. Then they would need to upgrade to at least TS 4.9. Note that the 4.16 LTS release *could* drop all TS versions up to 5.0. In general, however, we will not drop support for older versions unless there is a reason to do so (e.g. 5.0 itself introduced a desirable feature).

Additionally, we *may* make best-effort fixes to later (technically unsupported) TypeScript versions for LTS releases. For example, if TypeScript 4.7 introduced a breaking change which could be fixed by types-only changes to Ember 4.4 LTS, we would accept PRs to fix it and otherwise prioritize it in accordance with its severity (just as we do for runtime issues related to browsers, Node, or other ecosystem packages we depend on, e.g. `@babel` packages).

[^counting]: As part of its rejection of SemVer, TS just rolls over from an `x.9` release to the next major `y.0`, e.g. `2.9` to `3.0` and `3.9` to `4.0`.


##### Reasoning

Like browsers and Node, TypeScript regularly introduces new features which are attractive to use. Unlike browsers or Node, however, it is impossible to “polyfill” those new features for TypeScript. We want to enable primary Ember packages to take advantage of those new features without waiting for a full major release. For example, in the almost 4-year span between the releases of Ember 3.0 (February 2018) and Ember 4.0 (December 2021), TypeScript released the following key features which dramatically changed our ability to represent Ember’s APIs correctly or to use TypeScript effectively (as well as many other smaller enhancements):

- conditional types (2.8, March 2018)
- `unknown`, spread parameter types, improved tuple types with optional and spread elements, and composite projects (3.0)
- improved strictness settings (3.2, 4.0, 4.2, 4.4)
- `const` assertions and higher-order inference for functions, which was key to enabling Glint (3.4)
- assertion functions, allowing more useful typing of `assert` (3.7)
- the `declare` modifier, allowing safe declaration of injections and CPs (3.7)
- spec compatibility for class fields, optional chaining,. andish coalescing (3.7)
- spec compatibility for top-level `await` (3.8)
- variadic tuple types and labeled tuple elements (4.0, improved in 4.2)
- template literal types (4.1)
- spec compatibility for `#private` class fields (4.3)

Had we been publishing types and using the *simple majors*, we would not have been able to adopt *any* of those features, because doing so would have required downstream consumers to update to versions which supported them. This is basically the same problem we had with IE11 support: any feature which could not be polyfilled, we could not use at any point in the Ember 3 era.[^polyfill]

Using the “rolling window” policy allows us to adopt new features from TypeScript in the same way we do with Node and browsers, and never couples users to do TypeScript and Ember primary package upgrades simultaneously.

[^polyfill]: In fact, we could not even use some features which *could* be polyfilled in some places, because the polyfill was too expensive!


#### Secondary packages

All secondary packages (i.e. all officially-published packages which are not listed above) in the ecosystem should use the same [simple majors](https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#simple-majors) policy

> In *simple majors*, dropping support for a previously supported compiler version requires a breaking change.

As with the primary packages, this aligns secondary packages with their existing support policies, as they already treat Node version support exactly this way.

For example: `ember-cli-htmlbars` currently publishes types, but there is no documented contract for SemVer. Following this RFC and [the SemVer for TS RFC][rfc-0730], it must:

- link to the SemVer-for-TS spec
- include the currently supported TypeScript versions in its README
- specify that it uses the *simple majors policy* in its README
- add all supported TS versions to its CI jobs
- cut a new major any time it drops a TS version from support (which, for ecosystem stability, should generally be aligned with dropping a Node version when it goes out of LTS)


### Edition support policy

Per [RFC #0724: Official TypeScript Support][rfc-0724] (emphasis added):

> All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions **for the current edition**. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.

Ember’s types will always provide full support for the APIs of the *current* edition, and is *not* required to continue supporting previous editions when crossing a major version change. This does *not* supercede the Semantic Versioning commitment, however.

What this means in practice is:

1. If a new edition is introduced during a given major release (e.g. the projected Polaris Edition during 4.x), the types will maintain support for *both* editions. This is required by the SemVer support policy: dropping support for the previous edition would be a breaking change!

2. When a new major version is released after an edition has been introduced (e.g. v4 after Octane and presumably v5 after Polaris), Ember may drop some or all support for features which are not part of the updated programming model represented by the new edition.

The motivating example here is the custom class system from Ember Classic (as discussed below under [**Migration from DefinitelyTyped: Classic Features**](#classic-features)). While this continues to exist and works, it is extremely difficult to provide types for and the value of the types is very low. Ember users are recommended to use native classes instead. Accordingly, when Ember begins publishing its own types, we will only support a very limited version of the Classic features like `.extend()`, `.reopen()`, `.reopenClass()`, and legacy decorator forms which interoperate with them.

If we did *not* adopt this option, Ember would have to provide the same extensive support for the Classic features that the DefinitelyTyped version of the types have historically provided, despite the very bad cost-benefit ratio of these types for our maintenance.

In future editions, it is conceivable that we might lean on this escape hatch to drop support for legacy CLI features (after Embroider is standard) or legacy routing features (if Ember adopts a modernized routing system) etc. However, in general we do *not* expect to need it, because our designs have generally been accounting for TypeScript even before making it an officially supported language for the framework.


### RFC process updates

RFCs which introduce new APIs must specify the public types for those APIs. RFCs which deprecate existing APIs must consider the migration path for TypeScript users as well as JavaScript users.

Note that this is not a major new design constraint, because we have largely already been doing this! This simply formalizes the process Ember has been using for the past few years already: we have regularly used TypeScript signatures to represent new APIs, and TypeScript concerns have been included in the discussion of API proposals.

This does introduce two new small considerations:

- New APIs will now need to specify import paths for type-only imports. For example, today there is no public import for `Transition` or `RouteInfo`, because they are not intended for end users to construct. However, types for them *should* be publicly exported because end users need to be able to name those types them in their own code. If we were to write [RFC #0095: Router Service](https://emberjs.github.io/rfcs/0095-router-service.html) today, we would specify imports for both.

- New APIs will need to specify whether a given interface or type is intended for user-constructibility. This is part of the Semantic Versioning contract. By way of example:

    - Both `Transition` and `RouteInfo` are *non*-user-constructible. Although they are classes under the hood, it is illegal for end users to make their own copies: the only legal way to get one is *from the framework*. We can enforce this for TypeScript users with type machinery under the hood, but it is important that they be documented accordingly as well.

    - Classes like `Service` and the Glimmer `Component` are *intended* to be user-subclassed, but are *not* intended to be implemented directly.

    - Interfaces like the `ComponentManager`, `ModifierManager`, and `HelperManager` *are* intended to be user-constructible, and in fact this is the entire reason they exist.

The Detailed Design paragraph of the default RFC template will be updated to include corresponding text:

```markdown
> This is the bulk of the RFC.

> Explain the design in enough detail for somebody
familiar with the framework to understand, and for somebody familiar with the
implementation to implement. This should get into specifics and corner-cases,
and include examples of how the feature is used. Any new terminology should be
defined here. New types should be specified as they are intended to be used by
TypeScript consumers, including their import locations and whether they are
intended to be constructed by end users.
```

The “Transition path” paragraph of the deprecation RFC template will be updated to include the following:

```markdown
> This is the bulk of the RFC. Explain the use-cases that deprecated functionality
covers, and for each use-case, describe the transition path.
Describe it in enough detail for someone who uses the deprecated functionality
to understand, for someone to write the deprecation guide, and for someone
familiar with the implementation to implement. Make sure to include details
specific to TypeScript users, if any.
```


### Migration from DefinitelyTyped

There are many existing Ember TypeScript users, who use the `@types` packages maintained by the Typed Ember team on [the DefinitelyTyped repository][DT] since 2017. We need to support those users migrating off of DefinitelyTyped in a minimally-disruptive way. At the same time, we *do* have an opportunity to align the types with [the edition support policy described above](#edition-support-policy), as well as to fix some early infelicities in design choices.[^infelicities]

[DT]: https://github.com/DefinitelyTyped/DefinitelyTyped

Accordingly, we will:

- simplify our handling of Classic features (see [**Migration from DefinitelyTyped: Classic features**](#classic-features) below)
- update our handling of type registries (see [**Migration from DefinitelyTyped: Type registries**](#type-registries) below)
- simplify or improve other APIs if and as we see opportunities

[^infelicities]: There are a number of reasons for those infelicities: in some cases, it was simply our own ignorance when we wrote the types; in others, TypeScript did not yet support the features we needed to represent Ember; and in yet others Ember’s own design wasn’t great (we have all started designing better JS APIs in the meantime, partly informed by experience with TS!).

To reiterate, though: in general, the goal will be to *minimize* disruption to existing users. The majority of the work will be as described in [**How we teach this: Migration docs**](#migration-docs) below.

For the current DefinitelyTyped maintainers (the Typed Ember team and some other contributors), there is one additional step: we will follow the DefinitelyTyped [guide to removing a package](https://github.com/DefinitelyTyped/DefinitelyTyped#removing-a-package), so that users can get support for package versions *up to* the point where the package was removed from `@types`, while package versions after that which try to use `@types` will be notified that they should switch.


#### Classic features

Per the edition support policy, we will provide minimal support for Ember Classic features:

- **Ember's classic class system**: we will provide minimal definitions for the `.extend()`, `.reopen()`, `.reopenClass()`, and `.create()` methods, which make no attempt to use them to actually update the types of the items they modify.

    It is not possible to provide a good experience working with those types (in particular, working with mixins *at all* requires extensive unsafe casting), and they are no longer recommended for any new code. We will support them only because they are *required* for migrating some critical ecosystem code which still depends on them (especially around Ember Data).

    <details><summary>detailed discussion of classic class system updates</summary>

    All of the relevant tweaks to class types can be represented using [declaration merging][declaration-merging]. Given a class `Demo`:

    - including a `Mixin` with `.extend()` can be represented with a type alias for the mixin `type TheMixin = ...` and `interface Demo extends TheMixin {}`
    - reopen can be represented with a type alias for the mixin `type TheReopen = ...` and `interface Demo extends TheReopen {}`
    - `reopenClass` can be represented with a namespace for the reopened type, `namespace Demo { ... }`

    Accordingly, the types for the `.extend()`, `.create()`, `.reopen()`, and `.reopenClass()` methods can become much “dumber” than in the DefinitelyTyped definitions, providing a minimal layer of type safety but using these other techniques for the transition/fallback period.

    For a full working demo, see [this playground][classic-fallback-playground].

    [classic-fallback-playground]: https://www.typescriptlang.org/play?#code/PTAEFpNBnAXBDATrUBTAtgI1Y0B7TAK1QGMVYBPAB1WgihACgATUgGyVVBI+joFkAlgA9BAO1ABvRqBgJYgkt0Sp4sVAB4ASgD4AFFUR4q0AFygtASnNbGAX0Yt2nbrzoBhPCoDyRUimlZODVFNGF1MWYNdzCI5g8vVF9iMn0ZWVBYAAtBM1B3ABp02QA6MsNjPIIU2ABtAF1063yAbnT04IUlEhU1TRjUcNRIhJ8-VL1izJy8wqmKk3Nq-ybzdzaO+VCVY2Ho2OH4-MTk-zSM6dy1oouFqvHYG9Bm9ccgraUdmjF3N33BuKjJIPc4ZbJXfJPWR3JYPJ4vNoOJw8FwAMwArmIyII8BIAOaoWAaAAqBVAAGkDiNQABrVAUPCo0DE-QIRAE2DmUm0+nmcnNYm1cn1NqsFEqUAYrEKXGgDl6Nkc8yYmliPAAdzEZLpFHMcEQ4jxzRVas1oucEql2Nl0EJJLJlIBhzoOsZzNZSCVzO1vIpZIAbvA2OjUFyhfUBeHzeKuFaZRJbUSAGoe9mE5ViVUarU83VyA1iPEBoMh8xJ5pJjYovigACiWBwpzIVKOnjGNSkSJA9HAaEiaAbuGWzcoNDokF7TEY3YnoHQInEjBIuLgoAAIhg8EJRBIALygbfiEo9VTqPSBOeErJ4ZgAMSM6EPYj0nvMYnRg+a-rwgmYUimiYKjMZIAOTzjuAAKRhUCBZKepYbSyHYTzgeIUHGOYAAMRR2AhjijlwG7oFuC57pk1CoG6REkTuGwzlA6LQIac6kYw4jqIgqLwCQhGbi2dDUU+nZLm4658U61L1tgiBNrAJQScweiCaRlj-rIYghP6qDoVQeqwAWeKgAAPqA75sGwoD7mZbCIo49G9oxzFfMMS4rigWiUd81GWWpl7ZDe954OgHm7M+4J5NRzTvoOvmyCosDoog+KEkBuSgahYg6SBeFIfY+EURYnnDN5+4EW6IVeZujjsTgXE8WJxH8YVoXeZIDjUSUznPhVxWbnh05gLOjmFqAXW-PAfCuWIq49T8bglb5qIPrNqDMONfDmPpIb2BsYocBKGnoLQVDcbxjUXoMVBeCgy7TSgS1BSta1uOYmB4HgbCqGItkDfQoCsMRU2rkoVmoOqDV4HoeEkCUGkKFpOk+QARFkqDmXgZLql4bDMAAhEjbQw0d-l3g+T56AAjAATAAzHhghMnoROkYjuO7vuRNXgFy1Fc+liqReDOgEpm4lA9wW86t63QALUy3dAH2oCUbB4HiehI4APBuAJH7SM5aADgOEAA

    </details>


- **Ember’s `get` and `set` helpers:** we will not provide types to make `get` and `set` type-safe beyond simple property lookups on objects—i.e. no support for nested path lookups.

    While it would be possible to do so using advanced type system features, doing so would have a high maintenance cost and provides very little value in the Ember v4 era, where use of native property access is possible for all features which historically required `get` and `set` and their `-Properties` variants.[^get-set]

- **Classic computed property handling:** we will not provide “safe” types for the classic form of computed properties.

    <details><summary>detailed discussion of classic computed property updates</summary>

    Since they integrate with the clsasic class system and mixins, it is impossible to provide a correct experience of them in terms of the keys they accept or the `this` type within them: the types become circular. The supplied types for them will simply accept a dumb list of strings as dependent keys and a simple callback. All access to `this` will require unsafe casts.

    We will also continue to provide public types for the decorator forms, `@computed` as well as the computed property macros like `@alias`. However, decorators currently cannot affect the type of the decorated item (a TypeScript restriction), and so the public type definitions supplied will continue to simply specify them as `PropertyDecorator`s.

    Additionally, this means that we will eliminate the `UnwrapComputedPropertyGetter`, `UnwrapComputedPropertySetter`, and related types entirely. The return type will become the normal value return tyeps.

    The result will be similar to the definitions on DefinitelyTyped, but with much less “type machinery”.

    </details>

See below for a discussion of how we should approach TypeScript with Classic features in the documentation.

[declaration-merging]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html


#### Ember internals

Ember's internals will regularly include APIs which are *not* intended to be public, and should be excluded from public builds. In most cases, we can solve this by making sure our type publishing tooling understands the `@internal` annotation in comments and excludes items marked with it from publishing to the public API. In conjunction with the workflow described in [**Publishing types: Implementation**](#implementation), below, this can also allow us to publish internal-only builds for collaborators who need access to those APIs. For example, Ember’s test infrastructure lives in separate packages, but has sometimes needed access to private APIs to work.

A particularly vexing version of this problem is that Ember’s own internals still make extensive use of Ember Classic features—features we are explicitly choosing not to support by publishing rich types for them. This is well-motivated: in many cases we *must* continue to use those types internally to prevent consumers who are still using those features from being broken in surprising and hard-to-debug ways.[^zebra] Accordingly, there are *more* robust types for `.extend()`, `.reopen()`, etc. in Ember’s internals than we want to support publicly. This is also tractable, though: we can provide those internal-only extensions via [declaration merging][declaration-merging] in imports which are *not* part of the published build, and which therefore do not impact the public APIs.

The main risk here is that we need to make sure to run type tests against what is *published*, rather than from within the framework itself.

[^get-set]: This has been true for *many* things since Ember 3.1, which unlocked it for getters in the Ember Classic world; and for nearly everything since Ember Octane’s release in 3.15, which unlocked it for setters for all `@tracked` properties. With changes to Ember Data in 3.28, it also works (using native proxies) even for async relationships. Finally, its handling of possibly-`undefined` intermediate properties has been superceded by a language feature: [optional-chaining](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining).

[^zebra]: The primary example here is the “zebra-striping” problem with native classes and classic classes. When you set instance properties on a native class and then extend from it using a classic class, the values set in the subclass using `.extend()` will be superceded by the class properties on the parent native class. There are a number of other related issues around native and classic class interop; see [this Ember Twiddle][twiddle] for a demo of two of them. This “makes sense”: the fields set via `.extend()` go on the prototype while class fields are per-instance, and so override the prototype values—but it is extremely confusing in practice. Until we *remove* the ability to use `.extend()`, our internals likely need to be implemented as classic classes, or they need to use annoying hacks which amount to doing the same!

[twiddle]: https://ember-twiddle.com/fdf70756b8d551b3364fd3278f66c8a9


#### Type Registries

The existing type definitions on [DefinitelyTyped][DT] make heavy use of “type registries”, which use some advanced type system features introduced early in TypeScript 2.x to map string keys to specific types. This allowed us to support string-based lookups for many Ember Classic APIs, particularly in the dependency injection (DI) system and Ember Data lookups.

For the classic DI system, we no longer require (or benefit from) string key-based lookups to resolve the type of an injected item. In Ember Classic, we could use those key-based lookups to infer the type:

- `app/services/session.ts`

    ```ts
    import Service from '@ember/service';

    export default class SessionService extends Service {
      login(username: string, password: string) {
        // ...
      }

      logout() {
        // ...
      }
    }

    declare module '@ember/service' {
      interface Registry {
        session: SessionService;
      }
    }
    ```

- `app/components/some-component.ts` (note the odd mixed declaration form!):

    ```ts
    import Component from '@ember/component';
    import { service } from '@ember/service';
    import { action } from '@ember/object';

    export default Component.extend({
      // session here has the type SessionService...
      session: service('session'),
    }) {
      @action login(username: string, password: string) {
        // ...so this call is type safe
        this.session.login(username, string);
      }
    }
    ```

With the introduction of full support for native classes and decorators in Octane, and given the current status of the decorators implementation in TypeScript, this does not provide type inference. However, these kinds of type registries can still provide two benefits for consumers:

1. When renaming a service injection, like `@service('session') sessionService;`, or using its full name, like `@service('shared@session') session;`, the registry can still check that the resolved name is one that is registered.

2. It can be used with the other things in the DI system, e.g. making `Owner.lookup('service:session')` type safe, and thereby making things like `this.owner.lookup('service:session')` in tests automatically be well-typed.

The `@service` decorator will therefore continue to accept a string key, and will validate that against a registry, even though decorators cannot change the types of the items they decorate in TypeScript today. Additionally, the registry will be integrated into `Owner` types so that it can be used more generally. Moreover, the design for an `Owner` registry should allow others to integrate in the same way.

Controller injection, by contrast with service injection, is decreasingly used across the ecosystem and not generally recommended, and we expect it to be deprecated during Ember v6. Accordingly, we will *keep* support for the service registry while dropping support for the controller registry. (Given an appropriate design for `Owner`, end users could reimplement this if they so chose.)

Future designs for services and dependency injection more generally will need to be written to account for the capabilities of TypeScript’s implementation of Stage 3 decorators as they grow and change over time.

For Ember Data, there is considerably more ongoing need for registry-style APIs. `Store.findRecord` isn’t going anywhere any time soon, for example, and it *requires* some kind of registry to make `this.store.findRecord('user', 1)` correctly return a `User` model. Many other APIs within Ember Data similarly require registries for type safety. Thus, Ember Data will need its own dedicated design for handling those, and this RFC leaves those for the Ember Data team to address in a dedicated RFC.


### CLI Integration

We will introduce a new `--typescript` (`-ts`) flag for the `ember new` and `ember addon` commands, allowing users to opt into TypeScript when generating a new project. Using this flag will:

- Set the `isTypeScriptProject` option for `.ember-cli` (introduced in [RFC #0776][rfc-0776]) to `true`, so that blueprints are generated with TypeScript by default in the project.
- Configure linting:
    - In the`.eslintrc.js` blueprint:
        - Use `@typescript-eslint/parser` instead of the Babel ESLint parser.
        - Include `@typescript-eslint` in the `plugins` key.
        - Include `plugin:@typescript-eslint/recommended` in the `extends` key.
    - Install the `@typescript-eslint` dependencies instead of,  or in addition to (as appropriate), the Babel ESLint dependencies in `package.json`.
- Configure [Glint][glint] for type checking and, for addons, emitting type declarations during build.
    - Create `tsconfig.json` files and generate their `compilerOptions.paths`.
    - Configure `ember-cli-babel` to include the TypeScript transform. (This may just be an “out of the box” setting so it always works and does not require configuration!)
    - Set up packages with scripts to do type checking and, in the case of v1 addons, emitting type declarations using `glint`.

[rfc-0776]: https://emberjs.github.io/rfcs/0776-typescript-blueprints.html

We will also update the Glimmer Component blueprint in the Ember.js repo to include [the component’s signature][rfc-0748], so that it can be used by TypeScript.

We will be sunsetting `ember-cli-typescript` as part of this process. It was a valuable and needful part of the ecosystem when we did *not* have official support, but now it duplicates other sources of configuration and tooling, making maintenance needlessly more complicated. All of its capabilities can be managed more cleanly in other projects: `ember-source` and other addons can ship blueprints which support both TypeScript and JavaScript, `ember-cli-babel` and other build tools can manage transpilation, and `glint` supports end-to-end type checking.

[glint]: https://github.com/typed-ember/glint

We will also deprecate the `ember-cli-typescript-blueprints` repository, since it will become defunct, with the blueprints moving to the host repository (`ember-source`, `ember-data`, and `ember-cli`) and being authored in TypeScript directly, with types stripped for JS consumers, so they remain in sync permanently. (See again [RFC #0776][rfc-0776] for details.)

[rfc-0748]: https://github.com/emberjs/rfcs/pull/748


### Test Infrastructure

To meet the Semantic Versioning and stability guarantees described above, we need strong testing infrastructure in place. We need to avoid introducing breaking changes in our types (the same as in our runtime code). We also need to catch breaking changes introduced by TypeScript, so that we can mitigate them.

To this end, we will extend our existing test infrastructure in the following ways:

1. We will convert our test suite to use TypeScript, so that all existing tests can be used for catching type errors.
2. We will add dedicated “type tests” using tooling like [expect-type](https://github.com/mmkal/ts/tree/master/packages/expect-type) to guarantee we are upholding *exactly* the contract we intend for our published types.
3. We will add CI jobs which type check the code against all supported TypeScript versions.
4. We will incorporate checking against the `typescript@next` nightly builds so that we can identify breaking changes early.

Point (4) will make sure that we have early warning about any inbound breakage from TypeScript itself, generally giving us on the order of 2–3 Ember minor release cycles to prepare for those changes and prevent them from breaking Ember users.


### Publishing types

When Ember official packages begin publishing types, they will need to account for TypeScript's default of using Node module resolution to look up type definitions. Specifically, a number of Ember packages which have multiple “entry points”—that is, multiple modules in a package from which it is valid to import, like `@ember/object` and `@ember/object/computed`. The only way to make this work “automatically” today is to publish types in the root of the package, just as that was the only way to make non-root modules resolve correctly in a Node package historically. A publish step which copies the types to the root is possible, and that is how `ember-cli-typescript` has made types for addons work correctly. That is *not* desirable for Ember core packages, however, because it makes it impossible to provide things like preview access to types before stabilization, types for different editions, etc. (each discussed below).

In the future, we will be able to publish types in a much more “natural” way for Ember’s package design, by taking advantage of [Node package entry points][package-exports]. However, TypeScript support for that feature is still experimental and available only in TS nightly builds, so our design does not depend on it.

[package-exports]: https://nodejs.org/api/packages.html#package-entry-points


#### Implementation

As long as we are not publishing actual packages for the `@ember/*` and `@ember-data/*` packages, we will also need to include one additional file in our output which makes the published types visible to the consumer: a “root” entry point module for the package, published either in the root as `index.d.ts` or in some other location specified by the `types` key in `package.json`. Using `ember-source` as an example, we might publish the following to `dist/index.d.ts`, with `"types": "./dist/index.d.ts"` set in `package.json`:

```ts
import './types/ember-application.d.ts';
import './types/ember-object/index.d.ts';
import './types/ember-object/computed.d.ts';
// ...etc.
```

The referenced files in turn will have `declare module` statements in them, generated by whatever tooling we use to create public API rollups (see discussion below). The `index.d.ts` acts as a type-level “side-effect” module. It makes the `@ember/*` types *visible* to any app or addon which does `import 'ember-source';`. This will make compilation work correctly *without* configuring `compilerOptions.paths` in `tsconfig.json`.

We will accordingly incorporate that `import` statement in our blueprints (with a long comment explaining why it exists) and document it.

#### Release channels

These moves also allow us to support another constraint: As with runtime code, TypeScript types need to be provided via Ember's release channel mechanism.

1. Types for a given runtime feature should be available with the version the runtime feature appears with.
2. Types for unreleased features should be available only on `master` and in canary builds.

We can solve both (1) and (2) by using the `@alpha` and `@beta` tags in conjunction with tooling which understands how to use those to strip non-public types from the generated types.[^extractor-tool] When generating a canary build, items marked with `@alpha` will be included; but for beta and canary builds, they will be excluded. The same holds for beta vs. stable builds and the `@beta` flag.

As part of the rollout, we may also provide one *additional* level of publishing: publishing to a beta location, allowing early adopters to help prove out and find bugs with the types while not losing any *runtime* guarantees. For example: an app which tracks LTS releases for stability might nonetheless want to use the official TypeScript types, even if they are not yet published on Ember 4.4 LTS.

In that case, we will not yet be publishing a root `index.d.ts` for `ember-source` etc. in a location TypeScript will resolve automatically—not in the root, and with no corresponding `"types"` field in `package.json`. Instead, we might publish it to something like `types/experimental.d.t.s`. Early adopters could then do `import 'ember-source/types/experimental';`. This will prevent anyone from *accidentally* opting into those types, while still allowing feedback from early adopters.

This design works well with future possibilities in the design space as well:

- When TypeScript begins supporting Node’s [entry points][package-exports], we will be able to leave this in place while *also* using `exports` to make it unnecessary, allowing a smooth upgrade path. Once we *require* that version of TypeScript as the minimum supported version, we will be able to deprecate the import, and then we can drop it at the next Ember major.

- When delivering a new Edition, we *could* publish edition-specific types which allow users to opt into *only* using the new Edition, and they might do `import 'ember-source/types/polaris.d.ts`. This would be akin to how we set new defaults for linting, blueprints, etc. once the `"edition"` flag is updated for an app or addon, though stronger.

[^extractor-tool]: This RFC intentionally leaves the tool unspecified, because it is an implementation detail. Presently, it looks like our best bet will be combining multiple existing tools, for example combining [rollup-plugin-dts](https://github.com/Swatinem/rollup-plugin-dts) with [API Extractor](https://api-extractor.com). That could change over time, though!


## How we teach this

There are four major components to teaching the Ember community about this new capability:

- Publicizing it, including what it does and does not entail.
- Documenting the SemVer commitments
- Incorporating support for TypeScript into Ember’s documentation.
- Documenting the migration path for existing Ember TypeScript users from DefinitelyTyped to using Ember directly.

Note that this is in addition to the process-related updates described above in [**Detailed design: RFC process updates**](#rfc-process-updates).


### Publicizing

First, we should announce official support when it lands across Ember’s various media channels (blog, Twitter, etc.): official support for TypeScript is a big deal. If possible, we should also take the opportunity to engage with high-profile podcasts to talk about our approach and the benefits we hope it brings for both our users and for the rest of the TypeScript ecosystem.

In particular, we should emphasize:

- that our official support for TypeScript is about making it a full peer to JavaScript—*not* replacing JavaScript, and never *requiring* TypeScript, but rather supporting TypeScript users as equal peers to JavaScript users, and improving the JavaScript authoring experience using TypeScript “under the hood”

- what is new about Ember’s having official support, as compared to the community support we have had for the past few years, including:
  - the integration of TypeScript into the design process
  - the benefits of publishing types directly from Ember’s source, and thereby solving the problem of keeping Ember and its types in sync over time
  - the stability guarantees that come with a clear definition of and commitment to Semantic Versioning for TypeScript

Second, we should incorporate messaging about TypeScript support in all of our discussions of the planned Polaris edition. Along with Embroider and First-Class Component Templates (if accepted), it will represent a significant shift in the experience of authoring Ember apps.


### Documenting SemVer

Besides the per-package documentation, we will also include a discussion of how Ember handles *TypeScript* in its SemVer commitments under the **How Ember uses SemVer** section on the [Releases](https://emberjs.com/releases/) page. There, we will link to the published SemVer for Types spec as well as summarizing how end users should think about it—just as we already do for runtime. This should likely be a new subsection which extends the existing discussion, e.g. **Notes for TypeScript users** just after the existing **What SemVer means for your app** section.

Additionally, when each new version of Ember is released, any updates to supported versions should be included in the blog post associated with that version in a dedicated section at the same level as the **Ember**, **Ember Data**, and **Ember CLI** sections today. For example, in an Ember 4.6 release which added support for TypeScript 4.7, the section might look like this, immediately following the Ember CLI section:

> ### TypeScript support
>
> Using Ember does not require using TypeScript, but Ember provides first-class TypeScript integration for users who wish to use TypeScript, with strong backwards-compatibility guarantees.
>
> You can always update TypeScript to a supported version independently of updating your Ember, Ember Data, and Ember CLI versions.
>
> Ember.js, Ember Data, and Ember CLI 4.6 all **added support for TypeScript 4.7**. Supported TypeScript versions now include 4.5, 4.6, and 4.7.

In an Ember 4.8 LTS release which *dropped* support for TypeScript 4.5 (as described in [the example above](#example)), we would emphasize this in the text:

> ### TypeScript support
>
> Using Ember does not require using TypeScript, but Ember provides first-class TypeScript integration for users who wish to use TypeScript, with strong backwards-compatibility guarantees.
>
> You can always update TypeScript to a supported version independently of updating your Ember, Ember Data, and Ember CLI versions.
>
> Ember.js, Ember Data, and Ember CLI 4.6 all **added support for TypeScript 4.7** and **dropped support for TypeScript version 4.5**. Supported TypeScript versions now include 4.6, and 4.7. To upgrade to Ember 4.8, you should first upgrade to at least TypeScript 4.6.


### Ember’s documentation

Ember’s documentation needs to treat TypeScript as a first-class citizen. **We take it as a fundamental consideration that types and documentation *must* stay in sync.** In its most ambitious form, this could lead us to massively revamp Ember’s docs, so that every example can toggle between JS and TS. For prior art, see how Microsoft’s API docs support all of C#, F#, C++, and Visual Basic; or how Apple’s API docs support both Objective-C and Swift. However valuable and worthwhile such an investment would be, doing it would be a massive amount of work. Instead, this RFC recommends a more measured approach—while still encouraging further consideration of that very valuable work! It leaves the guides mostly as-is, with light additions of new content; and requires the updates *only* to API documentation, where it is a hard necessity.


#### Guides

We will add a new TypeScript-focused section to Ember’s guides, built on the lessons learned (and in some cases possibly using content directly from) the docs written for ember-cli-typescript. As with the existing guides at <docs.ember-cli-typescript.com>, the goal here will be to provide an explanation of the *additional* features and mechanics users need to know if working with TypeScript. Some key topics might include:

- the setup process, including running `--typescript` at the start of a project or manually configuring it later
- how we compile apps and addons (i.e. using Babel rather than tsc), and why
- how the `paths` mappings work and why they are necessary
- working with Ember Classic features

We should also introduce some of the material from the Typed Ember docs in dedicated TypeScript sections to each of the Core Concepts guides. For example:

- in the Components guide, we could add a section describing how to write the signature for a Glimmer Component
- in the Services guide, we could add a section show how to safely write a well-typed service injection
- etc.


#### API documentation

API documentation *must* be updated to show TypeScript type signatures. This will make it possible for TypeScript users to see in the docs exactly the same thing they see in their editor, thereby avoiding any potential confusion from documentation being out of sync with the types provided. In support of this, we will need to update our tooling to support deriving the API documentation information from the types, so that there is a single source of truth.

There are also two other new concerns for documenting types which are meant to be consumed *only* as types: where/how to import and document them, and whether they are user-constructible. I will use the `RouteInfo` type from Ember’s routing system as a motivating example here.

**Import locations:** historically, type-only imports have been documented but without *having* to pin down a fixed location. For example, as of the time of writing, `RouteInfo` is documented as belonging only to the `ember` module. This has been “fine” because users expect to *receive* `RouteInfo` instances, not construct them directly, but when needing to name the type, the type must have a definite import location (presumably `@ember/routing`).

**User-constructibility:** as [described in the SemVer for TS types RFC](https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#definitions), whether a given type is intended to be constructed by users impacts its public API contract. See the discussion on that RFC for details. For this RFC, it is sufficient to note that every published `interface` or `type` alias must explicitly specify whether it is legal for users to construct it. *Implicitly*, `RouteInfo`s are only ever provided by the framework, but only implicitly. The docs should explicitly specify that the type can be imported and named, but not implemented by users.

[^transition-on-DT]: Historically, users on DefinitelyTyped have had to import `Transition` and `RouteInfo` from private locations *or* use type hacks to get them from the return types of other functions. This is because Typed Ember has consistently maintained a rule that we only publish types corresponding to the documented public API of Ember itself, and there was no possible public API for these types as *type-only* exports, since Ember was not publishing types.


### Migration docs

As discussed briefly above, existing Ember TypeScript users have used the `@types` packages from [DefinitelyTyped][DT]. We must document a migration path for users, to be published as part of the blog post announcing officially-published types for any given package. This will include both a general migration path, common to all of these, and then specific details dealing with migration of specific Ember Classic patterns.


#### General migration guide

The outline of that migration path, regardless of the specific package, is:

1. Upgrade to a version of the package (e.g. `ember-source`) which officially publishes types.
2. Remove the corresponding `@types` package(s) from your dependencies.
3. Check that your program compiles. Here, we will provide a guide of expected changes, if any.
4. Invite bug reports, directing them to the package in question!

We will *need* to publish one of these guides/posts for each package or group of packages which begins officially publishing types, at the time they begin doing so (as well as in the release notes for the package in question, of course). Users who have types from both the package itself and a `@types` package may end up confused or experiencing odd issues in their editor, so we need to make this messaging very clear!

As described above in [**Detailed design: Rollout**](#rollout), we can and should start shipping types incrementally as packages are ready, rather than gating the ecosystem on *everything* being ready. Accordingly, we will probably need a fair number of these posts!

For example, `@ember/test-helpers`, `ember-qunit`, and `ember-mocha` could begin publishing types more or less immediately after this RFC is accepted, while for `ember-source`, the publication of types would happen in line with the normal release train, as described in [**Publishing types and release channels**](#publishing-types-and-release-channels) above. Thus, we could do publish a blog post for the release of official types in the infrastructure, which would guide people to the correct version to update to, and tell them to remove the `@types/ember__test-helpers` and `@types/ember-qunit` or `@types/ember-mocha` packages from their dependencies. In that specific example, we would not expect there to be any changes between the types as published on DefinitelyTyped and those published from the packages directly.

Similarly, when a minor version of `ember-source` is published with types, we should publish a dedicated migration post, to be published at the same time as, and linked from, the announcement blog post. That post *will* include the expected changes consumers can make. However, since we *know* the expected sets of changes there (as discussed under [**Ember Classic Features**](#ember-classic-features) below), we can also guide Ember developers to start making those changes *sooner*, by publishing a post outlining the details as soon as we begin publishing the types on our canary channel. Then the announcement blog post can reiterate those as well as modifications made in response to pre-release testing.


#### Ember Classic features

Besides the general migration guide, we will also provide tips for code which uses Classic features:

- for `get` and `set`, guidance about switching to Octane idioms

- for `.extend()`, `.create()`, `.reopen()`, and `reopenClass()`, examples of using [declaration merging][declaration-merging] to correctly represent the runtime result of those types


## Drawbacks

The major drawbacks here are the same as those in [RFC #0724][rfc-0724]:

> Adding TypeScript support imposes an additional maintenance burden on all contributors to Ember:
>
> - documentation must be kept up to date in both JavaScript and TypeScript
> - changes to APIs must be kept in sync with published types (when the types are not generated from the implementation)
> - managing support for TypeScript versions will require additional effort and versioning coordination
> - presumably, API designs will be constrained in new ways (though this may also be an upside!)

There are also a few drawbacks to the specific recommendations around the rollout design here:

- Providing a more minimal support path for Classic features could make adoption more difficult for some users who have not yet fully migrated to Octane.
- Using a “rolling majors” support policy *does* impose additional upgrade cost on our TypeScript users.


## Alternatives

The major alternative here is the same as that in [RFC #0724][rfc-0724]:

> TypeScript support has historically been managed by the community. We could continue with this approach, including e.g. investigating other alternatives to DefinitelyTyped for supplying types in a more robust way. This has worked reasonably well to date, though it has added friction for adopters, especially when the Typed Ember maintainers could not keep up with changes to Ember itself.

In terms of the details of the rollout specifically, however, there are a few specific alternative approaches available to us.


### Documentation

- We could leave the TypeScript docs in a separate location entirely, as they are today. This would require many of the same costs we pay today in terms of maintenance, and would also leave TypeScript something of a second-class citizen.

- We could build an entirely separate tooling stack to support TypeScript vs. JavaScript in our documentation. This would create major maintenance overhead, and again would mirror the situation we find ourselves in today with the ember-cli-typescript docs representing a totally separate “source of truth” for that part of the ecosystem.

- We could use this as an opportunity to investigate rebuilding our documentation tooling entirely. While attractive in some ways, these projects are time-consuming and this would introduce considerable risk and likely major timeline delay. Instead, using the things we learn from building support for TypeScript can and should inform future efforts.


### Classic features

Per the edition support policy, we could choose *not* provide direct support for Ember Classic features in the core types. Since those types are still in use throughout the ecosystem, including in key ways for Ember Data, we would need to support them *somehow*, but we could do so by instead providing a *bridge* for working with them, analogous to the legacy support packages provided at major version changes.

In that design, we would ship a package like `@ember-types/classic`, which took advantage of [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) to provide enhanced versions of those types. This would allow us to keep the supported public API published *by Ember* much smaller and simpler, while also providing an escape hatch for parts of the ecosystem which are still transitioning to Octane idioms (including especially Ember Data).

This would be a reasonable approach—and was in fact what the other Typed Ember folks and I originally thought we would do!—but we decided against it because of the problems with making the classic types work well *at all*. The approach we are *actually* proposing is minimal and easy to support, minimizes impact to the ecosystem as it stands, and actually provides *better* feedback during the transition period.


### Semantic versioning options

- Instead of adopting the “rolling window” TypeScript version policy, we could lock each Ember major version to the minimum supported version of TypeScript at the time the Ember major was released. For example, if TypeScript 5.0 were the minimum supported version for Ember 5.0, it would *remain* the supported version throughout the Ember 5.x life-cycle. The major downside here is that it prevents Ember itself from taking advantage of any new type system features for the entirety of the Ember major release.

    For context, if we had adopted the “simple majors” policy for TypeScript with the Ember 3.x era, we would have been stuck with TypeScript 2.6 or 2.7 until Ember 4.0’s release in November 2021. In that time frame, there were over 20 TypeScript releases, some of which included features which allowed for major improvements to the experience of authoring Ember apps and addons and caught many more bugs.

- Instead of allowing Ember’s published types to support only the current edition at a major, we could require that all public API be supported as long as it exists. The downside to this approach is primarily for the Ember 4.x era, where robustly supporting Ember Classic idioms with TypeScript is difficult at best and in some cases impossible. Presumably, by the time of Ember 5.0, it will be possible to publish types directly from Ember’s source (with no use of ambient types), so supporting pre-Polaris idioms may be *lower* effort than not.

    However, we fundamentally *need* that flexibility for official TypeScript support in the Ember 4.x era while we finish removing Classic APIs. Moreover, it will not hurt us to have the flexibility available for future releases: having the option on the table does not require us to use it.

- Instead of using `strict: true`, we could adopt a specific set of flags to support for the life of an Ember major series—presumably, the set of flags corresponding to `strict: true` at the time of a major version. However, this would mean we would not be providing benefits to users who *are* using `strict: true`, and might put us in the position of having to tell users *not* to use `strict: true` because our types don’t support it. **This is not merely hypothetical:** it was the case for 3–4 years for Ember’s types on DefinitelyTyped! The result is maintenance churn and needlessly lower strictness than available from TypeScript.


### Documentation

- The guides for migrating from DefinitelyTyped could be hosted as dedicated documentation rather than blog posts. This would have the upside of being long-lived documentation for apps which make this change at later points (since it requires updating to the specific Ember version before it becomes possible). However, it has the downside of being dedicated documentation we must maintain which is *only* valuable for that one specific transition, and it is really part of the "upgrade" process for apps using TypeScript.

- This RFC could specify details for documenting the disctinction between “primary” and “seconadry” packages (with implications for their SemVer commitments) in a future where the packages *do* actually exist and can be installed independently of each other. However, since it is not clear when that will happen, or what the versioning design for those packages will be, it seems more appropriate to defer any such discussion to an RFC which designs those features as a coherent whole.


## Unresolved questions

None!


---

---
stage: accepted # FIXME: This may be a further stage
start-date: 2022-02-25T00:00:00.000Z
release-date:
release-versions:
teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/801
project-link:
---

# Deprecate `blacklist` and `whitelist` build options

## Summary

This RFC proposes to deprecate the `blacklist` and `whitelist` build options, in
favour of the `exclude` and `include` build options.

## Motivation

In [RFC 639](https://emberjs.github.io/rfcs/0639-replace-blacklist-whitelist.html),
the `exclude` and `include` build options were introduced. These options provide
exactly the same functionality as the `blacklist` and `whitelist` build options,
but these new terms are more neutral.

RFC 639 was implemented and released in [Ember CLI v4](https://github.com/ember-cli/ember-cli/blob/master/CHANGELOG.md#v400),
which means we should be able to deprecate the old terms in favour of the new
ones somewhere in the near future.

## Transition Path

When either the `blacklist` or the `whitelist` build option is used, the
following deprecation message will be triggered:

```
Using the `addons.blacklist` or the `addons.whitelist` build option is deprecated.
Please use `addons.exclude` or `addons.include` respectively instead.
```

**Deprecation details:**

| Key     | Value                                           |
| ------- | ----------------------------------------------- |
| `for`   | `'ember-cli'`                                   |
| `id`    | `'ember-cli.blacklist-whitelist-build-options'` |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }`      |
| `until` | `'5.0.0'`                                       |

## Deprecation Guide

The `addons.blacklist` and the `addons.whitelist` build options are deprecated.
Please use `addons.exclude` or `addons.include` respectively instead.

### Before

```js
// ember-cli-build.js

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    addons: {
      blacklist: ['ember-freestyle'],
    },
  });

  return app.toTree();
};
```

### After

```js
// ember-cli-build.js

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    addons: {
      exclude: ['ember-freestyle'],
    },
  });

  return app.toTree();
};
```

## How We Teach This

At the moment, these options are not mentioned in the Ember CLI guides.
This means, no documentation updates are required.

## Drawbacks

- I cannot see any real drawbacks at the moment, the only user action that is
required to resolve the deprecation is to rename one or two configuration keys

## Alternatives

- I cannot think of any alternatives worth mentioning, keeping both sets of keys
doesn't seem like a good idea, because they provide exactly the same functionality

## Unresolved questions

- None at the moment


---

---
stage: recommended
start-date: 2022-03-29T00:00:00.000Z
release-date: 2023-03-03T00:00:00.000Z
release-versions:
  ember-cli: v4.11.0
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/811'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/885'
  released: 'https://github.com/emberjs/rfcs/pull/928'
  recommended: 'https://github.com/emberjs/rfcs/pull/934'
project-link:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Element Modifiers

## Summary

This RFC introduces the concept of user defined element modifiers and proposes
adding [ember-modifier](https://github.com/ember-modifier/ember-modifier)
to the blueprint that back `ember new`, providing an
officially-supported path for using modifiers out of the box.

This RFC supersedes the original [RFC #353 "Modifiers"][rfc-0353].

## Motivation

Ember Octane introduced Glimmer Components as a replacement for Classic
Components. They are simpler, more ergonomic, and more declarative. In contrast
with Classic Components, Glimmer Components don't have any element/DOM based
properties or hooks giving access to DOM. This was an intentional move as
component backing class gets disconnected from DOM manipulation.

Modifiers are similar to template helpers: they are functions or classes that can be used
in templates directly using `{{double-curlies}}` syntax. The major difference with modifiers
is that they are applied directly to *elements*:

```handlebars
<button {{effect "fade-in"}}>Save</button>
```

This RFC builds on top of low-level primitives for defining element modifiers
introduced in [RFC #373 "Element Modifier Manager"][rfc-0373].
The `ember-modifier` addon was built on top of those low-level primitives and
provides a convenient API for authoring element modifiers in Ember.

Element Modifiers were introduced as part of Ember Octane edition and are first class citizens
in Ember application, like components or helpers. However today, developers need to install
an additional library to be able to define custom modifiers.

This RFC seeks to fill this gap in Ember.js' development mental model by
providing `ember-modifier` in the blueprint. `ember-modifier` will be added
to `devDependencies`, same as e.g. @glimmer/component.

A basic element modifier is defined with the type of `modifier`.
For example these paths would be global element modifiers in an application:

* `app/modifiers/draggable.js`
* `app/modifiers/effect.js`

Similar to helpers, modifiers can be function-based:

```js
// /app/modifiers/on.js
import { modifier } from 'ember-modifier';

export default modifier((element, [eventName, handler]) => {
  element.addEventListener(eventName, handler);

  return () => {
    element.removeEventListener(eventName, handler);
  }
});
```

or class-based

```ts
// /app/modifiers/on.js
import Modifier from 'ember-modifier';
import { registerDestructor } from '@ember/destroyable';

function cleanup(instance: OnModifier) {
  let { element, event, handler } = instance;

  if (element && event && handler) {
    element.removeEventListener(event, handler);

    instance.element = null;
    instance.event = null;
    instance.handler = null;
  }
}

export default class OnModifier extends Modifier {
  element = null;
  event = null;
  handler = null;

  // Manage teardown
  constructor() {
    super(...arguments);
    registerDestructor(this, cleanup);
  }

  // Run on installation and all changes to tracked state.
  modify(element, [event, handler]) {
    // Clear any previous state.
    cleanup(this);

    // Set up the new handling.
    this.addEventListener(element, event, handler);
  }

  // methods for reuse
  addEventListener(element, event, handler) {
    // Store the current element, event, and handler for when we need to remove
    // them during cleanup.
    this.element = element;
    this.event = event;
    this.handler = handler;

    element.addEventListener(event, handler);
  };
}
```

While this is slightly more complicated than the function-based version,
that complexity comes along with much more *control*. It also allows us to hook
into Ember's dependency injection system, for example to use services.

[RFC #432: Contextual Helpers and Modifiers][rfc-0432] allows optional
invocation and partial application of modifiers, and allows modifiers to be
yielded, passed as arguments, etc. [RFC #779: First-Class Component
Templates][rfc-0779] allows defining them locally or importing them directly to
be used in a `<template>` context. This combination makes many patterns much
easier to implement:

```js
// /app/components/slide-up-card.js
import Component from '@glimmer/component';
import { modifier } from 'ember-modifier';

const lockBodyScroll = modifier((element, [shouldLockBodyScroll]) => {
  document.body.classList.add('lock-scroll');
  return () => document.body.classList.remove('lock-scroll');
});

export default class SlideUpCard extends Component {
  @action closeCard (event) {
    event.preventDefault();
    this.args.close();
  }

  <template>
    {{#if has-block}}
      {{yield (hash lock=lockBodyScroll onClick=this.closeCard)}}
    {{else}}
      <div
        class="slide-up-card"
        ...attributes
        {{lockBodyScroll}}
      >
        <p>{{@bodyContent}}</p>

        <button {{on "click" this.closeCard}}>Dismiss</button>
      </div>
    {{/if}}
  </template>
}
```

## Detailed design

The necessary changes to `ember-cli` are relatively small since we only need
to add the dependency to the `app` blueprint.

Note that `addon` blueprint will not include `ember-modifier` due to
unresolved question (at the time of writing this RFC) regarding how addons
should declare dependencies like `@glimmer/component`, `@glimmer/tracking`, `ember-modifier` etc.

This has the advantage (over including it as an implicit dependency), that
apps that don't want to use it for some reason can opt out by
removing the dependency from their `package.json` file.

**Notes:**
1. This is *not* the usual path for delivering features into Ember: we do not
   generally introduce community addons directly into the blueprint. In this
   specific case, we think it is the right move:

    - The addon has intentionally been reworked to rationalize it in
      terms of the rest of the Octane programming model, explicitly with an eye to adoption in this way.
    - We do *not* want to introduce `@glimmer/modifier` with exactly this
      API, at least not yet, because we believe we may want to introduce
      a slightly updated API from that package *without* requiring
      breaking changes in the future.
2. We are intentionally introducing more "incoherence" to the programming
   model with this addition. (Or rather, we are acknowledging the *existing*
   incoherence in the ecosystem, with an eye to making progress on resolving
   it!) In particular, as the community begins adopting strict mode templates
   via First-Class Component Templates in the months ahead, they will often
   end up importing from both `ember-modifier` and `@ember/modifier`:

   ```js
   import { on } from '@ember/modifier';
   import { modifier } from 'ember-modifier';
   const playWhen = modifier((el, [shouldPlay]) => {
     if (shouldPlay) {
       el.play();
     } else {
       el.pause();
     }
   });
   <template>
     <audio
       src={{@src}}
       {{on "error" @onBadLoad}}
       {{playWhen @shouldPlay}}
     />
   </template>
   ```

   As noted in (1) above, we have ideas on how to resolve this, but are
   intentionally not blocking on those in favor of unlocking this key
   functionality for Ember users in the Octane programming model *today*.

## How we teach this

Ember Guides already teach how to use modifiers in "Template Lifecycle, DOM, and Modifiers"
section of the guides.

However, there are a couple changes we need to make to the content of the
guides as they stand today:

1. We will remove the "install `ember-modifier`" instruction from the guides,
   since it will already be part of the blueprint.
2. We should include at least a minimal example of a class-based modifier. For
   that example, we can use something like `setInterval` to show how setup,
   updates, and teardown can be more convenient when using a class.
   (Note that here we should *only* teach the [newly-redesigned API][v3.2.0], not
   the deprecated previous APIs. This will simplify our teaching significantly,
   since we can describe how it matches the `Helper` APIs.)

## Drawbacks

- If we merge [RFC #757 "Default Modifier Manager][rfc-0757],
  it may seem redundant with this RFC.
- There is the potential for confusion between the `ember-modifier` package and
  the `@ember/modifier` package which ships as part of `ember-source`.

## Alternatives

- Introduce [RFC #757 "Default Modifier Manager][rfc-0757]
  creating modifiers and ask developers to install `ember-modifier`
  for more complex use cases.
- Integrate `ember-modifier` into the `@ember/modifier` package directly.
- Introduce a new `@ember/*` or `@glimmer/*` package for the contents of
  `ember-modifier`.

## Unresolved questions

None.

[rfc-0353]: https://github.com/emberjs/rfcs/pull/353
[rfc-0373]: https://emberjs.github.io/rfcs/0373-Element-Modifier-Managers.html
[rfc-0432]: https://emberjs.github.io/rfcs/0432-contextual-helpers.html
[rfc-0757]: https://github.com/emberjs/rfcs/pull/757
[rfc-0779]: https://github.com/emberjs/rfcs/pull/779
[v3.2.0]: https://github.com/ember-modifier/ember-modifier/releases/tag/v3.2.0

---

---
stage: recommended
start-date: 2022-03-29T00:00:00.000Z
release-date: 2023-01-21T00:00:00.000Z
release-versions:
  ember-cli: v4.10.0
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/812'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/886'
  released: 'https://github.com/emberjs/rfcs/pull/937'
  recommended: 'https://github.com/emberjs/rfcs/pull/943'
project-link:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Add tracked-built-ins

## Summary

This RFC proposes adding [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins)
to the blueprint that back `ember new`.

## Motivation

Ember had historically shipped `EmberArray` and `EmberObject`
as well as `Map` and `Set` implementations to make it easy
to work with those types in a reactive way.
`tracked-built-ins` does the same for the auto-tracking era.

Autotracking (Ember's reactivity model) is one of the key features of
[Ember Octane](https://emberjs.com/editions/octane/). `tracked-built-ins` fills the gap
in the reactivity mental model we have today when it comes to tracking updates in data structures.

Today, `@tracked` decorator may be used to track updates of the primitive values:

```js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

export default class CounterComponent extends Component {
  @tracked count = 0;

  @action increment() {
    this.count = this.count + 1;
  }

  @action decrement() {
    this.count = this.count - 1;
  }
}
```

However, there are cases when there are unknown, dynamic, or potentially infinite numbers
of decoratable keys. In such cases we can use `Object`, `Map` or another data structure
that fits most in the particular use case. The initial pattern proposed for Ember Octane
in such scenarios was to re-set the tracked property:

```js
class TrackedMap {
  @tracked map = new Map();

  updateMapValue(key, value) {
    this.map.set(key, value);
    this.map = this.map;
  }
}
```

This pattern is problematic however, because it's not obvious what the
purpose of re-setting the property is. A developer unfamiliar with Ember may
mistakenly believe this was an error, and remove this statement, causing
bugs. This pattern is not easy to search on the Internet, which makes it more
difficult to learn and to teach. Finally, it's fairly easy this way for the
state to get out of sync with the rest of the system if a developer forgets
to add the extra re-set after mutating the value.

Over time, it's become clear that this pattern is actually an anti-pattern
for these reasons, and something we should begin to discourage in general.

[RFC #669 "Tracked Storage Primitives"][rfc-0669] introduced low level primitives
that allow to implement tracked versions of JavaScript's built-in classes
in an addon like [tracked-built-ins](https://github.com/tracked-tools/tracked-built-ins):

```ts
import {
  TrackedObject,
  TrackedArray,
  TrackedMap,
  TrackedSet,
  TrackedWeakMap,
  TrackedWeakSet,
} from 'tracked-built-ins';

class Foo {
  @tracked value = 123;

  obj = new TrackedObject<{[string: number]}>({ foo: 123 });
  arr = new TrackedArray<string, number>(['foo', 123]);
  map = new TrackedMap<string, number>(['foo', 123]);
  set = new TrackedSet<string, number>(['foo', 123]);
  weakMap = new TrackedWeakMap<{[object: number]}>([[{}, 456]]);
  weakSet = new TrackedWeakSet<string, number>(['foo', 123]);
}
```

or using `tracked()` decorator:

```ts
import { tracked } from 'tracked-built-ins';

class Foo {
  @tracked value = 123;

  obj = tracked<{[string: number]}>({ foo: 123 });
  arr = tracked<string, number>(['foo', 123]);
  map = tracked<string, number>(new Map(['foo', 123]));
  set = tracked<string, number>(new Set(['foo', 123]));
  weakMap = tracked<{[string: number]}>(new WeakMap([[{}, 456]]));
  weakSet = tracked<string, number>(new WeakSet(['foo', 123]));
}
```

## Detailed design

The necessary changes to `ember-cli` are relatively small since we only need
to add the dependency to the `app` blueprint.

Note that `addon` blueprint will not include `tracked-built-ins` due to
unresolved question (at the time of writing this RFC) regarding how addons
should declare dependencies like `@glimmer/component`, `@glimmer/tracking`, `tracked-built-ins` etc.

This has the advantage (over including it as an implicit dependency), that
apps that don't want to use it for some reason can opt out by
removing the dependency from their `package.json` file.

At the time of writing this RFC, `tracked-built-ins` provides
autotracked alternatives only to the 6 data structure types
most commonly used in real-world JavaScript today:

- `Object`
- `Array`
- `Map`
- `Set`
- `WeakMap`
- `WeakSet`

However, this should not be considered final and immutable list of types,
and we are open to adding other built-in data structures in the future
*if and as usage demonstrates the necessity thereof*.

The tracked data structures create a *shallow* copy of the original object
in order to avoid its mutation which may lead to issues.

The tracked data structures provided by `tracked-built-ins` addon are *not* deeply tracked.
This can be demonstrated in such example:

```ts
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { TrackedObject } from 'tracked-built-ins';

export default class Scoreboard extends Component {
  obj = new TrackedObject({
    foo: {
      bar: 'baz'
    },
    bar: 'baz'
  });

  @action
  myAction() {
    this.obj.bar = 'barBaz'; // is autotracked and triggers re-render.
    this.obj.foo.bar = 'barBaz'; // is *not* autotracked and *does not* trigger re-render.
  }

  <template>
    bar: {{this.obj.bar}}
    foo.bar: {{this.obj.foo.bar}}

    <button type="button" {{on "click" this.myAction}}>press me</button>
  </template>
}
```

There several reasons for that limitation:
 - the correct semantics for a framework-level hook there aren't obvious.
 - it is possible to build variants on it fairly cheaply in user-land given `tracked()` as updated here.

## How we teach this

The following guide should be added to the Autotracking In-Depth guide in the official guides, and the
sections on [POJOs][guides-pojos] and [Array][guides-arrays] should be removed.

### Tracked data structures

Generally, you should try to create classes with their tracked properties enumerated
and decorated with `@tracked`, instead of relying on dynamically created objects.
In some cases however, there could be a prohibitive number of possible properties,
or there could be no way to know them in advance.
In this case, you should use tracked versions of JavaScript's built-in
Plain Old JavaScript Object (POJO), array or keyed collection (Maps, Sets, WeakMaps, WeakSets)
provided by `tracked-built-ins` package.

```js
import {
  TrackedObject,
  TrackedArray,
  TrackedMap,
  TrackedSet,
  TrackedWeakMap,
  TrackedWeakSet,
} from 'tracked-built-ins';
```

For example, we could make a scoreboard component that keeps score for an
arbitrary number of players, and keep track of the score for each player using
tracked version of JavaScript [Map][global-objects-map].

**Note:** In this and the following examples, I am using `<template>` from
[RFC #779][rfc-0779].

```js
// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { TrackedMap } from 'tracked-built-ins';

const PLAYERS = [
  { name: 'Zoey' },
  { name: 'Tomster' },
];

export default class Scoreboard extends Component {
  // Create a map from player -> score, with each player's score starting at 0
  scores = new TrackedMap(PLAYERS.map(p => [p, 0]));

  @action
  incrementScore(player) {
    let currentScore = this.scores.get(player);

    this.scores.set(player, currentScore + 1);
  }

  <template>
    {{#each-in this.scores |player score|}}
      <div>
        {{player.name}}: {{score}}
    
        <button type="button" {{on "click" (fn this.incrementScore player)}}>
          +
        </button>
      </div>
    {{/each-in}}
  </template>
}
```

Let's take a look into another example involving a shopping cart, where we keep track
of the items added to cart using tracked version of JavaScript's [Array][global-objects-array].

```js
// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { TrackedArray } from 'tracked-built-ins';

export default class Cart extends Component {
  items = new TrackedArray([
    { productName: 'Jeans' },
    { productName: 'T-shirt' },
  ]);

  @action
  addPants(item) {
    this.items.push(item);
  }

  <template>
    {{#each this.items as |item|}}
      <div>
        {{item.productName}}
      </div>
    {{/each}}
  
    <button type="button" {{on "click" (fn this.addPants @pants)}}>
      Add Pants
    </button>
  </template>
}
```

## Drawbacks

> Why should we *not* do this? Please consider the impact on teaching Ember,
on the integration of this feature with other existing and planned features,
on the impact of the API churn on existing apps, etc.

> There are tradeoffs to choosing any path, please attempt to identify them here.

## Alternatives

- `tracked-built-ins` can be added both to the `app` and `addon` blueprints.

- Do nothing and recommend using re-setting the property to track data structure changes.

  The tradeoffs of this approach described in "Motivation" section of this RFC.

- Don't add `tracked-built-ins` to the blueprint and only update Ember Guides.

  Ember.js is advertised as "batteries included" framework with complete out-of-the-box experience.
  Asking users to install additional dependencies to achieve relatively common problem contradicts
  with that paradigm.

## Unresolved questions

- What, if any, substantive changes to the APIs presented by `tracked-built-ins` should we make?

- Should we introduce these at something like `@glimmer/tracking` instead?

  ```js
  import { tracked, TrackedMap, TrackedSet /* etc. */ } from '@glimmer/tracking';
  ```

- Alternatively, should they have a dedicated module for each type?

  ```js
  import TrackedMap from '@glimmer/tracking/map';
  import TrackedSet from '@glimmer/tracking/set';
  // etc.
  ```

[rfc-0669]: https://emberjs.github.io/rfcs/0669-tracked-storage-primitive.html
[rfc-0779]: https://emberjs.github.io/rfcs/0779-first-class-component-templates.html
[guides-pojos]: https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_plain-old-javascript-objects-pojos
[guides-arrays]: https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_arrays
[global-objects-map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
[global-objects-array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array


---

---
stage: accepted
start-date: 2022-04-19
release-date:
release-versions:
teams:
  - cli
prs:
  accepted: https://github.com/emberjs/rfcs/pull/814
project-link:
---

# Add stylelint to Ember blueprints

## Summary

This RFC proposes adding [stylelint](https://stylelint.io/) to the blueprints 
that back `ember new` and `ember addon`.

## Motivation

Ember app and addons already come with a broad variety of linting plugins targeting various areas 
of our codebases:

* [ember-template-lint](https://github.com/ember-template-lint/ember-template-lint) - Handlebars & Ember Templating Best Practices
* [eslint](https://eslint.org/) - General JavaScript Best Practices
* [eslint-plugin-ember](https://github.com/ember-cli/eslint-plugin-ember) - Ember JavaScript Best Practices
* [eslint-plugin-node](https://github.com/mysticatea/eslint-plugin-node) - Node Best Practices
* [eslint-plugin-qunit](https://github.com/platinumazure/eslint-plugin-qunit) - QUnit Best Practices [RFC](https://github.com/emberjs/rfcs/blob/master/text/0702-eslint-plugin-qunit.md)
* [prettier](https://prettier.io/) - Automated Code Styling [RFC](https://github.com/emberjs/rfcs/blob/master/text/0628-prettier.md)

With all these amazing tools in place, however, we still have a major aspect of our Ember codebases 
that are not benefiting from mature tooling to enforce best practices and automate code styling: CSS.

[Stylelint](https://github.com/stylelint/stylelint) is a modern linter for stylesheets that ships with 
over 170 built-in rules, sane default configs, and robust plugin support.

## Detailed design

The general idea is that we will update the `app` and `addon` [blueprints](https://github.com/ember-cli/ember-cli/tree/master/blueprints) 
to add a few Stylelint-related packages to the `package.json`, add config files to enable this tooling 
by default, and add commands to the `scripts` section of `package.json` to expose easy access to this 
tool consistent with our existing linters.

### Packages

The following packages will be added to the `devDependencies` section of both blueprints:

* [stylelint](https://github.com/stylelint/stylelint) - The base linter
* [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard) - The standard rule config supported by the stylelint community
* [stylelint-prettier](https://github.com/prettier/stylelint-prettier) - Plugin to support prettier auto-formatting as stylelint rules
* [stylelint-config-prettier](https://github.com/prettier/stylelint-config-prettier) - Plugin to disable stylelint rules that conflict with prettier's automatic behavior

Prettier itself is already included in the Ember blueprints by default.

### Configuration Changes

A `.stylelintrc.js` file will be added with the following contents:

```js title=".stylelintrc.js"
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

There are many rules, configs, and plugins available for stylelint and prettier, but we are 
intentionally avoiding being prescriptive on anything that isn't nearly universally agreed upon 
by the stylelint, prettier, and Ember communities.

#### Lint Ignores

A `.stylelintignore` file will be added with the following contents:

```title=".stylelintignore"
# unconventional js
/blueprints/*/files/
/vendor/

# compiled output
/dist/
/tmp/

# dependencies
/bower_components/
/node_modules/

# misc
/coverage/
!.*
.*/
.eslintcache
.lint-todo/

# ember-try
/.node_modules.ember-try/
/bower.json.ember-try
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try
```

These contents are based on the existing `.eslintignore` and `.prettierignore` files for consistency.

### Blueprint Changes

In general, it is recommended that all blueprints provided by addons should satisfy the default 
linting configuration of a new Ember application. As such, the blueprints provided by ember-cli 
will be updated as needed to ensure that they satisfy these new linting requirements.

#### `package.json` scripts

The `app` and `addon` blueprints will be updated to add style-related linting scripts:

```json title="package.json"
{
  "scripts": {
    "lint:css": "stylelint \"**/*.{css}\"",
    "lint:css:fix": "npm-run-all \"lint:css --fix\"",
  }
}
```

#### Linting Stylelint's Config

`.stylelintrc.js` should be [linted as a node file](https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/.eslintrc.js#L26-L38) 
in eslint's config.

#### npmignore

`/.stylelintrc.js` should be added to the `addon` blueprint's [`npmignore` file](https://github.com/ember-cli/ember-cli/blob/master/blueprints/addon/files/npmignore).

## How we teach this

We do not currently discuss linting or stylistic formatting in either guides.emberjs.com or cli.emberjs.com.

However, [previous linting RFCs](https://github.com/emberjs/rfcs/blob/master/text/0628-prettier.md) have 
proposed adding a subsection to the CLI guides to discuss linting. As that is implemented, we can include 
basic information about style linting as well.

Documentation for the new rules can be found within the Doc sites & READMEs for the packages being added by this RFC.

## Drawbacks

For those introducing stylelint to an existing codebase, the largest drawback is generally the 
initial cost of fixing linting violations. This can be mitigated by individually disabling noisy 
lint rules and working to fix violations overtime, or by extending the [lint-todo](https://github.com/lint-todo/) 
functionality available for `ember-template-lint` and `eslint` to support `stylelint` as well. 
However, note that this RFC is more likely to impact newly-generated applications where there 
will be no existing lint violations to fix as opposed to existing applications.

## Alternatives

>Ember applications may choose to use CSS, SCSS, LESS, or other approaches for styling. How do we 
>reconcile our default linting config?

Today, the de facto default for Ember apps via the blueprints is CSS, so our default configuration 
should strive to support that use-case. `stylelint` has readily-available support for popular 
preprocessors built-in, and there are plugins like [`stylelint-scss`](https://github.com/stylelint-scss/stylelint-scss) 
that add rules specific to those ecosystems for teams to opt into.

>Why name the scripts `lint:css` instead of something more universal like `lint:style`?

With CSS being the default in Ember applications, this is consistent with our existing linting strategy. 
While teams may choose to adopt a preprocessor like SASS in the same way they could adopt TypeScript 
over JavaScript, we still default to `lint:js` and `lint:hbs` to match the standard file types of 
a new Ember application.

>Why use `stylelint-config-standard` over `stylelint-config-recommended`?

The standard config intentional extends the recommended config, which is just a smaller subset of rules. 
The [README](https://github.com/stylelint/stylelint-config-standard/blob/main/README.md) for the standard 
config talks briefly about the philosophy behind the additional rules it adds. If there is a strong case 
for the standard config being a divergence from how the Ember community would commonly author stylesheets, 
we could fall back to the recommended config instead. However, the standard config appears to provide sane 
defaults for new applications.

## Unresolved questions

This RFC will be updated as such questions are posed, until we have an answer.


---

---
stage: recommended
start-date: 2022-05-23T00:00:00.000Z
release-date: 2022-12-13T23:20:00.000Z
release-versions:
  ember-source: v4.8.3
teams:
  - framework
  - typescript
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/821'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/874'
  released: 'https://github.com/emberjs/rfcs/pull/884'
  recommended: 'https://github.com/emberjs/rfcs/pull/893'
project-link:
---

# Public API for Type-Only Imports


## Summary <!-- omit in toc -->

Introduce public import locations for type-only imports which have previously had no imports, and fully specify their public APIs for end users:

- `Owner`, with `RegisterOptions` and `Factory`
- `Transition`
- `RouteInfo` and `RouteInfoWithAttributes`


## Outline <!-- omit in toc -->

- [Motivation](#motivation)
- [Detailed design](#detailed-design)
  - [`Owner`](#owner)
    - [`RegisterOptions`](#registeroptions)
    - [`Factory`](#factory)
    - [`FactoryManager`](#factorymanager)
    - [`FullName`](#fullname)
    - [`getOwner` and `setOwner`](#getowner-and-setowner)
  - [`Transition`](#transition)
  - [`RouteInfo`](#routeinfo)
    - [`RouteInfoWithAttributes`](#routeinfowithattributes)
  - [`Resolver`](#resolver)
- [How we teach this](#how-we-teach-this)
  - [`Owner`](#owner-1)
  - [`Transition`, `RouteInfo`, and `RouteInfoWithAttributes`](#transition-routeinfo-and-routeinfowithattributes)
  - [Blog post](#blog-post)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
- [Unresolved questions](#unresolved-questions)


## Motivation

Prior to supporting TypeScript, Ember has defined certain types as part of its API, but *without* public imports, since the types were not designed to be imported, subclassed, etc. by users. For the community-maintained type definitions, the Typed Ember team chose to match that policy so as to avoid committing the main project to public API. With the introduction of TypeScript as a first-class language (see esp. RFCs [0724: Official TypeScript Support][0724] and [0800: TypeScript Adoption Plan][0800]) those types now need public imports so that users can reference them; per the [Semantic Versioning for TypeScript Types spec][spec], they also need to define *how* they are public: can they be sub-classed, re-implemented, etc.?

[0724]: https://rfcs.emberjs.com/id/0724-road-to-typescript
[0800]: https://rfcs.emberjs.com/id/0800-ts-adoption-plan
[spec]: https://www.semver-ts.org

Additionally, the lack of a public import or contract for the `Owner` interface has been a long-standing problem for *all* users, but especially TypeScript users, and given the APIs provided for e.g. the Glimmer Component class where `owner` is the first argument, the pervasive use of `getOwner` in low-level library code, etc., it is important for TypeScript users to be able to use an `Owner` safely, and for JavaScript users to be able to get autocomplete etc. from the types we ship.


## Detailed design

**Note:** For the terms "user-constructible" and "user-subclassable" see the [Semantic Versioning for TypeScript Types spec][spec].

### `Owner`

`Owner` is a **non-user-constructible** interface, with an intentionally minimal subset of the existing `Owner` API, aimed at what we *want* to support for `Owner` in the future:

```ts
export default interface Owner {
  lookup(fullName: FullName): unknown;

  register(
    fullName: FullName,
    factory: Factory<unknown> | object,
    options?: RegisterOptions
  ): void;

  factoryFor(fullName: FullName): FactoryManager<unknown> | undefined;
}
```

`Owner` is the default import from a new module, `@ember/owner`:

```ts
import type Owner from '@ember/owner';

function useOwner(owner: Owner) {
  let someService = owner.lookup('service:some-service');
  // ...
}
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/owner').default} owner
 */
function useOwner(owner) {
  let someService = owner.lookup('service:some-service');
  // ...
}
```


`Owner` is non-user-constructible because constructing it correctly also requires the ability to provide a factory manager.[^existing-owner-usage]

In support of `Owner`, there are also four other newly-public types: `RegisterOptions`, `Factory`, `FactoryManager`, and `FullName`.

[^existing-owner-usage]: Existing usage of the Owner interface this way (e.g. setting custom owners for tests) mostly falls under the "intimate API" rules, and will likely be deprecated after a future introduction of a `createOwner()` hook so that that there is a public API way to get the required type.


#### `RegisterOptions`

`RegisterOptions` is a user-constructible interface:

```ts
export interface RegisterOptions {
  instantiate?: boolean | undefined;
  singleton?: boolean | undefined;
}
```

Although users will not usually need to use it directly, instead simply passing it as a POJO to `Owner#register`, it is available as a named export from `@ember/owner`:

```ts
import { type RegisterOptions } from '@ember/owner';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/owner').RegisterOptions} registerOptions
 */
function useRegisterOptions(registerOptions) {
  // ...
}
```


#### `Factory`

`Factory` is an existing concept available to users via [the `Engine#lookup` API][ff]. The public API only includes a `create` method, and we maintain that in this RFC. The result is this user-constructible interface:

[ff]: https://api.emberjs.com/ember/4.3/classes/EngineInstance/methods/factoryFor?anchor=lookup

```ts
export interface Factory<T> {
  create(initialValues?: Partial<T>): T;
}
```

`Factory` is available as a named import from `@ember/owner`:

```ts
import { type Factory } from '@ember/owner';

function useFactory(factory: Factory<unknown>) {
  let instance = factory.create();
}
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/owner').Factory<unknown>} factory
 */
function useFactory(factory) {
  let instance = factory.create();
}
```

```ts
import { type Factory } from '@ember/owner';

class Person {
  name: string;
  age: number;

  private constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class PersonFactory implements Factory<Person> {
  create({ name = "", age = 0 } = {}) {
    return new Person(name, age);
  }
}
```

(This is not the actual usual internal implementation in Ember, but shows that it can be implemented safely with these types.)


#### `FactoryManager`

`FactoryManager` is an existing concept available to users via [the `Engine#factoryFor` API][ff]. The public API to date has included only two fields, `class` and `create`, and we maintain that in this RFC. The result is this **non-user-constructible** interface:

[ff]: https://api.emberjs.com/ember/4.3/classes/EngineInstance/methods/factoryFor?anchor=lookup

```ts
export interface FactoryManager<T> {
  readonly class: Factory<T>;
  create(initialValues?: Partial<T>): T;
}
```

`FactoryManager` is now available as a named import from `@ember/owner`:

```ts
import { type FactoryManager } from '@ember/owner';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/owner').FactoryManager} factoryManager
 */
function useFactoryManager(factoryManager) {
  // ...
}
```


#### `FullName`

The `FullName` type is a user-constructible alias for Ember’s string namespacing:

```ts
export type FullName = `${string}:${string}`;
```

This form allows both the namespaced (`namespace@type:name`) and non-namespaced (`type:name`) variants of these keys. It does not fully validate that these match Ember’s own internal rules for these types, but provides a bare-minimum check on the type safety of strings passed into `Owner` APIs.

Although users will not usually need to use it directly, instead simply passing it as a string literal to `Owner#lookup`, `Owner#register`, or `Owner#factoryFor`, it is available as a named import from `@ember/owner`:

```ts
import { type FullName } from '@ember/owner';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/owner').FullName} fullName
 */
function useFullName(fullName) {
  // ...
}
```


#### `getOwner` and `setOwner`

Both of the existing `getOwner` and `setOwner` functions now make *much* more sense as named exports from `@ember/owner`. They will also now take `owner` as the type of their argument explicitly:

```ts
export function getOwner(object): Owner | undefined;
export function setOwner(object: unknown, owner: Owner): void;
```

The existing exports from `@ember/application` will become re-exports of these functions. The existing exports will also be deprecated, with the deprecation becoming "Available" no earlier than the first minor *after* an LTS containing the updated import location. For example, if `getOwner` and `setOwner` are available to import from `@ember/owner` in Ember v4.7, the deprecation for the imports from `@ember/application` would not be deprecated until at least Ember v4.9, after Ember v4.8 LTS.[^timeline]

[^timeline]: This is in line with our normal approach to deprecation: it allows the addon ecosystem to absorb the change via LTS support releases, so that consuming apps are not flooded with deprecations without recourse.


### `Transition`

`Transition` is a non-user-constructible, non-user-subclassable class. It is identical to the *existing* public API, with two new features:

- the specification of the generic type `T` representing the resolution state of the `Promise` associated with the route (and used with `RouteInfoWithAttributes`; see below)
- a public import location

Since it is neither constructible nor implementable, it should be supplied as type-only export. For example:

```ts
class _Transition<T = unknown>
  implements Pick<Promise<T>, 'then' | 'catch' | 'finally'> {

  data: Record<string, unknown>;
  readonly from: RouteInfoWithAttributes<T> | null;
  readonly promise: Promise<T>;
  readonly to: RouteInfo | RouteInfoWithAttributes<T>;
  abort(): Transition<T>;
  followRedirects(): Promise<T>;
  method(method?: string): Transition<T>;
  retry(): Transition<T>;
  trigger(ignoreFailure: boolean, name: string): void;
  send(ignoreFailure: boolean, name: string): void;

  // These names come from the Promise API, which Transition implements.
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    onrejected?: (reason: unknown) => TResult2 | PromiseLike<TResult2>,
    label?: string,
  ): Promise<TResult1 | TResult2>;
  catch<TResult = never>(
      onRejected?: (reason: unknown) => TResult | PromiseLike<TResult>,
      label?: string,
  ): Promise<TResult | T>;
  finally(onFinally?: () => void, label?: string): Promise<T>;
}

export default interface Transition<T> extends _Transition<T> {}
```

It is the default import from `@ember/routing/transition`:

```ts
import type Transition from '@ember/routing/transition';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/routing/transition').default} theTransition
 */
function takesTransition(theTransition) {
  // ...
}
```

### `RouteInfo`

`RouteInfo` is a non-user-constructible interface. It is identical to the *existing* public API, with the addition of a public import.

```ts
export default interface RouteInfo {
  readonly child: RouteInfo | null;
  readonly localName: string;
  readonly name: string;
  readonly paramNames: string[];
  readonly params: Record<string, string | undefined>;
  readonly parent: RouteInfo | null;
  readonly queryParams: Record<string, string | undefined>;
  readonly metadata: unknown;
  find(
    callback: (item: RouteInfo, index: number, array: RouteInfo[]) => boolean,
    target?: unknown
  ): RouteInfo | undefined;
}
```

It is the default import from `@ember/routing/route-info`:

```ts
import type RouteInfo from '@ember/routing/route-info';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/routing/route-info').default} routeInfo
 */
function takesRouteInfo(routeInfo) {
  // ...
}
```


#### `RouteInfoWithAttributes`

`RouteInfoWithAttributes` is a non-user-constructible interface, which extends `RouteInfo` by adding the `attributes` property. The attributes property represents the resolved return value from the route's model hook:

```ts
export interface RouteInfoWithAttributes<T = unknown> extends RouteInfo {
  attributes: T;
}
```

It is a named export from `@ember/routing/route-info`:

```ts
import { type RouteInfoWithAttributes } from '@ember/routing/route-info';
```

JS users can refer to it in JSDoc comments using `import()` syntax:

```js
/**
 * @param {import('@ember/routing/route-info').RouteInfoWithAttributes} routeInfo
 */
function takesRouteInfoWithAttributes(routeInfoWithAttributes) {
  // ...
}
```


### `Resolver`

The resolver is a contract implemented by libraries outside Ember itself, such as `ember-resolver`, `ember-strict-resolver`, and any number of custom resolvers which exist in apps across the ecosystem. It has never had public documentation, but is fully public API. It is a user-constructible interface with the following definition (using the `Factory` and `FullName` types exported from the new `@ember/owner` module):

```ts
export type KnownForTypeResult<Name extends string> = {
  [fullName in `${Name}:${string}`]: boolean | undefined;
};

export interface Resolver {
  knownForType?: <Name extends string>(type: Name) => KnownForTypeResult<Name>;
  lookupDescription?: (fullName: FullName) => string;
  makeToString?: (factory: Factory<object>, fullName: FullName) => string;
  normalize?: (fullName: FullName) => string;
  resolve(name: string): Factory<object> | object | undefined;
}
```

The `KnownForTypeResult` utility type associated with it is also available as a named export. Unfortunately, due to currently limitations with TypeScript, you will generally have to *cast* to it, but it provides some type safety to callers, because it will *only* allow types corresponding to the passed string if users pass a string literal.

Both are available as named, type-only, user-constructible interfaces from `@ember/owner`:

```ts
import { Resolver, KnownForTypeResult } from '@ember/owner';
```


## How we teach this

These concepts all already exist, but need updates to and in some cases wholly new pages in Ember's API docs.


### `Owner`

- We need to introduce API documentation in a new, dedicated module for `Owner`, `@ember/owner`. The docs on `Owner` itself should become the home for much of the documentation currently shared across the `EngineInstance` and `ApplicationInstance` classes.

- We need to document the relationship between `EngineInstance` and `ApplicationInstance` as implementations of `Owner`.

- We must update the existing docs for `factoryFor` to clarify that it is the only public API for getting a `FactoryManager`.


### `Transition`, `RouteInfo`, and `RouteInfoWithAttributes`

These types need two updates to the existing API documentation:

- Specify the modules they can be imported from (as noted above).

- Specify that these types are *not* meant to be implemented by end users. For example:

  > While the `Transition` interface can be imported to name the type for use in your own code, it is not user-implementable. The only supported way to get a `Transition` is by using Ember's routing APIs, like [the `transitionTo` method](https://api.emberjs.com/ember/4.3/classes/RouterService/methods/transitionTo?anchor=transitionTo) on [the router service](https://api.emberjs.com/ember/4.3/classes/RouterService).

  And:

  > While the `RouteInfo` interface can be imported to name the type for use in your own code, it is not user-implementable. The only supported way to get a `RouteInfo` is using a public API which provides it, including but not limited to:
  >
  > - the `from` or `to` properties on an instance of [the `Transition` class](https://api.emberjs.com/ember/4.3/classes/Transition)
  > - the `currentRoute` property on [the `RouterService` class](https://api.emberjs.com/ember/4.4/classes/RouterService)
  > - the `child` or `parent` properties on another `RouteInfo` instance, or as returned from the `find()` method on a `RouteInfo`


### Blog post

Besides the API docs described above and the usual discussion of new features in an Ember release blog post, we will include an extended discussion in that blog post, a blog post timed to come out around the same time as that release, or a blog post corresponding to when we add them to DefinitelyTyped, as makes the most sense. That post will situate these as part of the work done on the "road to TypeScript":

- emphasizing the benefits to both JS and TS users

- providing a straightforward explanation of the "non-user-constructible" constraint and refer users to the Semantic Versioning for TypeScript Types spec for more details

- explaining some choices about the public `Owner` API:
    - that it includes the subset of the `Owner` API we want to maintain over time, *not* the full set available on the `EngineInstance` type, much of which we expect to deprecate over the course of the 4.x release cycle
    - that it does not include type safe registry look-ups, since we are waiting to see what TypeScript does with the Stage 3 decorators spec before deciding how to work with registries going forward[^revise]

[^revise]: Depending on implementation timelines, it is possible we will revise this based on what TypeScript ships in the meantime.

More general work to clarify the use of TypeScript with these APIs will be addressed as part of the forthcoming RFCs on integrating TypeScript into Ember's docs.


## Drawbacks

For once: none! These are already all "intimate API" *at minimum*—`Owner` is effectively public API—and the only difference between the _status quo_ and the proposed outcome is that users can know these imports won't break. Moreover, the design here is forward-compatible with any iterations on these types we can currently foresee, including expanding the type of `Owner#lookup` to support registry, changes to the `Owner` API per [RFC #0585: Improved Ember Registry APIs][0585], or future directions for the Ember routing layer.

[0585]: https://rfcs.emberjs.com/id/0585-improved-ember-registry-apis


## Alternatives

- We could leave these in their private API locations.
- We could not publish these types at all, and have users continue to use utility types to name them (`ReturnType` etc.).


## Unresolved questions

- Should `Owner` be exported from `@glimmer/owner` instead? Presently, that acts as only a pass-through, with the notion of an owner being delegated to implementors of the various Glimmer "manager" APIs..

- Should `Owner` have any other of its existing APIs, and in particular should it be identical to the APIs exposed via `EngineInstance`, including these additional methods?
    - `inject`
    - `ownerInjection`
    - `registerOptions`
    - `registerOptionsForType`
    - `registeredOption`
    - `registeredOptions`
    - `registeredOptionsForType`
    - `unregister`

    (Since `Owner` itself has never been public API, and we hope to *deprecate and remove* all of these methods in the 4.x → 5.0 era, it seems best to leave them off of `Owner` in the newly-public API, only publishing the interface we want to support long-term.


- Should `Owner` be directly user-constructible, or should users be restricted to subclassing one of the existing concrete instances (`Engine` or its subclass `Application`)?


---

---
stage: released
start-date: 2022-07-12T00:00:00.000Z
release-date:
release-versions:
  ember-source: 6.0.0
  ember-cli: 6.0.0
teams:
  - steering
  - framework
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/830'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/878'
  released: 'https://github.com/emberjs/rfcs/pull/1057'
---

# Evolving Ember's Major Version Process

## Summary <!-- omit in toc -->

Introduce a standard release train for *major* releases, analogous to Ember's release train for minor releases:

- After every `M.12` minor release, Ember will ship a new major, `(M+1).0`, which removes any deprecated code targeted for that major release.
- Deprecations targeting the next major cannot be introduced later than the `M.10` release.

**The result is a steady 18-month cadence between Ember major releases, complementing our steady 6-week cadence between Ember minor releases.**

How this would work in practice for Ember's lifecycle from 4.8 to 7.0

| Ember Release |   Release date    |   LTS date    |
| ------------- | ----------------- | ------------- |
| 4.8           | October 2022      | November 2022 |
| 4.12          | April 2023        | May 2023      |
| **5.0**       | **May 2023**      |               |
| 5.4           | October 2023      | December 2023 |
| 5.8           | April 2024        | May 2024      |
| 5.12          | September 2024    | November 2024 |
| **6.0**       | **November 2024** |               |
| 6.4           | April 2025        | May 2024      |
| 6.8           | October 2025      | November 2025 |
| 6.12          | March 2026        | May 2026      |
| **7.0**       | **May 2026**      |               |


### Note <!-- omit in toc -->

There are two related considerations in this space:

- How does this relate to the lockstep versioning policy Ember, Ember CLI, and Ember Data have historically followed?
- What do we expect the timing of Ember Polaris to be relative to this cadence? More generally, exactly how should Editions relate to major releases?

However, those questions are orthogonal to this proposal: we can maintain lockstep, or not, with a standard cadence for major releases; and we can also decide whether (and if so, how) to align editions with major releases whatever cadence majors come on.


### Outline <!-- omit in toc -->

- [Motivation](#motivation)
- [Detailed design](#detailed-design)
  - [Freeze deprecations at `M.10`](#freeze-deprecations-at-m10)
  - [Bootstrap with Ember v5.0](#bootstrap-with-ember-v50)
  - [Simplify major version process](#simplify-major-version-process)
  - [Prior art](#prior-art)
- [How we teach this](#how-we-teach-this)
  - [Publicize the change](#publicize-the-change)
  - [Website 'Releases' page](#website-releases-page)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
  - [No change](#no-change)
  - [Pick a different cadence](#pick-a-different-cadence)
  - [Different point for freezing deprecations](#different-point-for-freezing-deprecations)
- [Unresolved Questions](#unresolved-questions)


## Motivation

Ember's approach to release versioning has served us well for the last seven years. We target minor releases every six weeks, and then do a major release to remove deprecated code on some long interval. Major releases being rare has been an explicit goal. Per [the Releases page][releases-current]:

>   You might notice that although Ember has been around for a long time, it's version number is low.
> That is because Ember aims to ship new features in minor releases, and make
  major releases as rare as possible.
> When you see a library or framework that has <i>many</i> major versions, each one of those numbers
  represents a "breaking change."
> Breaking changes force development teams to spend time researching
  the changes and modifing their codebase before they can upgrade.
> The bigger the codebase, or the more complex the app, the more time and effort it takes.
> Ember is committed to providing a better experience than that.

[releases-current]: https://github.com/ember-learn/ember-website/blob/a7a4191dc76170c855c9a0e93108c75456cdc554/app/templates/releases/index.hbs#L74-L84

The result is a steadily increasing time between major releases:[^pandemic]

| Transition |   Time    |  Start of major   | Start of next major |
| ---------- | --------- | ----------------- | ------------------- |
| 1.0 → 2.0  | 2 years   | August 13, 2013   | August 13, 2015     |
| 2.0 → 3.0  | ~2½ years | August 13, 2015   | February 14, 2018   |
| 3.0 → 4.0  | ~4 years  | February 14, 2018 | December 20, 2021   |

This is as we would expect given the explicit goal to "make major releases as rare as possible", especially given how the framework has matured such that it has not *needed* breaking changes as often. However, this policy of minimizing the number of major releases has actually tended over time to make major upgrades *more* rather than less painful—for both Ember users and Ember maintainers.[^maintainers]

- **For users:** Since each release major release comes after a longer period of time, it includes more deprecations to remove. This means that while the major releases may be more rare, they actually become *harder* over time. They also are not predictable, and therefore are difficult to account for in planning—unlike minor and LTS releases, which are *very* predictable!

- **For maintainers:** There is planning and coordination required for a major release, as well as a great deal of removal of deprecated code. This currently happens on an _ad hoc_ basis when the Framework team decides it is time. However, that means that the amount of planning work can grow very large, and the amount of work involved in removing deprecated code can be more or less unbounded. This is hard!

Switching to a predictable cadence will address both of these problems. In particular, it means that a deprecation targeting a given release will come with an expected *timeline*. Seeing that a deprecation targets v6 will tell someone that it will be removed in roughly March 2024, with the first LTS release in August 2024. That is incredibly valuable for medium- and long-term planning.

Additionally, removing deprecated code regularly decreases the surface area of the framework. This has a number of benefits:

- The API surface area is smaller, making it easier for users to know what they should use and what they should not.

- There is less code shipped in a bundle (though we also plan to address this by making Ember fully tree-shake-able and implementing "deprecation shaking").

- Introducing new features and fixing bugs are both easier, because there are fewer legacy interactions to account for over time.

- Related, new contributors can onboard more easily, because there are fewer crufty old parts of the code base to understand.

Finally, doing releases on a predictable cadence/release train also has the same effect on *major* releases that it does on *minor* releases: it decreases the pressure to get deprecations in before a major release, because there will always be another major release—and it won't be that long! It also means that the "freeze" period doesn't become a worry: it only freezes deprecations targeting the *next* major. This also enables longer-targeted deprecations where it makes sense.

For example: imagine a deprecation of some major piece of Ember landing early in 5.x (maybe deprecating the classic router in favor of some hypothetical new router design). Knowing the release cadence means that can *intentionally* target removal in 7.0 instead of 6.0. This will allow the deprecation to do its work as a messaging signal ("Don't use this in new code, and start migrating to the new thing"), while also providing a predictable and *long-term* schedule for its removal.


[^pandemic]: Even granting that the pandemic likely increased the time between 3.0 and 4.0 somewhat, we would likely have had *at least* a 2½–3-year gap between those releases.

[^maintainers]: We always prioritize users over maintainers if there is a hard choice between the two, but we also care about the long-term sustainability of the project. Things that make maintainers' lives hard decrease the sustainability of the project over time!


## Detailed design


### Freeze deprecations at `M.10`

One of the major things we learned from the 1.13 → 2.0 transition was that having too many deprecations piled up at the end of a major release can *feel* like it violates Ember's commitment to "stability without stagnation". Since then, we have frozen deprecations targeting the next major release late in the previous major release cycle. However, there have been two ongoing issues with this:

- Users have not known *when* that freeze would come. This made it difficult to know when to target a deprecation, or whether a deprecation was valuable at a given point in time, since it wasn't clear when the next major would even be.

- There has been a tendency to rush to get in deprecations in the period just before the freeze (in large part because major releases have been unpredictable: if you don't get it in *now*, it may be *years* before the deprecation takes effect!), which again undermines.

Given a known major release cadence, we can explicitly target a specific release as the last allowed time to target a given major. However, we can *also* keep landing deprecations past that freeze: they just have to target the next major. You could, for example, land a deprecation in 4.11 targeting 6.0, or even 7.0!


### Bootstrap with Ember v5.0

When Ember adopted its 6-week "release train" cadence for minor releases, it used the 1.1 release to "bootstrap" the process and help the team learn how to do it, identify gaps, etc., with no features added. We should do the same here with 5.0.


### Simplify major version process

Given the commitment to ship a major version on a schedule, it is critical that we make it as easy as possible to do so. We will therefore simplify the process of enabling a major so that there is no need for a large amount of work to be done immediately before its release.

**The following is non-normative but reflects our current best thinking:**

One likely mechanic for the `ember-source` package (and its internal subpackages) is to update our deprecation workflow and mechanics in the following ways:

1. Introduce new tooling to Ember's internal tests which simulate the mode in which the deprecation fails. (We already have some of this, but need to iterate on it.)

2. Require that all new deprecations test both the deprecated and non-deprecated paths, so we can be confident that removing the deprecation will not cause test failures. (This was an issue in the run up to 4.0.)

3. When releasing a major, the deprecations will be enabled *automatically* because they target that major version. Then the dead (deprecated) code paths can be removed incrementally and at will, rather than it *having* to be removed prior to the major release.


### Prior art

- Angular uses a six-month cadence for major releases, with every other major release (the even-numbered releases) being an LTS release.

- Node uses a six-month cadence for major releases, with every other major release (the even-numbered releases) being an LTS release.

- TypeScript uses a quarterly release cadence, and releases a "major" once they  hit the `M.9` release. Notably, they do not use SemVer, so this is not a particularly relevant comparison for *how* we approach this. It is relevant mostly by way of providing another example of a standard cadence for releases.


## How we teach this

### Publicize the change

When this RFC is accepted, we will publish a blog post to the Ember.js blog, tweet about it from the official account, and post the update to the official Discord and Discourse instances. We may also consider publishing in other media about it (e.g. publishing a dedicated video to the Ember Videos channel on YouTube).

Additionally, when we release the final minor version of the 4.x series and again when we release 5.0, we should explicitly describe the updated policy. This is similar to how Ember approached the introduction of the "release train" with 1.x and the messaging around major releases at the 2.0 release.


### Website 'Releases' page

Update the **Our Goals** section:

- Update this bullet point to include major releases:

    > - Make a minor release about every six weeks, so teams that use Ember can plan their work

    Updated:

    > - Make a minor release about every six weeks and a major release about every eighteen months, so teams that use Ember can plan their work

- Wholly reframe this bullet point:

    > - Only cut a new major version (i.e. make a breaking change) when we really, really have to

    Instead of focusing on duration, emphasize that we don't make breaking changes lightly:

    > - Only make breaking changes when we really, really have to

Update the **How Ember uses SemVer** section to clarify that we want to make breaking changes both rare *and predictable* and therefore manageable. We should also take this as an opportunity to clarify how we use major releases and editions.

The previous text:

> You might notice that although Ember has been around for a long time, it's version number is low. That is because Ember aims to ship new features in minor releases, and make major releases as rare as possible. When you see a library or framework that has many major versions, each one of those numbers represents a "breaking change." Breaking changes force development teams to spend time researching the changes and modifying their codebase before they can upgrade. The bigger the codebase, or the more complex the app, the more time and effort it takes. Ember is committed to providing a better experience than that.

Updated:

> Ember aims to ship new features in minor releases, to make breaking changes rare, and to make major releases predictable. Breaking changes force development teams to spend time researching the changes and modifying their codebase before they can upgrade. The bigger the codebase, or the more complex the app, the more time and effort it takes. Ember is committed to providing a better experience than that:
>
> 1. **We never couple the addition of new features to breaking changes.** Instead, we introduce a new feature to replace an existing feature, provide a migration path, then sometime later deprecate the old feature, and finally remove the old feature in a later major release.
>
> 2. **Ember major versions only remove deprecated features. They never introduce new features.** This means major releases are not exciting, just a predictable point where some cleanup happens.
>
> 3. **Ember's big releases are *Editions*.** An Edition lands in a minor release and is therefore always backwards compatible. It represents the point where all the features we shipped in minor releases are polished, well-documented, and recommended for everyone to use. [Read more here.](https://emberjs.com/editions/)


## Drawbacks

- We must use this as a way of *getting better* at doing major releases. As we have done them to date, this would be incredibly stressful.

- If we land too many large deprecations in a major release, it will still cause painful churn for both users and maintainers.

- If we do not communicate clearly about this, it could surprise or confuse both existing and potential new Ember users.


## Alternatives


### No change

Keep our existing approach, releasing new majors rarely. Focus *all* of our efforts on "deprecation shaking." That solves two parts of the motivation: allowing users not to pay for deprecated code in their bundle which they aren't using, and allowing Ember to signal clearly that users *should* stop using a given pattern. The rest of the motivation would be unaddressed, though.


### Pick a different cadence

We could adopt a different time-based cadence:

- This RFC originally proposed a **60-week cadence**, including the idea of an extra-long cycle for doing the major release.

**Annual:**  This would involve doing a major release just 4 weeks after the `M.8` release, which is a very compressed timeline, so we might need to instead target `M.7` as an LTS, followed by a 10-week cycle for the major release. Alternatively, we could shift to 4- or 8-week release cycles and update our LTS cadence accordingly.

**An longer cycle:** 16 minor releases, 24 minor releases, etc. That would still make the releases *predictable*, but we would still pile up deprecations for longer, and the work for both users and maintainers at the release cycle would still be higher. Additionally, we know from experience in software in general (especially around "devops") that the longer the cycles involved in any given process, the harder they tend to be. A higher cadence for releases actually tends to be *easier*.

That might suggest picking an even shorter cadence: new majors after every LTS release, e.g. 5.0, 5.4 LTS, 6.0, etc. That *would* help with the planning and we would get quite good at the process. There is also precedent, in that this is how both Angular and Node work. However, Angular and Node also *constantly* have LTS releases in active support across major releases, which ups the maintenance burden significantly. Picking a timeline of approximately a year (2 LTS releases) seems to best balance these tradeoffs.


### Different point for freezing deprecations

The `M.10` release is chosen as a point late in the cycle, and is actually earlier the point we have frozen deprecations relative to the next major in the pas. It is also relatively arbitrary, though! By taking the pressure off of any given major release, it's also less important. Our only *hard* constraint is that new deprecations targeting the next major not be introduced in the final LTS, so we could equally well choose `M.9` or `M.11`. And of course, if we picked a different cadence, we would pick a different value here as well.


## Unresolved Questions

- Given the intent to use Ember v5 for a "bootstrapping" process, should we freeze targeting deprecations for it early (say, as soon as this RFC is merged), to avoid making it more painful?


---

---
stage: recommended
start-date: 2022-07-22T00:00:00.000Z
release-date: 2024-04-19T00:00:00.000Z
release-versions:
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/831'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/959'
  released: 'https://github.com/emberjs/rfcs/pull/1018'
  recommended: 'https://github.com/emberjs/rfcs/pull/1019'
project-link: 'https://github.com/ember-learn/cli-guides/issues/272'
suite:
---

<!--- 
Directions for above: 

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# Standardize use of scripts in package.json for common tasks


## Summary

This change encourages developers to use scripts in `package.json` 
for certain commands when working with Ember
applications, rather than using global Ember CLI commands like `ember serve` or focusing on npm/yarn.
This aligns Ember with norms in the JavaScript community, and
helps in reducing the confusion around Ember-specific commands.

## Motivation

In many JavaScript projects, the following commands are very common:

```
npm start
npm test
```

These scripts are defined in the `package.json` of Ember apps, however,
Ember's documentation tells developers to run these commands instead:

```
ember serve
ember test
```

Notably, `ember test` and `npm test` give different results.

When we run `ember test`, it sets the environment to test and performs `Ember.onerror` validation by default.
Whereas, in the case of `npm test`, there is an abstraction of the underlying commands that allows the user to run extra checks such as lint tests across the files and finally performs `ember test`.
This is useful in carrying on a sequence of instructions and using them without having to worry about how they function behind the hood.
As a result, a lot of developer time is saved and it also reduces the human error that might have been made if the abstract tooling was not used.

`ember test`
![Ember test](/images/ember_test.png)

`npm test` 
![Npm test](/images/npm_test.png)

If documentation encouraged using `yarn` or `npm`, this would allow developers to customize the scripts
themselves while also having a standard command that everyone can run in any project 
and get an expected output, regardless of what's going on under the hood. We can include a link to "prior art" of showing `npm start` in CLI output.

Consider cases where the author of an addon sets up `yarn test` to run with `ember-exam`.
In such cases, one shouldn't be manually changing the default documentation for a script that already existed.

In another case of using the `package.json` script for start/test, it allows teams to abstract details about their specific dev environment,
which makes developers' jobs easier. They can use `yarn start` or 
`pnpm start` without actually having to know which command starts the server.
Moreover, using tooling abstraction provided by npm/yarn helps in staying consistent with industry standards rather than having to use bespoke
tools.

## Detailed design

This will involve two steps

1. We should decide whether we want a Standardize the use of yarn/npm scripts.

2. Then we make the changes in READMEs, contributing guides, CLI output, and in learning docs.

## How we teach this

The following resources would need to change:

* Ember-cli guides
* Ember guides 
* Ember API documentation 
* The Super Rentals tutorial
* Readme.md and Contributing.md of repos
* Blueprints in `ember-cli`
* We should mention that developers should always refer to Contributing.md for full instructions when working with a new app or addon. And following commands as examples: start, test, build, and prepare.

## Drawbacks

> Why should we *not* do this? Please consider the impact on teaching Ember,
on the integration of this feature with other existing and planned features,
on the impact of the API churn on existing apps, etc.
https://github.com/ember-cli/ember-cli/issues/8969#issuecomment-1167894022

> There are tradeoffs to choosing any path, please attempt to identify them here.

## Alternatives

* No change

## Unresolved questions

*  How does the difference between yarn 1, 2, and 3 affect us if we made this change?
*  Should we show yarn and npm for every example?


---

---
stage: accepted
start-date: 2022-08-18
release-date:
release-versions:
teams:
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/846

---

<!--- 
Directions for above: 

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# EmberData | Deprecate Proxies

## Summary

Deprecates usage of proxy apis provided by `Ember.ObjectProxy`, `Ember.PromiseProxyMixin` and `Ember.ArrayProxy` in favor of Promises, Native Arrays, and Native Proxies where appropriate.

Specifically this affects `RecordArray` `AdapterPopulatedRecordArray`, `ManyArray`, `PromiseArray`, and `PromiseRecord` but not `PromiseBelongsTo`.

## Motivation

Historically EmberData built many presentation classes overtop of Framework primitives out of necessity. Native Proxies did not yet exist, Promises were relatively unheard of, and async state management was the Wild West.

Today we have better native primitives available to us, affording us the opportunity to significantly simplify these presentation objects and better align them with user expectations in the modern Javascript world and Octane Ember.

Importantly, this simplification will allow for us to address the performance of the most expensive costs of managing and presenting data. It will also sever one of the last entanglements the core of EmberData has with the Framework. While this RFC does not in itself enable Ember-less usage of EmberData, it does
in effect make this a near possibility. 

## Transition Path

### PromiseRecord|PromiseArray

`id: 'ember-data:deprecate-promise-proxies'`

> Accessing any value on the proxy that is not a promise method will trigger a deprecation. This is similar in effect to [RFC 795](https://rfcs.emberjs.com/id/0795-ember-data-return-promise-save). Additionally we deprecate promise state flags, this includes deprecating the flags kept in RFC 795.

**Affected APIs:** `store.findRecord`, `store.queryRecord`, `model.save`, `store.findAll` and `store.query`

**Resolution:**

`await` the returned promise to receive the value to interact with. For promise state flags consider using [ember-promise-helpers](https://github.com/fivetanley/ember-promise-helpers)


----

### RecordArray|AdapterPopulatedRecordArray|ManyArray

`id: 'ember-data:deprecate-ember-array-like'`

> Utilizing EmberObject APIs or ArrayLike APIs that do not correlate to Native Array APIs will be deprecated.

- **Affected APIs:** `store.query|findAll|peekAll` and `hasMany` relationships on `@ember-data/model`
- **Resolution:** Convert to the corresponding native array API. In the most common case of `toArray()` this means to use `slice()` instead.

----

### PromiseBelongsTo | Model.errors

Since there is no path for a PromiseProxy to not exist for belongsTo relationships, deprecating 
this promise proxy is left for the deprecation of Model / belongsTo more broadly.

- **Affected APIs:** async `belongsTo` relationships on instances of `@ember-data/model`, `errors` property on instance of `@ember-data/model`

In the interest of parity and in order to make native property access usage easier to refactor to we considered converting Errors and PromiseBelongsTo into native proxies which would allow dot notation access to work. However, for PromiseBelongsTo this would encourage not resolving the value before interacting with it, and encouraging folks to refactor towards `await` before use is key for the next stage in which async relationships will not exist at all in their current form. For this reason, we choose to leave this Proxy as-is. For `Errors` we have the complication that Errors is a recursive proxy that functions as an `ArrayProxy` an `ObjectProxy` and its own class. We prefer to find a replacement API that would not have the confusion of both `errors.name[0]` and `errors[0]` being valid interactions.

We would note that even if Model / belongsTo are not deprecated before 5.0, their replacements will be available.

## How We Teach This

> Would the acceptance of this proposal mean the Ember guides must be
re-organized or altered? Does it change how Ember is taught to new users
at any level?

No, the current guides do not make use of proxy behavior.

> Does it mean we need to put effort into highlighting the replacement
functionality more? What should we do about documentation, in the guides
related to this feature?  

We should likely create examples of loading and working with async data within components, as it is not always the case that users resolve data in a parent component or route before passing it down. Generally this means surfacing patterns around `resources` and async template helpers like `ember-promise-helpers`.

> How should this deprecation be introduced and explained to existing Ember
users?

The APIs were necessary in the classic world, but not in the Octane world. This simplification will not only allow for us to reduce the size, complexity and performance costs of these classes while also aligning their usage with the "just Javascript" mental model.

## Drawbacks

As with all deprecations, apps will experience some churn. For apps using EmberData, the churn in the 4.x cycle is likely to be high, of which this will be yet-another contributing factor.

## Alternatives

The alternative (not doing this) would prevent deprecation and removal of classic/legacy ember framework code more broadly, as well as it would prevent EmberData from progressing towards being decoupled from the framework and eliminating performance bottlenecks. The cost of this legacy infrastructure is as high as 30% of the overall runtime cost of EmberData.


---

---
stage: accepted
start-date: 2022-08-26T00:00:00.000Z
release-date:
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - data
  - framework
prs:
  accepted: https://github.com/emberjs/rfcs/pull/847
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate Support for `ember-cli-qunit` and `ember-cli-mocha` When Generating Test Blueprints

## Summary

This RFC proposes to deprecate support for [`ember-cli-qunit`](https://github.com/ember-cli/ember-cli-qunit) and [`ember-cli-mocha`](https://github.com/ember-cli/ember-cli-mocha) when generating test blueprints.

## Motivation

Both `ember-cli-qunit` and `ember-cli-mocha` were deprecated a long time ago in favor of [`ember-qunit`](https://github.com/emberjs/ember-qunit) and [`ember-mocha`](https://github.com/emberjs/ember-mocha) respectively.

Deprecating (and later on, removing) support for both addons would greatly reduce the amount of test blueprints we have in [`ember-source`](https://github.com/emberjs/ember.js) and [`ember-data`](https://github.com/emberjs/data).

## Transition Path

The `test-framework-detector.js` files [in `ember-source`](https://github.com/emberjs/ember.js/blob/master/blueprints/test-framework-detector.js) and [in `ember-data`](https://github.com/emberjs/data/blob/master/packages/private-build-infra/src/utilities/test-framework-detector.js) will be updated to display a deprecation message whenever `ember-cli-qunit` or `ember-cli-mocha` is detected when generating test blueprints:

```
Support for `ember-cli-qunit` when generating test blueprints has been deprecated.
Please migrate to using `ember-qunit` instead.
```

**Deprecation details:**

| Key     | Value                                            |
| ------- | ------------------------------------------------ |
| `for`   | `'ember-source'`                                 |
| `id`    | `'ember-source.ember-cli-qunit-test-blueprints'` |
| `since` | `{ available: '4.X.X', enabled: '4.X.X' }`       |
| `until` | `'5.0.0'`                                        |

> NOTE: `ember-cli-qunit` and `ember-source` in the deprecation message and details above should be replaced with `ember-cli-mocha` and `ember-data` appropriately.

## Deprecation Guide

### `ember-cli-qunit` Test Blueprints

Support for `ember-cli-qunit` when generating test blueprints has been deprecated.
Please migrate to using `ember-qunit` instead:

**Using Yarn:**

- Run `yarn remove ember-cli-qunit`
- Run `yarn add ember-qunit --dev`
- Update `tests/test-helper.js` to replace any imports from `ember-cli-qunit` with imports from `ember-qunit`

**Using npm:**

- Run `npm uninstall ember-cli-qunit`
- Run `npm install ember-qunit --save-dev`
- Update `tests/test-helper.js` to replace any imports from `ember-cli-qunit` with imports from `ember-qunit`

> NOTE: This guide has been taken from [`ember-cli-qunit`'s `README.md` file](https://github.com/ember-cli/ember-cli-qunit#migrating-to-ember-qunit).

### `ember-cli-mocha` Test Blueprints

Support for `ember-cli-mocha` when generating test blueprints has been deprecated.
Please migrate to using `ember-mocha` instead:

**Using Yarn:**

- Run `yarn remove ember-cli-mocha`
- Run `yarn add ember-mocha --dev`
- Update `tests/test-helper.js` to replace any imports from `ember-cli-mocha` with imports from `ember-mocha`

**Using npm:**

- Run `npm uninstall ember-cli-mocha`
- Run `npm install ember-mocha --save-dev`
- Update `tests/test-helper.js` to replace any imports from `ember-cli-mocha` with imports from `ember-mocha`

> NOTE: This guide has been taken from [`ember-cli-mocha`'s `README.md` file](https://github.com/ember-cli/ember-cli-mocha#migrating-to-ember-mocha).

## How We Teach This

I don't think we need to update any learning material to reflect this deprecation.

## Drawbacks

I don't think there are any real drawbacks, aside from the usual churn that deprecations introduce.

## Alternatives

I don't think there are any meaningful alternatives.

## Unresolved questions

None at the moment.

---

---
stage: recommended
start-date: 2022-08-21T00:00:00.000Z
release-date:
release-versions:
  ember-source: 5.10.0
teams:
  - framework
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/848'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1020'
  released: 'https://github.com/emberjs/rfcs/pull/1042'
  recommended: 'https://github.com/emberjs/rfcs/pull/1043'
project-link:
---

# Deprecate array prototype extensions

## Summary

This RFC proposes to deprecate array prototype extensions.

## Motivation

Ember historically extended the prototypes of native Javascript arrays to implement `Ember.Enumerable`, `Ember.MutableEnumerable`, `Ember.MutableArray`, `Ember.Array`. This added convenient methods and properties, and also made Ember arrays automatically participate in the Ember Classic reactivity system.

Those convenient methods increase the likelihood of becoming potential roadblocks for future built-in language extensions, and make it confusing for users to onboard: is it specifically part of Ember, or Javascript? Also with Ember Octane, the new reactivity system, those classic observable-based methods are no longer needed.

We had deprecated [Functions](https://github.com/emberjs/rfcs/blob/master/text/0272-deprecation-native-function-prototype-extensions.md) and [Strings](https://github.com/emberjs/rfcs/blob/master/text/0236-deprecation-ember-string.md) prototype extensions. Array is the last step. And internally we had already been preferring generic array methods over prototype extensions ([epic](https://github.com/emberjs/ember.js/issues/15501)).

Continuing in that direction, we should consider recommending the usage of native array functions as opposed to convenient prototype extension methods, and the usage of `@tracked` properties or `TrackedArray` over classic reactivity methods.

## Transition Path

For convenient methods like `filterBy`, `compact`, `sortBy` etc., the replacement functionalities already exist either through native array methods or utility libraries like [lodash](https://lodash.com), [Ramda](https://ramdajs.com), etc.

For mutation methods (like `pushObject`, `removeObject`) or observable properties (like `firstObject`, `lastObject`) participating in the Ember classic reactivity system, the replacement functionalities also already exist in the form of immutable update style with tracked properties like `@tracked someArray = []`, or through utilizing `TrackedArray` from `tracked-built-ins`.

We don't need to build anything new specifically, however, the bulk of the transition will be
focused on deprecating the existing usages of array prototype extensions.

## How We Teach This

We should turn off `EmberENV.EXTEND_PROTOTYPES` by default for new applications.

For existing apps, a deprecation message will be displayed when `EmberENV.EXTEND_PROTOTYPES` flag is not set to `false`. Clear instructions will be provided about turning off the flag and fixing any existing breaks.

An entry to the [Deprecation Guides](https://deprecations.emberjs.com/v4.x) will be added outlining the different recommended transition strategies. ([Proposed deprecation guide](https://github.com/ember-learn/deprecation-app/pull/1192))

Rule `ember/no-array-prototype-extensions` is available for both [eslint](https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-array-prototype-extensions.md) and [template lint](https://github.com/ember-template-lint/ember-template-lint/blob/master/docs/rule/no-array-prototype-extensions.md) usages. Rule examples have recommendations for equivalences.

We can leverage the fixers of lint rule to auto fix some of the issues, e.g. the built-in [fixer](https://github.com/ember-template-lint/ember-template-lint/blob/master/docs/rule/no-array-prototype-extensions.md) of `firstObject` usages in template. 

We also should create codemods or autofixers in lint rules for some of the convinient functions like `reject`, `compact`, `any` etc. More discussions on **Unresolved Questions** section.

Examples (taken from [Deprecation Guide](https://github.com/smilland/rfcs/pull/1)): 
### Convenient methods
Examples of deprecated and current code:
```js
import Component from '@glimmer/component';
import { uniqBy, sortBy } from 'lodash';

export default class SampleComponent extends Component {
  abc = ['x', 'y', 'z', undefined, 'x'];
  
  // deprecated
  def = this.abc.compact();
  ghi = this.abc.uniq();
  jkl = this.abc.toArray();
  mno = this.abc.uniqBy('y');
  pqr = this.abc.sortBy('z');
  // ...

  // current
  // compact
  def = this.abc.filter(el => el !== null && el !== undefined);
  // uniq
  ghi = [...new Set(this.abc)];
  // toArray
  jkl = [...this.abc];
  // uniqBy
  mno = uniqBy(this.abc, 'y');
  // sortBy
  pqr = sortBy(this.abc, 'z');
};
```

### Observable properties and methods in js
Examples of deprecated code:
```js
import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class SampleComponent extends Component{
  abc = [];

  // observable property
  get lastObj() {
    return this.abc.lastObject;
  }

  @action
  someAction(newItem) {
    // observable method
    this.abc.pushObject(newItem);
  }
};
```

Examples of current code. 
#### Option 1: use `tracked` property
```js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class SampleComponent extends Component{
  @tracked abc = [];

  get lastObj() {
    return this.abc.at(-1);
  }

  @action
  someAction(newItem) {
    this.abc = [...abc, newItem];
  }
};
```

#### Option 2: use `TrackedArray`
```js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import { TrackedArray } from 'tracked-built-ins';

export default class SampleComponent extends Component{
  abc = new TrackedArray();

  get lastObj() {
    return this.abc.at(-1);
  }

  @action
  someAction(newItem) {
    abc.push(newItem);
  }
};
```

### Observable properties in templates
Examples of deprecated code:

```hbs
<Foo @bar={{@list.firstObject.name}} />
```

Examples of current code:
```hbs
<Foo @bar={{get @list '0.name'}} />
```

After the deprecated code is removed from Ember (at 5.0), we need to remove the [options to disable the array prototype extension](https://guides.emberjs.com/v4.2.0/configuring-ember/disabling-prototype-extensions/) from Official Guides and we also need to update the [Tracked Properties](https://guides.emberjs.com/v4.2.0/upgrading/current-edition/tracked-properties/#toc_arrays) `Arrays` section with updated suggestions.

## Drawbacks
- For users relying on Ember array prototype extensions, they will have to refactor their code and use equivalences appropriately.
- A lot of existing Ember forums/blogs had been assuming the enabling of array prototype extensions which could cause confusions for users referencing them.
- Increase package sizes, for example, before `this.abc.filterBy('x');`, now `this.abc.filter(el => el !== 'x');`.
- Although `tracked-built-ins` is on the path to stabilization as an official API via [RFC #812](https://github.com/emberjs/rfcs/pull/812), it is not yet officially recommended and its API may change somewhat between now and stabilization.

## Alternatives
- Do the deprecation as suggested here for use within Ember itself, but extract it as a standalone library for users who want to use it. This will only work as long as the underlying Ember Classic reactivity system is supported.

    As a variation on this, we could do this but explicitly only support it up through the first LTS release in the 5.x series.

- Continuing allowing array prototype extensions but turning the `EXTEND_PROTOTYPES` off by default.

- Do one of these, but target Ember v6 instead.

- Do nothing.

## Unresolved questions
- The current lint rule [ember/no-array-prototype-extensions](https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-array-prototype-extensions.md) has some false positives because static analysis can't always know when a given object is a native array vs. an `EmberArray` (which has the same array convenience methods) vs. another class with overlapping method names (although the rule does employ some heuristics to avoid false positives when possible).
- Difficulties for providing stable codemods or autofixers:
  1. giving false positives on lint rules, same will apply to codemods or autofixers;
  2. when migrating certain methods, we need to access object. Shall we use Ember `get` or native way? Unless we fully remove ObjectProxy dependency, codemods or autofixers would still require manual work in certain cases.
  3. observable functions or properties requires manual refactoring;


---

---
stage: recommended
start-date: 2022-08-27T00:00:00.000Z
release-date: 2023-04-08T00:00:00.000Z
release-versions:
  ember-data: v4.12.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/854'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/923'
  recommended: 'https://github.com/emberjs/rfcs/pull/926'
---

<!--- 
Directions for above: 

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->

# EmberData Cache V2.1

## Summary

A rename of the Cache (RecordData) API with new restrictions and additional amendments
to the accepted #461 RecordData V2 spec. These alterations will further simplify EmberData
while increasing its flexibility and extensibility. In turn, this increased flexibility
provides the backbone for further design and exploration of new capabilities such as
QueryCache, GraphQL and an enhanced SSR and Rehydration Mode.

## Motivation

We originally designed RecordData as a public formalization of one of the core
responsibilities of `InternalModel`. This allowed applications that had needed to reach
into private API to achieve criticial feature support a public avenue for doing so. However,
even then we recognized that this was merely a bridge for supporting users while we
underwent heavier refactoring to rationalize the internals and better explore what was
needed in a long-term cache solution.

Between the efforts in ember-m3, orbit.js, our own implementation of RecordData V1 and V2,
and through the process of eliminating InternalModel we were able to come to a better
understanding of what capabilities the cache lacks today. Some of these learnings resulted
in [RFC #461](https://rfcs.emberjs.com/id/0461-ember-data-singleton-record-data). Others
were floated as internal proposals for some time, but needed more cleanup to happen
internally for us to be confident in their direction.

These changes look to either solve (or tee up) multiple key issues for our users. The below
discussion is not comprehensive nor exhaustive, but representative of the kinds of problems
we're looking to solve by effecting these changes.

For example: currently, if users want to avoid refetching a query they must design and place
their own cache in front of the store's query method. With the proposed changes, the cache
becomes capable of managing this responsibility. This turns out to be ideal for handling
paginated collections and GraphQL responses as well. Near Future RFCs will directly utilize
the changes in this RFC to bring these capabilities to users of EmberData.

Similarly, the query context and response documents contain information critical for the
correct handling of individual resources it contains. For instance, when fetching a related
collection via a link it is not a requirement of the `JSON:API` spec that the records in the
response have a relationship back to the requesting record of their own. Access to the original
response document is necessary to know both the membership and the ordering of the returned
relationship data. Today, EmberData iterates payloads and fills in the gaps of this missing
information by creating artificial records, but that ties us unnecessarily to the JSON:API spec
and results in unnecessarily high overhead for processing a response. A Cache which received
the full request context and document could properly update this relationship without any
additional overhead.

**Its the URL. Its always the URL**

Until now, EmberData has focused on being a Resource cache. While many of the changes here do
affect the Resource Caching APIs, **the introduction of Document caching is perhaps the most
substantive change in EmberData's long history.**

For many years discussion of a Document Cache focused on finding a solution to caching the
response of `Store.query` such that repeat calls did not require hitting network if that was
unnecessary. Typically these discussions got hung up on cache lifetimes and what to use as
cache-keys.

Then in late 2017 we had the insight that relationships also suffered from this lacking
capability, and began work on what was then [the collections RFC](https://github.com/runspired/rfcs/blob/ember-data-collections/text/0000-ember-data-collections.md).

Unfortunately, that RFC was premature, not for its proposed design but because it turned out to
require other Cache improvements it did not specify, was too coupled to JSON:API at a time when
we had already realized we wanted to support GraphQL, and required [Identifiers](https://github.com/emberjs/rfcs/pull/403)
to be fully realized.

As we continued to work through GraphQL support built over our R&D efforts in [ember-m3](https://github.com/hjdivad/ember-m3),
it became increasingly clear that if we were to truly make the data format opaque to the Store,
then the Cache must also be responsible for determining what in a response Document constituted
a Resource.

And so, with time, we embraced the lesson that Web Engineers have had to learn to embrace time and
time again: `use the URL`.

Caching by URL gives EmberData immediate access to a host of potential capabilities.

- `URL` is a unique identifier, including encoding information about pagination, sorting,
    filtering, and order
- `headers` associated with a URL typically contain cache directives a Cache implementation
    could utilize for data lifetimes
- `body` of a response to a URL can be in any format, not just JSON, and so caching blobs for
    images, xml documents like SVG, video streams, etc. becomes feasible (these are capabilities
    `Identifiers` previously allowed but only at a `Resource` level which made it not all that
    useful)

Caching by URL gives EmberData enhanced abilities when the response Document and Cache 
implementation are aligned in format. For instance, with JSON:API the top level of a response 
will often contain

- `links` (URLs!) for additional pages related to the current query (`next`, `prev` and so on)
- `meta` that may contain information around total count still to be loaded
- `order` implicitly the order of the `data` array in a collection response *is* valuable 
    information for sorting
- `included` information about what was and was not loaded for a particular request, which might
    be used to construct a more robust secondary fetch. For instance, instead of loading `user`
    and then later loading individual resources or types of resources associated to that user, 
    you might be able to use this information to construct a request for exactly the set of 
    missing data to fill out the graph once it becomes needed.

A Document centric cache is also essential to the GraphQL story where while the Document as 
a whole is a composition of Resources the entry point is the query itself.

Our vision with EmberData is one of composable primitives flexible enough to handle organizing
and coordinating desired capabilities. It is clear to us now that to embrace that vision requires
embracing the URL.

But this new Cache brings so much more! In a move atypical for EmberData, we
are proposing new public APIs here that are not simply a codification of private
APIs we've had years to explore. Our reasoning is straightforward: to encourage
exploration within constraints.

**Streaming the Future**

The addition of Documents to the cache provides the ability to cache all information
necessary for reconstruction of what was delivered to the UI. This affords a number
of interesting opportunities around cache dump and cache restore, including among other
things for offline support, rehydration, and background workers.

We don't want to stand in the way of such exploration while waiting to dream of the
perfect API, but we would like to provide a framework for it that helps cache's know
what to implement to be maximally compatible with solutions the community may dream up.

To this end, we are introducing with minimal constraints and guidance streaming APIs
for dumping, restoring and patching the cache. The format is almost entirely opaque,
because typically the optimal serialization form will be as-close as possible to the
form the cache stores this information in regularly. Where it is not opaque is merely
the constraint that the format needs to be chunkable. Of course a Cache could choose
to treat the entire state as one chunk, but hopefully by encouraging chunking from the
beginning Cache implementations will position themselves to take maximal advantage of
the very good native streaming and buffer APIs.

**Forking the Past**

The final change to this version of the Cache is that it will support forking. Cache
forking is a technique we are ~~stealing~~ (uh) ~~borrowing~~ (err) *learning* from [Orbit.js](https://github.com/orbitjs/orbit/blob/2df79c5d67f2311c3bdc84941a18cc6896668f25/website/docs/memory-sources.md#forking-memory-sources)

On the surface, forking has been described to us by some folks as a solution without a
problem. We disagree. Forking is the right sort of boring solution that has the power
to be disruptive in just how simple and boring it is. Why is that? Instead of solving
one problem, it is a general solve to a large set of problems.

Need to load a lot of modeled relational data for a single route or component, but for
memory concerns want to unload it when you exit that route or dismount that component?
Use a fork! The fork will allow you load additional data related to data you have already
loaded previously, then safely and quickly toss it away later when you no longer need it.

Need to edit a lot of relational data and save it in one go? Use a fork! If you later
want to discard the edits, instead of trying to keep track of what changed, just toss
away the fork. Or, if you want to persist it, save all changes to the fork in one single
go.

Want to have some data loaded for all routes, but have other routes or engines manage their
own data but still correctly be able to reference the global data? That's right, use forks!

Want to be able to edit a whole lot of data and serialize the changes for local storage for
a save/restore feature for a form, but don't want to pollute those records for where they
appear elsewhere in your UI? Use a fork!

Is it a bird, is it a plane? It might sound like a knife and feed you as easily as a spoon...
but its a fork!

### The Grand Vision (Abbreviated)

This RFC codifies the direction and vision that the EmberData team has been building
towards in our long-term strategy since early in my tenure on the team. To anyone who
has been in these discussions the ideas presented here are not new, and we already know
how they fit neatly into that vision; but for the community at large many of these
changes may still be a surprise.

This RFC is not "the grand vision", but it is an integral piece. Without it, changes we
have planned for the presentation, network and store primitives will not be possible.

Above, I have laid out several key use-cases and motivations for the changes herein,
but the observant will recognize that this RFC does not expose APIs or specify how
the store, network, or current model primitives might make use of these cache APIs. We
leave each of these to their own RFCs – coming very soon – but for the sake of adequate
discussion herein we outline the direction we expect those RFCs to take.

**The APIs shown in this section are not a proposed design but representative of the overall vision for EmberData in the near future** 

**`From Fetch to Fully Distributed Replica Database`**

For the network layer, we see the introduction of `FetchManager`, a managed flow
for making requests that allows registration of middleware to handle fulfillment
or decoration of the request or response. This service would thereby make headers
and auth management easy to handle, letting apps that previously had multiple
unorganized services or ad-hoc fetch handlers to unify over one conventional flow.

This managed `Fetch` flow would (by default) not be integrated with the Store, thereby
skipping the cache and providing access to raw responses.

```ts
class FetchManager {
  registerMiddlewares(wares: Middleware[]);

  async request(req: RequestOptions): RequestFuture;
}
```

For the store, we see the addition of a new API – `Store.request` – overwhich all
existing store methods will be rebuilt as "convenience macros". This delegates to
the above `FetchManager`, but passes the Store's cache (which is potentially a fork)
as a reserved arg, and which manages passing the result to the Cache and instantiating
any records or other presentation classes required in the return value.

```ts
class Store {
  async request(req): RequestFuture;
}
```

```ts
import { gql } from '@ember-data/graphql';

const USER_QUERY = gql`query singleUser($id: Id) {
  user(id: $id) {
    name
    friends {
      name
    }
  }
}`;

class extends Route {
  @service store;

  async model({ id }) {
    const user = await this.store.request(USER_QUERY({ id }, { cache: { backgroundReload: true } }));

    return user.data;
  }
}
```

Similarly, we see request-builders (like the graphql example above) becoming the primary mechanism
by which folks query for data. This ensures URLs are available for the cache, illuminates the mental
model of `fetch => fully distributed replica Database`, simplifies the mental model of EmberData in
general by removing the mystery of "how" and "when" data is fetched, and encourages a pattern that
can benefit from static analysis and build-time optimizations (such as pre-built GraphQL queries).

```ts
import { buildUrlForFindRecord } from '@ember-data/request-builders';

class extends Route {
  @service store;

  async model({ id }) {
    const user = await this.store.request({
      url: buildUrlForFindRecord({
        type: 'user',
        id,
        incude: 'friends,company,parents,children,pets'
      })
    });

    return user.data;
  }
}
```

The Store will also gain APIs for forking and for peeking documents.

For modeling data, we see a story that is immutable-by-default. All edits run through forks,
which occurs by calling `Store.fork` which would similarly setup its cache via `Cache.fork`.

A major benefit of this approach is that it gives application developers the ability to choose
the specifics of the optimistic or pessimistic timing of when the "remote" state is updated.

An app might eagerly update the primary store on every edit, or it might update it optimistically
once a save has initiated, or it may wait only until the server has confirmed the update to do so.

In this way, global state always reflects the developer's wishes for the specific application:
whether that is the persisted state or the mutated state.

Of course, because these APIs are opaque and the Store is merely playing the role of coordinator,
libraries can choose to create all sorts of pairing of capabilities and patterns between cache
and presentation, and we will be able to maintain the existing `@ember-data/model` story for some
time as a "legacy" approach that users can install if they are not yet ready to upgrade to these
newer features and patterns.

**Reimagining the Install and Learning Experience**

The sum total of these changes (this RFC and planned RFCs) leads to a new default story for
EmberData. For this reason I have at times in jest referred to it as "The Grand EmberData
Modules Disunification RFC".

For some time now the inclusion of EmberData's `ember-data` package in the `ember-cli` blueprint
has made increasingly less sense: not because we don't want EmberData to be the default, but
because we don't see there existing just one "EmberData way".

An ideal install experience would likely focus on capabilities and requirements, a guided install
where running `npx ember-data` walks you through choices like `JSON:API` vs `GraphQL`, "just fetch"
or all the way to "distributed replica" along the way showing what packages you will need and in
the end installing them and wiring them together to get you started.

An ideal learning experience would likely take a similar path; documentation that guides the user
incrementally from fetch to full-story, and a tutorial app that shows using EmberData for just
fetch+ and then as needs in the tutorial app expand adding in additional packages and capabilities
to match.

And so armed with this context, let's dive in.

## Detailed design

This RFC proposes five substantive changes.

### 1. `RecordData` becomes `Cache`

First, the cache interface is renamed from `RecordData` to `Cache`. This is to reflect its upgraded responsibilities from handling only Resource data to also handling the caching of Documents. Additionally, `Cache` implementations MUST be Singletons.

The following APIs are affected by this change.

 - `StoreWrapper.recordDataFor` is deprecated without replacement. Since the cache is a Singleton it will already contain a reference to itself.

 - On `Store`
   - `Store.instantiateRecord` will receive only two args: `identifier` and `createArgs`
    - the removed args are `recordDataFor` and `notificationManager` which are now available as the store's `cache` and `notifications` properties
   - The notification manager (already public via instantiateRecord) is made accessible via `Store.notifications`
   - `Store.createRecordDataFor` is deprecated in favor of `Store.createCache`
   - `Store.createCache` and `Store.cache` are added with the following signatures
 
   ```ts
   class Store {
    /**
     * This hook allows for supplying a custom cache
     * implementation following the Cache spec.
     * This hook will only be called once by the Store
     * the first time cache access is needed.
     *
     * For interopability, there are multiple avenues
     * for composing caches together to support a range
     * of capabilities.
     *
     * When extending a store with an alternative cache
     * you may super this meethod. Alternatively you may
     * extend another public Cache implementation, or
     * manually instantiate and wrap another cache implentation as a delegate.
     *
     * You should not call this method yourself.
     * 
     * @method createCache (hook)
     * @public
     * @returns {Cache} a new Cache instance
     */
      createCache(store: StoreWrapper): Cache;

      /**
       * The store's Cache instance. Instantiates it
       * if needed.
       *
       * @property {Cache} cache
       * @public
       */
      cache: Cache;

      /**
       * Provides access to the NotificationManager instance
       * for this store.
       *
       * The NotificationManager can be used to subscribe to changes
       * for any identifier.
       *
       * @property {NotificationManager} notifications
       * @public
       */
      notifications: NotificationManager;


      /**
       * A hook which an app or addon may implement. Called when
       * the Store is attempting to create a Record Instance for
       * a resource.
       *
       * This hook can be used to select or instantiate any desired
       * mechanism of presentating cache data to the ui for access
       * mutation, and interaction.
       *
       * @method instantiateRecord (hook)
       * @param identifier
       * @param createRecordArgs
       * @param recordDataFor
       * @param notifications
       * @returns A record instance
       * @public
       */
      instantiateRecord(
        identifier: StableRecordIdentifier,
        createRecordArgs: { [key: string]: unknown },
      ): RecordInstance;
   }
   ```

 - From a Package Perspective
   - `@ember-data/record-data` will be rebranded as `@ember-data/json-api` and the Cache
      implementation will be publically available as `import Cache from '@ember-data/json-api';`
      This means consumers are free to extend this implementation if desired, though this is not recommended.
   - A new package, `@ember-data/graph`, will be introduced, it will currently contain no public
      API exports. This is done so that EmberData may experiment with providing additional
      official cache implementations that also make use of the primitives we are designing for 
      managing relationships between resources. This abstract utility will become public after
      some additional iteration.

### 2. Simplification of Resource Cache API

These changes are *instead of* the changes in the original RecordData V2 RFC.

> **Note** for a transitionary period `Store.createRecordDataFor` will still be invoked if present and
> it should return the singleton cache instance if the RecordData has been upgraded to Cache 2.1.
> This should ease the transition from V1 to V2 and provide interop between.

Below is the finalized "v2.1" API for Resources. All existing methods and signatures not
contained herein are deprecated.

<table>
<thead>
  <tr><th>Cache APIs</th><th>Associated Types</th></tr>
</thead>
<tbody>
<tr>
<td valign="top">

```ts
export interface Cache {
  /**
   * The Cache Version that 
   * this implementation implements. Defaults
   * to '1' if not defined.
   * 
   * @type {'1'|'2'}
   * @property version
   */
  version: '2';

  // Resource Cache APIs
  // ===================

  /**
   * Push resource data from a remote source into the cache for this identifier
   *
   * @method upsert
   * @public
   * @param identifier
   * @param data
   * @param hasRecord
   * @returns {void | string[]} if `hasRecord` is true then calculated key changes should be returned
   */
  upsert(
    identifier: StableRecordIdentifier,
    data: ResourceBlob,
    hasRecord?: boolean
  ): void | string[];

  /**
   * [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client
   *
   * It returns properties from options that should be set on the record during the create
   * process. This return value behavior is deprecated.
   *
   * @method clientDidCreate
   * @public
   * @param identifier
   * @param createArgs
   */
  clientDidCreate(
    identifier: StableRecordIdentifier,
    createArgs?: Record<string, unknown>
  ): Record<string, unknown>;

  /**
   * [LIFECYCLE] Signals to the cache that a resource
   * will be part of a save transaction.
   *
   * @method willCommit
   * @public
   * @param identifier
   */
  willCommit(
    identifier: StableRecordIdentifier
  ): void;

  /**
   * [LIFECYCLE] Signals to the cache that a resource
   * was successfully updated as part of a save transaction.
   *
   * @method didCommit
   * @public
   * @param identifier
   * @param data
   */
  didCommit<T>(
    identifier: StableRecordIdentifier,
    data: StructuredDataDocument<T>
  ): void;

  /**
   * [LIFECYCLE] Signals to the cache that a resource
   * was update via a save transaction failed.
   *
   * @method commitWasRejected
   * @public
   * @param identifier
   * @param errors
   */
  commitWasRejected(
    identifier: StableRecordIdentifier,
    errors?: StructuredErrorDocument
  ): void;

  /**
   * [LIFECYCLE] Signals to the cache that all data for a resource
   * should be cleared.
   * 
   * This method is a candidate to become a mutation
   *
   * @method unloadRecord
   * @public
   * @param identifier
   */
  unloadRecord(
    identifier: StableRecordIdentifier
  ): void;

  // Flexible Resource APIs
  // ======================
  // These APIs have additional
  // signatures detailed in
  // other sections

  /**
   * Perform an operation on the cache to update the remote state.
   *
   * Note: currently the only valid operation is a MergeOperation
   * which occurs when a collision of identifiers is detected.
   *
   * @method patch
   * @public
   * @param op the operation to perform
   * @returns {void}
   */
  patch(
    op: Operation
  ): void;

  /**
   * Update resource data with a local mutation.
   * Currently supports operations on relationships
   * only.
   *
   * @method mutate
   * @public
   * @param operation
   */
  mutate(
    mutation: Mutation
  ): void;

  /**
   * Peek resource data from the Cache.
   * 
   * In development, if the return value
   * is JSON the return value
   * will be deep-cloned and deep-frozen
   * to prevent mutation thereby enforcing cache
   * Immutability.
   * 
   * This form of peek is useful for implementations
   * that want to feed raw-data from cache to the UI
   * or which want to interact with a blob of data
   * directly from the presentation cache.
   * 
   * An implementation might want to do this because
   * de-referencing records which read from their own
   * blob is generally safer because the record does
   * not require retainining connections to the Store
   * and Cache to present data on a per-field basis.
   * 
   * This generally takes the place of `getAttr` as
   * an API and may even take the place of `getRelationship`
   * depending on implementation specifics, though this
   * latter usage is less recommended due to the advantages
   * of the Graph handling necessary entanglements and
   * notifications for relational data.
   * 
   * @method peek
   * @public
   * @param identifier
   * @returns {ResourceBlob | null} the known resource data
   */
  peek(
    identifier: StableRecordIdentifier
  ): ResourceBlob | null;

  // Granular Resource Data APIs
  // ===========================

  /**
   * Retrieve the data for an attribute from the cache
   *
   * @method getAttr
   * @public
   * @param identifier
   * @param field
   * @returns {unknown}
   */
  getAttr(
    identifier: StableRecordIdentifier,
    field: string
  ): unknown;
  
  /**
   * Mutate the data for an attribute in the cache
   * 
   * This method is a candidate to become a mutation
   *
   * @method setAttr
   * @public
   * @param identifier
   * @param field
   * @param value
   */
  setAttr(
    identifier: StableRecordIdentifier,
    field: string,
    value: unknown
  ): void;

  /**
   * Query the cache for the changed attributes of a resource.
   *
   * @method changedAttrs
   * @public
   * @deprecated
   * @param identifier
   * @returns { <field>: [<old>, <new>] }
   */
  changedAttrs(
    identifier: StableRecordIdentifier
  ): Record<string, [unknown, unknown]>;
  
  /**
   * Query the cache for whether any mutated attributes exist
   *
   * @method hasChangedAttrs
   * @public
   * @param identifier
   * @returns {boolean}
   */
  hasChangedAttrs(
    identifier: StableRecordIdentifier
  ): boolean;

  /**
   * Tell the cache to discard any uncommitted mutations to attributes
   *
   * This method is a candidate to become a mutation
   * 
   * @method rollbackAttrs
   * @public
   * @param identifier
   * @returns {string[]} the names of fields that were restored
   */
  rollbackAttrs(
    identifier: StableRecordIdentifier
  ): string[];

  /**
   * Query the cache for the current state of a relationship property
   *
   * @method getRelationship
   * @public
   * @param identifier
   * @param field
   * @returns resource relationship object
   */
  getRelationship(
    identifier: StableRecordIdentifier,
    field: string
  ): Relationship;


  // Resource State
  // ===============

  /**
   * Update the cache state for the given resource to be marked
   * as locally deleted, or remove such a mark.
   *
   * This method is a candidate to become a mutation
   * 
   * @method setIsDeleted
   * @public
   * @param identifier
   * @param isDeleted {boolean}
   */
  setIsDeleted(
    identifier: StableRecordIdentifier,
    isDeleted: boolean
  ): void;

  /**
   * Query the cache for any validation errors applicable to the given resource.
   *
   * @method getErrors
   * @public
   * @param identifier
   * @returns {ValidationError[]}
   */
  getErrors(
    identifier: StableRecordIdentifier
  ): ValidationError[];

  /**
   * Query the cache for whether a given resource has any available data
   *
   * @method isEmpty
   * @public
   * @param identifier
   * @returns {boolean}
   */
  isEmpty(
    identifier: StableRecordIdentifier
  ): boolean;

  /**
   * Query the cache for whether a given resource was created locally and not
   * yet persisted.
   *
   * @method isNew
   * @public
   * @param identifier
   * @returns {boolean}
   */
  isNew(
    identifier: StableRecordIdentifier
  ): boolean;

  /**
   * Query the cache for whether a given resource is marked as deleted (but not
   * necessarily persisted yet).
   *
   * @method isDeleted
   * @public
   * @param identifier
   * @returns {boolean}
   */
  isDeleted(
    identifier: StableRecordIdentifier
  ): boolean;

  /**
   * Query the cache for whether a given resource has been deleted and that deletion
   * has also been persisted.
   *
   * @method isDeletionCommitted
   * @public
   * @param identifier
   * @returns {boolean}
   */
  isDeletionCommitted(
    identifier: StableRecordIdentifier
  ): boolean;

}
```

</td>
<td valign="top">

<details>
  <summary>Types</summary>



```ts
// The ResourceBlob is an opaque type that must
// satisfy two constraints.
// (1) it should be possible for the IdentifierCache
// to be able to generate a RecordIdentifier for it
// whether by default or due to configuration.
// (2) it should be in a format expected by the Cache.
// This format is Cache declared.
// 
// this Opaqueness allows arbitrary storage of any
// serializable / transferable state including such things
// as Buffers and Strings.
type ResourceBlob = unknown;

// a "Stable" RecordIdentifier means
// that the object reference is known to
// the IdentifierCache, and as such
// referential integrity may be used
// to key by reference if desired.
interface StableRecordIdentifier {
  type: string;
  lid: string;
  id: string | null;
}

// An error relating to a Resource
// Received when attempting to persist
// changes to that resource.
// 
// considered "opaque" to the Store itself.
//
// Currently we restrict Errors to being
// shaped in JSON:API format; however,
// this is a restriction we will willingly
// recede if desired. So long as the
// presentation layer and the cache and the
// network layer are in agreement about the
// schema of these Errors, then EmberData
// has no reason to enforce this shape.
interface ValidationError {
  title: string;
  detail: string;
  source: {
    pointer: string;
  };
}

interface Op {
  op: string;
}

// Occasionally the IdentifierCache
// discovers that two previously thought
// to be distinct Identifiers refer to
// the same ResourceBlob. This Operation
// will be performed giving the Cache the
// change to cleanup and merge internal
// state as desired when this discovery
// is made.
interface MergeOperation extends Op {
  op: 'mergeIdentifiers';
  // existing
  record: StableRecordIdentifier; 
  // new
  value: StableRecordIdentifier;
}

// An Operation is an action that updates
// the remote state of the Cache in some
// manner. Additional Operations will be
// added in the future.
type Operation = MergeOperation;

// A Mutation is an action that updates
// the local state of the Cache in some
// manner.
// Most Mutations are in theory also
// Operations; with the difference being
// that the change should be applied as
// "local" or "dirty" state instead of
// as "remote" or "clean" state.
// 
// Note: this RFC does not publicly surface
// any of the mutations listed here as
// "operations", though the (private) Graph
// already expects and utilizes these.
// and we look forward to an RFC that makes
// the Graph a fully public API.
type Mutation =
  | ReplaceRelatedRecordsMutation
  | ReplaceRelatedRecordMutation
  | RemoveFromRelatedRecordsMutation
  | AddToRelatedRecordsMutation
  | SortRelatedRecordsMutation;


// Note: in v1 data could be a ResourceIdentifier, now
// we request that it be in the stable form already.
interface ResourceRelationship {
  data?: StableRecordIdentifier | null;
  meta?: Dict<JSONValue>;
  links?: Links;
}

// Note: in v1 data could be a ResourceIdentifier, now
// we request that it be in the stable form already.
interface CollectionRelationship {
  data?: StableRecordIdentifier[];
  meta?: Dict<JSONValue>;
  links?: PaginationLinks;
}

type Relationship = ResourceRelationship | CollectionRelationship;

```

</details>

<details>
  <summary>Mutations</summary>



```ts

interface AddToRelatedRecordsMutation {
  op: 'addToRelatedRecords';
  record: StableRecordIdentifier;
  field: string;
  value: StableRecordIdentifier | StableRecordIdentifier[];
  index?: number;
}

interface RemoveFromRelatedRecordsMutation {
  op: 'removeFromRelatedRecords';
  record: StableRecordIdentifier;
  field: string;
  value: StableRecordIdentifier | StableRecordIdentifier[];
  index?: number;
}

interface ReplaceRelatedRecordMutation {
  op: 'replaceRelatedRecord';
  record: StableRecordIdentifier;
  field: string;
  // never null if field is a collection
  value: StableRecordIdentifier | null; 
  // if field is a collection,
  //  the value we are swapping with
  prior?: StableRecordIdentifier;
  index?: number;
}

interface ReplaceRelatedRecordsMutation {
  op: 'replaceRelatedRecords';
  record: StableRecordIdentifier;
  field: string;
  // the records to add. If no prior/index
  //  specified all existing should be removed
  value: StableRecordIdentifier[];
  // if this is a "splice" the
  //  records we expect to be removed
  prior?: StableRecordIdentifier[];
  // if this is a "splice" the
  //   index to start from
  index?: number;
}

interface SortRelatedRecordsMutation {
  op: 'sortRelatedRecords';
  record: StableRecordIdentifier;
  field: string;
  value: StableRecordIdentifier[];
}

```

</details>

</td>
</tr>
</tbody>
</table>

A key takeaway from these changes should be that generally the Resource API is evolving away
from hyper-granular methods for operating on the cache towards general-purpose methods
that allow for customized granularity and can be extended via additional sigantures (operations)
instead of by adding new methods.

This is partly-due to the cache evolving to handle more than just resources, but it is also due
to us desiring to eliminate non-opaque-schema from the core APIs. EmberData should not need to
care whether some field is an Attribute or a Relationship. It needs to manage the flow of mutations
and queries, but it need not define their specificity nor shoe-horn the mechanics into artificial
constraints.

We expect further evolution in this area in the future, mostly in the direction of removing
single-purpose methods towards operational flows.

### 3. Introduction of Document Cache API

The design for caching documents focuses on solving three key constraints.

1) It should be possible to serialize the cache, and so the data handed to cache should
    be in a serialized form.
2) It should be possible to rebuild/retrieve the raw response via peek so that if
    desired the Cache could be used as little more than (for instance) an in-memory
    JSON store.
3) The cache should have access to serializable information about the request and response
    that may be required for proper cache storage, management or desired for later access.

<table>
<thead>
<tr><th>Cache APIs</th><th>Associated Types</th></tr>
</thead>
<tbody>
<tr>
<td>

```ts
class Cache {
  /**
   * Cache the response to a request
   * 
   * Unlike `store.push` which has UPSERT
   * semantics, `put` has `replace` semantics similar to
   * the `http` method `PUT`
   * 
   * the individually cacheable resource data it may contain
   * should upsert, but the document data surrounding it should
   * fully replace any existing information
   * 
   * Note that in order to support inserting arbitrary data
   * to the cache that did not originate from a request `put`
   * should expect to sometimes encounter a document with only
   * a `data` member and therefor must not assume the existence
   * of `request` and `response` on the document.
   * 
   * @method put
   * @param {StructuredDocument} doc
   * @returns {ResourceDocument}
   * @public
   */
  put(doc: StructuredDocument): ResourceDocument;

  /**
   * Update the "remote" or "canonical" (persisted) state of the Cache
   * by merging new information into the existing state.
   *
   * @method patch
   * @param {Operation} op
   * @returns {void}
   * @public
   */
  patch(
    op: Operation
  ): void;

  /**
   * Update the "local" or "current" (unpersisted) state of the Cache
   * 
   * @method mutate
   * @param {Mutation} mutation
   * @returns {void}
   * @public
   */
  mutate(
    mutation: Mutation
  ): void;

  /**
   * Peek the Cache for the existing data associated with
   * a StructuredDocument
   * 
   * @method peek
   * @param {StableDocumentIdentifier}
   * @returns {ResourceDocument | null}
   * @public
   */
  peek(
    identifier: StableDocumentIdentifier
  ): ResourceDocument | null;

  /**
   * Peek the Cache for the existing request data associated with
   * a cacheable request
   * 
   * @method peekRequest
   * @param {StableDocumentIdentifier}
   * @returns {StableDocumentIdentifier | null}
   * @public
   */
  peekRequest(identifier: StableDocumentIdentifier): StructuredDocument<ResourceDocument> | null;

  didCommit<T>(
    identifier: StableRecordIdentifier,
    data: StructuredDataDocument<T>
  ): void;

  commitWasRejected(
    identifier: StableRecordIdentifier,
    errors?: StructuredErrorDocument
  ): void;
}
```


</td>
<td>

```ts

interface RequestInfo extends Request {
  disableTestWaiter?: boolean;
  /*
   * data that a handler should convert into
   * the query (GET) or body (POST)
   */
  data?: Record<string, unknown>;
  /*
   * options specifically intended for handlers
   * to utilize to process the request
   */
  options?: Record<string, unknown>;
}

interface ResponseInfo {
  readonly headers: ImmutableHeaders; // to do, maybe not this?
  readonly ok: boolean;
  readonly redirected: boolean;
  readonly status: number;
  readonly statusText: string;
  readonly type: string;
  readonly url: string;
}

interface StructuredDataDocument<T> {
  request: RequestInfo;
  response: Response | ResponseInfo | null;
  content: T;
}
interface StructuredErrorDocument extends Error {
  request: RequestInfo;
  response: Response | ResponseInfo | null;
  error: Error;
  content?: unknown;
}

type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;

// must have one of meta, data or error
interface ResourceDocument {
  // the url or cache-key associated with the structured document
  lid: string; 
  links?: Links;
  meta?: Meta;
  data?: StableRecordIdentifier | StableRecordIdentifier[] | null;
  error?: Error;
}

```

</td>
</tr>
</tbody>
</table>

#### Notice about RequestStateService

Currently the `RequestStateService` which provides access to promise information about
save/fetch requests for individual resources will not be altered. However, the response
cache it provides will now differ in structure from the `StructuredDocument` provided to the
cache, and relying on it for more than querying the status of a request will prove brittle
as we expect this to undergo further design work to align with `StructuredDocument` in the
near future as we introduce a new design for managing requests.


#### Changes to `store.push`

Historically, `store.push` received a `JSON:API` document from which it decomposed resources
from within `data` and `included` which it then individually inserted into the cache. As well,
`store.push` was the primary mechanism by which data would load into the cache following any
request.

Beginning with this new cache implementation, this role will be significantly reduced. Instead,
responses from requests will be passed as `StructuredDocuments` directly to the cache for the
cache to decompose as it sees fit.

`store.push` will remain, however it too will see two significant changes.
  1) It will no longer decompose the data it receives, instead pushing that
      data (`T`) into the cache via `cache.put({ data: T })`
  2) It will no longer be required that the data given to `push` be in `JSON:API` format,
      the new requirement will be that it be in the format expected by the configured `Cache`.

### 4. Introduction of Streaming Cache API

Cache implementations should implement two methods to support streaming
SSR and AOT Hydration.

`cache.dump` should return a stream of the cache's contents that can be
provided to the same cache's `hydrate` method. The only requirement is
that a `Cache` should output a stream from `cache.dump` that it can also import
via `cache.hydrate`. The opaque nature of this contract allows cache implementations
the flexibility to experiment with the best formats for fastest restore.

`cache.dump` returns a promise resolving to this stream to allow the cache the
opportunity to handle any necessary async operations before beginning the stream.

`cache.hydrate` should accept a stream of content to add to the cache, and return
a `Promise` the resolves when reading the stream has completed or rejects if for
some reason `hydrate` has failed. Currently there is no defined behavior for
recovery when `hydrate` fails, and caches may handle a failure however they see fit.

A key consideration implementations of `cache.hydrate` must make is that `hydrate`
should expect that it may be called in two different modes: both during initial
hydration and to hydrate additional state into an already booted application.



```ts
class Cache {
  /**
   * Serialize the entire contents of the Cache into a Stream
   * which may be fed back into a new instance of the same Cache
   * via `cache.hydrate`.
   * 
   * @method dump
   * @returns {Promise<ReadableStream>}
   * @public
   */
  async dump(): Promise<ReadableStream<unknown>>;
 
  /**
   * hydrate a Cache from a Stream with content previously serialized
   * from another instance of the same Cache, resolving when hydration
   * is complete.
   * 
   * This method should expect to be called both in the context of restoring
   * the Cache during application rehydration after SSR **AND** at unknown
   * times during the lifetime of an already booted application when it is
   * desired to bulk-load additional information into the cache. This latter
   * behavior supports optimizing pre/fetching of data for route transitions
   * via data-only SSR modes.
   * 
   * @method hydrate
   * @param {ReadableStream} stream
   * @returns {Promise<void>}
   * @public
   */
  async hydrate(stream: ReadableStream<unknown>): void;
}
```


### 5. Introduction of Cache Forking

Cache implementations should implement three methods to support
 store forking. While the mechanics of how a Cache chooses to
 fork are left to it, forks should expect to live-up to the following
 constraints.

1. A parent should never retain a reference to a child.
2. A child should never mutate/update the state of a parent.

> Note: when saving state on a `Store`, the `store` is provided as the
> first argument to Adapter and Serializer methods, thereby allowing
> these class instances to access information about the current `Store`
> which may not be the same instance as the singleton `Store`
> injectible as a service. This is in keeping with the same existing design
> we have today for these classes to support multiple unique top-level stores.

```ts
class Store {
  /**
   * Create a fork of the Store starting
   * from the current state.
   * 
   * @method fork
   * @public
   * @returns Promise<Store>
   */
  async fork(): Promise<Store>;

  /**
   * Merge a fork back into a parent Store
   * 
   * @method merge
   * @param {Store} store
   * @public
   * @returns Promise<void>
   */
  async merge(store: Store): void;
}
```

```ts
class Cache {
  /**
   * Create a fork of the cache from the current state.
   * 
   * Applications should typically not call this method themselves,
   * preferring instead to fork at the Store level, which will
   * utilize this method to fork the cache.
   * 
   * @method fork
   * @public
   * @returns Promise<Cache>
   */
  async fork(): Promise<Cache>;

  /**
   * Merge a fork back into a parent Cache.
   * 
   * Applications should typically not call this method themselves,
   * preferring instead to merge at the Store level, which will
   * utilize this method to merge the caches.
   * 
   * @method merge
   * @param {Cache} cache
   * @public
   * @returns Promise<void>
   */
  async merge(cache: Cache): void;

  /**
   * Generate the list of changes applied to all
   * record in the store.
   * 
   * Each individual resource or document that has
   * been mutated should be described as an individual
   * `Change` entry in the returned array.
   * 
   * A `Change` is described by an object containing up to
   * three properties: (1) the `identifier` of the entity that
   * changed; (2) the `op` code of that change being one of
   * `upsert` or `remove`, and if the op is `upsert` a `patch`
   * containing the data to merge into the cache for the given
   * entity.
   * 
   * This `patch` is opaque to the Store but should be understood
   * by the Cache and may expect to be utilized by an Adapter
   * when generating data during a `save` operation.
   * 
   * It is generally recommended that the `patch` contain only
   * the updated state, ignoring fields that are unchanged
   * 
   * ```ts
   * interface Change {
   *  identifier: StableRecordIdentifier | StableDocumentIdentifier;
   *  op: 'upsert' | 'remove';
   *  patch?: unknown;
   * }
   * ```
   * 
   */
  async diff(): Promise<Change[]>;
}
```

## The complete v2.1 Cache Interface

```ts
interface Cache {
  version: '2';

  // Cache Management
  // ================

  put<T>(doc: StructuredDocument<T>): ResourceDocument;
  patch(op: Operation): void;
  mutate(mutation: Mutation): void;

  peek(identifier: StableRecordIdentifier): ResourceBlob | null;
  peek(identifier: StableDocumentIdentifier): ResourceDocument | null;

  peekRequest(identifier: StableDocumentIdentifier): StructuredDocument<ResourceDocument> | null;

  upsert(
    identifier: StableRecordIdentifier,
    data: ResourceBlob,
    hasRecord: boolean
  ): void | string[];

  // Cache Forking Support
  // =====================

  async fork(): Promise<Cache>;
  async merge(cache: Cache): void;
  async diff(): Promise<object[]>;

  // SSR Support
  // ===========

  async dump(): Promise<ReadableStream<unknown>>;
  async hydrate(stream: ReadableStream<unknown>): void;

  // Resource Support
  // ================

  willCommit(
    identifier: StableRecordIdentifier
  ): void;

  didCommit<T>(
    identifier: StableRecordIdentifier,
    data: StructuredDataDocument<T>
  ): void;

  commitWasRejected(
    identifier: StableRecordIdentifier,
    errors?: StructuredErrorDocument
  ): void;

  getErrors(
    identifier: StableRecordIdentifier
  ): ValidationError[];

  getAttr(
    identifier: StableRecordIdentifier,
    field: string
  ): unknown;

  setAttr(
    identifier: StableRecordIdentifier,
    field: string,
    value: unknown
  ): void;

  changedAttrs(
    identifier: StableRecordIdentifier
  ): Record<string, [unknown, unknown]>;

  hasChangedAttrs(
    identifier: StableRecordIdentifier
  ): boolean;

  rollbackAttrs(
    identifier: StableRecordIdentifier
  ): string[];

  getRelationship(
    identifier: StableRecordIdentifier,
    field: string
  ): Relationship;

  unloadRecord(
    identifier: StableRecordIdentifier
  ): void;

  isEmpty(
    identifier: StableRecordIdentifier
  ): boolean;

  clientDidCreate(
    identifier: StableRecordIdentifier,
    createArgs?: Record<string, unknown>
  ): Record<string, unknown>;

  isNew(
    identifier: StableRecordIdentifier
  ): boolean;

  setIsDeleted(
    identifier: StableRecordIdentifier,
    isDeleted: boolean
  ): void;

  isDeleted(
    identifier: StableRecordIdentifier
  ): boolean;

  isDeletionCommitted(
    identifier: StableRecordIdentifier
  ): boolean;
}
```

## Typescript Support

All implementable interfaces involved in this RFC will be made available via a new package
`@ember-data/experimental-preview-types`. These types should be considered unstable. When 
we no longer consider these types experimental we will mark their stability by migrating
them to `@ember-data/types`.

Documentation for these types is likely to ship
 publicly before the types themselves become installable, and will do so using the final 
 package name (`@ember-data/type`) so that the interfaces are easily explorable on 
 `api.emberjs.com` even before they are mature enough for consumption.

The specific reason for this instability is the need to flesh out and implement an official
pattern for *registries* for record types and their fields. For instance, we expect to change
from `type: string` to the more narrowable and restricted `keyof ModelRegistry & string` when that occurs.

## How we teach this

- updated learning URLs
- updated learning materials (see [emberjs/data#8394](https://github.com/emberjs/data/issues/8394))
- while this adds to cache, it does not add
  the APIs needed for network/store etc.
  future RFCs for exposing these capabilities
  will better define the learning story for the
  average user. Basic integration was defined by [RFC#860](https://github.com/emberjs/rfcs/pull/860)

## Drawbacks

- we haven't explored with implementations on some of these
  ideas; however, it is difficult to explore sans-accepted-rfc
  due to useful features requiring some minimal handshake agreement
  with other layers of the system.
- but singleton + versioning + manager should keep us safely constrained to allow this     
  exploration while still staying within bounds of steerable patterns.

## Alternatives

- a separate document cache
- ephemeral records / buffered proxies
- multiple stores fully isolated (no cache inheritance)
- SSR support at the "source" (Adapter) level only, similar to Shoebox. This approach has a large number of negative performance ramifications.


---

---
stage: recommended
start-date: 2022-11-08T00:00:00.000Z
release-date: 2023-05-15T00:00:00.000Z
release-versions:
  ember-source: 5.0.0
teams:
  - data
  - framework
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/858'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/908'
  released: 'https://github.com/emberjs/rfcs/pull/956'
  recommended: 'https://github.com/emberjs/rfcs/pull/960'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate `ember-mocha`

## Summary

This RFC proposes to officially deprecate [`ember-mocha`](https://github.com/emberjs/ember-mocha).

Consequently, this would also deprecate support for `ember-mocha` when 
generating test blueprints. Both `ember-source` and `ember-data` have logic to 
determine the presence of `ember-mocha` in order to use the appropriate test blueprints.

## Motivation

`ember-mocha` has been unmaintained for a while now. The last release was 
published on [Jun 16, 2019](https://github.com/emberjs/ember-mocha/releases/tag/v0.16.0). 
It also seems this release is [not compatible with Ember v4](https://github.com/emberjs/ember-mocha/issues/691). 
Instead of letting `ember-mocha` slowly fade away, it feels better to officially deprecate 
it and clearly communicate this to the community.

Additional benefits:

- Having only `ember-qunit`, saves developers the time and effort of having to make a choice between `ember-mocha` and `ember-qunit`
- The Ember.js ecosystem can fully focus on building functionality around one testing framework

## Transition Path

We should:

- Update `ember-mocha`'s README to state that `ember-mocha` is officially 
deprecated, and that users should consider migrating to [`ember-qunit`](https://github.com/emberjs/ember-qunit) instead
- Officially mark `ember-mocha` as deprecated on [the npm registry](https://www.npmjs.com/)
- Update the test-framework detectors in `ember-source` and `ember-data` to 
deprecate support for `ember-mocha`:
  - https://github.com/emberjs/ember.js/blob/master/blueprints/test-framework-detector.js
  - https://github.com/emberjs/data/blob/master/packages/private-build-infra/src/utilities/test-framework-detector.js
- Write a small guide that explains how to migrate from `ember-mocha` to `ember-qunit`

## Possible Migration Strategy

### 1. Install `ember-qunit` And Its Required Peer Dependencies

Required peer dependencies:

- [`@ember/test-helpers`](https://github.com/emberjs/ember-test-helpers)
- [`qunit`](https://github.com/qunitjs)

Please note that, at the time of writing, `ember-qunit` also requires you to run [`ember-source`](https://github.com/emberjs/ember.js) v3.28 or higher.

Please refer to [the official `app` blueprint](https://github.com/ember-cli/ember-cli/tree/master/blueprints/app/files) for a complete setup of all these packages:

- [Update `tests/test-helper.js`](https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/tests/test-helper.ts)
- [Update `tests/helpers/index.js`](https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/tests/helpers/index.ts)
- [Update `tests/index.html`](https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/tests/index.html#L23-L28)

### 2. Migrate Your Tests One by One

Please refer to [this commit](https://github.com/1024pix/pix/pull/5258/commits/b0eccbdb63caee853d67d2b368c9f6079a334a08) for an exhaustive example on how to migrate your tests.

We also recommend using one of the following codemods, to speed up this process:

- [mocha-to-qunit](https://github.com/freshworks/ember-freshdesk-codemods/tree/master/transforms/mocha-to-qunit) - The original Mocha to QUnit codemod
- [mocha-to-qunit fork](https://github.com/1024pix/ember-codemods/tree/master/transforms/mocha-to-qunit) - Forked from `mocha-to-qunit`, and used in the commit linked above
- [ember-mocha-to-qunit-codemod](https://github.com/yads/ember-mocha-to-qunit-codemod) - A more recently written Mocha to QUnit codemod

### 3. Clean up All References to Mocha

This includes (but not limited to):

- References and packages in your `package.json` file
- References in your `.eslintrc.js` file
- References in custom test blueprints, if you have any
- References in documentation
- ...

### 4. Install `eslint-plugin-qunit` And `qunit-dom`

We also recommend to install and use [`eslint-plugin-qunit`](https://github.com/platinumazure/eslint-plugin-qunit) and [`qunit-dom`](https://github.com/mainmatter/qunit-dom).

- `eslint-plugin-qunit` provides useful ESLint rules for QUnit
- `qunit-dom` provides high-level DOM assertions for QUnit

Though these packages aren't required to complete the migration, they will help you in writing better tests for QUnit. These packages are also part of [the official `app` blueprint](https://github.com/ember-cli/ember-cli/tree/master/blueprints/app/files).

## How We Teach This

References to `ember-mocha` should be removed from all learning materials, for example:

- https://guides.emberjs.com/release/testing/testing-tools/#toc_mocha-chai-dom
- https://guides.emberjs.com/release/testing/testing-tools/#toc_summary
- https://guides.emberjs.com/release/testing/#toc_how-to-filter-tests

## Drawbacks

People using `ember-mocha` will have to migrate to using `ember-qunit` instead 
at some point. This feels like a large migration to take on (depending on project size), 
though I have no experience with this.

## Alternatives

If there is any interest, we could also consider transferring `ember-mocha` to 
the [Adopted Ember Addons](https://github.com/adopted-ember-addons) organisation on GitHub?

## Unresolved questions

None at the moment.

---

---
stage: released
start-date: 2023-11-10T00:00:00.000Z
release-date:
release-versions:
  ember-data: v4.12.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/860'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/879'
  released: 'https://github.com/emberjs/rfcs/pull/925'
project-link:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# EmberData | Request Service

## Summary

Proposes a simple abstraction over `fetch` to enable easy management of request/response
flows. Provides associated utilities to assist in migrating to this new abstraction. Adds
 new APIs to the Store to make use of this abstraction.

## Motivation

- `Serializer` lacks the context necessary to serialize/normalize data on a per-request basis
  - This is especially true when performing "actions", RPC style requests, "partial" save
    requests, and "transactional" saves
  - Often users end up needing to pre-normalize in the adapter in order to supply information
    contained in either `headers` or to convert into `JSON` from other forms (such as `jsonb`, `json5` `protocol buffers` or similar)
- `Adapter` is inflexible and difficult to grow as an interface for managing data 
fulfillment from a source.
- Applications have need of a low-level primitive solution for managed fetch to ensure proper headers, authentication, error handling, SSR support, test-waiter support, and request de-duping/caching.
- The `Adapter` pattern stands in the way of pagination-by-default and query caching
- The `Adapter` pattern does not fit with many common data-fetching paradigms today
- The `Adapter` pattern does not fit with transactional saves

## Detailed design

### RequestManager

A `RequestManager` provides a request/response flow in which
configured handlers are successively given the opportunity
to handle, modify, or pass-along a request.

```ts
interface RequestManager {
  request<T>(req: RequestInfo): Future<T>;
}
```


For example:

```ts
import RequestManager from '@ember-data/request';
import Fetch from '@ember/data/request/fetch';
import Auth from 'ember-simple-auth/ember-data-handler';
import Config from './config';

const { apiUrl } = Config;

// ... create manager
const manager = new RequestManager();
manager.use([Auth, Fetch]);

// ... execute a request
const response = await manager.request({
  url: `${apiUrl}/users`
});
```

**Futures**

The return value of `manager.request` is a `Future`, which allows
access to limited information about the request while it is still
pending and fulfills with the final state when the request completes.

A `Future` is cancellable via `abort`.

Handlers may optionally expose a ReadableStream to the `Future`
for streaming data; however, when doing so the future should not
resolve until the response stream is fully read.

```ts
/**
 * @class Future
 * @public
 */
interface Future<T> extends Promise<StructuredDocument<T>> {
  /**
   * Cancel this request by firing the AbortController's signal.
   *
   * @method abort
   * @public
   * @returns {void}
   */
  abort(): void;

  /**
   * Get the response stream, if any, once made available.
   *
   * @method getStream
   * @public
   * @returns {Promise<ReadableStream | null>}
   */
  getStream(): Promise<ReadableStream | null>;

  /**
   *  Run a callback when this request completes. Use sparingly.
   * 
   * @method onFinalize
   * @param cb the callback to run
   * @public
   * @returns {void}
   */
  onFinalize(cb: () => void): void;
}
```

The `StructuredDocument` interface is the same as is proposed in emberjs/rfcs#854 but is shown here in richer detail.

```ts
interface RequestInfo extends Request {
  disableTestWaiter?: boolean;
  /*
   * data that a handler should convert into
   * the query (GET) or body (POST)
   */
  data?: Record<string, unknown>;
  /*
   * options specifically intended for handlers
   * to utilize to process the request
   */
  options?: Record<string, unknown>;

  /**
   * Allows supplying a custom AbortController for
   * the request, if none is supplied one is generated
   * for the request. When calling `next` if none is
   * provided the primary controller for the request
   * is used.
   * 
   * controller will not be passed through onto the immutable
   * request on the context supplied to handlers.
   */
  controller?: AbortController;

  /**
   * Once a request has been made it becomes immutable, this
   * includes Headers. To modify headers you may copy existing
   * headers using `new Headers([...headers.entries()])`.
   * 
   * Immutable headers instances have an additional method `clone`
   * to allow this to be done swiftly.
   */
  headers?: Headers;

  /**
   * Typically you should not set this, though you may choose to curry
   * a received signal if calling next. signal will automatically be set
   * to the associated controller's signal if none is supplied.
   */
  signal?: AbortSignal;
}

interface ResponseInfo {
  headers: Headers;
  ok: boolean;
  redirected: boolean;
  status: number;
  statusText: string;
  type: string;
  url: string;
}

interface StructuredDataDocument<T> {
  request: RequestInfo;
  response: Response | ResponseInfo | null;
  content: T;
}
interface StructuredErrorDocument extends Error {
  request: RequestInfo;
  response: Response | ResponseInfo | null;
  error: Error;
  content?: unknown;
}
type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;
```

A `Future` resolves with a StructuredDataDocument or rejects with a StructuredErrorDocument.

**Request Handlers**

Requests are fulfilled by handlers. A handler receives the request context
as well as a `next` function with which to pass along a request to the next
handler if it so chooses.

If a handler calls `next`, it receives a `Future` which fuulfills to a `StructuredDocument`
that it can then compose how it sees fit with its own response.

```ts
type NextFn = <P>(req: RequestInfo) => Future<P>;

interface Handler {
  request<T = unknown>(context: RequestContext, next: NextFn<T>): Promise<T> | Future<T>;
}
```

`RequestContext` contains information about the request as well as a few methods
 for building up the `StructuredDocument` and `Future` that will be part of the
 response.

```ts
interface RequestContext<T> {
  readonly request: RequestInfo;

  setStream(stream: ReadableStream | Promise<ReadableStream | null>): void;
  setResponse(response: ResponseInfo | Response | null): void;
}
```

A basic `fetch` handler with support for streaming content updates while
the download is still underway might look like the following, where we use
[`response.clone()`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) to `tee` the `ReadableStream` into two streams.

A more efficient handler might read from the response stream, building up the 
response data before passing along the chunk downstream.

```ts
const FetchHandler = {
  async request(context) {
    const response = await fetch(context.request);
    context.setResponse(reponse);
    context.setStream(response.clone().body);

    return response.json();
  }
}
```

Request handlers are registered by configuring the manager via `use`

```ts
manager.use([Handler1, Handler2])
```

Handlers will be invoked in the order they are registered ("fifo", first-in 
first-out), and may only be registered up until the first request is made. It
is recommended but not required to register all handlers at one time in order
to ensure explicitly visible handler ordering.

**Stream Currying**

`RequestManager.request` differs from `fetch` in one **extremely crucial detail**
and we feel the need to deeply describe how and why.

For context, it helps to understand a few of the use-cases that RequestManager
is intended to allow.

- Historically EmberData could not be used to manage and return streaming content (such as
 video files). With this change, it can be. (The Identifiers RFC and Cache 2.1 RFCs also 
 make this ability pervasive throughout all layers of EmberData)
- It might be the case that a handler "tees" or "forks" a request, fulfilling it by either
  making multiple parallel `fetch` requests, or by calling `next` multiple times, or by
  fulfilling part of the request from one source (one API, in-memory, localStorage, IndexedDB
   etc.) and the rest from another source (a different API, a WebWorker, etc.)
- Handlers may only be amending the request and passing it along, for instance an Auth handler
 may simply be ensuring the correct tokens or headers or cookies are attached.

`await fetch(<req>)` behaves differently than some realize. The fetch promise resolves not
once the entirety of the request has been received, but rather at the moment headers are 
received. This allows for the body of the request to be processed as a stream by application
code *while chunks are still being received by the browser*. When an app chooses to
`await response.json()` what actually occurs is the browser reads the stream to completion
and then returns the result. Additionally, this stream may only be read **once**.

In designing the `RequestManager`, we do not want to eliminate this ability to subscribe to
and utilize the stream by either the application or the handler. We believe it crucial that
the full power and flexibility of native APIs remains in developers hands, and do not want
to create a restriction such that developers feel the need to create complicated workarounds
for what would feel like an unnecessary restriction to gain access to built-in APIs.

However, because there is potentially a chain of handlers involved, and because there are 
potentially multiple streams involved, and because we require that `await manager.request(<req>)`
 resolves with fully realized content, we find ourselves in a design conundrum.

We have considered several variations on how to support streams: from a two-tiered promise structure
 similar to `fetch` (which quickly fails due to the chained nature of handlers), to enforcing that 
handlers synchronously call `setStream` either with a ReadableStream or a promise resolving to one.

Each variation has had drawbacks, some were critical and some simply had poor ergonomics. What we
have arrived at is this:

Each handler may call `setStream` only once, but may do so *at any time* until the promise that
the handler returns has resolved. The associated promise returned by calling `future.getStream`
will resolve with the stream set by `setStream` if that method is called, or `null` if that method
has not been called by the time that the handler's request method has resolved.

Handlers that do not create a stream of their own, but which call `next`, should defensively
pipe the stream forward. While this is not required (see automatic currying below) it is better
to do so in most cases as otherwise the stream may not become available to downstream handlers
or the application until the upstream handler has fully read it.

```ts
context.setStream(future.getStream());
```

Handlers that either call `next` multiple times or otherwise have reason to create multiple 
fetch requests should either choose to return no stream, meaningfully combine the streams,
or select a single prioritized stream.

Of course, any handler may choose to read and handle the stream, and return either no stream or
a different stream in the process.

**Automatic Currying of Stream and Response**

In order to simplify what we believe will be a common case for handlers which are merely decorating
a request, if `next` is called only a single time and `setResponse` was never called by the handler
the response set by the next handler in the chain will be applied to that handler's outcome. For 
instance, this makes the following pattern work `return (await next(<req>)).data;`.

Similarly, if `next` is called only a single time and neither `setStream` nor `getStream` was
 called, we automatically curry the stream from the future returned by `next` onto the future returned by the handler.

Finally, if the return value of a handler is a `Future`, we curry the entire thing. This makes the
 following possible and ensures even `data` and `error` is curried when doing so: `return next(<req>)`.

In the case of the `Future` being returned from a handler not using `async/await`, `Stream` proxying is automatic and immediate and does not wait for the `Future` to resolve. If the handler uses `async/await` we have no ability to detect the Future until the handler has fully resolved. This means that if using `async/await` in your handler you should always pro-actively pipe the stream.

**Using as a Service**

Most applications will desire to have a single `RequestManager` instance, which
can be achieved using module-state patterns for singletons, or for Ember 
applications by exporting the manager as an Ember service.

*services/request.ts*
```ts
import RequestManager from '@ember-data/request';
import Fetch from '@ember/data/request/fetch';
import Auth from 'ember-simple-auth/ember-data-handler';

export default class extends RequestManager {
  constructor(createArgs) {
    super(createArgs);
    this.use([Auth, Fetch]);
  }
}
```

**Using with the Store Service**

Assuming a manager has been registered as the `request` service.

*services/store.ts*
```ts
import Store from '@ember-data/store';
import { service } from '@ember/service';

export default class extends Store {
  @service('request') requestManager;
}
```

Alternatively to have a request service unique to the store:

```ts
import Store from '@ember-data/store';
import RequestManager from '@ember-data/request';
import Fetch from '@ember/data/request/fetch';

export default class extends Store {
  requestManager = new RequestManager();

  constructor(args) {
    super(args);
    this.requestManager.use([Fetch]);
  }
}
```

If using the package `ember-data`, the following configuration will automatically be done in order
to preserve the legacy Adapter and Serializer behavior. Additional handlers or a service injection
like the above would need to be done by the consuming application in order to make broader use of
`RequestManager`.

```ts
import Store from '@ember-data/store';
import RequestManager from '@ember-data/request';
import { LegacyNetworkHandler } from '@ember-data/legacy-compat';

export default class extends Store {
  requestManager = new RequestManager();

  constructor(args) {
    super(args);
    this.requestManager.use([LegacyHandler]);
  }
}
```

### Using `store.request(<req>)`

The `Store` will add support for using the `RequestManager` via `store.request(<req>)`.

```ts
class Store {
  request<T>(req: RequestInfo): Future<Reified<T>>;
}
```

There are three significant differences when calling `store.request` instead of `requestManager.request`.

1) the Store will be added to `RequestInfo`, and an additional `cacheOptions` property is available

```ts
interface StoreRequestInfo extends RequestInfo {
  cacheOptions?: { key?: string, reload?: boolean, backgroundReload?: boolean };
  store: Store;
}
```

2) The `StructuredDocument` is supplied to `cache.put(doc)` and the return value's
 `data` member is altered to either a single record or array of records resulting
  from instantiating the entities contained in the `ResourceDocument` returned by
  `cache.put`.

3) Both an operation (`op`) and and array of identifiers (`records`) may be provided
  as part of the request. While this information could also be included in `options`,
  we are giving it top-level precedence since handlers which perform data normalization
  will almost always require this information.

  `op` may be any `string` that your handlers will recognize, though EmberData will provide
   an `op` matching one of the current Adapter request types when it is used to build the
   RequestInfo object.

   `records` should be all records expected to be saved or fetched during the course of
   the request. Similarly, EmberData will populate this for you when using the request-builders
   or when the request is generated by the Store. This list will be used to update the status
   of the `RequestStateService` detailed in [RFC #466](https://rfcs.emberjs.com/id/0466-request-state-service)

```ts
interface StoreRequestInfo extends RequestInfo {
  cacheOptions?: { key?: string, reload?: boolean, backgroundReload?: boolean };
  store: Store;

  op?: 'findRecord' | 'updateRecord' | 'query' | 'queryRecord' | 'findBelongsTo' | 'findHasMany' | 'createRecord' | 'deleteRecord';
  records?: StableRecordIdentifier[];
}
```

**Background Reload Error Handling**

When an error occurs during a background request we will update the cache with the StructuredErrorDocument but will swallowed the Error at that point.

This prevents consuming applications from being required to catch the error unless
they wish to via a handler.

### RequestStateService

We do not intend to make any adjustments to the RequestStateService at this time, though
this new paradigm enables us to easily manage a list of requests key'd by URL that could
be useful for both application code and the Ember Inspector. If you are interested in adding
such support, we would accept an RFC. With the greatly improved flow this RFC brings we
expect that the overall design of the RequestStateService ought to be revisited.

### Registering a CacheHandler

While any handler could make use of a cache, there is a handler granted specialized
status which effectively functions as the very first handler in the handler chain
(some additional special priviledges may be afforded around timing).

Only one such handler may exist, and an error will be thrown if more than one
is attempted to be registered.

This method should only be used by a consuming application when the RequestManager
instance is not the same instance used by the `Store`. If using `@ember-data/store`,
`@ember-data/store` configures a `CacheHandler` which utilizes the `Cache`, the `LifetimesService`
and `cacheOptions` to gate whether the request continues down the handler chain.

This same handler is what is responsible for updating the `Cache` via `Cache.put` once
the request completes.

```ts
class RequestManager {
  /**
   * Register a handler to use for primary cache intercept.
   *
   * Only one such handler may exist. If using the same
   * RequestManager as the Store instance the Store
   * registers itself as a Cache handler.
   *
   * @method useCache
   * @public
   * @param {Handler[]} cacheHandler
   * @returns {void}
   */
  useCache(cacheHandler: Handler): void;
}
```

### Cache Lifetimes

In the past, cache lifetimes for single resources were controlled by either 
supplying the `reload` and `backgroundReload` options or by the Adapter's hooks
for `shouldReloadRecord`, `shouldReloadAll`, `shouldBackgroundReloadRecord` and 
`shouldBackgroundReloadAll`.

This behavior will now be controlled by the combination of either supplying `cacheOptions`
on the associated `RequestInfo` or by supplying a `lifetimes` service to the `Store`.

Explicit `cacheOptions` will always take precedence over the `lifetimes` service.

```ts
class Store {
  lifetimes: LifetimesService;
}

interface LifetimesService {
  isHardExpired(identifier: StableDocumentIdentifier): boolean;
  isSoftExpired(identifier: StableDocumentIdentifier): boolean;
}
```

**Legacy Compatibility**

In order to support the legacy adapter-driven lifetime behaviors of `findRecord`
and similar store methods, these methods will still consult the adapter prior to
consulting the lifetimes service. Requests that originate through `store.request`
will not consult the Adapter methods.

### Legacy Adapter/Serializer Support

In order to provide migration support for Adapter and Serializer, a `LegacyNetworkHandler` would be
provided. This handler would take a request and convert it into the older form, calling the appropriate
Adapter and Serializer methods. If no adapter exists for the type (including no application adapter), this
handler would call `next`. In this manner an app can incrementally migrate request-handling to this
new paradigm on a per-type basis as desired.

The legacy handler would only attempt to handle requests with an `op` and no `url`. Requests with a `url`
would be forwarded on via `next`. In this way, individual requests can be migrated away from legacy by
either directly invoking `store.request` with the correct args or by utilizing a request builder which
assigns the url to the request object.

The package `ember-data` would automatically configure this handler. If not using `ember-data`
this configuration would need to be done explicitly.

We intend to support this handler through at least the 5.x series, not deprecating it's usage
before 6.0.

Similarly, the methods `adapterFor` and `serializerFor` will not be deprecated until at least 6.0;
however, it should no longer be assumed that an application has an adapter or serializer at all.

### Migrating Away From Legacy Finders

In order to support transitioning to this new paradigm, we would introduce new url-building
and request-building utility functions in a new package (`@ember-data/request-utils`) that
closely mirror what occurs by using the corresponding store and Adapter methods today.

Note: the lack of `findAll` in this list is intentional, we do not intend to implement this
separately from `query`.

```ts
import { findRecord, queryRecord, query, updateRecord, createRecord, deleteRecord, saveRecord } from '@ember-data/request-utils';

const { data: user } = await store.request(findRecord('user', '1'));
const { data: user } = await store.request(queryRecord('user', { username: 'runspired' }));
const { data: users } = await store.request(query('user', {}));

await store.request(updateRecord(user));
await store.request(createRecord(user));
await store.request(deleteRecord(user));
await store.request(saveRecord(user));
```

Each of these request-builders returns an object satisfying the `RequestInfo` interface, which
could also be manually constructed.

Additionally, a url-builder similar in behavior to the `BuildURLMixin` is provided.
Notable differences include that is also serializes query params into the URL, and
assumes the first argument is the "path for type".

The following config properties will be supply-able via the app's `ember-cli-build`

```ts
interface Config {
  '@embroider/macros': {
    setConfig: {
      '@ember-data/request-utils': {
        {
          apiNamespace: string;
          apiHost: string;
        }
      }
    }
  }
}
```


```ts
import { buildUrl } from '@ember-data/request-utils';

// findRecord with include
const url = buildUrl('user', '1', { include: 'friends' });

// query page 3 of users
const url = buildUrl('users', null, { limit: 25, offset: 50 });

// query for a single user
const url = buildUrl('user', null, { username: 'runspired' });

// query the first page of comments for post 1
const url = buildUrl('post/1/comments/list', null, { limit: 10, offset: 0 });
```

### Deprecating Legacy Finders

We would not immediately deprecate methods on the Store for requesting data until at
least 6.0; however, applications should begin migrating all requests to this new
paradigm and expect that the following methods will be deprecated at some point during
the 6.x cycle

  - `store.findRecord`
  - `store.findAll`
  - `store.query`
  - `store.queryRecord`
  - `store.saveRecord`

Users that want to maintain these finder methods for longer would be able to add them back
 within their own application or library if desired; however, because these methods cannot
 easily utilize the full feature set of the cache, pagination, or request-manager we expect
 that their utility will diminish quickly.

### Migrating Away from Serializers

We do not intend to provide a direct replacement of Serializers in any form. Instead,
given the current power and flexibility of the Cache, we recommend aligning the
Cache implementation with your API implementation.

If data normalization is still needed, we recommend writing a few helper functions
that a handler can use to quickly transform the data as necessary. Due to having better
context of the request, and due to the much smaller surface area to reason about, writing
a function to transform data between formats should prove to be simple, quick and effective.
We expect some addons may be created that offer helper functions for common transformations.

Since Serializers will not be officially deprecated until some point after 6.0, we feel
that this is more than ample time for applications and addons to explore this space and
either become comfortable with the realization that such data transformation is largely
 unecessary and wasteful or can be done via much simpler and surgical mechanisms.

Of course, users can always choose to continue using Serializers (and Adapters) forever.
Their deprecation within EmberData will be scoped to (1) EmberData itself no longer being
aware of the concept and (2) the `adapter` and `serializer` packages being deprecated.

If desired, other libraries could take on support of these packages, and make use of
public APIs to restore these behaviors, utilizing the same public APIs EmberData will
use to support them until deprecated. We suspect, however, the insane improvement in ergonomics
and feature-set that this shift brings will –over the course of the few years prior to full
removal– prove to users that the Adapter and Serializer world is no longer the best paradigm
for their applications.

### Typescript Support

Although EmberData has not more broadly shipped support for Typescript, experimental types
will be shipped specifically for the RequestManager package. We can do this because the lack
of entanglement with the other packages affords us the ability to more safely ship this subset
of types while the others are still incomplete.

Types for other packages will eventually be provided but we will not rush them at this time.

## How we teach this

- EmberData should create new documentation and guides to cover using the RequestManager.

- Existing documentation and guides should be re-written to either reference these new
patterns or to be clear that they discuss a legacy pattern that is no longer recommended.

- The learning story for EmberData should be reworked to one that incrementally grows from
  a simple abstraction over fetch, to fetch with a cache, to fetch with a cache and resource
  graph and presentational concerns.

## Drawbacks

Historically, Adapters hid away construction of requests from app-developers which kept 
application code focused only on working with data that was magically fetched and processed
in the background.
 
When this worked, it worked very well, and many users have loved this magic deeply. However,
this abstraction came at the great cost of making EmberData difficult to fit into many common
scenarios, difficult to reason about and debug when data-fetching failed, and difficult to
extend when even very trivial changes to request construction were required.
 
We do not feel the occassional magic of it all working outweighs the drawbacks of
keeping the system as is, and so we have chosen a slightly more verbose approach that grants
developers flexibity, power, and ease-of-use.

## Alternatives

We considered building this over the existing Adapter interface, deprecating Serializers and
instead encouraging data-transformation to be done within the Adapter. In fact, this pattern
is fully possible today, we could just better document it and do nothing more. However, this
approach does not solve the need for more general request management, nor does it interact
well with common development paradigms such as GraphQL query building, nor does it allow us
to introduce pagination-by-default, and finally it does very little to advance the goal of being
a document centric cache.

---

---
stage: recommended
start-date: 2022-12-15T00:00:00.000Z
release-date: 2023-01-12T00:00:00.000Z
release-versions:
  ember-source: v4.10.0
teams:
  - framework
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/889'
  released: 'https://github.com/emberjs/rfcs/pull/895'
  recommended: 'https://github.com/emberjs/rfcs/pull/899'
project-link:
---

# Deprecate @ember/error

## Summary

The @ember/error package is just a re-export of the native Error and is therefore unnecessary.

## Motivation

Removal of unnecessary code keeps the codebase cleaner and simplifies developer burden.

## Transition Path

There is no use case for this anymore. A simple codemod can convert current uses to the native Error class.

## How We Teach This

Remove @ember/error from docs.

## Drawbacks

You'll have to run a codemod to resolve existing usage. However, this is trivial and will actually simplify user code.

## Alternatives

None.

## Unresolved questions

None.


---

---
stage: recommended
start-date: 2023-03-06T14:09:00.000Z
release-date: 2023-09-21T00:00:00.000Z
release-versions:
  ember-cli: v5.3.0
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/907'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/932'
  released: 'https://github.com/emberjs/rfcs/pull/944'
  recommended: 'https://github.com/emberjs/rfcs/pull/971'
project-link:
suite:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# `pnpm` support

## Summary

Enable Ember CLI users to opt into using `pnpm` for package management.

## Motivation

[`pnpm`](https://pnpm.io/) is a popular alternative to both `npm` and `yarn` that prioritizes correctness, especially for `peerDependencies` and monorepos. 

`pnpm` has very active maintainance, support, and financial funding.
Their [website](https://pnpm.io/) states that `pnpm` is:
 - Fast: `pnpm` is up to 2x faster than the alternatives 
 - Efficient: Files inside `node_modules` are cloned or hard linked from a single content-addressable storage 
 - Supports monorepos: `pnpm` has built-in support for multiple packages in a repository
 - Strict: `pnpm` creates a non-flat `node_modules` by default, so code has no access to arbitrary packages.

For folks with lots of projects on their computers, `pnpm` is _extremely_ space-efficient.
Where `npm` and `yarn` would duplicate `node_modules` per-project, `pnpm` will only download a package (at a specific version) once across your whole machine.

Additionally, `npm` and `yarn` repeatedly have demonstrated that their strategies with `peerDependencies` are not correct, and it is vitally important we use and support a tool that can guide folks towards correctly creating addons. For example, `@embroider/macros` relies on node's resolution algorithm, so having `peerDependencies` resolved correctly is important for `dependencySatisfies` to work as expected in monorepos. 

Ember CLI currently only supports `npm` (default) and `yarn` for project initialization as well as various commands. At present, projects work with `pnpm`, but the tooling is unaware.



## Detailed design

Enabling `pnpm` is designed as opt-in to prevent disruptions to developer's current workflow, much the same as `yarn`.

There are a few integration points that we must support for `pnpm` (and any package manager):
 - `ember install`
 - `ember init`, `ember new`, `ember addon`
 - `ember try:one`, `ember try:each`
 - generated C.I. configs
 - Documenation

### `ember install`

There are two mechanisms through which to opt-in.
The first one is the presence of a `pnpm-lock.yaml` file in the project root.

The `pnpm-lock.yaml` file is generated by `pnpm` when you run `pnpm install` (or the shorter `pnpm i`),
so we assume that its presence means the developer intends to use `pnpm` to manage their dependencies.

Alternatively you, you can force Ember CLI to use `pnpm` with the `--pnpm` flag.

To recap:

- `ember install ember-resources` with `pnpm-lock.yaml` present will use `pnpm`
- `ember install ember-resources` without `pnpm-lock.yaml` present will use npm
- `ember install ember-resources --pnpm` will use `pnpm`

### `ember init`, `ember new`, `ember addon`

Since this triad of commands is generally ran before a project is set up, there is no `pnpm-lock.yaml` file presence to check.
This means we are left with the `--pnpm` flag, which will also be added to these commands:

- `ember new my-app` will use npm
- `ember new my-app --pnpm` will use `pnpm`

The above also applies to `ember addon` and `ember init`, noting that `ember init` doesn't receive any arguments.

#### `--skip-npm`

The `--skip-npm` flag _actually means_ "skip installation of dependencies" when using `ember addon` and `ember new`, 
including skipping installation with both `npm` and `yarn`. 
This will need to be extended to also skip installation of dependencies when `pnpm` is used.

For example:
```bash
ember new my-app --pnpm --skip-npm
```


### `ember try:one`, `ember try:each`

At the time of writing this RFC, `ember-try` already supports `pnpm`, but it is undocumented in [the README](https://github.com/ember-cli/ember-try).
Documentation will need to be added to the README, 
as well as the relevant `ember-cli` blueprints will need to correctly configure `usePnpm: true` in the `ember-try.js` config file when the `pnpm` flag is present.


### generated C.I. configs

At the time of writing this RFC, `ember-cli` supports two C.I. environments: Travis and GitHub Actions. 

Both the `.travis.yml` and `.github/workflows/ci.yml` config files for relevant blueprints will need to support the `pnpm` option such that C.I. passes on new projects using `pnpm`.

### for addons

Addons should be stricter than  defaults, so that they are good stewards of the ecosystem and don't leak accidental uncertainty to their consumers.

In addon projects, the `.npmrc` will need the following defaults:
```
# all peer dependencies must be declared or forwarded to the consumer
auto-install-peers=false

# we want true isolation in addons -- if a dependency is not declared, we want an error
reslove-peers-from-workspace-root=false
```

### Documentation

These pages presently mention `npm` / `yarn` and will need to be updated to include `pnpm` 
 - https://cli.emberjs.com/release/basic-use/assets-and-dependencies/
 - https://guides.emberjs.com/release/addons-and-dependencies/

## How we teach this

The Ember Guides should be updated to reflect the new flags, where applicable,
as well as the new behavior of `ember install` in the presence of a `pnpm-lock.yaml` -- though most of the guides use `ember` as the CLI tool for managing packages. 

We may want to consider updating the [tutorial](https://guides.emberjs.com/release/tutorial/part-1/orientation/) (and its automation) to use `pnpm`, as `npm` is very slow.


In addition, the built-in instructions for `ember help` should be updated to reflect the new flags.


## Drawbacks

- `pnpm` is very strict about peers and what dependencies are allowed in a project and will error if a project's package.json is incorrect for a given scenario. `pnpm` is very clear about these errors and what to do for action items, but it means that we'll need to make sure that `pnpm` is tested in `ember-cli` when generating new projects so that we can be certain that folks' "first time experience" is smooth
- There may be other package managers in the future, but we cannot see the future. There have been talks about making ember-cli somehow generically handle package-managers, but it is unknown how that would work, and is unneeded for now.


## Alternatives

- Figure out a way to generically handle any package manager 
- Continue with the partial pnpm support we have today

## Unresolved questions

- Are there any other references in the guides to `npm` or `yarn`?
  The only place I could find that _mentioned_ `yarn` is here: https://guides.emberjs.com/release/addons-and-dependencies/
- Is there a `--package-manager` flag / option in `ember-cli`? for blueprint authors, that may be useful.
- Should `--skip-npm` be aliased to `--skip-install`?




---

---
stage: recommended
start-date: 2023-03-25T00:00:00.000Z
release-date: 2023-12-11T00:00:00.000Z
release-versions:
  ember-cli: 5.5.0
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/918'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/954'
  released: 'https://github.com/emberjs/rfcs/pull/978'
  recommended: 'https://github.com/emberjs/rfcs/pull/994'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate Support for Travis CI

## Summary

This RFC proposes to officially deprecate support for generating a Travis CI 
config file when creating a new app or addon.

## Motivation

Since Travis CI announced the end of its unlimited support for open-source 
projects, most of the (the entire?) Ember community has switched over to using
GitHub Actions instead. This basically leaves the `.travis.yml` files in the 
`app` and `addon` blueprints unused. Even though the maintenance cost of keeping 
these files around is pretty low, not having to maintain them would be even 
better. It would make [PRs like this](https://github.com/ember-cli/ember-cli/pull/10222) 
slightly less cumbersome. Also, since almost no one actually uses these files, 
it becomes harder to know/ensure they are up to date and follow the current best 
practices.

## Transition Path

We should:

- Show a deprecation warning when creating a new app or addon using the 
`--ci-provider=travis` option
- Show a deprecation warning when picking the `Travis CI` option during the 
interactive new flow
- Add a comment to the `.travis.yml` files in the `app` and `addon` blueprints 
mentioning that they are deprecated - Adding a comment is the easiest thing to 
do implementation wise and people who _do_ wish to continue using Travis CI, can 
simply remove the comment again

## How We Teach This

I _think_ we would only need to remove all references to Travis CI from the 
learning materials.

## Drawbacks

Can't think of any at the moment.

## Alternatives

Continue supporting Travis CI.

## Unresolved questions

None at the moment.

---

---
stage: ready-for-release
start-date: 2023-05-31T00:00:00.000Z
release-date:
release-versions:
teams:
  - cli
  - data
  - framework
  - learning
  - steering
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/931'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/933'
project-link:
suite:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# JS Representation of Template Tag

## Summary

Formalize a Javascript-spec-compliant representation of template tag.

## Motivation

The goal of this RFC is to improve the plain-Javascript representation of the Template Tag (aka "first-class component templates") feature in order to:

- reduce the number and complexity of API calls required to represent a component
- efficiently coordinate between different layers of build-time and static-analysis tooling that need to use preprocessing to understand our GJS syntax extensions.
- avoid exposing a "bare template" as a user-visible value
- provide a declarative way to opt-in to run-time (as opposed to build-time) template compilation.
- enable support for class private fields in components

As an illustrative example, currently this template tag expression:

```js
let x = <template>Hello {{ message }}</template>;
```

Has the plain javascript representation:

```js
import { precompileTemplate } from "@ember/component";
import templateOnlyComponent from "@ember/component/template-only";
import { setComponentTemplate } from "@ember/component";
let x = setComponentTemplate(
  precompileTemplate("Hello {{message}}", {
    strictMode: true,
    scope: () => ({ message }),
  }),
  templateOnlyComponent()
);
```

This RFC proposes simplifying the above case to:

```js
import { template } from "@ember/template-compiler";
let x = template("Hello {{message}}", {
  scope: () => ({ message }),
});
```

As a second illustrative example, currently this class member template:

```js
class Example extends Component {
  <template>Hello {{message}}</template>
}
```

Has the plain javascript representation:

```js
import { precompileTemplate } from "@ember/component";
import { setComponentTemplate } from "@ember/component";
class Example extends Component {}
setComponentTemplate(
  precompileTemplate("Hello {{message}}", {
    strictMode: true,
    scope: () => ({ message }),
  }),
  Example
);
```

This RFC proposes simplifying the above case to:

```js
import { template } from "@ember/template-compiler";
class Example extends Component {
  static {
    template(
      "Hello {{message}}",
      {
        component: this,
        scope: () => ({ message }),
      },
    );
  }
}
```

## Detailed design

This RFC introduces a new importable API:

```js
import { template } from "@ember/template-compiler";
```

The following sections will detail the semantics of this `template()` function. In typical usages, calls to this `template()` will be pre-processed at build time. By default, the template compiler is not included in the build, and if this function is called at runtime without the template compiler, it will throw an runtime error.

However, there are use cases where runtime template compilation is desirable. For that purpose, we further introduce an importable module as an opt-in to include the template compiler:

```js
import "@ember/template-compiler/runtime";
```

When this module is imported into the build, it'll make the template compiler available, which allows the `template()` function to be called at runtime with compatible semantics as the build time pre-processing. Note that this is not an opt-in to disable or otherwise influence build-time compilation, it merely provides the necessary components for the `template()` function to be callable at runtime. See the dedicated section for additional details.

### Scope Access

To give templates access to the relevant Javascript scope, we offer **two different forms** for two different use cases. A critical feature of this design is that *both forms* have valid Javascript syntax **and** semantics. That means they can actually run when you want them to, with no further processing. And they are fully understandable by all spec-compliant Javascript tools. This is in contrast with intermediate forms like `[__GLIMMER_TEMPLATE("<HelloWorld />")]` in the current ember-template-imports implementation or the proposed:

```js
template`<HelloWorld />`
```

from [RFC 813](https://github.com/emberjs/rfcs/pull/813), which both lack any mechanism to access the surrounding scope, and therefore need "magic" beyond Javascript to make them run.

#### Explicit Form

The "Explicit Form" makes all data flow statically visible. It's the appropriate form to publish to NPM. To produce Explicit Form, build tools need to do a full parse of the template and a full lexical analysis of Javascript and Handlebars scopes.

Examples of Explicit Form:

```js
import { template } from '@ember/template-compiler';

// when nothing is needed from scope, no scope params are required:
const Headline = template("<h1>{{yield}}</h1>");

// local variable access works the same as in current precompileTemplate
const Section = template(
  "<Headline>{{@title}}</Headline>", 
  { 
    scope: () => ({ Headline}) 
  }
);

// in class member position, we can also put private fields in scope
class extends Component {
  static {
    template(
      "<Section @title={{this.title}} @subhead={{this.#secret}} />", 
      {
        component: this,
        scope: (instance) => ({ 
          Section, 
          "#secret": instance.#secret
        }),
      },
    )
  }
}
```

> This RFC is focused on making sure the scope accessors can do everything javascript can do, which is why we're including private fields. However, additional work beyond this RFC is required to make the template compiler correctly parse expressions like `{{this.#secret}}`. 

#### Implicit Form

The "Implicit Form" is cheaper and easier to produce because it doesn't need to do any lexical analysis and doesn't need to parse the handlebars at all.

The downside is that data flow is not all statically visible, because it relies on `eval`.

Implicit Form has two key use cases:
 - as an intermediate format between a preprocessor stage (which can eliminate all GJS special syntax and semantics) and the rest of a standard Javascript toolchain.
 - as the implementation format in sandbox-like environments where dynamic code execution is the whole point.

Examples of Implicit Form:

```js
import { template } from '@ember/template-compiler';

// Notice that all of these have the exact same
// `params` argument. It's always the same. 
// That's why it's easy to produce.

const Headline = template(
  "<h1>{{yield}}</h1>",
  {
    eval() { return eval(arguments[0]); }
  }
);

const Section = template(
  "<Headline>{{@title}}</Headline>", 
  { 
    eval() { return eval(arguments[0]); }
  }
);

class extends Component {
  static {
    template(
      "<Section @title={{this.title}} @subhead={{this.#secret}} />", 
      {
        component: this,
        // this handles private fields just fine,
        // see Appendix A.
        eval() { return eval(arguments[0]); }
      },
    )
  }
}
```

> _eval seems bad, what about Content Security Policy?_<br>
> Typical apps never needs to actually _run_ the eval. This is a communication format between layers of build tooling. You _can_ run it, if you're making something like an interactive development sandbox. But that is a case that already requires `eval` anyway.

> _Why `arguments[0]` instead of an explicit argument?_<br>
> If we picked a local name to use for the argument, we would shadow that name in the surrounding scope. Whereas `arguments` is already a keyword that exists for this purpose, and can never collide with other local bindings.


### Type Signature

```ts
import { ComponentLike } from '@glint/template';

declare function template<S>(
  templateContent: string,
  params?: Params<never>
): ComponentLike<S>;

declare function template<C extends ComponentLike<any>>(
  templateContent: string,
  params: Params<C>
): C;

interface Params<ComponentClass> {
  component?: ComponentClass;
  strict?: boolean;
  moduleName?: string;
  eval?: () => Record<string, unknown>;
  scope?: (
    instance: ComponentClass extends ComponentLike<any>
      ? InstanceType<ComponentClass>
      : never
  ) => Record<string, unknown>;
}

```

### Strict defaults to true

Unlike `precompileTemplate`, our `strict` param defaults to true instead of false if it's not provided. This is aligned with the expectation that our main programming model is moving everyone toward handlebars strict mode by default.

This also addresses the naming confusing between earlier RFCs (which used "strict") and the implementations in the ecosystem (which used "strictMode").

### Always Returns a Component

A key difference between `precompileTemplate` and our new `template` is that its return value is always a _component_, never a "bare template". In this sense, the implementation combines the jobs of `precompileTemplate` and `setComponentTemplate`.

Bare templates are a historical concept that we'd like to move away from, in order to have fewer things to teach.

When the `component` argument is passed, the return value is that backing class, with the template associated, just like `setComponentTemplate`. When the `component` argument is not provided, it creates and returns a new template-only component.

> _Aren't route templates "bare templates"? What about them?<br>_
> Yes, this RFC deliberately doesn't say anything about route templates. We expect a future routing RFC to use components to express what today's route templates express. This RFC also doesn't deprecate `precompileTemplate` yet -- although that will clearly be a good goal _after_ a new routing design addresses route templates.

### Runtime Compilation

Ember always had the ability to compile template at runtime. However, because this incur significant costs and most apps do not benefit from it, this feature is disabled by default and requires an explicit opt-in to include the runtime compiler.

Traditionally, this is done with:

```js
// ember-cli-build.js
app.import("node_modules/ember-source/dist/ember-template-compiler.js");
```

The new `"@ember/template-compiler/runtime"` module is interned to serve as a replacement for this, which better aligns with the direction we are headed. For example, this module can be imported on only the routes that needs it, and in conjunction with route-based code splitting that would reduce the performance hit on the initial load.

Note that, even with the template compilation is available at runtime, the result of the compilations may be subtly different – applications may have custom glimmer/handlebars AST plugins in their build, and these plugins will not be available at runtime.

Other than that, the signature and semantics of the `template()` function is intended to be identical between the build time pre-processing and runtime calls, and the build time pre-processing can be thought of as an optimization. In order to guarantee that the build-time optimization can be performed correctly, the next section details some syntactic restrictions. Sticking to the `"@ember/template-compiler"` import and adhering to the permissible subset of syntax enables authoring/emitting isomorphic code that is agnostic to where the compilation actually happens.

That said, as a convenience, the `runtime` module will also re-export the `template()` function:

```js
import { template } from "@ember/template-compiler/runtime";
```

This guarantees that these `template` call will not be touched by any build-time preprocessing, relaxes any static checks for the syntactic restrictions and ensures the runtime compiler is available.

### Syntactic Restrictions

The runtime template compiler has no syntactic restrictions.

The ahead-of-time template compiler has syntactic restrictions on `templateContents`, `params.scope`, and `params.eval`.

`templateContents` must be one of:

- a string literal
- a template literal with no expressions

If provided, `params.scope` must be:

- an arrow function expression or function expression
  - that accepts zero or one arguments
  - with body containing either
    - an expression
    - or a block statement that contains exactly one return statement
  - where the return value is an object literal
    - whose properties are all non-computed
    - whose values are all either
      - identifiers
      - or private field member expressions on our argument identifier

If provided, `params.eval` must be:
 - an object method
 - whose body contains exactly one return statment.
 - where the return value must be exactly `eval(arguments[0])`.

In summary:

|                        | Template Contents              | Scope Param                                  | Template Syntax Errors   | Payload          |
| ---------------------- | ------------------------------ | -------------------------------------------- | ------------------------ | ---------------- |
| Build-time compilation | Restricted to a string literal | Restricted to a few explicitly-allowed forms | Stops your build         | Smaller & Faster |
| Runtime compilation    | Unrestricted                   | Unrestricted                                 | Can by caught at runtime | Larger & Slower  |

### Older things that are intentionally dropped

`precompileTemplate` and its predecessors like `import { hbs } from 'ember-cli-htmlbars'` accepted some additional params that we are choosing not to keep.

 - `insertRuntimeErrors`: instead you should use `@ember/template-compiler/runtime` and catch the exception thrown by `template()`.

## How we teach this

Mentioning these APIs is appropriate when introducing the template tag feature in the guides. We can explain template tag as a convenience over these lower-level APIs and show side-by-side how a given template tag "really means" a call to `template()`. These examples should probably use the Explicit Form.

We can also mention that fully runtime template compilation is possible using `@ember/template-compiler/runtime` and show this example in Implicit Form, since that pairs well with a dynamic, REPL-like environment.

## Drawbacks



## Alternatives

This RFC builds off the proposal in
https://github.com/emberjs/rfcs/pull/813.

The main difference is that RFC 813 offered a form:

```
template`<Foo />`
```

that converts `<template>` into valid JS syntax _without_ working JS semantics.

### Type Strictness Alternative

The typescript types as written above don't prevent you from using `scope` and
`eval` simultaneously. We could use more complicated types to enforce that. See [example](https://www.typescriptlang.org/play?#code/PTAEFpM0GUEsDmA7AhgFwK4CcCmoAmOAZnEnGnAPZIRTiggBQjcAtgA6VZqgDkAAggA2pNMBxIAbnCzVWEtOBysARjizghlSgGccvANwsOXHgG9QAYUomkCgDJwA1ngC+oIrNZ9BIpGLRldiF0fSM2Tm4rG047fw8vH2E2eSxgAGMY6gVDZkJ0kNwPDCR0impQQI4QwIAeGAA+AApGUEqgmpxrfwUALlAdNCxSBAAaVtB2FCwUVh0Afn6YIbgygFUyalqAUQAPYNXyAAVp2Z0AMS4AFQ7QgHkkIQBPUAAfUABJasO0E5m5hqMACU-Wstgczhw9QaRnyhTwRBKZSoNCqwVCtUsoBwu0CSHwOmi4P8jhctRQSCeDWaEzRnW6eLQ-UGwyQYwmKhQ6ScI0sIR0OlB4zaU3+CyWK3WmyQO32InSx1Oc0uWD5KAFACEuS58JiGm9Pt8Fb8lTpASCrEYWD0sEQuXgtXo-mdQGYJizVmhFqAVNohDgKUY2qxKPgMP6AHKzHDej1soyuZiidR29J4PYHY3O5XXW6BB7PbG4iQE0COnDZwluto6TLsGP9JpA0AAXn1ACUcJksLq42NQCUnEhKAB3JAwxiJ62BW320AZ+WKsUqtWa7U4XVYnF40tg2IQskUqmAtrbkuE8uV13uusN0BNUiDClp-ofJBP0o4K5Pet65tt0BO27XsVjZUYByQIdR3HBMkxtVM8C+TMlxdM98QvdUK1Na9T0kFAhEbf99UHYcx1gxg0B-PANhRABpHAnh0Worn1FtQCuIsd0JDj5lAFwnkoIh2NAfo7EkdQjEo+tYElNAaOoAAJHAhHrLBmPAq4AEEhCEVjhLQ0sjwmXiOIAMlAP4KHw2ogK4XU9gKDBCFqeSkHoxjmO03TwP4wT2IacCSkIEg7HwakJlEnBxKwSSqJk4YpRRZi9OWBK5OlJSVPUdT-KtEBaCgeddlmYIcEJOh6CYRhMnfHgtHSfDWz4EcuCEfBckYRFSnKGgcQKFA2CaQUBlAhBm2rUBcEwLAaAAAwAdQAC0oFAAEJQAAEjMHRXFm8j8sAGXJGHy-g0B0JR9i7RR1FkLBaFAEc8AapBhx4KYBR9Sg0EWgZb1ACl8GxPChAAOjBii8xwJpZtqdgGkyrRwLMMx6vw1xXFW2pgDh2akYmKL8KbHC2kmnBpt64GmmmBAMHkfwdAAbQABgAXSBINQFcYVfsoetCNbfUmgsVGhE5oFxlcdnmHywBQcgh6pQmh2H4eUxHXRRygGqEdHMexhpceJ2teZwfmAKF0ARbFiWpeOsA5bpRWYbhhHKCRjWtZ1rGcbx3DCfGiY2im7AKcJ6naYURnWaltoucnG3Zeq-lCT2Er-QARk488iX3fxagsTSsAQYaLFQeRmVGgx-oQE3QCQWm1Du9xXH1Cbq54ABiQhaybcvWQQYnA7J4PQFmrbvrgHQQepyfS5wdwJ82sxx8n6ep+r9wngDLBCUoNqQb2iYpxrNB0FWAf2gVwIlbh5G+pCNhKkWieQc7sr0nRr39fA5efZJmtb0bI+E+n4iL3gmn-U8ux+psG5hAvgr9ay8H6EA58OAX5d3SLAkmkssGSw5omKcCd+ofRTtUHAAAmTO6Fs7ZFzvnQuxda7Rl7iMSuKBq6iXruoTmnMW4TDbqABB6Qe4jT7ufIOM0R5jyfivBhINZ7z0JNI5+q92Fz1AJvaYO894HxjswY+p90jnwdlfJ2DRb5QPvt4Ze6C34fz1gbH+59fZCCJuAiBEiQ6uLDnTM6zM2Ycz-rHIJ0dOaTmlmAA6909B4FengCos0CZCFmj6ZSo5E7qmTsVMhABmKhu4shxDQHnUABci79BLsw0RrCq41zrqobhTc+FtAEUIkRfZxFD0kaPJeMip5yIUaABeyjZFFzXuozR29QC73wPvfB+iRqGOMZDa+5izB3wGtYvpQj7He0fhPX+f8jZ83vCgkBAswEBwgRsmBVy-68CEUgoZtVUG2NrFgmO4s7kMDAKdc6OJ6xlCUFgW691HqgGeq9SYmTPrfR5tJAGQN8JgxBt8pJbjvmD3Jki7xhdw7038aEoJuDQkEMYEAA) courtesy of @chriskrycho. I didn't go with that in the RFC because it's harder to read and explain, and I don't think this low-level API present much practical risk that people will be accidentally including both together. 


## Unresolved questions

### Appendix A: Field Access Patterns

This is a fully-working example that can run in a browser. It uses a toy rendering engine just to illustrate how scope access is working.

```html
<script type="module">
  let templates = new WeakMap();

  function template(content, params) {
    templates.set(params.component, { content, params });
  }

  function render(instance) {
    let { content, params } = templates.get(instance.constructor);
    return content.replace(/\{\{([^}]*)\}\}/g, (m, g) =>
      get(instance, params, g)
    );
  }

  function get(instance, params, path) {
    if (params.eval) {
      if (path.startsWith("this.")) {
        return params.eval("arguments[1]." + path.slice(5), instance);
      }
      return params.eval(path);
    } else {
      if (path.startsWith("this.#")) {
        return params.scope(instance)[path.slice(5)];
      } else if (path.startsWith("this.")) {
        return instance[path.slice(5)];
      } else {
        return params.scope(instance)[path];
      }
    }
  }

  let local = "I'm a local variable";
  class ImplicitExample {
    publicField = "I'm a public field";
    #privateField = "I'm a private field";
    static {
      template(
        `DymamicExample
        publicField={{this.publicField}}, privateField={{this.#privateField}}, local={{local}}
        `,
        {
          component: this,
          eval() {
            return eval(arguments[0]);
          },
        }
      );
    }
  }

  class ExplicitExample {
    publicField = "I'm a public field";
    #privateField = "I'm a private field";
    static {
      template(
        `StaticExample:
        publicField={{this.publicField}}, privateField={{this.#privateField}}, local={{local}}
        `,
        {
          component: this,
          scope: (instance) => ({
            local,
            "#privateField": instance.#privateField,
          }),
        }
      );
    }
  }

  console.log(render(new ImplicitExample()));
  console.log(render(new ExplicitExample()));
</script>
```


---

---
stage: accepted
start-date: 2023-07-27T00:42:02.085Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - framework
  - learning
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/939
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Introduce a Wildcard Module Import API

## Summary

Introduce `import.meta.glob()` for use in all Ember apps and addons.

## Motivation

This RFC is siblings with [an RFC](https://github.com/emberjs/rfcs/pull/938) that deprecates all usage of Ember's traditional AMD infrastructure. That necessarily means we will remove `requirejs.entries` and `requirejs._eak_seen`. So we need to explain what you're supposed to use instead if you need to enumerate modules. `import.meta.glob()` is one answer to that question.

## Detailed design

First, an illustrative example:

```js
// If you type this in your app:
const widgets = import.meta.glob('./widgets/*.js')

// It gets automatically converted into something like this:
const widgets = {
  './widgets/first.js': () => import('./widgets/first.js'),
  './widgets/second.js': () => import('./widgets/second.js'),
}
```

This design builds off [Vite's Glob Import Feature](https://vitejs.dev/guide/features.html#glob-import), but since that feature is non-standard and offers a rather wide API surface area, we're picking a well-defined subset that we're committed to supporting, not just under Vite but under all build tooling that we support, including today's classic builds.

`import.meta.glob()` is a special function that:
 - can only be used with a string-literal first argument
 - can only be invoked directly as `import.meta.glob()`. You cannot pass it as a value, nor can you pass `import.meta` as a value and then try to call `.glob()` on that.

The string argument **must** start with `./` or `../`. Only relative imports are supported.

Escaping your own package via repeated `../` is not allowed.

 - For Ember apps, your package is the `/app` directory. 
 - For classic (v1) Ember addons, your package is the `/addon` directory.
 - For v2 Ember Addons, your package is your actual NPM package.

### Pattern Matching Specifics

The pattern always uses `/` as the path separator, regardless of operating system.

No automatic file extension resolution is performed -- to match `.js`, your pattern should end in `.js`.

 - You should think of this happening *before* any transpilation renames your files. If you're authoring typescript, you should write `import.meta.glob('./files/*.ts')` and it will give you back an object whose keys also end in `".ts"`. Similarly, when targeting `.gjs` or `.gts` files you should say so explicitly, like `import.meta.glob('./files/*.gjs')`.

 - However, due to the way template-only components work, you should think of this happening *after* the automatically-created Javascript representation of a template-only component is created. That is, if you want to import a directory full of components, even if some of them are template-only components represented by `.hbs` files, you should still `import.meta.glob('./components/*.js')` as that will match the automatically-created components.

    > An import with an explicit `.hbs` extension has a specific historical meaning that is *not* a component, it's a bare template. You almost never want to do that manually. It's an implementation detail of template co-location and a historical compatibility feature. So if you tried to do `import.meta.glob('./components/*.{js,hbs}')` you would get back a mix of components and things-that-are-not-really-components.
    >
    > Ultimately this is a concern that goes away once you adopt `.gjs` and that would be our recommendation going forward.

`*` matches everything except:
 - path separators 
 - names starting with "." (hidden files)

`**` matches zero or more directories

`?` matches any single character except path separators

`[abc]`: a sequence of characters inside `[]` match any character in that sequence

`{.js,.gjs}`: bash-style brace expansion

### Lazy Mode

By default, `import.meta.glob` gives you asynchronous access to the modules. This is designed to work nicely in systems that lazily load code. However, it does not promise to *introduce* laziness where laziness does not already exist. When building with the classic build pipeline, all your own app code is always included in the bundle regardless of whether anyone imports it or not, and that remains true regardless of whether you use `import.meta.glob()` to access some modules. 

When building with Embroider, you can achieve lazy loading by using `import.meta.glob()` in combination with other features like `staticAppPaths` or `staticComponents`.

The return value from `import.meta.glob()` is the same either way -- you always get functions that return `Promise<Module>`. 

### Eager Mode

`import.meta.glob` supports an optional second argument. The only supported value at this time is the literal `{ eager: true }`.

When eager is true, you get synchronous access to all the modules. These modules cannot be lazily loaded evaluated  -- they will load and evaluate eagerly.

For example:

```js
// If you type this in your app:
const widgets = import.meta.glob('./widgets/*.js', { eager: true })

// It gets automatically converted into something like this:
import _w0 from './widgets/first.js';
import _w1 from './widgets/second.js';
const widgets = {
  './widgets/first.js': _w0,
  './widgets/second.js': _w1,
}
```

### Replacing cross-package usages

Historically, people have used `requirejs.entries` to have complete global access to everywhere from everywhere. `import.meta.glob` is deliberately more restrictive. For example, an addon cannot use `import.meta.glob` to load code out of the consuming application. Instead, addon authors will need to ask apps to pass them what they need.

For example, a future version of `ember-cli-mirage` might tell app authors to put this code into their app and/or tests as a way to dynamically gain access to all the Mirage-specific models, adapters, serializers, etc that the user has written:

```js
import { setup } from 'ember-cli-mirage';

setup(import.meta.glob('./mirage/**/*.js'))
```

Similarly, to do auto-discovery of ember-data models, an existing API like `discoverEmberDataModels()` would now accept them explicitly:

```js
import { discoverEmberDataModels } from 'ember-cli-mirage';

discoverEmberDataModels(import.meta.glob('../models/*.{js,ts}'));
```

### Not allowed in publication format

Addons are free to use `import.meta.glob` in their own code, but our tooling should implement it within the addon's own build, *before* publishing to NPM. `import.meta.glob` is not allowed in published addons on NPM.

This greatly reduces future compatibility concerns, and it doesn't cost us anything in terms of flexibility, given that this spec says `import.meta.glob` is not allowed to cross package boundaries anyway. That is: at publish time, the full list of files that any `import.meta.glob()` expands into is statically known.

### Types

`import.meta.glob` has this signature:

```ts
(pattern: string): Record<string, () => Promise<unknown>>
(pattern: string, { eager: true }): Record<string, unknown>
```

When you know that the things you're importing have a shared interface, it will behoove you to cast to it:

```ts
import { ComponentLike } from '@glimmer/template';

type Button = ComponentLike<{ 
  Args: { "onClick": () => void }, 
  Element: HTMLButtonElement, 
  Blocks: { default: [] } 
}>;

const buttons: Record<string, () => Promise<{ default: Button }>> = import.meta.glob('./buttons/*.js');
```


## How we teach this

We probably do not want to introduce this feature immediately to new users. In typical application development you won't often need it in your own code. So I don't think we need to bring it up in initial tutorial-level content.

In the guides, I think we should add a section titled "ES Modules: Imports and Exports" to the page [Working with HTML, CSS, and JavaScript](https://guides.emberjs.com/release/getting-started/working-with-html-css-and-javascript/). Right now "Modules" exist as a bullet point that directs you to MDN. Similar to what we currently do with classes, we can add a dedicated section with more details.

> ### Modules: Imports and Exports
> Ember apps are authored as JavaScript Modules (also know as "ES Modules"). By convention, your app's modules live in the `/app` directory, so if you see an import like `import Article from "your-app/models/article"`, that is referring to `/app/models/article.js`. If you install dependencies from NPM you can import from them as well.
> 
> In a default Ember app, you can use dynamic `import()` to load third-party modules from NPM on demand, but you can't use it on your own app code. (That feature is available if you're building with [Embroider](https://github.com/embroider-build/embroider/), but that is not the default experience yet.)
>
> If you need to import many modules at once, Ember apps support an extension on top of ES modules called `import.meta.glob()`. For example, `import.meta.glob('./widgets/*.js')` will give you access to all the matching files. You can only use `import.meta.glob()` on files within your own package.

The more detailed nuances of what `import.meta.glob` supports should be taught through good error messages. For example, all of these need to give clear explanation in an error messages:

 - trying to pass a non-string-literal to `import.meta.glob`
 - trying to escape your package via `../`
 - trying to import a pattern that doesn't start with `./` or `../`

## Drawbacks

As designed, this is not a drop-in replacement for the old system. Addons that relied on the looseness of the old system are going to need to make breaking changes to their public API to adapt to this change. I think those breaking changes are likely to be "constant cost" changes that are not expensive, even for big application, so I consider this worth it in order to get us into a more long-term-supportable position that is compatible with standard Javascript.

## Alternatives

### Globally powerful import.meta.glob

We could attempt to allow more globally-powerful `import.meta.glob`. For example, it might be possible to make patterns starting with `/` always search the current application, even when an addon is asking. This would give addon authors more of the power they're used to having, but I think it's a much riskier feature to enable across the ecosystem. I'm not convinced we could make it work at reasonable cost in even all current build systems, never mind future ones. As written, this RFC has low-risk of causing compatibility problems in the future since the feature is not allowed in addon publication format. This makes it much easier to evolve the feature over time without breaking the universe.

### Additional Vite feature space

Features from Vite's implementation that I didn't incorporate because I don't want to sign us up to reimplement them in every build system:

 - absolute imports, starting with `/`. This is not a well-defined concept in today's Ember apps because they do not have a single directory representing the app's web root.
 - `as: 'raw'` which gives you the raw source code of matching files
 - `as: 'url'` which gives you URLs to the matching files
 - named imports mode, which allows you to ask for specific names instead of whole modules
 - custom queries

None of these are necessarily bad, but they aren't strictly necessary to meet our needs and a more minimalist spec is more likely to remain stable and supported over the long term.  An app that's using Vite is free to use Vite-specific extensions if they choose to be accept that dependency. 



---

---
stage: accepted
start-date: 2023-09-18T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/964
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# EmberData | Deprecate Legacy Request Support

## Summary

Deprecates methods on `store` and `model` that utilize non-request-manager request paradigms. These
methods are no longer recommended in the face of the greater utility of `store.request`.

Deprecates methods on store associated to older request paradigms / the inflexibility of older paradigms.

These deprecations would target 6.0.

## Motivation

This RFC is a debt collection. The newer RequestManager paradigm offers a pipeline approach to requests and preserves the context of the request throughout its lifecycle. This newer paradigm solves the issues
with limited power and flexibility that the adapter/serializer approach suffered and which led to so many ejects to fetch+push, work arounds, frustrations, and library removals.

The RequestManager paradigm ensures that any request starts by providing FetchOptions. These may be built programmatically (for instance for relationships or collections that return links information from the API), or by builders, or even manually.

Users have the choice of providing the body for a request at the point of the request, or inserting one later using a request handler. For both cases, EmberData provides access to the cache and its APIs for diffing state changes, as well as `serializePatch` and `serializeResources` utils for each cache implementation that we ship.

The paradigm has the simple goal of "use the platform". Importantly, it is this usage that allows us to intelligently cache requests and documents alongside resources, opening up vast possibilities for helpful new features for EmberData that these older methods do not support.

The legacy pattern's inflexibility meant that users often needed to eject from using adapter/serializer paradigms to fetch data. The new paradigm does not have these constraints, so we wish to deprecate methods that served only as work arounds or only work with these now legacy concepts.

## Detailed design

### Deprecating Historical Request Methods

Currently, the Store allows users to continue using the historical methods for fetching or mutating data.

**Group 1**

- `store.findRecord`
- `store.findAll`
- `store.query`
- `store.queryRecord`
- `store.saveRecord`
- `model.save`
- `model.reload`
- `model.destroyRecord`

These historical methods include the `hasMany` and `belongsTo` async auto-fetch behaviors on `@ember-data/model`

**Group 2**
- accessing an async belongsTo
- accessing an async hasMany

As well as corresponding relationship reference fetching methods

**Group 3**
- `HasManyReference.load()`
- `HasManyReference.reload()`
- `BelongsToReference.load()`
- `BelongsToReference.reload()`

These historical request methods currently translate their arguments into the shape expected by RequestManager with a few major caveats:

- they require using the LegacyCompatHandler and adapter/serializer logic or something mimicking it
- they are not as flexible at the callsite
- they are not cacheable since they do not set cacheKey and do not provide a url

Now that builders have shipped in 5.3, deprecating all of group 1 allows us to begin simplifying the mental model of how EmberData should be used.

Groups 2 and 3 should not be deprecated until we've either provided an alternative decorator to replace async `belongsTo` and `hasMany` or shipped [SchemaRecord](#8845)

#### What to do instead

Examples here are shown for apps that use `JSON:API`. Apps using other paradigms should use the builders for `REST` or `ActiveRecord` if
applicable, or author their own (or a new community lib!) if not.

- `store.findRecord`
- `model.reload`

```ts
import { findRecord } from '@ember-data/json-api/request';

const result = await store.request(findRecord('user', '1'));
const user = result.content.data;
```

- `store.findAll`

If you don't want all records in the store + what the API says

```ts
import { query } from '@ember-data/json-api/request';

const result = await store.request(query('user'));
const users = result.content.data;
```

If you do want all records in the store + what the API says. Note,
we would heavily discourage this approach having watched as it leads
to difficult to disentangle complexity in applications.

```ts
import { query } from '@ember-data/json-api/request';

await store.request(query('user'));
const users = store.peekAll('user');
```

- `store.query`

For requests that are expected to send a "body" to the API see notes
in the saveRecord section below.

```ts
import { query } from '@ember-data/json-api/request';

const result = await store.request(query('user', params));
const users = result.content.data;
```

- `store.queryRecord`

```ts
import { query } from '@ember-data/json-api/request';

const result = await store.request(query('user', { ...params, limit: 1 } ));
const user = result.content.data[0] ?? null;
```

- `store.saveRecord`
- `model.save`

For requests that are expected to send a "body" to the API applications
may choose to either serialize the body at the point of the request or
to implement a Handler for the RequestManager to do so.

EmberData does not provide a default handler which serializes because this
is a unique concern for every app. However, EmberData does provide utilities
on both the Cache and for some of the builders to make this easy.

For JSON:API we show the "at point of request" approach using the utils
provided by the `@ember-data/json-api` package here.

**for create**

```ts
import { recordIdentifierFor } from '@ember-data/store';
import { createRecord, serializeResources } from '@ember-data/json-api/request';

const record = store.createRecord('user', {});
const request = createRecord(record);
request.body = JSON.stringify(
  serializeResources(
    store.cache,
    recordIdentifierFor(record)
  )
);

await store.request(request);
```

**For update**

```ts
import { recordIdentifierFor } from '@ember-data/store';
import { updateRecord, serializePatch } from '@ember-data/json-api/request';

user.name = 'Chris';

const request = updateRecord(user);
request.body = JSON.stringify(
  serializePatch(
    store.cache,
    recordIdentifierFor(user)
  )
);

await store.request(request);
```

Note if you only wanted to save the single mutation you just made, you could.

```ts
import { updateRecord, serializePatch } from '@ember-data/json-api/request';

// local mutation (reflected on model immediately)
user.name = 'Chris';

const request = updateRecord(user);
request.body = JSON.stringify(
  {
    data: {
      type: 'user',
      id: user.id,
      attributes: {
        name: user.name
      }
    }
  }
);

await store.request(request);
```

**for delete**

- also `model.destroyRecord`

```ts
import { deleteRecord } from '@ember-data/json-api/request';

store.deleteRecord(user);
await store.request(deleteRecord(user));
store.unloadRecord(user);
```

### For Async Relationships / Sync Relationship Reload

Use [LinksMode](https://github.com/emberjs/data/blob/main/guides/relationships/features/links-mode.md) which enables autofetch / explicit fetch of a relationship to utilize the RequestManager pipeline in
full instead of adapters/serializers via the LegacyNetworkHandler.

### Deprecating Store Data Munging

Additionally, we deprecate store methods for data munging:

- `store.pushPayload`
- `store.serializeRecord`

#### What to do instead 

**For Modern Apps**

- align the cache and API format, use `store.push` to upsert
- use the same normalization functions written for handling responses in the app's request handlers, use `store.push` to upsert
- migrate the request to just use `RequestManager` now that the limitations of the adapter pattern are gone

**For Apps still using Legacy**

- Use `store.serializerFor` and `serializer.normalizeResponse` to normalize payloads before using `store.push`.
- Some previous discussion https://github.com/emberjs/data/issues/4213#issuecomment-413370235
- Some examples of how to work without this method: https://github.com/emberjs/data/pull/4110#issuecomment-417391930


## How we teach this

- API Docs should remove usage examples of older patterns, replacing them with
  newer patterns. Ensure consistency before deprecating.
- Guides, and the Tutorial should remove usage examples of older patterns, replacing them with
  newer patterns.
- We do not activate this deprecation until at least the tutorial has been updated to new patterns

## Drawbacks

The only drawback here is that this deprecation doesn't go further. We do not at this time deprecate adapters
and serializers or the LegacyNetworkHandler. This is because to do so we must also deprecate the auto-fetch
behaviors of async relationships in `@ember-data/model`. We prefer to deprecate those aspects of the system
only once replacements are firmly in place.

However, we think continuing to clarify the mental model for everything else is important, especially because
`@ember-data/model` is not a required component of an EmberData installation and users can utilize everything
else today without Adapter/Serializer/Model should they so choose.

## Alternatives

Convert all of these APIs to expect builder input. We have not taken this avenue as we feel the scope of that
deprecation would be much harder to manage and much tougher to navigate. However, an application may choose to
extend the store and implement any of the request method they choose in this manner because they have the knowledge
of which builder to use.

```ts
import { findRecord } from 'app/builders';

class extends Store {
  async findRecord(type, id, options?): Promise<Record | null>; {
    const result = await this.request(findRecord(type, id, options));
    return result.content.data;
  }
}
```


---

---
stage: accepted
start-date: 2023-10-06
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - data
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/977 
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# v2 App Format 

## Summary

This RFC defines a new app format, 
building off the prior work in [v2 Addon format](https://rfcs.emberjs.com/id/0507-embroider-v2-package-format),
and is designed to make Ember apps more compatible with the rest of the JavaScript ecosystem. This RFC will define conventions of the app and clearly identify functionality that is considered "compatibility integrations" and could be considered optional in the near future.

## Motivation

When ember-cli was created there was no existing JS tooling that met the needs of the Ember Framework. Over the years we have added more and more developer-friendly conventions to our build system that many Ember applications and addons depend on. As the wider JavaScript tooling story has evolved over the years Ember has fallen behind, this is mainly because our custom-built tools have not been keeping up with the wider community and we haven’t been able to directly use any more advanced tooling in our apps. Efforts have been started to improve the situation with the advent of [Embroider](https://github.com/embroider-build/embroider) but the current stable release of Embroider still runs inside ember-cli and is somewhat bound in terms of performance and capability by the underlying technology [broccolijs](https://github.com/broccolijs/broccoli) and some other architectural decisions.

Over the past year the Ember Core Tooling team have been working hard to invert the control between bundlers and ember-cli, which means that instead of ember-cli running a bundler (such as Webpack in the current Embroider stable version) as part of its build system the whole Ember build process will essentially become a plugin to the bundler. This means that we can more effectively make use of bundler innovations, performance improvements, and we are more capable of adapting to whatever next generation of build systems come to the Javascript ecosystem.

With the Ember build system as a plugin to bundlers we have the ability to only intervene on things that are Emberisims (i.e. not-standard) and as we work to make Ember more standard we can eventually turn off these ”compatibility plugins”. Compatibility plugins will need to be powered by an “ember prebuild” that collects information about your app and addons and output metadata that the bundler plugins will consume. The intention is that this prebuild will be done automatically for you as part of the bundler plugin setup and you should not have to worry about preforming extra steps.

This RFC is not going to describe a new blueprint where you don't need any compatibility plugins (or an ember prebuild) to run an Ember app, this RFC instead is going to propose a new blueprint that has all the compatibility plugins turned on so that it is easiest for most people to upgrade to. Any discussion about a minimal “compatibility-free” blueprint should happen in a later RFC. 

## Key Ideas

Much like the [v2 Addon format RFC](https://rfcs.emberjs.com/id/0507-embroider-v2-package-format#key-ideas) we want the new app blueprint to rely on ES Modules and not leave anything hidden or automatic. This not only makes it easier for developers to know where things are coming from, it also makes it easier for bundlers to know what to do with Ember applications.

Each of the following sections go into detail of all the changes between the current blueprint and the new proposal which is currently being developed at https://github.com/embroider-build/app-blueprint

### Focus on Vite

The new app blueprint will default to using Vite to power local development and build for production. Vite has been on a meteoric rise in popularity over the past few years, and it represents the state of the art when it comes to Developer Ergonomics.  Standardising on such a popular build system will bring the Ember community a lot of benefits but the key areas of improvement that we expect developers to experience are: 

- significantly improved rebuild speeds during local development
- the ability to use "standard" vite plugins with your Ember apps
- significant improvements to debugability of your code in development because Vite serves ES Modules directly to your browser in development

### Removal of requirejs support

The default build system that will be used in this new blueprint will be Vite and for the most part Vite requires that your app is described in terms of ES Modules. The default build from `ember-cli` would express all of your modules using AMD and requirejs `define()` statements. There is an open RFC for [Strict ES Module Support](https://github.com/emberjs/rfcs/pull/938) that removes Ember's reliance on AMD to define modules and that RFC would be a requirement for this one i.e. when building with Vite you essentially have no requirejs module support. This means that any addon or application that interacts with requirejs would need to be updated for people to upgrade to this new blueprint.

### Top level await added

Since we are now using ES Modules througout the whole application it now becomes possible to use [top-level-await](https://v8.dev/features/top-level-await) in the module-scope of any of your files. This opens up a lot of possibilities for Ember developers and is a great example of how adopting standards helps to bring improvements from the wider ecosystem to Ember developers.

## Detailed design

In this section I'm going to go through each of the changes in the new proposed blueprint, in each section I will do my best to explain the reasoning for why it needs to be like this but if you have any questions or comments please feel free to comment on the RFC and we will try to update that section.

### Entrypoint -> index.html

A lot of modern bundlers make use of your index.html file as the main entrypoint to kick off bundling. Any files that are referenced in your index.html would then end up getting bundled.

This already an issue for an Ember app because the index.html that is traditionally found at `app/index.html` is ultimately not used directly. Information in the index.html file is used to generate the real file that is used at the end of the pipeline. 

This new blueprint proposes to remove this oddity and both allow bundlers to look directly at the source index.html instead of the output build artifact and will remove almost all ember build customisations that targed the index.html. We still intend to support `{{content-for}}` entries in the index.html with a few caveats that I will explain in more detail in the next section, but the support for `{{content-for}}` will need to be provided by a bundler plugin that has the ability to replace content in the index.html. 

The index.html will also have an inline script tag that performs the application boot. This process used to be hidden away in a `{{content-for “app-boot”}}` section in one of the javascript files automatically added to the index.html during the build pipeline. This explicit inline application boot significantly improves the visibility of how the application actually boots and should allow developers to customise that process without our build system needing to provide a way to handle those customisations. Incidently this now means that if you are using an addon to customise the `{{content-for “app-boot”}}` then this will no longer work. If Embroider discovers that an app is trying to customise the app-boot in any way it will throw this error: 

> Your app uses at least one classic addon that provides content-for 'app-boot'. This is no longer supported.
> 
> With Embroider, you have full control over the app-boot script, so classic addons no longer need to modify it under the hood.
> 
> The following code is used for your app boot:
> 
> {{inline-custom-app-boot-code}}
> 
> 1. If you want to keep the same behavior, copy and paste it to the app-boot script included in app/index.html.
> 2. Once app/index.html has the content you need, remove the present error by setting "useAddonAppBoot" to false in the build options.

The embedded boot section in the index.html will look like the following: 

```
<script type="module">
  import Application from './app/app';
  import environment from './app/config/environment';
  Application.create(environment.APP);
</script>
```

This boot section touches app/app.js and the new app/config/environment.js files which are both described in sections below.

#### content-for in index.html

The way that `{{content-for}}` works in ember-cli currently is under-specified and cronically under documented. The highest level summary is that anyone can currently add `{{content—for “any-string“}}` and as long as any active ember-addon provided a value for that specific content-for section the exact string that the addon provided would be injected at that point in the document. While we are familiar with sections like `{{content-for “head”}}` there is no pre-defined list and the common sections are only common due to convention. This makes it **extremely** hard for a modern build system that doesn’t understand ember-addons to be able to know what to do with these sections. 

We are proposing that we codify the conventional sections as the default set, and the ember prebuild will be able to collate the text each addon wants to add to these sections 

- head
- test-head
- head-footer
- test-head-footer
- body
- test-body
- body-footer
- test-body-footer
- config-module
- app-boot

If you are using any other custom `{{content-for}}` section then you will need to explicitly pass this to your embroider config via a `availableContentForTypes` configuration

### App Entrypoint -> app/app.js

In a classic build ember-cli would collect all the of the modules in your app into an entrypoint in the build that would go through and define each of the modules in the require.js AMD registry. There is already an [RFC that describes the fact that we want to deprecate this AMD registry](https://github.com/emberjs/rfcs/blob/strict-es-module-support/text/0938-strict-es-module-support.md), but the key thing for this RFC is that we are trying to think of our app as series of real ES Modules we need to provide some way for the built-in discovery of these modules that allows Ember to still resolve those modules by name (for Dependency Injection concerns like services)

We are providing this with the virtual module `'@embroider/virtual/compat-modules';`. This means that any bundler plugin that wants to support Ember needs to be able to support virtual module imports. The contents of this file can be obtained by asking the Embroider resolver which collates the list of modules during the Ember prebuild.

We then pass the list of modules to an updated version of the Ember Resolver (that has already been released) which means that the Ember Resolver no longer needs to rely on requirejs.entries to find all of the parts of your application. This set of compat modules also needs to be passed into the `loadInitializers()` from `ember-load-initializers` so that doesn't use AMD for initalizer discovery either. Here is an example of the difference in the `app/app.js` file:

```diff
 import Application from '@ember/application';
+import compatModules from '@embroider/virtual/compat-modules';
 import Resolver from 'ember-resolver';
 import loadInitializers from 'ember-load-initializers';
 import config from 'current-blueprint/config/environment';

 export default class App extends Application {
   modulePrefix = config.modulePrefix;
   podModulePrefix = config.podModulePrefix;
-  Resolver = Resolver;
+  Resolver = Resolver.withModules(compatModules);
 }

-loadInitializers(App, config.modulePrefix);
+loadInitializers(App, config.modulePrefix, compatModules);
```

One very important thing to note is that because we're moving from AMD to real ESM modules we now have a timing change for any code that is executing in the module scope, this code will now be executed eagerly and will not wait until the module is actually consumed by your app. This change happens because AMD inherently lazily executes module code only when that module is consumed, and ES modules are inherently a static graph of modules.

For the most part this change should not affect many people and most of the problems that we noticed related to this change came from addons that had code that had errors in it but was never cleaned up. It was never noticed before because the code was not being exercised by tests or consumers of the addons so most of the time the fix was to just delete the previously inert code.

### Application Config -> app/config/environment.js and config/environment.js

In a Classic build ember-cli automatically generated a module `app/config/environment.js` in your application build pipeline that is customisable with the config `storeConfigInMeta`. If `storeConfigInMeta` is true (which is the default) then the contents of this module will look for a `<meta>` tag in your html and parse out the your previously serialised config object and return the value as the default export from the module. This is what people recieve when they import from `app-name/config/environment`.

This is another example of an Ember-specific complexity in the build system that can be confusing for other build systems. In the new blueprint we propose making the `app/config/environment.js` file exist in your source, and the contents will clearly be loading the config from meta: 

```js
import loadConfigFromMeta from '@embroider/config-meta-loader';

export default loadConfigFromMeta('app-name');
```

The serialising of the config into the index.html is still being handled by `{{content-for 'head'}}` and is not going to change as a result of this RFC.

One restriction in the new blueprint is that we don't have an automatic implementation for when `storeConfigInMeta` is set to `false`. Our reasoning is that if you have set this setting then you are likely doing something custom and you would need to update `app/config/environment.js` to reflect your custom setup. We don't need to provide any customisation here because this is a user-owned module and you can edit it as you please.

### Test Entrypoint -> tests/index.html and tests/test-helper.js

The `tests/index.html` will have the same treatment as the main `index.html` where the test boot code will now be exposed directly in an inline script so that test booting is not hidden deep in the build pipeline.

```html
<script type="module">
    import { start } from './test-helper';
    import.meta.glob("./**/*.{js,gjs,gts}", { eager: true });
    start();
</script>
```

To facilitate this new API the test-helper needs to be changed to essentially "wrap" its contents in a function that can be called rather than it running as a side effect of the import: 

```diff
 import Application from 'current-blueprint/app';
 import config from 'current-blueprint/config/environment';
 import * as QUnit from 'qunit';
 import { setApplication } from '@ember/test-helpers';
 import { setup } from 'qunit-dom';
-import { start } from 'ember-qunit';
+import { start as qunitStart } from 'ember-qunit';
 
+export function start() {
 setApplication(Application.create(config.APP));
 setup(QUnit.assert);
 
-start();
+qunitStart();

+}
```

This also allows us to load qunit, load all the test files, and then start qunit once all the tests are loaded. The loading of the test files is now also made explicit with the line: 

```js
import.meta.glob("./**/*.{js,gjs,gts}", { eager: true });
```

`import.meta.glob` is described in detail in the [Introduce a Wildcard Module Import API RFC](https://rfcs.emberjs.com/id/0939-import-glob). It is natively supported in Vite but it would need to be implemented in any other build system that wants to support building an Ember app.

### Explicit Babel Config -> babel.config.cjs

In a classic build ember-cli-babel manages all configurations to babel in a way that is entirely hidden to the end-user. This is nice considering that users don't need to manage this file themselves, but it is also problematic because if anyone wants to customise their babel config they need to rely on extension points provided by both ember-cli and ember-cli-babel and in some cases those extension points may not even be available e.g. it is currently impossible for an app to configure an ast-transform for the ember-template-compiler and people workaround this issue by creating an in-repo addon that does this configuration for them.

In the new blueprint we will have an explicit `babel.config.cjs` that will come pre-configured with all the babel-plugins that ember-cli-babel would have configured for you.

Here is the full contents of the proposed babel file: 

```js
const {
  babelCompatSupport,
  templateCompatSupport,
} = require('@embroider/compat/babel');

module.exports = {
  plugins: [
    [
      'babel-plugin-ember-template-compilation',
      {
        compilerPath: 'ember-source/dist/ember-template-compiler.js',
        enableLegacyModules: [
          'ember-cli-htmlbars',
          'ember-cli-htmlbars-inline-precompile',
          'htmlbars-inline-precompile',
        ],
        transforms: [...templateCompatSupport()],
      },
    ],
    [
      'module:decorator-transforms',
      {
        runtime: {
          import: require.resolve('decorator-transforms/runtime-esm'),
        },
      },
    ],
    [
      '@babel/plugin-transform-runtime',
      {
        absoluteRuntime: __dirname,
        useESModules: true,
        regenerator: false,
      },
    ],
    ...babelCompatSupport(),
  ],

  generatorOpts: {
    compact: false,
  },
};
```

You can see that there are two functions being imported from `@embroider/compat/babel`: `babelCompatSupport()` and `templateCompatSupport()`. This collects any extra babel config that is provided by any installed v1 ember-addon and makes sure that it still works with this new config. When an app no longer has any v1 ember-addons these functions can be removed but we will likely be leaving them in the default blueprint for the foreseeable future because they cost nothing if they are not being used.

For people who are familiar with Babel config files you may have noticed that we have not included `@babel/preset-env` in this config. While our browser support has classically been handled by babel and `@babel/preset-env`, Vite has a config option [`build.target`](https://vite.dev/config/build-options#build-target) that controls what browsers you would like to down-compile your code for. This `build.target` config is passed to esbuild which is ultimately in charge of making sure your code runs in your stated targets i.e. in your `config/targets` file. While we are still going to read your `config/targets` file and pass that to the `build.target` config, it's worth noting that esbuild does not support the same range of browsers that `@babel/preset-env` does. This isn't a problem for the default blueprint because it supports all browsers that are part of Ember's official support matrix. We also don't see this as a blocker for adoption of this new blueprint because any applications that have a wider browser support matrix than Vite's `build.target` can provide can just manually configure `@babel/preset-env` in their babel config, now that it's significantly easier to edit your babel config.

### Ember Pre-Build Config -> ember-cli-build.js

To enable the current stable version of embroider you need to wrap your Ember Application defined in `ember-cli-build.js` in a `compatBuild()` function. The `compatBuild()` function takes a plugin that runs your bundler (i.e. Webpack) as part of the ember-cli pipeline and an optional config that allows you to turn on each of the "static flags" of embroider one-by-one.

In the "Inversion of Control" version of the blueprint we intend to keep the same `compatBuild()` API but the job of the builder will be very different. Instead of Vite running as part of the ember-cli pipeline we are only running a prebuild that collects information about your application and its addons to make that available to the Embroider Vite plugin. When running directly in Vite the builder argument to `compatBuild()` will be inert and will do nothing.

To continue to support commands like `ember build` or `ember test` we need some way for ember-cli to interact with Vite and allow Vite to build the application and run tests against the built output. Running `ember test` will essentially run Vite once (as a "one shot build" with no watching functionality) using the builder imported from `@embroider/vite` and then run `ember test --path {outdir}` where `{outdir}` will target the build output from Vite. This allows us to continue to support testem and any CI process that people have defined to use `ember build` without needing to update. Here is an example of an updated `ember-cli-build.js` file:

```diff
 const EmberApp = require('ember-cli/lib/broccoli/ember-app');
+const { compatBuild } = require('@embroider/compat');
+const { builder } = require('@embroider/vite');

 module.exports = function (defaults) {
   let app = new EmberApp(defaults, {});
-  return app.toTree();
+  return compatBuild(app, builder, { /* optional Embroider options */ });
 };
```

The other change that will happen in the next Embroider major release (and will be true for the new blueprint) is that the options passed to `compatBuild()` will have **all the static flags turned on by default**. 

Also some flags, like `staticEmberSource`, `staticAddonTrees`, and  `staticAddonTestSuportTrees` are forced to be on and will throw an error if you try to set them to false. This error will give guidance wherever possible and link to relevant documentation.

### Explicit Bundler Config -> vite.config.mjs

If you are using the current stable release of Embroider then Embroider is generating a Webpack config for you automatically. It is possible for you to make some changes via config but the majority of the Webpack config file is hidden from you. 

This RFC proposes that we don't hide the bundler config any more, we will instead have a standard Vite config file that configures the required Embroider plugins. 

Here is the current version of the proposed vite config: 

```js
import { defineConfig } from 'vite';
import { extensions, classicEmberSupport, ember } from '@embroider/vite';
import { babel } from '@rollup/plugin-babel';

export default defineConfig({
  plugins: [
    classicEmberSupport(),
    ember(),
    // extra plugins here
    babel({
      babelHelpers: 'runtime',
      extensions,
    }),
  ],
});
```

This config is defining 2 "compound plugins" that contain all the functionality needed for an Ember app to be built with Vite. We have split them into `classicEmberSupport()` and `ember()` to communicate that some of the plugins could be considered optional if you aren't using classic Ember features e.g. you have converted all your templates to GJS files.

### Application metadata -> package.json 

In the [v2 Addon format RFC](https://rfcs.emberjs.com/id/0507-embroider-v2-package-format) we introduced the fact that the package.json `ember-addon` MetaData object should be versioned to identify which addons have been upgraded to the new spec. We will be reusing that concept for v2 apps by requiring the following section to be added to the package.json

```json
{
    "ember-addon" {
        "type": "app",
        "version": 2
    }
}
```

This will opt Embroider into modern resolving rules so that it can interoperate properly with bundlers.

### Exports -> package.json

[Package Exports](https://webpack.js.org/guides/package-exports/) is an addition to the ESM resolving rules that all modern bundlers support. It allows you to configure paths that should be importable from ouside your package, as well as giving you a standard way to "redirect" imports that target your package. 

We already use these semantics in Ember applications when we expect `import SomeComponent from 'app-name/components/some-component'` to actually import the file path `/path/to/app-name/app/components/some-component.js`. In this example you can see that the `/app/` subpath has been added to the location. In ember-cli this semantic is handled in broccoli by actually rewriting paths, but this is one of the main reasons why tooling gets confused by our import paths because it's not using a standard method to define our import paths.

The new blueprint will add the following exports section to the package.json by default: 

```json
{
    "./tests/*": "./tests/*",
    "./*": "./app/*"
}
```

This essentially "redirects" all requests to modules in the `app` folder, with the exepction of any path that has `app-name/tests/` at the start. This means that importing your test helpers like `import superHelper from 'app-name/tests/helpers/super-helper'` won't try to import from the path `/path/to/app-name/app/tests/helpers/super-helper.js`

## How we teach this

All of the guides will need to be updated to make sure that we reference the build system correctly. We will also need to make sure that the system we use that automatically builds the tutorial for us can work with the new build system and blueprint.

It will also probably be worthwhile getting Embroider API documentation added to https://api.emberjs.com/ as one of the listed projects on the left-hand side.

The majority of this RFC is written from the perspective of someone that is running `ember new` for the first time on a brand new app, but we will need to make sure to write both upgrade guides and appropriate codemods for anyone that is wanting to upgrade their apps from the old blueprints to this new default. We also need to put some consideration into the experience of people using [ember-cli-update](https://github.com/ember-cli/ember-cli-update) to upgrade Ember versions when we make this the new default. 

It's also important to note that this RFC does not represent the new bluerpint for a Polaris application. This is just upgrading our build system to use more modern and standard tools. Any communication around this RFC change should be explicit that this is a **part** of what is needed for Polaris but this blueprint update is not giving you all of polaris. This is a single step in that direction.

## Drawbacks

### Upgradability

If developers are using ember-cli-update to upgrade their apps there might be a case where in an upcoming version of Ember they will be "opted in" to an Embroider build with Vite. We don't expect this process to be automatic but we do think that we can get most applications across this line with the use of tooling and codemods. One way to mitigate this problem is that we could maintain a "classic blueprint" until the next Ember major release that people could switch to while they are figuring out how to upgrade to Embroider and Vite.

### Webpack support

The blueprint will default to using Vite as a bundler, and we plan to document the process to add support for more bundlers as part of the implementation of this RFC. We had originally intended to provide support for Webpack as a bundler to help people who have already upgraded to the current stable Embroider version and customised their Webpack builds but Webpack support is not trivial to implement. The Ember Tooling Team believes that the benefits of having Vite as the default build experience are so great that we should not delay the implementation of this RFC while we try to backport the Inversion of control implementation of Embroider to Webpack. 

## Unresolved questions

### package.json meta key

The way that Embroider is currently implemented the Ember MetaData in package.json is set with the key `ember-addon` even for applications. On the one hand it seems good that the applications and addons use the same key for this, but on the other hand it may be confusing that the key for the metadata has the word `addon` in it. We could move both addons and apps to just use the metadata key `ember` but that could create chrun with very little benefit.


---

---
stage: recommended
start-date: 2023-11-02T15:40:00.000Z
release-date: 2024-05-10T00:00:00.000Z
release-versions:
teams:
  - cli
  - data
  - framework
  - learning
  - steering
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/984'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1005'
  released: 'https://github.com/emberjs/rfcs/pull/1021'
  recommended: 'https://github.com/emberjs/rfcs/pull/1025'
project-link:
suite:
---


<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Treat Safari as an Evergreen Browser

## Summary

Safari's release cadence has increased as well as relevant-device compatibilty. This RFC proposes an amendment to the [browser support](https://emberjs.com/browser-support/) policy (introduced in [RFC#685](https://rfcs.emberjs.com/id/0685-new-browser-support-policy)) to treat Safari the same as Chrome and FireFox for Desktop and Mobile devices.

## Motivation

Treating Safari differently from other browsers is no longer necessary due to changes in release cadence. Only being able to adjust Safari support with an RFC and at major versions is unnecessary overhead.

## Detailed design

Ember v6 will support Safari based on usage statistics, the same as other browsers we support.


## How we teach this

### A new browser support policy

Diff:
- remove non-evergreen section
- place Safari under Evergreen Desktop and Evergreen Mobile
- actual numbers subject to change as time passes, this is an example

```diff
{{page-title "Browser Support"}}
<div class="container layout">
  <section aria-labelledby="section-browser-support-policy">
    <h1 id="section-browser-support-policy">Ember.js Browser Support Policy</h1>


+    <h2>Ember 6.0.0</h2>
+
+    <p>
+      In Ember 6.0.0, the framework supports the following major browsers:
+    </p>
+
+    <ul class="list-unstyled layout my-3">
+      <EsCard class="lg:col-2">
+        <div class="text-center text-md">Desktop</div>
+        <ul>
+          <li>Google Chrome >= 103</li>
+          <li>Mozilla Firefox >= 102</li>
+          <li>Microsoft Edge >= 110</li>
+          <li>Safari >= 16.4</li>
+        </ul>
+      </EsCard>
+      <EsCard class="lg:col-2">
+        <div class="text-center text-md">Mobile</div>
+        <ul>
+          <li>Google Chrome >= 112</li>
+          <li>Mozilla Firefox >= 110</li>
+          <li>Safari >= 16.4</li>
+        </ul>
+      </EsCard>
+      <EsCard class="lg:col-2">
+        <div class="text-center text-md">Testing</div>
+        <ul>
+          <li>Google Chrome</li>
+          <li>Mozilla Firefox</li>
+        </ul>
+      </EsCard>
+    </ul>

    <h2>Ember 5.0.0</h2>

    <p>
      In Ember 5.0.0, the framework supports the following major browsers:
    </p>

    <ul class="list-unstyled layout my-3">
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Desktop</div>
        <ul>
          <li>Google Chrome >= 103</li>
          <li>Mozilla Firefox >= 102</li>
          <li>Microsoft Edge >= 110</li>
          <li>Safari >= 12</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Mobile</div>
        <ul>
          <li>Google Chrome >= 112</li>
          <li>Mozilla Firefox >= 110</li>
          <li>Safari >= 12</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Testing</div>
        <ul>
          <li>Google Chrome</li>
          <li>Mozilla Firefox</li>
        </ul>
      </EsCard>
    </ul>

    <h2>Ember 4.0.0</h2>

    <p>
      In Ember 4.0.0, the framework supports the following major browsers:
    </p>

    <ul class="list-unstyled layout my-3">
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Desktop</div>
        <ul>
          <li>Google Chrome >= 92</li>
          <li>Mozilla Firefox >= 91</li>
          <li>Microsoft Edge >= 93</li>
          <li>Safari >= 12</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Mobile</div>
        <ul>
          <li>Chrome Android >= 96</li>
          <li>Firefox Android >= 94</li>
          <li>Safari >= 12</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Testing</div>
        <ul>
          <li>Google Chrome</li>
          <li>Mozilla Firefox</li>
        </ul>
      </EsCard>
    </ul>

    <h2>Ember 3.0.0</h2>

    <p>
      Ember currently targets Internet Explorer 11 as a baseline for support. This means that generally all modern and relatively recent browsers will work with Ember, since browsers are backwards compatible by design. Ember runs tests against the latest desktop versions of the following browsers:
    </p>

    <div class="layout my-3">
      <div class="card lg:col-2 lg:start-3">
        <div class="card__content">
          <ul>
            <li>Google Chrome</li>
            <li>Mozilla Firefox</li>
            <li>Microsoft Edge</li>
            <li>Internet Explorer 11</li>
            <li>Safari</li>
          </ul>
        </div>
      </div>
    </div>

    <p>
      Other browsers may work with Ember.js, but are not explicitly supported. If you
      would like to add support for a new browser, please <a href="https://github.com/emberjs/rfcs">submit an RFC or RFC issue for discussion</a>!
    </p>


    <p>
      We determine support on a browser-by-browser basis. Browsers are categorized as
      either <em>evergreen</em> or <em>non-evergreen</em>. The categorization is as follows:
    </p>

    <h3 class="text-center">Evergreen</h3>

    <ul class="list-unstyled layout my-3">
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Desktop</div>
        <ul>
          <li>Google Chrome</li>
          <li>Mozilla Firefox</li>
          <li>Microsoft Edge</li>
+         <li>Safari</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Mobile</div>
        <ul>
          <li>Google Chrome</li>
          <li>Mozilla Firefox</li>
+         <li>Safari</li>
        </ul>
      </EsCard>
      <EsCard class="lg:col-2">
        <div class="text-center text-md">Testing</div>
        <ul>
          <li>Google Chrome</li>
          <li>Mozilla Firefox</li>
        </ul>
      </EsCard>
    </ul>

-    <h3 class="text-center">Non-evergreen</h3>
-
-    <div class="layout">
-      <ul class="list-unstyled layout lg:col-4 lg:start-2 my-3">
-        <EsCard class="lg:col-3">
-          <div class="text-center text-md">Desktop</div>
-          <ul>
-            <li>Safari</li>
-          </ul>
-        </EsCard>
-        <EsCard class="lg:col-3">
-          <div class="text-center text-md">Mobile</div>
-          <ul>
-            <li>Safari</li>
-          </ul>
-        </EsCard>
-      </ul>
-    </div>

    <p>
-     For evergreen browsers, the minimum version of the browser that we support is
+     For evergreen browsers, the minimum version of the browser that we support can be
      determined at the time of every minor release, following this formula:
    </p>

    <div class="layout my-3">
      <div class="card">
        <div class="card__content">
-          <p>Whichever browser version is greater/more recent out of:</p>
+          <p>
+            Whichever browser version is greater/more recent out of the following,
+            given that the owning entity (e.g.: Apple, Google, Mozilla) still supports the version
+          </p>

          <ol>
            <li>
              The lowest/least recent version that fulfills any one of these properties:
              <ul>
                <li>It is the latest version of the browser.</li>
                <li>It is the latest LTS/extended support version of the browser (such as Firefox ESR).</li>
                <li>It has at least <em>0.25%</em> of global marketshare usage across mobile and
              desktop, based on <a href="https://gs.statcounter.com/">statcounter</a>.</li>
              </ul>
            </li>
            <li>
              The minimum version supported in the previous release
            </li>
          </ol>
        </div>
      </div>
    </div>

    <p>
      To simplify, the supported version either moves forward or stays the same for
      each release based on overall usage and LTS/current release versions.
    </p>

    <p>
      For non-evergreen browsers, support is locked at a specific major version, and
      we support all major versions above that version.
+     However, all supported browsers are considered ever green.
    </p>

-    <div class="layout">
-      <ul class="list-unstyled layout lg:col-4 lg:start-2 my-3">
-        <EsCard class="lg:col-3">
-          <div class="text-center text-md">Desktop</div>
-          <ul>
-            <li>Safari: 12</li>
-          </ul>
-        </EsCard>
-        <EsCard class="lg:col-3">
-          <div class="text-center text-md">Mobile</div>
-          <ul>
-            <li>Safari: 12</li>
-          </ul>
-        </EsCard>
-      </ul>
-    </div>

    Within a version of a browser, we only support the most recent patch release.
  </section>
</div>
```

## Drawbacks

More calculations for us to do when determining browser support for a particular version of ember.
(based on the algorithm described in 

> Whichever browser version is greater/more recent out of:

)


## Alternatives


## Unresolved questions



---

---
stage: recommended
start-date: 2023-12-15T00:00:00.000Z
release-date:
release-versions:
  ember-source: 5.10.0
teams:
  - cli
  - framework
  - learning
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/995'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1012'
  released: 'https://github.com/emberjs/rfcs/pull/1023'
  recommended: 'https://github.com/emberjs/rfcs/pull/1040'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate non-co-located components.

## Summary

Deprecates
- classic component layout
- pods component layout


Once this deprecation is implemented, only the following will be allowed:
- co-located components 
- gjs / gts components

## Motivation

These older component layouts force build tooling to keep a lot of resolution rules around, and makes it hard for codemods and other community tooling to effectively work across folks' projects.


## Transition Path

There are two types of paths to migrate off the old layouts 
- use a currently supported multi-file layout (keeping separate `js`, `ts`, and `hbs` files)
- migrate the component entirely to the latest component format, `gjs`, `gts`, (aka `<template>`)

There are some tools to help with this:
- [Classic to Colocation](https://github.com/ember-codemods/ember-component-template-colocation-migrator)
- [Convert pods to Colocation](https://github.com/ijlee2/ember-codemod-pod-to-octane)
- [Convert to `<template>`](https://github.com/IgnaceMaes/ember-codemod-template-tag)


Specifically, these layouts are no longer supported

### Classic 

```
{app,addon}/
  components/
    foo.js
    namespace/
      bar.js
  templates/
    components/
      foo.hbs
      namespace/
        bar.hbs
```

### Pods' Component layout.

```
{app,addon}/
  components/
    foo/
      component.js
      template.hbs
    namespace/
      bar/
        component.js
        template.hbs
```

The above example(s) could fairly easily be migrated (by users) to:

```
{app,addon}/
  components/
    foo.js 
    foo.hbs
    namespace/
      bar.js
      bar.hbs
```

Or using `component-structure=nested`

```
{app,addon}/
  components/
    foo/
      index.js 
      index.hbs
    namespace/
      bar/
        index.js
        index.hbs
```

Note, however, that classic components _importing_ the `layout` and setting it on an `@ember/component` will still work.
The key thing being deprecated is the runtime resolution of templates, so if there is an import involved, there is no runtime resolution.

### `ember-source`

The blueprint for components will need to remove the `classic` option:

Here is the output at the time of authoring this RFC:
```bash 
❯ pnpm ember g component --help
Requested ember-cli commands:

ember generate <blueprint> <options...>
  Generates new code from blueprints.
  aliases: g
  --dry-run (Boolean) (Default: false)
    aliases: -d
  --verbose (Boolean) (Default: false)
    aliases: -v
  --pod (Boolean) (Default: false)
    aliases: -p, -pods
  --classic (Boolean) (Default: false)
    aliases: -c
  --dummy (Boolean) (Default: false)
    aliases: -dum, -id
  --in-repo-addon (String) (Default: null)
    aliases: --in-repo <value>, -ir <value>
  --lint-fix (Boolean) (Default: true)
  --in (String) (Default: null) Runs a blueprint against an in repo addon. A path is expected, relative to the root of the project.
  --typescript (Boolean) Generates a version of the blueprint written in TypeScript (if available).
    aliases: -ts

      component <name> <options...>
        Generates a component.
        --path (String) (Default: components)
          aliases: --no-path (--path="")
        --component-class (@ember/component, @glimmer/component, @ember/component/template-only, "") (Default: --no-component-class)
          aliases: -cc (--component-class=@ember/component), -gc (--component-class=@glimmer/component), -tc (--component-class=@ember/component/template-only), -nc (--component-class=""), --no-component-class (--component-class=""), --with-component-class (--component-class=@glimmer/component)
        --component-structure (flat, nested, classic) (Default: flat)
          aliases: -fs (--component-structure=flat), -ns (--component-structure=nested), -cs (--component-structure=classic)

```

Specifically, we'll remove:
- `--component-structure=classic` and its alias


## How We Teach This

Guides and docs already don't mention the above old layouts.

### Deprecation Guide

#### component templates in `templates/components`

**Before**
```
{app,addon}
  components/
    demo.js
  templates/
    components/
      demo.hbs
```

**After**
```
{app,addon}
  components/
    demo.js
    demo.hbs
```

**After (gjs)**
```
{app,addon}
  components/
    demo.gjs
```

#### Pods


**Before**
```
{app,addon}
  components/
    demo/
      component.js
      template.hbs
```

**After**
```
{app,addon}
  components/
    demo/
      index.js
      index.hbs
```

**After (non-nested)**
```
{app,addon}
  components/
    demo.js
    demo.hbs
```

**After (gjs)**
```
{app,addon}
  components/
    demo.gjs
```


## Drawbacks

If upgrading to ember v6 without any changes,
- Some super old addons may break
- Some super old apps may break    

In either case, it's been ~4 years since co-located components were introduced, and the deprecation will give folks actionable information for how to move forward (ideally with a link to the deprecation site which can then link to tools folks can try).

## Alternatives

none

## Unresolved questions

none


---

---
stage: accepted
start-date: 2023-12-22T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - framework
  - learning
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/997
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Make `{{on}}` a built in modifier  

## Summary

Today, when using gjs/gts/`<template>`, in order to bind event listeners, folks _must import_ the `{{on}}` modifier.
Because event listening is so commonplace, this is a grating annoyance for developers.

This RFC proposes that `{{on}}` be built in to `glimmer-vm` and not require importing.

## Motivation

Given how common it is to use the `{{on}}` modifier:

```gjs
import { on } from '@ember/modifier';

<template>
    <button {{on 'click' @doSomething}}>
        click me
    </button>

    <form {{on 'submit' @localSubmit}}>
        <label
            {{on 'keydown' @a}}
            {{on 'keyup' @a}}
            {{on 'focus' @a}}
            {{on 'blur' @a}}
        >
        </label>

        <button>
            submit
        </button>
    </form>
</template>
```

It should be built in to the templating engine, Glimmer, so that folks don't need to import it.

There is precedence for this already as the following are already commonplace and built in:
- `(helper)`
- `(modifier)`
- `(component)`

It's historically been the stance that, 

"If it can be built in userspace, it should be, leaving the framework-y things to be only what can't exist in userspace"

But to achieve the ergonomics that our users want, we should provide a more cohesive experience, rather than require folks import from all of (in the same file):
- `@glimmer/component`
- `@glimmer/tracking`
- `@ember/modifier`
- `@ember/helper`
- `ember-modifier`
- `ember-resources`
- `tracked-built-ins`

Some of the above may unify in a separate RFC, but for the template-utilities, since the modules that provide them are already so small, it makes sense to inherently provide them by default. Especially as we can target strict-mode only, so that we don't run in to the same implementation struggles that built-in [Logical Operators](https://github.com/emberjs/rfcs/pull/562), [Numeric Comparison Operators](https://github.com/emberjs/rfcs/pull/561), and [Equality Operators](https://github.com/emberjs/rfcs/pull/560) have faced.

<details><summary>some context on those RFCs</summary>

The main problem with adding default utilities without strict-mode is that it becomes very hard to implement a way for an app to incrementally, and possibly per-addon, or per-file, to adopt the default thing due to how resolution works. Every usage of the built in utility would also require a global resolution lookup (the default behavior in loose mode templates) to see if an addon is overriding the built ins -- and then, how do you opt in to the built ins, and _not_ let addons override what you want to use?

With gjs/gts/`<template>`, this is much simpler, as in strict-mode, you can check if the scope object defines the helpers, and if not, use the built in ones.

This strategy of always allowing local scope to override default-provided utilities will be a recurring theme.

</details>

---------------

_Making `on` a built-in will help make writing components feel more cohesive and well supported, as folks will not need to cobble together many imported values_

----------------

## Detailed design

This change would affect strict-mode only. This is so that today's existing code that imports `on` from `@ember/modifier` will still work due to how values defined locally in scope override globals.

The behavior of `on` would be the same as it is today, but defined by default in the `glimmer-vm`.


`on` will be a keyword, and for backwards compatibility, this will require that keywords, in strict mode, be overrideable by the strict-mode scope bag.


## How we teach this

Once implemented, the guides, if they say anything about gjs/gts/`<template>` and `on` by the time this would be implemented, would only remove the import.

## Drawbacks

People may not know where `on` is defined.
- counterpoint: do they need to?, we are defining a lanugage, trying to make it ergonomic.

We need to allow keywords to be overridable in Glimmer -- this is a behavior most languages do not allow.

## Alternatives

- Use a prelude
    - preludes were mentioned during the initial exploration of strict-mode templates, and were decided against, because addons would not be able to assume a prelude exists, as apps could define their own, and this sort of re-introduces the app-tree-merging behavior that we've been trying to get away from. 

- Use an alternate syntax: `on:click={{handler}}` or `on:{eventname}={{value}}`
    - This would be even more ergonomic, and I think we should do this syntax anyway, but may take longer to implement. -- thought would not require glimmer allow the scope bag to overrid keywords.
        

## Unresolved questions

- What happens if we want to remove a keyword? (like `mut`)
  - same as today, we only need to commit to a major to remove the keyword in and then do it - providing ample deprecation time, ending with the final removal.


---

---
stage: accepted
start-date: 2023-12-22T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - framework
  - learning
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/998
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Make `(fn)` a built in helper 

## Summary

Today, when using gjs/gts/`<template>`, in order to bind event listeners, folks _must import_ the `(fn)` helper.
Because partial application is so commonplace, this is a grating annoyance for developers.

This RFC proposes that `(fn)` be built in to `glimmer-vm` and not require importing.

## Motivation

There is precedence for `fn` being built in, as all the other partialy-application utilities are already built in.

- `(helper)`
- `(modifier)`
- `(component)`

It's historically been the stance that, 

"If it can be built in userspace, it should be, leaving the framework-y things to be only what can't exist in userspace"

But to achieve the ergonomics that our users want, we should provide a more cohesive experience, rather than require folks import from all of (in the same file):
- `@glimmer/component`
- `@glimmer/tracking`
- `@ember/modifier`
- `@ember/helper`
- `ember-modifier`
- `ember-resources`
- `tracked-built-ins`

Some of the above may unify in a separate RFC, but for the template-utilities, since the modules that provide them are already so small, it makes sense to inherently provide them by default. Especially as we can target strict-mode only, so that we don't run in to the same implementation struggles that built-in [Logical Operators](https://github.com/emberjs/rfcs/pull/562), [Numeric Comparison Operators](https://github.com/emberjs/rfcs/pull/561), and [Equality Operators](https://github.com/emberjs/rfcs/pull/560) have faced.

<details><summary>some context on those RFCs</summary>

The main problem with adding default utilities without strict-mode is that it becomes very hard to implement a way for an app to incrementally, and possibly per-addon, or per-file, to adopt the default thing due to how resolution works. Every usage of the built in utility would also require a global resolution lookup (the default behavior in loose mode templates) to see if an addon is overriding the built ins -- and then, how do you opt in to the built ins, and _not_ let addons override what you want to use?

With gjs/gts/`<template>`, this is much simpler, as in strict-mode, you can check if the scope object defines the helpers, and if not, use the built in ones.

This strategy of always allowing local scope to override default-provided utilities will be a recurring theme.

</details>

---------------

_Making `fn` a built-in will help make writing components feel more cohesive and well supported, as folks will not need to cobble together many imported values_

----------------


## Detailed design

This change would affect strict-mode only. This is so that today's existing code that imports `fn` from `@ember/helper` will still work due to how values defined locally in scope override globals.

The behavior of `fn` would be the same as it is today, but defined by default in the `glimmer-vm`.

`fn` will be a keyword, and for backwards compatibility, this will require that keywords, in strict mode, be overrideable by the strict-mode scope bag.

## How we teach this

Once implemented, the guides, if they say anything about gjs/gts/`<template>` and `fn` by the time this would be implemented, would only remove the import.

The guides should also detail which functions are built in to the framework and, therefore, do not need to be imported.

## Drawbacks

People may not know where `fn` is defined.
- counterpoint: do they need to?, we are defining a lanugage, trying to make it ergonomic.

## Alternatives

- Use a prelude
    - preludes were mentioned during the initial exploration of strict-mode templates, and were decided against, because addons would not be able to assume a prelude exists, as apps could define their own, and this sort of re-introduces the app-tree-merging behavior that we've been trying to get away from. 

## Unresolved questions

- What happens if we want to remove a keyword? (like `mut`)
  - same as today, we only need to commit to a major to remove the keyword in and then do it - providing ample deprecation time, ending with the final removal.


---

---
stage: accepted
start-date: 2023-12-22T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - framework
  - learning
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/0999
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Make `(hash)` a built in helper 

## Summary

Today, when using gjs/gts/`<template>`, in order to make objects in a template, folks _must import_ the `(hash)` helper.
Because creating objects is fairly commonplace, this is an annoyance for developers, especially as almost every other language has object literal syntax.

This RFC proposes that `(hash)` be built in to `glimmer-vm` and not require importing.

## Motivation

Arrays and Objects are not only very common to create, they are essential tools when yielding data out of components.

There is alternate motivation to implement _literals_ for arrays and objects, but that is a bigger can of worms for another time.

## Detailed design

This change would affect strict-mode only. This is so that today's existing code that imports `hash` from `@ember/helper` will still work due to how values defined locally in scope override globals.

The behavior of `hash` would be the same as it is today, but defined by default in the `glimmer-vm`.

Being built in can give folks confidence that each property in the hash is individually reactive.

## How we teach this

Once implemented, the guides, if they say anything about gjs/gts/`<template>` and `hash` by the time this would be implemented, would only remove the import.

The guides should also detail which functions are built in to the framework and, therefore, do not need to be imported.

## Drawbacks

People may not know where `hash` is defined.
- counterpoint: do they need to?

## Alternatives

n/a

## Unresolved questions

n/a


---

---
stage: accepted
start-date: 2023-12-22T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - framework
  - learning
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1000
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Make `(array)` a built in helper 

## Summary

Today, when using gjs/gts/`<template>`, in order make arrays in templates, folks _must import_ the `(array)` helper.
Because creating arrays is fairly commonplace, this is an annoyance for developers, in part, due to how almost every other language has array literal syntax.

This RFC proposes that `(array)` be built in to `glimmer-vm` and not require importing.

## Motivation

Arrays and Objects are not only very common to create, they are essential tools when yielding data out of components.

There is alternate motivation to implement _literals_ for arrays and objects, but that is a bigger can of worms for another time.

## Detailed design

This change would affect strict-mode only. This is so that today's existing code that imports `array` from `@ember/helper` will still work due to how values defined locally in scope override globals.

The behavior of `array` would be the same as it is today, but defined by default in the `glimmer-vm`.

Being built in can give folks confidence that each element in the array is individually reactive.

## How we teach this

Once implemented, the guides, if they say anything about gjs/gts/`<template>` and `array` by the time this would be implemented, would only remove the import.

The guides should also detail which functions are built in to the framework and, therefore, do not need to be imported.

## Drawbacks

People may not know where `array` is defined.
- counterpoint: do they need to?

## Alternatives

n/a

## Unresolved questions

n/a


---

---
stage: recommended
start-date: 2023-12-26T00:00:00.000Z
release-date:
release-versions:
  ember-source: 6.3.0
teams:
  - framework
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1001'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1013'
  released: 'https://github.com/emberjs/rfcs/pull/1061'
  recommended: 'https://github.com/emberjs/rfcs/pull/1089'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate named `inject` export from `@ember/service`

## Summary

As of [`ember-source@4.1`](https://blog.emberjs.com/ember-4-1-released) (and [RFC#752](https://github.com/emberjs/rfcs/pull/752)),  `inject` is an old alias that's no longer needed

## Motivation

`import { service } from '@ember/service'`
makes more sense than 
`import { inject as service } from '@ember/service'`

This allows us to slim down our public API surface area to more of _what's needed_.


## Transition Path

Most folks can do a mass find and replace switch from `inject as service` to just `service`.

An example codemod could look [something like this](https://astexplorer.net/#/gist/119f88339ea024e7cde63c71f52ce216/4d128a1239cbb56e00a69d3f710d67c20ed0e431)
```js 
export const parser = 'ts'

export default function transformer(file, api) {
  const j = api.jscodeshift;
  
  const importNames = new Set();

  const root = j(file.source);
  
  // find things we want to get rid of
  root
    .find(j.ImportSpecifier)
    .forEach(path => {
      if (path.node.imported.name === 'inject') {
      	importNames.add(path.node.local.name);
      }
    })
  
  // now it's time to replace
  root.find(j.ClassProperty).forEach(path => {
    let node = path.node;
    
    let hasInject = hasDecorators(node, [...importNames.values()]);
    
    if (!hasInject) return;
    
    node.decorators = node.decorators.map(decorator => {
      let { expression } = decorator;
      
      if (expression.type === 'Identifier') {
        if (importNames.has(expression.name)) {
          decorator.expression = j.identifier('service');
        }
      }
      
      if (expression.type === 'CallExpression') {
        decorator.expression.callee = j.identifier('service');
      }
      
      return decorator;
    });
  });
  
  return root.toSource();
}

// Copied from: https://github.com/NullVoxPopuli/ember-concurrency-codemods/tree/main
function firstMatchingDecorator(node, named = []) {
  if (!node.decorators) return;

  return node.decorators.find((decorator) => {
    let { expression } = decorator;

    switch (expression.type) {
      case 'MethodDefinition': {
      }
      case 'CallExpression': {
        let { callee } = expression;

        switch (callee.type) {
          case 'Identifier':
            return named.includes(callee.name);
          case 'MemberExpression': {
            let { object } = callee;

            return named.includes(object.callee.name);
          }
        }
      }
      case 'Identifier':
        return named.includes(expression.name);
    }
  });
}

function hasDecorators(node, named = []) {
  return Boolean(firstMatchingDecorator(node, named));
}
```

<details><summary>The test scenarios</summary>

```ts 
import { inject } from '@ember/service';
import { inject as service } from '@ember/service';
// import Service from '@ember/service';
import BaseService from '@ember/service';
import { inject as serviceDecorator } from '@ember/service';
import { inject as x } from '@ember/service';
// import { service } from '@ember/service';
import { service as y } from '@ember/service';
// import Service, { inject, service } from '@ember/service';
import Service, { inject as s } from '@ember/service';


export default class Demo extends Service {
  
}

export default class Demo2 extends BaseService {
  // simple
  @inject router;
  @service router1;
  @x router2;
  @y router3;
  @serviceDecorator router4;
  @inject('router') router41;
  
  // TS-only
  @inject declare router5: Type;
  @inject('router') declare router51: Type;
  @service declare router6: Type;
  @x declare router7: Type;
  @y declare router8: Type;
  @serviceDecorator declare router9: Type;
}
```

</detailS>


## How We Teach This

The docs / guides already use the new import path.

## Drawbacks

As with any deprecation, we introduce an upgrade cliff for addons that are updated infrequently, and consequently their consuming apps.
As a mitigation, we could, for v1 addons, add an additional transform to ember-cli-babel to automatically upgrade `inject` from `@ember/service` to `service`.
This does narrow the range a bit, as `service` was introduced in ember-source@4.1, so libraries could not support from 3.28 to 6 (or whichever major ends up removing the `inject`) without adding `@embroider/macros` to conditionally import `inject` or `service` based on the consumer's ember-source version.

## Alternatives

do nothing, the cost of an export alias is:
- a few extra bytes
- mental gymnastics for teaching
- "another case to cover" for tooling

add a lint against `inject`
- all the downsides of the above ("do nothing") may still be present

## Unresolved questions

n/a


---

---
stage: ready-for-release
start-date: 2024-01-22T00:00:00.000Z
release-date:
release-versions:
teams:
  - cli
  - data
  - framework
  - learning
  - steering
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1003'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1015'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate `import Ember from 'ember'; 

## Summary

This RFC proprosing deprecating all APIs that have module-based replacements, as described in [RFC #176](https://rfcs.emberjs.com/id/0176-javascript-module-api) as well as other `Ember.*` apis that are no longer needed.

## Motivation

The `import Ember from 'ember';` set of APIs is implementn as a barrel file, and properly optimizing barrel files [is a lot of work, requiring integration with build time tools](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js).

**If anyone one dependency in an app's dependency tree does `import ... from 'ember'`, every feature of the framework is shipped to your users, without any ability for you to optimize.**

By removing this set of exports, we have an opportunity to shrink some apps (as some APIs are not used), improving the load performance of ember apps -- and we removing all of these gives us a chance to have a better grasp of what we can get rid of permananently.

Many of these APIs already have alternatives, and those will be called out explicitly in the _Transition Path_ below.

## Transition Path

This list is semi-exhaustive, in that it covers _every_ export from 'ember', but may not exhaustivily provide alternatives.

Throughout the rest of this RFC, the following key will be used:
- 🌐 to mean "this is public API"
- 🔒 to mean "this is private API"
- 🧷 to mean "this is protected API"
- 🫣 to mean "no declared access"

### Testing utilities

APIs for wiring up a test framework (e.g. QUnit, _etc_)

|   | API | Usage: EmberObserver | -- | 
| - | --- | ----- | -- |
|🌐 | `Ember.Test` | [A good few](https://emberobserver.com/code-search?codeQuery=Ember.Test&sort=updated&sortAscending=false) | |
|🌐 | `Ember.Test.Adapter` | [`ember-cli-fastboot` and `@ember/test-helpers`](https://emberobserver.com/code-search?codeQuery=Ember.Test.Adapter&sort=updated&sortAscending=false) | currently available at [`@ember/test`](https://api.emberjs.com/ember/5.6/modules/@ember%2Ftest) |
|🌐 | `Ember.Test.QUnitAdapter` | [`ember-cli-fastboot`](https://emberobserver.com/code-search?codeQuery=Ember.Test.QUnitAdapter&sort=updated&sortAscending=false) | |
|🌐 | `Ember.setupForTesting` | [`ember-cli-fastboot`](https://emberobserver.com/code-search?codeQuery=Ember.setupForTesting&sort=updated&sortAscending=false) | | 

If needed, these will need to be moved to a module such as `@ember/test`.

### A way to communicate with the ember-inspector

The inspector will be hit especially hard by the removal of these APIs.

A good few already have available imports though.

|   | API | import |
| - | --- | ------ |
|🔒| `Ember.meta` | `import { meta } from '@ember/-internals/meta';` |
|🌐| `Ember.VERSION` | `import { VERSION } from '@ember/version';` |
|🔒| `Ember._captureRenderTree` | `import { captureRenderTree } from '@ember/debug';` |
|🔒| `Ember.instrument` | `import { instrument } from '@ember/instrumentation';` |
|🔒| `Ember.subscribe` | `import { subscribe } from '@ember/instrumentation';` |
|🔒| `Ember.Instrumentation.*` | `import { * } from '@ember/instrumentation';`  |
|🫣| `Ember.ViewUtils` | `import * as viewUtils from '@ember/-internals/views';`[^view-utils]  |
|🔒| `Ember.ViewUtils.getChildViews` | `import { getChildViews } from '@ember/-internals/views';` |
|🫣| `Ember.ViewUtils.getElementView` | `import { getElementView } from '@ember/-internals/views';` |
|🔒| `Ember.ViewUtils.getRootViews` | `import { getRootViews } from '@ember/-internals/views';` |
|🔒| `Ember.ViewUtils.getViewBounds` | `import { getViewBounds } from '@ember/-internals/views';` |
|🔒| `Ember.ViewUtils.getViewBoundingClientRect` | `import { getViewBoundingClientRect } from '@ember/-internals/views';` |
|🔒| `Ember.ViewUtils.getViewClientRects` | `import { getViewClientRects } from '@ember/-internals/views';` |
|🔒| `Ember.ViewUtils.getViewElement`  | `import { getViewElement } from '@ember/-internals/views';` |
|🫣| `Ember.ViewUtils.isSimpleClick` | `import { isSimpleClick } from '@ember/-internals/views';` |
|🫣| `Ember.ViewUtils.isSerializationFirstNode` | `import { isSerializationFirstNode } from '@ember/-internals/glimmer';` |

[^view-utils]: Not all of these exports are used for `ViewUtils`.


Perhaps we can have folks add this to their apps:
```js
import { macroCondition, isDevelopingApp, importSync } from '@embroider/macros';

if (macroCondition(isDevelopingApp())) {
  // maybe this is side-effecting and installs 
  // some functions on `globalThis` that the inspector could call
  // since the inspector can't import modules from a built app.
  importSync('@ember/inspector-support');
}
```

### No replacements.

Applies to both the value and type exports (if applicable). All of these will not be re-exported from other `@ember/*` packages, but the following tables will show addon usage[^why-addon-usage] in the ecosystem and potential paths forward for library authors.

[^why-addon-usage]: Addons are notorious for doing things they shouldn't, accessing private APIs, doing crazy things so users don't have to, working around ecosystem and broader ecosystem problems etc. It's also expected that addon authors will be able to handle migrations more quickly than app devs.


|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🫣 | `Ember._getPath` | [None](https://emberobserver.com/code-search?codeQuery=Ember._getPath) | n/a |
|🫣 | `Ember.isNamespace` | [None](https://emberobserver.com/code-search?codeQuery=Ember.isNamespace) | n/a |
|🫣 | `Ember.toString` | [None](https://emberobserver.com/code-search?codeQuery=Ember.toString) | n/a |
|🔒 | `Ember.Container` | [Many, but old or docs](https://emberobserver.com/code-search?codeQuery=Ember.Container) | n/a |
|🔒 | `Ember.Registry` | [Many, but old or docs](https://emberobserver.com/code-search?codeQuery=Ember.Registry) | n/a |

Internal decorator utils
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🫣 | `Ember._descriptor` | EmberObserver: [None](https://emberobserver.com/code-search?codeQuery=Ember._descriptor) | n/a |
|🔒 | `Ember._setClassicDecorator` | EmberObserver: [ember-concurrency](https://emberobserver.com/code-search?codeQuery=Ember._setClassicDecorator) | n/a |

Reactivity
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🔒 | `Ember.beginPropertyChanges` | [ember-m3 + old addons](https://emberobserver.com/code-search?codeQuery=Ember.beginPropertyChanges) | n/a |
|🔒 | `Ember.endPropertyChanges` | [ember-m3 + old addons](https://emberobserver.com/code-search?codeQuery=Ember.endPropertyChanges) | n/a |
|🔒 | `Ember.changeProperties` | [None](https://emberobserver.com/code-search?codeQuery=Ember.changeProperties) | n/a |

Observable 
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🌐 | `Ember.hasListeners` | [None](https://emberobserver.com/code-search?codeQuery=Ember.hasListeners) | n/a |

Mixins
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🔒 | `Ember._ContainerProxyMixin` | [mostly old addons](https://emberobserver.com/code-search?codeQuery=Ember._ContainerProxyMixin&sort=updated&sortAscending=false). Includes `ember-decorators`, `ember-data-has-many-query`, `ember-graphql-adapter`, `ember-cli-fastboot` (in tests / test-support) | n/a |
|🔒 | `Ember._RegistryProxyMixin` | [mostly old addons](https://emberobserver.com/code-search?codeQuery=Ember._RegistryProxyMixin&sort=updated&sortAscending=false). Includes `ember-decorators`, `ember-data-has-many-query`, `ember-graphql-adapter`, `ember-cli-fastboot` (in tests / test-support) | n/a |
|🔒 | `Ember._ProxyMixin` | [`ember-bootstrap-components`, 8 years ago](https://emberobserver.com/code-search?codeQuery=Ember._ProxyMixin&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.ActionHandler` | ['ember-error-tracker' + old addons](https://emberobserver.com/code-search?codeQuery=Ember.ActionHandler&sort=updated&sortAscending=false). Many usages include pre-modules Ember usage. | n/a |
|🔒 | `Ember.Comparable` | [ember-data-model-fragments](https://emberobserver.com/code-search?codeQuery=Ember.Comparable&sort=updated&sortAscending=false) | n/a |


Utility
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🫣 | `Ember.lookup` | [old addons, > 6 years](https://emberobserver.com/code-search?codeQuery=Ember.lookup&sort=updated&sortAscending=false) | Use `getOwner(...).lookup` from [`@ember/owner`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fowner/getOwner) |
|🌐 | `Ember.libraries` | [Many usages, mostly ember-data and related](https://emberobserver.com/code-search?codeQuery=Ember.libraries&sort=updated&sortAscending=false) | This isn't a behavior that Ember needs to provide, nor should it be library authors' responsibilty to register themselves with a library listing system. App authors could choose to use any webpack or other build plugin that collections this information, such as [webpack-node-modules-list](https://github.com/ubilabs/webpack-node-modules-list) or [unplugin-info](https://github.com/yjl9903/unplugin-info). | 
|🫣 | `Ember._Cache` | [None](https://emberobserver.com/code-search?codeQuery=Ember._Cache&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.GUID_KEY` | [`ember-data-save-relationships`, 6 years ago](https://emberobserver.com/code-search?codeQuery=Ember.GUID_KEY&sort=updated&sortAscending=false) | n/a |
| 🔒 | `Ember.canInvoke` | [@summit-electric-supply](https://emberobserver.com/code-search?codeQuery=Ember.canInvoke&sort=updated&sortAscending=false) | use [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining), e.g.: `this.foo?.method?.()` |
|🔒 | `Ember.generateGuid` | [`ember-flexberry + old addons](https://emberobserver.com/code-search?codeQuery=Ember.generateGuid&sort=updated&sortAscending=false) | Use [`guidFor`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fobject%2Finternals/guidFor) or [`uuid`](https://www.npmjs.com/package/uuid) or the browser-native [`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) |
|🌐 | `Ember.uuid` | [3 recent addons](https://emberobserver.com/code-search?codeQuery=Ember.uuid&sort=updated&sortAscending=false) | Use [`guidFor`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fobject%2Finternals/guidFor) or [`uuid`](https://www.npmjs.com/package/uuid) or the browser-native [`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) |
|🔒 | `Ember.wrap` | [None](https://emberobserver.com/code-search?codeQuery=Ember.wrap&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.inspect` | [old addons](https://emberobserver.com/code-search?codeQuery=Ember.inspect&sort=updated&sortAscending=false) | n/a | 
|🫣 | `Ember.Debug` | [old addons](https://emberobserver.com/code-search?codeQuery=Ember.Debug&sort=updated&sortAscending=false) | use [`@ember/debug`](https://api.emberjs.com/ember/5.6/modules/@ember%2Fdebug) | 
|🫣 | `Ember.cacheFor` | [old addons](https://emberobserver.com/code-search?codeQuery=Ember.cacheFor&sort=updated&sortAscending=false) | potentially [`@glimmer/tracking/primitives/cache`](https://api.emberjs.com/ember/5.6/modules/@glimmer%2Ftracking%2Fprimitives%2Fcache) |
|🌐 | `Ember.ComputedProperty` | [aside from docs, old addons](https://emberobserver.com/code-search?codeQuery=Ember.ComputedProperty&sort=updated&sortAscending=false). Most recent usage is 3 years ago in `ember-cli-furnance-validation` | n/a |
|🫣 | `Ember.RouterDSL` | [old addons](https://emberobserver.com/code-search?codeQuery=Ember.RouterDSL&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.controllerFor` | [None](https://emberobserver.com/code-search?codeQuery=Ember.controllerFor&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.generateController` | [bitbird-core-ember-routing, 5 years ago](https://emberobserver.com/code-search?codeQuery=Ember.generateController&sort=updated&sortAscending=false) | n/a |
|🔒 | `Ember.generateControllerFactory` | [None](https://emberobserver.com/code-search?codeQuery=Ember.generateControllerFactory&sort=updated&sortAscending=false) | n/a |

|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🌐 | `Ember.VERSION` | EmberObserver: [Not many usages](https://emberobserver.com/code-search?codeQuery=Ember.VERSION&sort=updated&sortAscending=false). | This has the ember version in it, but it could be converted to a virtual module to import from somewhere, such as `@ember/version` |
|🔒 | `Ember._Backburner` | EmberObserver: [None](https://emberobserver.com/code-search?codeQuery=Ember._Backburner&sort=updated&sortAscending=false) | n/a |
|🌐 | `Ember.inject` | EmberObserver: [Many, all using classic classes](https://emberobserver.com/code-search?codeQuery=Ember.inject&sort=updated&sortAscending=false). A lot of results are also classic-class docs. | Use [`@service`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fservice/service) |

Any projects using these are already not safe for embroider and won't work with Vite
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🫣 | `Ember.__loader` | [159 addons. Some experimental. Most from `@ascua`](https://emberobserver.com/code-search?codeQuery=Ember.__loader&sort=updated&sortAscending=false) | n/a |
| 🫣 | `Ember.__loader.require` | [same as `Ember.__loader`](https://emberobserver.com/code-search?codeQuery=Ember.__loader.require&sort=updated&sortAscending=false) | n/a |
| 🫣 | `Ember.__loader.define` | [5 addons, ~2 recent](https://emberobserver.com/code-search?codeQuery=Ember.__loader.define&sort=updated&sortAscending=false). One is `ember-cli-fastboot` (tests, test-support). | n/a |
|🫣 | `Ember.__loader.registry` | [13 addons, ~5 recent](https://emberobserver.com/code-search?codeQuery=Ember.__loader.registry&sort=updated&sortAscending=false). One is `ember-cli-fastboot` (tests, test-support). | n/a |
|🔒 | `Ember.BOOTED` | [None](https://emberobserver.com/code-search?codeQuery=Ember.BOOTED&sort=updated&sortAscending=false) | n/a |


Replaced by [RFC #931][RFC-931].
For scenarios where folks would like to compile templates at runtime, see [RFC #931][RFC-931] or the code of [ember-repl](https://www.npmjs.com/package/ember-repl).
|   | API | Usage: EmberObserver | Migration |
| - | --- | ----- | --------- |
|🔒 | `Ember.TEMPLATES` | [`ember-resolver`](https://emberobserver.com/code-search?codeQuery=Ember.TEMPLATES&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.HTMLBars` | [Lots of usage (encompasses the below APIs)](https://emberobserver.com/code-search?codeQuery=Ember.HTMLBars&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.HTMLBars.DOMHelper` | [`ember-cli-fastboot`](https://emberobserver.com/code-search?codeQuery=Ember.HTMLBars.DOMHelper&sort=updated&sortAscending=false) uses `protocolForURL`, `parseHTML` | n/a |
|🫣 | `Ember.HTMLBars.template` | [`ember-cli-fastboot`](https://emberobserver.com/code-search?codeQuery=Ember.HTMLBars.template&sort=updated&sortAscending=false) (and `ember-ast-hot-load`) | n/a |
|🫣 | `Ember.HTMLBars.compile` | [old addons](https://emberobserver.com/code-search?codeQuery=Ember.HTMLBars.compile&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.HTMLBars.precomple` | [`ember-ast-hot-load`](https://emberobserver.com/code-search?codeQuery=Ember.HTMLBars.precompile&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.Handlebars` | [174 addons, mostly @ascua](https://emberobserver.com/code-search?codeQuery=Ember.Handlebars&sort=updated&sortAscending=false) and also a lot of mentions in docs. | n/a |
|🫣 | `Ember.Handlebars.template` | [None](https://emberobserver.com/code-search?codeQuery=Ember.Handlebars.template&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.Handlebars.Utils.escapeExpression` | [100 addons, mostly @ascua](https://emberobserver.com/code-search?codeQuery=Ember.Handlebars.Utils.escapeExpression&sort=updated&sortAscending=false) | Removed in [ember.js PR#20360](https://github.com/emberjs/ember.js/pull/20360) as it is not public API. |
|🫣 | `Ember.Handlebars.compile` | [`ember-cli-fastboot` and `ember-collection`](https://emberobserver.com/code-search?codeQuery=Ember.Handlebars.compile&sort=updated&sortAscending=false) | n/a |
|🫣 | `Ember.Handlebars.precomple` | [None](https://emberobserver.com/code-search?codeQuery=Ember.Handlebars.precompile&sort=updated&sortAscending=false) | n/a |


Other APIs
- 🫣 `Ember.testing`  
  Instead, use

  ```js
  import { macroCondition, isTesting } from '@embroider/macros';

  // ...

  if (macroCondition(isTesting())) {
    // test only code here
  }
  ```

- 🌐 `Ember.onerror`
  Instead you may be able to use an event listener for the `error` event on window.
  ```js
  window.addEventListener('error', /* ... event handler ... */);
  ```

  For promise rejections, you'll want to use the `unhandledrejection` event.
  ```js
  window.addEventListener('unhandledrejection', /* ... event handler ... */);
  ```


  If you really need the original behavior:
  ```js 
  import { getOnerror, setOnerror } from '@ember/-internals/error-handling';
  ```
  But this should not be needed.


[RFC-931]: https://github.com/emberjs/rfcs/pull/931



#### Imports Available

Most of this is covered in [RFC #176](https://rfcs.emberjs.com/id/0176-javascript-module-api)

Unless otherwise stated, there will not be usage-based decision on these, as they all exist under available imports today.

|   | `Ember.` API | Use this instead | 
| - | ------------ | ---------------- |
|🌐 | `Ember.FEATURES` | `import { isEnabled, FEATURES } from '@ember/canary-features';` | 
|🌐 | `Ember._setComponentManager` | `import { setComponentManager } from '@ember/component';` | 
|🌐 | `Ember._componentManagerCapabilities` | `import { capabilities } from '@ember/component';` | 
|🌐 | `Ember._modifierManagerCapabilities` | `import { capabilities } from '@ember/modifier';` | 
|🌐 | `Ember._createCache` | `import { createCache } from '@glimmer/tracking/primitives/cache';` [RFC #615][RFC-615] | 
|🌐 | `Ember._cacheGetValue` | `import { getValue } from '@glimmer/tracking/primitives/cache';` [RFC #615][RFC-615] | 
|🌐 | `Ember._cacheIsConst` | `import { isConst } from '@glimmer/tracking/primitives/cache';` [RFC #615][RFC-615] | 
|🌐 | `Ember._tracked` | `import { tracked } from '@glimmer/tracking';` | 
|🌐 | `Ember.RSVP` | `import RSVP from 'rsvp';` | 
|🌐 | `Ember.guidFor` | `import { guidFor } from '@ember/object/internals';` | 
|🌐 | `Ember.getOwner` | `import { getOwner } from '@ember/owner';` | 
|🌐 | `Ember.setOwner` | `import { setOwner } from '@ember/owner';` |
|🌐 | `Ember.onLoad` | `import { onLoad } from '@ember/application';` | 
|🌐 | `Ember.runLoadHooks` | `import { runLoadHooks } from '@ember/application';` | 
|🌐 | `Ember.Application` | `import Application from '@ember/application';` | 
|🌐 | `Ember.ApplicationInstance` | `import ApplicationInstance from '@ember/application/instance';` | 
|🌐 | `Ember.Namespace` | `import Namespace from '@ember/application/namespace';` | 
|🌐 | `Ember.A` | `import { A }  from '@ember/array';` | 
|🌐 | `Ember.Array` | `import Array  from '@ember/array';` |
|🌐 | `Ember.NativeArray` | `import { NativeArray }  from '@ember/array';` |
|🌐 | `Ember.isArray` | `import { isArray }  from '@ember/array';` |
|🔒 | `Ember.makeArray` | `import { makeArray }  from '@ember/array';` |
|🌐 | `Ember.MutableArray` | `import MutableArray  from '@ember/array/mutable';` |
|🌐 | `Ember.ArrayProxy` | `import ArrayProxy  from '@ember/array/proxy';` |
|🌐 | `Ember._Input` | `import { Input }  from '@ember/component';` |
|🌐 | `Ember.Component` | `import Component  from '@ember/component';` |
|🌐 | `Ember.Helper` | `import Helper  from '@ember/component/helper';` |
|🌐 | `Ember.Controller` | `import Controller  from '@ember/controller';` |
|🔒 | `Ember.ControllerMixin` | `import { ControllerMixin } from '@ember/controller';` |
|🌐 | `Ember.assert` | `import { assert } from '@ember/debug';` |
|🌐 | `Ember.warn` | `import { warn } from '@ember/debug';` |
|🌐 | `Ember.debug` | `import { debug } from '@ember/debug';` |
|🌐 | `Ember.deprecate` | `import { deprecate } from '@ember/debug';` |
|🫣 | `Ember.deprecateFunc` | `import { deprecateFunc } from '@ember/debug';` |
|🌐 | `Ember.runInDebug` | `import { runInDebug } from '@ember/debug';` |
|🌐 | `Ember.Debug.registerDeprecationHandler` | `import { registerDeprecationHandler } from '@ember/debug';` |
|🌐 | `Ember.ContainerDebugAdapter` | `import ContainerDebugAdapter from '@ember/debug/container-debug-adapter';` |
|🌐 | `Ember.DataAdapter` | `import DataAdapter from '@ember/debug/data-adapter';` |
|🌐 | `Ember._assertDestroyablesDestroyed` | `import { assertDestroyablesDestroyed } from '@ember/destroyable';` | 
|🌐 | `Ember._associateDestroyableChild` | `import { associateDestroyableChild } from '@ember/destroyable';` | 
|🌐 | `Ember._enableDestroyableTracking` | `import { enableDestroyableTracking } from '@ember/destroyable';` |
|🌐 | `Ember._isDestroying` | `import { isDestroying } from '@ember/destroyable';` | 
|🌐 | `Ember._isDestroyed` | `import { isDestroyed } from '@ember/destroyable';` |
|🌐 | `Ember._registerDestructor` | `import { registerDestructor } from '@ember/destroyable';` |
|🌐 | `Ember._unregisterDestructor` | `import { unregisterDestructor } from '@ember/destroyable';` |
|🌐 | `Ember.destroy` | `import { destroy } from '@ember/destroyable';` |
|🌐 | `Ember.Engine` | `import Engine from '@ember/engine';` |
|🌐 | `Ember.EngineInstance` | `import Engine from '@ember/engine/instance';` |
|🔒 | `Ember.Enumerable` | `import Enumerable from '@ember/enumerable';` |
|🔒 | `Ember.MutableEnumerable` | `import MutableEnumerable from '@ember/enumerable/mutable';` |
|🌐 | `Ember.Object` | `import Object from '@ember/object';` |
|🌐 | `Ember._action` | `import { action } from '@ember/object';` |
|🌐 | `Ember.computed` | `import { computed } from '@ember/object';` |
|🌐 | `Ember.defineProperty` | `import { defineProperty } from '@ember/object';` |
|🌐 | `Ember.get` | `import { get } from '@ember/object';` |
|🌐 | `Ember.getProperties` | `import { getProperties } from '@ember/object';` |
|🌐 | `Ember.notifyPropertyChange` | `import { notifyPropertyChange } from '@ember/object';` |
|🌐 | `Ember.observer` | `import { observer } from '@ember/object';` |
|🌐 | `Ember.set` | `import { set } from '@ember/object';` |
|🌐 | `Ember.trySet` | `import { trySet } from '@ember/object';` |
|🌐 | `Ember.setProperties` | `import { setProperties } from '@ember/object';` |
|🌐 | `Ember._dependentKeyCompat` | `import { dependentKeyCompat } from '@ember/object/compat';` |
|🌐 | `Ember.expandProperties` | `import { expandProperties } from '@ember/object/computed';` |
|🌐 | `Ember.CoreObject` | `import EmberObject from '@ember/object';` |
|🌐 | `Ember.Evented` | `import Evented from '@ember/object/evented';` |
|🌐 | `Ember.on` | `import { on } from '@ember/object/evented';` |
|🌐 | `Ember.addListener` | `import { addListener } from '@ember/object/events';` |
|🌐 | `Ember.removeListener` | `import { removeListener } from '@ember/object/events';` |
|🌐 | `Ember.sendEvent` | `import { sendEvent } from '@ember/object/events';` |
|🌐 | `Ember.Mixin` | `import Mixin from '@ember/object/mixin';` |
|🔒 | `Ember.mixin` | `import { mixin } from '@ember/object/mixin';` |
|🌐 | `Ember.Observable` | `import Observable from '@ember/object/observable';` |
|🌐 |`Ember.addObserver` | `import { addObserver } from '@ember/object/observers';` |
|🌐 | `Ember.removeObserver` | `import { removeObserver } from '@ember/object/observers';` |
|🌐 | `Ember.PromiseProxyMixin` | `import EmberPromiseProxyMixin from '@ember/object/promise-proxy-mixin';` |
|🌐 | `Ember.ObjectProxy` | `import ObjectProxy from '@ember/object/proxy';` |
|🧷 | `Ember.HistoryLocation` | `import HistoryLocation from '@ember/routing/history-location';` |
|🧷 | `Ember.HashLocation` | `import HashLocation from '@ember/routing/hash-location';` |
|🧷 | `Ember.NoneLocation` | `import NoneLocation from '@ember/routing/none-location';` |
|🌐 | `Ember.Route` | `import Route from '@ember/routing/route';` |
|🌐 | `Ember.run` | `import { run } from '@ember/runloop';` |
|🌐 | `Ember.Service` | `import Service from '@ember/service';` |
|🌐 | `Ember.compare` | `import { compare } from '@ember/utils';` |
|🌐 | `Ember.isBlank` | `import { isBlank } from '@ember/utils';` |
|🌐 | `Ember.isEmpty` | `import { isEmpty } from '@ember/utils';` |
|🌐 | `Ember.isEqual` | `import { isEqual } from '@ember/utils';` |
|🌐 | `Ember.isPresent` | `import { isPresent } from '@ember/utils';` |
|🌐 | `Ember.typeOf` | `import { typeOf } from '@ember/utils';` |
|🌐 | `Ember._getComponentTemplate` | `import { getComponentTemplate } from '@ember/component';` | 
|🌐 | `Ember._setComponentTemplate` | `import { setComponentTemplate } from '@ember/component';` | 
|🌐 | `Ember._helperManagerCapabilities` | `import { capabilities } from '@ember/helper';` | 
|🌐 | `Ember._setHelperManager` | `import { setHelperManager } from '@ember/helper';` | 
|🌐 | `Ember._setModifierManager` | `import { setModifierManager } from '@ember/modifier';` | 
|🌐 | `Ember._templateOnlyComponent` | `import templateOnly from '@ember/component/template-only';` | 
|🌐 | `Ember._invokeHelper` | `import { invokeHelper } from '@ember/helper';` | 
|🌐 | `Ember._hash` | `import { hash } from '@ember/helper';` | 
|🌐 | `Ember._array` | `import { array } from '@ember/helper';` | 
|🌐 | `Ember._concat` | `import { concat } from '@ember/helper';` | 
|🌐 | `Ember._get` | `import { get } from '@ember/helper';` | 
|🌐 | `Ember._on` | `import { on } from '@ember/modifier';` | 
|🌐 | `Ember._fn` | `import { fn } from '@ember/helper';` | 
|🌐 | `Ember.ENV` | `import MyEnv from '<my-app>/config/environment';` (for apps) or `owner.resolveRegistration('config:environment')` for addons|


[RFC-615]: https://rfcs.emberjs.com/id/0615-autotracking-memoization

## Implementation Plan 

These can happen in any order

- Add deprecations to each `Ember.*` access
- Add the [Testing utilities](#testing-utilities) to `@ember/test`, if needed.
- Add an `@ember/version` package to `ember-source`
- Add re-exports of private APIs, `ComputedProperty`, and `_setClassicDecorator` 
    These will still be deprecated on `Ember.`, and will be deprecated themselves as we progress through deprecating Ember Classic.
- Update ember-inspector to use imports for the internals and instrumentation APIs
- Add `@ember/inspector-support` to `ember-source` to manage things like `LIBRARIES`. 
    ```js
    import { libraries } from '@ember/inspector-support';

    libraries.add('ember-data', '5.3.1');
    // and/or
    libraries.addAll(depInfoFromPlugin);
    ```
- Add deprecation guide entries for each API

## How We Teach This

While `@ember/-internals` were created to be internal, introducing new names for them would create churn and would make it harder for addon authors to support a wide range of versions. The internals paths all work today on supported releases, so dropping the deprecated usage doesn't reduce your support matrix, whereas using a newly-introduced import path would. 

_All `@ember/-internals(/*)?` APIs mentioned above are now public API, and to remove any of those APIs, they will need to go through the deprecation process._

------------

The guides already use the modern imports where available.

There is a place that needs updating, around advanced debugging, where folks configure Backburner to be in debug mode.
- https://guides.emberjs.com/release/applications/run-loop/#toc_where-can-i-find-more-information
- https://guides.emberjs.com/release/configuring-ember/debugging/#toc_errors-within-emberrunlater-backburner
  - Access to backburner here isn't relevant though because it's accessed from the `run` import from `@ember/runloop`

When using embroider and `staticEmberSource: true`, the benefits of not having this file can be realized in apps (as long as the app and all consumed addons do not import from 'ember')

Available Codemods

- https://github.com/ember-codemods/ember-modules-codemod (from the work of RFC 176)

## Deprecation Guide

- Separate ids for each API so that folks don't have to scroll too far to get to their migration path (if a migration path exists).
- Mostly using the above tables, but without the `Usage: EmberObserver` column.

## Drawbacks

n/a, to be more module-friendly, we must get rid of the `'ember'` import. 

## Alternatives

Don't use `@ember/-internals` and create new public APIs for all of the things currently under `@ember/-internals`. This would create a lot of churn in the ecosystem, when we want to get rid of some of these APIs anyway.

## Unresolved questions

n/a

Q: Do our instrumentation and internals sub-packages have any SemVer guarantees? Or are we allowed to "do what we need to" and not care about _public-facing_ SemVer?
A: If something is privately but heavily used, we will try to deprecate before removing the API and make sure the deprecation makes it in to an LTS before that removal.


---

---
stage: recommended
start-date: 2024-02-13T00:00:00.000Z
release-date: 2024-06-07T00:00:00.000Z
release-versions:
  ember-source: 5.9.0
teams:
  - cli
  - data
  - framework
  - learning
  - steering
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1006'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1011'
  released: 'https://github.com/emberjs/rfcs/pull/1022'
  recommended: 'https://github.com/emberjs/rfcs/pull/1036'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate `(action)` template helper and `{{action}}` modifier. 

## Summary

The `(action)` template helper and `{{action}}` modifier was common pre-Octane. Now that we have native classes and the `{{on}}` modifier, we no longer need to use `(action)` or `{{action}}`

## Motivation

Remove legacy code with confusing semantics.

This is a part of _[Deprecating Ember Classic (pre-Octane)](https://github.com/emberjs/rfcs/issues/832)_.

## Transition Path

This was written in the [Octave vs Classic cheatsheet](https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/#component-properties__ddau)

<details><summary>that content here</summary>

### Before (pre-Octane)

```js
// parent-component.js
import Component from '@ember/component';

export default Component.extend({
  count: 0
});

```
```hbs
{{!-- parent-component.hbs --}}
{{child-component count=count}}
Count: {{this.count}}

```
```js
// child-component.js
import Component from '@ember/component';

export default Component.extend({
  actions: {
    plusOne() {
      this.set('count', this.get('count') + 1);
    }
  }
});
```
```hbs
{{!-- child-component.hbs --}}
<button type="button" {{action "plusOne"}}>
  Click Me
</button>
```

### After (post-Octane)
```js
// parent-component.js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

export default class ParentComponent extends Component {
  @tracked count = 0;

  @action plusOne() {
    this.count++;
  }
}

```
```hbs
{{!-- parent-component.hbs --}}
<ChildComponent @plusOne={{this.plusOne}} />
Count: {{this.count}}

```
```hbs
{{!-- child-component.hbs --}}
<button type="button" {{on "click" @plusOne}}>
  Click Me
</button>

```

</details>

But what we could put in the deprecation app:

### Scenario: `action` is passed a string

Before:
```hbs
<button type="button" {{action "plusOne"}}>
  Click Me
</button>
```

After

```hbs
<button type="button" {{on 'click' this.plusOne}}>
  Click Me
</button>
```
or, if `plusOne` is passed in as an argument 
```hbs
<button type="button" {{on 'click' @plusOne}}>
  Click Me
</button>
```

If the `plusOne` action is in an actions object, it needs to move out:

Before:
```js
import Component from '@glimmer/component';

export default class Demo extends Component {
    actions = {
        plusOne() {
           /* ... */ 
        }
    }
}
```
or
```js
import Component from '@ember/component';

export default class Demo extends Component {
    actions = {
        plusOne() {
           /* ... */ 
        }
    }
}
```
or
```js
import Component from '@ember/component';

export default Component.extend({
    actions: {
        plusOne() {
           /* ... */ 
        }
    }
})
```

After:
```js
import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class Demo extends Component {
    @action
    plusOne() {
       /* ... */ 
    }
}
```

Note that `@action` is completely different from `(action)` or `{{action}}` (and is partly a motivator for deprecating `(action)` and `{{action}}`, to reduce ambiguity).

`@action` is binds the `this` on the method to the instance of the class. 

### Scenario: `action` is passed a function reference

Before:
```hbs
<SomeComponent @update={{action this.plusOne}} />
```

After

```hbs
<SomeComponent @update={{this.plusOne}} />
```

### Scenario: `action` is passed parameters

Before:
```hbs
<SomeComponent @update={{action this.plus 1}} />
```

After:
```hbs
<SomeComponent @update={{fn this.plus 1}} />
```

### Scenario: `action` is used with `mut` 

Before:
```hbs
<SomeComponent @update={{action (mut @value.property)}} />
```
After:
```js
// parent.js
import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class SomeComponent extends Component {
    @action
    handleUpdate(value) {
        this.args.property = value; 
    }
}
```
```hbs
{{! parent.hbs }}
<SomeComponent @update={{this.handleUpdate}} />
```

Related, [Combining function arguments with action functions](https://guides.emberjs.com/release/components/component-state-and-actions/#toc_combining-arguments-and-actions)

### Related: `send`

When removing `(action)` or `{{action}}` with a _string_ name, you'll also need to verify that there are no [`send`](https://api.emberjs.com/ember/5.6/classes/Component/methods/send?anchor=send) calls with that same string.

## How We Teach This

The guides already cover how to invoke functions in the modern way.

Remove: https://api.emberjs.com/ember/5.6/classes/Ember.Templates.helpers/methods/action?anchor=action

## Drawbacks

Older code will stop working once the deprecated code is removed.

## Alternatives

- adding an import so folks can keep using action in gjs.
  I don't think we should do this because we want to clean up antiquated patterns, rather than encourage their continued existence.

## Unresolved questions

- Could there be a codemod?
  _Potentially_ for action usage that references `this.properties`. For string actions, it's impossible.



---

---
stage: released
start-date: 2024-02-22T00:00:00.000Z
release-date:
release-versions:
  ember-cli: 6.3.0
teams:
  - cli
  - data
  - framework
  - learning
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1009'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1048'
  released: 'https://github.com/emberjs/rfcs/pull/1086'
project-link:
suite:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Move the deprecation workflow library to be installed in apps by default 

## Summary

Historically, folks have benefitted from [ember-cli-deprecation-workflow](https://github.com/mixonic/ember-cli-deprecation-workflow). This behavior is _so useful_, that it should be built in to folks applications by default.

## Motivation

Everyone needs a deprecation-workflow, and yet `ember-cli-deprecation-workflow` is not part of the default blueprint. 

This RFC proposes how we can ship deprecation workflow handling behavior in apps by default, which may give us a blessed path for better integrating with build time deprecations as well (though that is not the focus of this RFC).


## Detailed design


Have `ember-cli-deprecation-workflow` installed by default.

1. applications must have `@embroider/macros` installed by default.
2. the app.js or app.ts can conditionally import a file which sets up the deprecation workflow 
    ```diff app/app.js
      import Application from '@ember/application';
    + import { importSync, isDevelopingApp, macroCondition } from '@embroider/macros';

      import loadInitializers from 'ember-load-initializers';
      import Resolver from 'ember-resolver';
      import config from 'test-app/config/environment';

    + if (macroCondition(isDevelopingApp())) {
    +   importSync('./deprecation-workflow');
    + }

      export default class App extends Application {
        modulePrefix = config.modulePrefix;
        podModulePrefix = config.podModulePrefix;
        Resolver = Resolver;
      }

      loadInitializers(App, config.modulePrefix);
    ```
3. then in `app/deprecation-workflow.js` would use the already public API, 
    ```js
    import setupDeprecationWorkflow from 'ember-cli-deprecation-workflow';

    setupDeprecationWorkflow({
    /**
        false by default, but if a developer / team wants to be more aggressive about being proactive with
        handling their deprecations, this should be set to "true"
    */
      throwOnUnhandled: false,
      handlers: [
        /* ... handlers ... */
      ]
    });
    ```


This follows the README of [ember-cli-deprecation-workflow](https://github.com/ember-cli/ember-cli-deprecation-workflow?tab=readme-ov-file#getting-started).

    

## How we teach this

We'd want to add a new section in the guides under [`Application Concerns`](https://guides.emberjs.com/release/applications/) that talks about deprecations, how and how to work through those deprecations.

All of this content already exists using a similar strategy as above, here, [under "Configuring Ember"](https://guides.emberjs.com/release/configuring-ember/handling-deprecations/#toc_deprecation-workflow), and also walks through how to use `ember-cli-deprecation-workflow`. 

This README of [ember-cli-deprecation-workflow](https://github.com/ember-cli/ember-cli-deprecation-workflow?tab=readme-ov-file#getting-started) also explains, in detail, how to use this tool / workflow, and that content can be copied in to the guides.

## Drawbacks

For older projects, this could be _a_ migration. But as it is additional blueprint boilerplate, it is optional.

## Alternatives

There are only a few features of `ember-cli-deprecation-workflow` that we need to worry about:
- enabled or not - do we check deprecations at all, or ignore everything (current default)
- `throwOnUnhandled` - this is the most aggressive way to stay on top of your deprecations, but can be frustrating for folks who may not be willing to fix things in `node_modules` when new deprecations are introduced.
  
- `window.flushDeprecations()` - prints the list of deprecations encountered since the last page refresh
- Matchers - a fuzzier way to match deprecation messages rather than strictly matching on the deprecation id (sometimes deprecation messages have information about surrounding / relevant context, and these could be used to more fine-grainedly work through large-in-numbers deprecations)
- Logging / Ignoring / Throwing - when encountering a matched deprecation (whether by id or by regex, how should it be handled?)


However, folks can get a basic deprecation-handling workflow going in their apps without the above features,

1. applications must have `@embroider/macros` installed by default.
2. the app.js or app.ts can conditionally import a file which sets up the deprecation workflow 
    ```diff app/app.js
      import Application from '@ember/application';
    + import { importSync, isDevelopingApp, macroCondition } from '@embroider/macros';

      import loadInitializers from 'ember-load-initializers';
      import Resolver from 'ember-resolver';
      import config from 'test-app/config/environment';

    + if (macroCondition(isDevelopingApp())) {
    +   importSync('./deprecation-workflow');
    + }

      export default class App extends Application {
        modulePrefix = config.modulePrefix;
        podModulePrefix = config.podModulePrefix;
        Resolver = Resolver;
      }

      loadInitializers(App, config.modulePrefix);
    ```
    this conditional import is now easily customizable for folks in their apps, so they could opt to _not_ strip deprecation messages in production, and see where deprecated code is being hit by users (reported via Sentry, BugSnag, or some other reporting tool) -- which may be handy for folks who have a less-than-perfect test suite (tests being the only current way to automatically detect where deprecated code lives).
3. the `app/deprecation-workflow.js` would use the already public API, [`registerDeprecationHandler`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fdebug/registerDeprecationHandler)
    ```ts
    import { registerDeprecationHandler } from '@ember/debug';

    import config from '<app-moduleName>/config/environment';

    const SHOULD_THROW = config.environment !== 'production';
    const SILENCED_DEPRECATIONS: string[] = [
      // Add ids of deprecations you temporarily want to silence here.
    ];

    registerDeprecationHandler((message, options, next) => {
      if (!options) {
        console.error('Missing options');
        throw new Error(message);
      }

      if (SILENCED_DEPRECATIONS.includes(options.id)) {
        return;
      } else if (SHOULD_THROW) {
        throw new Error(message);
      }

      next(message, options);
    });
    ```


This simple implementation of deprecation workflow may work for libraries' test-apps, but it is not as robust as what `ember-cli-deprecation-workflow` offers, per the above-listed set of features that folks are used to.

To get all of those features from `ember-cli-deprecation-workflow`, we could define a function, `setupDeprecationWorkflow`, taken from the [Modernization PR on ember-cli-deprecation-workflow](https://github.com/mixonic/ember-cli-deprecation-workflow/pull/159), this is what the deprecation-workflow file could look like:

<details><summary>ember-cli-deprecation-workflow/index.js</summary>

```js
import { registerDeprecationHandler } from '@ember/debug';

const LOG_LIMIT = 100;

export default function setupDeprecationWorkflow(config) {
  self.deprecationWorkflow = self.deprecationWorkflow || {};
  self.deprecationWorkflow.deprecationLog = {
    messages: {},
  };

  registerDeprecationHandler((message, options, next) =>
    handleDeprecationWorkflow(config, message, options, next),
  );

  registerDeprecationHandler(deprecationCollector);

  self.deprecationWorkflow.flushDeprecations = flushDeprecations;
}

let preamble = `import setupDeprecationWorkflow from 'ember-cli-deprecation-workflow';

setupDeprecationWorkflow({
  workflow: [
`;

let postamble = `  ]
});`;

export function detectWorkflow(config, message, options) {
  if (!config || !config.workflow) {
    return;
  }

  let i, workflow, matcher, idMatcher;
  for (i = 0; i < config.workflow.length; i++) {
    workflow = config.workflow[i];
    matcher = workflow.matchMessage;
    idMatcher = workflow.matchId;

    if (typeof idMatcher === 'string' && options && idMatcher === options.id) {
      return workflow;
    } else if (typeof matcher === 'string' && matcher === message) {
      return workflow;
    } else if (matcher instanceof RegExp && matcher.exec(message)) {
      return workflow;
    }
  }
}

export function flushDeprecations() {
  let messages = self.deprecationWorkflow.deprecationLog.messages;
  let logs = [];

  for (let message in messages) {
    logs.push(messages[message]);
  }

  let deprecations = logs.join(',\n') + '\n';

  return preamble + deprecations + postamble;
}

export function handleDeprecationWorkflow(config, message, options, next) {
  let matchingWorkflow = detectWorkflow(config, message, options);
  if (!matchingWorkflow) {
    if (config && config.throwOnUnhandled) {
      throw new Error(message);
    } else {
      next(message, options);
    }
  } else {
    switch (matchingWorkflow.handler) {
      case 'silence':
        // no-op
        break;
      case 'log': {
        let key = (options && options.id) || message;

        if (!self.deprecationWorkflow.logCounts) {
          self.deprecationWorkflow.logCounts = {};
        }

        let count = self.deprecationWorkflow.logCounts[key] || 0;
        self.deprecationWorkflow.logCounts[key] = ++count;

        if (count <= LOG_LIMIT) {
          console.warn('DEPRECATION: ' + message);
          if (count === LOG_LIMIT) {
            console.warn(
              'To avoid console overflow, this deprecation will not be logged any more in this run.',
            );
          }
        }

        break;
      }
      case 'throw':
        throw new Error(message);
      default:
        next(message, options);
        break;
    }
  }
}

export function deprecationCollector(message, options, next) {
  let key = (options && options.id) || message;
  let matchKey = options && key === options.id ? 'matchId' : 'matchMessage';

  self.deprecationWorkflow.deprecationLog.messages[key] =
    '    { handler: "silence", ' + matchKey + ': ' + JSON.stringify(key) + ' }';

  next(message, options);
}
```

</details>

and at this point, we may as well build it into `ember` and not use an additional library at all, **and this is what the primary proposal of this RFC: build the deprecation workflow setup function in to ember**, so re-running through the setup steps:

1. applications must have `@embroider/macros` installed by default.
2. the app.js or app.ts can conditionally import a file which sets up the deprecation workflow 
    ```diff app/app.js
      import Application from '@ember/application';
    + import { importSync, isDevelopingApp, macroCondition } from '@embroider/macros';

      import loadInitializers from 'ember-load-initializers';
      import Resolver from 'ember-resolver';
      import config from 'test-app/config/environment';

    + if (macroCondition(isDevelopingApp())) {
    +   importSync('<app-moduleName>/deprecation-workflow');
    + }

      export default class App extends Application {
        modulePrefix = config.modulePrefix;
        podModulePrefix = config.podModulePrefix;
        Resolver = Resolver;
      }

      loadInitializers(App, config.modulePrefix);
    ```
    this conditional import is now easily customizable for folks in their apps, so they could opt to _not_ strip deprecation messages in production, and see where deprecated code is being hit by users (reported via Sentry, BugSnag, or some other reporting tool) -- which may be handy for folks who have a less-than-perfect test suite (tests being the only current way to automatically detect where deprecated code lives).
3. the `app/deprecation-workflow.js` would use the already public API, [`registerDeprecationHandler`](https://api.emberjs.com/ember/5.6/functions/@ember%2Fdebug/registerDeprecationHandler)
    ```js
    import { setupDeprecationWorkflow } from '@ember/debug';

    setupDeprecationWorkflow({
      throwOnUnhandled: true,
      handlers: [
        /* ... handlers ... */
      ]
    });
    ```



## Unresolved questions

n/a


---

---
stage: released
start-date: 2024-05-11T00:00:00.000Z
release-date:
release-versions:
  ember-data: 5.3.0
teams:
  - data
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1026'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1035'
  released: 'https://github.com/emberjs/rfcs/pull/1047'
project-link:
suite:
---

# EmberData | Deprecate Store extending EmberObject

## Summary

This RFC deprecates the Store extending from EmberObject. All EmberObject specific
APIs included.

## Motivation

There are two motivations:

First, extending EmberObject is vestigial. The Store makes no use of any EmberObject API,
not even for use with Ember's container or service injection.

Second, in order to support any Ember version, support any non-Ember framework, and support
EmberData running in non-browser environments we want to remove unnecessary coupling to the Ember framework.

## Detailed design

Instead of deprecating every EmberObject method, we will feature flag the Store extending
EmberObject at the module level. This ensures the deprecation only prints once, and that
once resolved the Store will no longer extend thereby making it feasible to utilize the
benefits of not extending EmberObject immediately.

To resolve the deprecation, users will need to confirm they are not using EmberObject APIs
on the Store. Generally speaking, this has been limited to `.extend` e.g.

```ts
const AppStore = Store.extend({});
```

This pattern is now rare in the wild, but where it exists can be safely refactored to

```ts
class AppStore extends Store {}
```

Once confirmed (or in order to confirm) that the Store in an app no longer requires
extending EmberObject, the deprecation config boolean may be used to both remove the
deprecation AND the deprecated code.

```ts
const app = new EmberApp(defaults, {
  emberData: {
    deprecations: {
      DEPRECATE_STORE_EXTENDS_EMBER_OBJECT: false
    }
  }
});
```

An upcoming shift in how EmberData manages configuration would mean that applications
using the new configuration (not yet released) would do the following:

```ts
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = async function (defaults) {
  const { setConfig } = await import('@warp-drive/build-config');

  const app = new EmberApp(defaults, {});

  setConfig(app, __dirname, {
    deprecations: {
      DEPRECATE_STORE_EXTENDS_EMBER_OBJECT: false
    }
  });

  return app.toTree();
};
```

## How we teach this

Guides would be added for this deprecation to both the deprecation app and the API docs.

Generally, folks do not tend to treat the Store as an EmberObject or utilize legacy EmberObject
APIs with it, so both the teaching and the migration overhead are low.

## Drawbacks

none

## Alternatives

- deprecate every classic method to help folks find usage
    - not chosen as it's rare *and* setting the deprecation flag to `false` will cause any such locations to be findable via error
- create a new package `@warp-drive/core` or `@warp-drive/store` and have users migrate by swapping import
  locations.
    - not chosen as this is too minimal a change

## Unresolved questions

None


---

---
stage: accepted
start-date: 2024-05-11T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - data
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1027
project-link:
suite: 
---

# EmberData | SchemaService

## Summary

Upgrades the SchemaService API to improve DX and support new features.
Deprecates many APIs associated to the existing SchemaService.

## Motivation

The SchemaService today is primarily a way to rationalize the schema information
contained on Models. However, as we experimented with ember-m3, GraphQL, ModelFragments
and base improvements to Models we've come to realize this information is both
feature incomplete *and* more wieldy than required.

So while building SchemaRecord, we've iterated on these APIs and the
associated Schemas to gain confidence in a redesign. This is that redesign.

## Detailed design

- [The SchemaService](#the-schemaservice)
- [Resource Schemas](#resource-schemas)
- [Field Schemas](#fieldschema)
- [Transformations](#transformations)
- [Derivations](#derivations)
- [Hashing Functions](#hashing-functions)
- [Locals](#locals)
- [Schema Defaults](#schema-defaults)
- [ModelFragments](#modelfragments)
- [Deprecations](#deprecations)

### The SchemaService

The SchemaService defines required methods for loading and accessing
information about a resource.

```ts
interface SchemaService {
  // Retrieval APIs
  fields(resource: { type: string } | StableRecordIdentifier): Map<string, FieldSchema>;
  resource(resource: { type: string } | StableRecordIdentifier): ResourceSchema;
  transformation(field: GenericField | ObjectField | ArrayField | { type: string }): Transformation;
  derivation(field: DerivedField | { type: string }): Derivation;
  hashFn(field: HashField | { type: string }): HashFn;

  hasTrait(name: string): boolean;
  resourceHasTrait(resource: { type: string } | StableRecordIdentifier, trait: string): boolean;
  hasResource(type: string): boolean;

  // Loading APIs
  registerResources(schemas: ResourceSchema[]): void;
  registerResource(schema: ResourceSchema): void;
  registerTransformation(transform: Transformation): void;
  registerDerivation(derivation: Derivation): void;
  registerHashFn(hashFn: HashFn): void;
}
```

To supply a SchemaService, use the `createSchemaService` hook on the store.
This is analagous to the `createCache` hook on the store and similarly it
will only be called a single time to create the SchemaService when it is
first needed.

> [!TIP] 
> Curious *why* `createCache` and `createSchemaService` are hooks but `lifetimes`
> and `requestManager` are properties you assign?
> Apps can have multiple stores. `lifetimes` and `requestManager` are designed to
> be shared across store instances, whereas caches (and schema) are specific to
> a store instance.

```ts
class extends Store {
  createSchemaService() {
    return new SchemaService();
  }
}
```

When using `@ember-data/model`, this would look like:

```ts
import { buildSchema } from '@ember-data/model/hooks';

class extends Store {
  createSchemaService() {
    return buildSchema(this);
  }
}
```

When using `@warp-drive/schema-record`, this would look like:

```ts
import { SchemaService } from '@warp-drive/schema-record/schema';

class extends Store {
  createSchemaService() {
    return new SchemaService();
  }
}
```

If migrating between two implementations, you may sometimes want to create
a delegating service, for instance, the below shows a sketch of how that
might be done for `fields` and `hasResource` methods.

```ts
class MySchemaService {
  constructor(
    private newService: SchemaService,
    private oldService: SchemaService
  ) {}

  fields(resource) {
    return this.newService.hasResource(resource.type)
      ? this.newService.fields(resource)
      : this.oldService.fields(resource);
  }

  hasResource({ type }) {
    return this.newService.hasResource(type) || this.oldService.hasResource(type);
  }
}
```

Generally it will be best to only have one active schema service at a time, but
when necessary this approach gives control to you to determine which resources
should be delegated to which schema service.

For users migrating from `@ember-data/model` to `@warp-drive/schema-record`, a
delegating SchemaService will be provided from `@ember-data/model/migration-support`.

This service will fallback to attempting to lookup ResourceSchema from available
Models when a resource is not available from a prior call to `registerResource`.

```ts
import { DelegatingSchemaService } from '@ember-data/model/migration-support';
import { SchemaService } from '@warp-drive/schema-record/schema';

class extends Store {
  createSchemaService() {
    const schema = new SchemaService();
    return new DelegatingSchemaService(schema);
  }
}
```

#### Utilizing the SchemaService

To utilize the schema service, the created service can be accessed via the
`schema` property on either the `store` or via the same property on the 
`capabilities` passed to a Cache.

### Resource Schemas

```ts
type ResourceSchema = {
  /**
   * For primary resources, this should be an IdentityField
   * 
   * for schema-objects, this should be either a HashField or null
   */
  identity: IdentityField | HashField | null;
  /**
   * The name of the schema
   *
   * For cacheable resources, this should be the
   * primary resource type.
   *
   * For object schemas, this should be the name
   * of the object schema. object schemas should
   * follow the following guidelines for naming
   *
   * - for globally shared objects: The pattern `$field:${KlassName}` e.g. `$field:AddressObject`
   * - for resource-specific objects: The pattern `$${ResourceKlassName}:$field:${KlassName}` e.g. `$User:$field:ReusableAddress`
   * - for inline objects: The pattern `$${ResourceKlassName}.${fieldPath}:$field:anonymous` e.g. `$User.shippingAddress:$field:anonymous`
   */
  type: string;
  traits?: string[];
  fields: FieldSchema[];
};
```

### FieldSchema

The following is the list of valid FieldSchema.

> [!IMPORTANT]  
> `IdentityField` and `HashField` may never appear in a ResourceSchema's `fields`
> these field types are *only* valid for `identity`.

```ts
type FieldSchema =
  | GenericField
  | LocalField
  | ObjectField
  | SchemaObjectField
  | ArrayField
  | SchemaArrayField
  | DerivedField
  | ResourceField
  | CollectionField
  | LegacyAttributeField
  | LegacyBelongsToField
  | LegacyHasManyField;
```

```ts
/**
 * Represents a field whose value is the primary
 * key of the resource.
 *
 * This allows any field to serve as the primary
 * key while still being able to drive identity
 * needs within the system.
 *
 * This is useful for resources that use for instance
 * 'uuid', 'urn' or 'entityUrn' or 'primaryKey' as their
 * primary key field instead of 'id'.
 */
export type IdentityField = {
  kind: '@id';

  /**
   * The name of the field that serves as the
   * primary key for the resource.
   */
  name: string;
};


/**
 * Represents a specialized field whose computed value
 * will be used as the primary key of a schema-object
 * for serializability and comparison purposes.
 *
 * This field functions similarly to derived fields in that
 * it is non-settable, derived state but differs in that
 * it is only able to compute off of cache state and is given
 * no access to a record instance.
 *
 * This means that if a hashing function wants to compute its value
 * taking into account transformations and derivations it must
 * perform those itself.
 *
 * A schema-array can declare its "key" value to be `@hash` if
 * a schema-object has such a field.
 *
 * Only one hash field is permittable per schema-object, and
 * it should be placed in the `ResourceSchema`'s `@id` field
 * in place of an `IdentityField`.
 */
export type HashField = {
  kind: '@hash';

  /**
   * The name of the field that serves as the
   * hash for the resource.
   *
   * Only required if access to this value by
   * the UI is desired, it can be `null` otherwise.
   */
  name: string | null;

  /**
   * The name of a function to run to compute the hash.
   * The function will only have access to the cached
   * data for the record.
   */
  type: string;

  /**
   * Any options that should be provided to the hash
   * function.
   */
  options?: ObjectValue;
};


/**
 * A generic "field" that can be used to define
 * primitive value fields.
 *
 * Replaces "attribute" for primitive value fields.
 * Can also be used to eject from deep-tracking of
 * objects or arrays.
 *
 * A major difference between "field" and "attribute"
 * is that "type" points to a legacy transform on
 * "attribute" that a serializer *might* use, while
 * "type" points to a new-style transform on "field"
 * that a record implementation *must* use.
 */
export type GenericField = {
  kind: 'field';
  name: string;
  /** the name of the transform to use, if any */
  type?: string;
  /**
   * Options to pass to the transform, if any
   *
   * Must comply to the specific transform's options
   * schema.
   */
  options?: ObjectValue;
};

/**
 * Represents a field whose value is a local
 * value that is not stored in the cache, nor
 * is it sent to the server.
 *
 * Local fields can be written to, and their
 * value is both memoized and reactive (though
 * not deep-tracked).
 *
 * Because their state is not derived from the cache
 * data or the server, they represent a divorced
 * uncanonical source of state.
 *
 * For this reason Local fields should be used sparingly.
 *
 * Currently, while we document this feature here,
 * only allow our own SchemaRecord should utilize them
 * and the feature should be considered private.
 *
 * Example use cases that drove the creation of local
 * fields are states like `isDestroying` and `isDestroyed`
 * which are specific to a record instance but not
 * stored in the cache. We wanted to be able to drive
 * these fields from schema the same as all other fields.
 *
 * Don't make us regret this decision.
 */
export type LocalField = {
  kind: '@local';
  name: string;
  /**
   * Not currently utilized, we are considering
   * allowing transforms to operate on local fields
   */
  type?: string;
  options?: { defaultValue?: PrimitiveValue };
};

/**
 * Represents a field whose value is an object
 * with keys pointing to values that are primitive
 * values.
 *
 * If values of the keys are not primitives, or
 * if the key/value pairs have well-defined shape,
 * use 'schema-object' instead.
 */
export type ObjectField = {
  kind: 'object';
  name: string;

  /**
   * The name of a transform to pass the entire object
   * through before displaying or serializing it.
   */
  type?: string;

  /**
   * Options to pass to the transform, if any
   *
   * Must comply to the specific transform's options
   * schema.
   */
  options?: ObjectValue;
};

/**
 * Represents a field whose value is an object
 * with a well-defined structure described by
 * a non-resource schema.
 *
 * If the object's structure is not well-defined,
 * use 'object' instead.
 */
export type SchemaObjectField = {
  kind: 'schema-object';
  name: string;

  /**
   * The name of the ResourceSchema that describes the
   * structure of the object.
   *
   * These `identity` for a SchemaObject shoul be either
   * a `HashField` or `null`. It should never be an IdentityField.
   */
  type: string;

  options?: {
    /**
     * Whether this SchemaObject is Polymorphic.
     *
     * If the SchemaObject is polymorphic, `options.type` must also be supplied.
     *
     * @typedoc
     */
    polymorphic?: boolean;

    /**
     * If the SchemaObject is Polymorphic, the key on the raw cache data to use
     * as the "resource-type" value for the schema-object.
     *
     * Defaults to "type".
     *
     * @typedoc
     */
    type?: string;
  };
};

/**
 * Represents a field whose value is an array
 * of primitive values.
 *
 * If the array's elements are not primitive
 * values, use 'schema-array' instead.
 */
export type ArrayField = {
  kind: 'array';
  name: string;

  /**
   * The name of a transform to pass each item
   * in the array through before displaying or
   * or serializing it.
   */
  type?: string;

  /**
   * Options to pass to the transform, if any
   *
   * Must comply to the specific transform's options
   * schema.
   */
  options?: ObjectValue;
};

/**
 * Represents a field whose value is an array
 * of objects with a well-defined structure
 * described by a non-resource schema.
 *
 * If the array's elements are not well-defined,
 * use 'array' instead.
 */
export type SchemaArrayField = {
  kind: 'schema-array';
  name: string;

  /**
   * The name of the schema that describes the
   * structure of the objects in the array.
   */
  type: string;

  /**
   * Options for configuring the behavior of the
   * SchemaArray.
   */
  options?: {
    /**
     * Configures how the SchemaArray determines whether
     * an object in the cache is the same as an object
     * previously used to instantiate one of the schema-objects
     * it contains.
     *
     * The default is `'@identity'`.
     *
     * Valid options are:
     *
     * - `'@identity'` (default) : the cached object's referential identity will be used.
     *       This may result in significant instability when resource data is updated from the API
     * - `'@index'`              : the cached object's index in the array will be used.
     *       This is only a good choice for arrays that rarely if ever change membership
     * - `'@hash'`               : will lookup the `@hash` function supplied in the ResourceSchema for
     *       The contained schema-object and use the computed result to determine and compare identity.
     * - <field-name> (string)   : the name of a field to use as the key, only GenericFields (kind `field`)
     *       Are valid field names for this purpose. The cache state without transforms applied will be
     *       used when comparing values. The field value should be unique enough to guarantee two schema-objects
     *       of the same type will not collide.
     */
    key?: '@identity' | '@index' | '@hash' | string;

    /**
      * Whether this SchemaArray is Polymorphic.
      * 
      * If the SchemaArray is polymorphic, `options.type` must also be supplied.
      */ 
    polymorphic?: boolean;

    /**
     * If the SchemaArray is Polymorphic, the key on the raw cache data to use
     * as the "resource-type" value for the schema-object.
     * 
     * Defaults to "type".
     */
    type?: string; // default '"type"'
  };
};

/**
 * Represents a field whose value is derived
 * from other fields in the schema.
 *
 * The value is read-only, and is not stored
 * in the cache, nor is it sent to the server.
 *
 * Usage of derived fields should be minimized
 * to scenarios where the derivation is known
 * to be safe. For instance, derivations that
 * required fields that are not always loaded
 * or that require access to related resources
 * that may not be loaded should be avoided.
 */
export type DerivedField = {
  kind: 'derived';
  name: string;

  /**
   * The name of the derivation to use.
   *
   * Derivations are functions that take the
   * record, options, and the name of the field
   * as arguments, and return the derived value.
   *
   * Derivations are memoized, and are only
   * recomputed when the fields they depend on
   * change.
   *
   * Derivations are not stored in the cache,
   * and are not sent to the server.
   *
   * Derivation functions must be explicitly
   * registered with the schema service.
   */
  type: string;

  /**
   * Options to pass to the derivation, if any
   *
   * Must comply to the specific derivation's
   * options schema.
   */
  options?: ObjectValue;
};

/**
 * Represents a field that is a reference to
 * another resource.
 */
export type ResourceField = {
  kind: 'resource';
  name: string;

  /**
   * The name of the resource that this field
   * refers to. In the case of a polymorphic
   * relationship, this should be the trait
   * or abstract type.
   */
  type: string;

  /**
   * Options for resources are optional. If
   * not present, all options are presumed
   * to be falsey
   */
  options?: {
    /**
     * Whether the relationship is async
     *
     * If true, it is expected that the cache
     * data for this field will contain a link
     * that can be used to fetch the related
     * resource when needed.
     */
    async?: boolean;

    /**
     * The name of the inverse field on the
     * related resource that points back to
     * this field on this resource to form a
     * bidirectional relationship.
     *
     * If null, the relationship is unidirectional.
     */
    inverse?: string | null;

    /**
     * If this field is satisfying a polymorphic
     * relationship on another resource, then this
     * should be set to the trait or abstract type
     * that this resource implements.
     */
    as?: string;

    /**
     * Whether this field is a polymorphic relationship,
     * meaning that it can point to multiple types of
     * resources so long as they implement the trait
     * or abstract type specified in `type`.
     */
    polymorphic?: boolean;
  };
};

/**
 * Represents a field that is a reference to
 * a collection of other resources, potentially
 * paginate.
 */
export type CollectionField = {
  kind: 'collection';
  name: string;

  /**
   * The name of the resource that this field
   * refers to. In the case of a polymorphic
   * relationship, this should be the trait
   * or abstract type.
   */
  type: string;

  /**
   * Options for resources are optional. If
   * not present, all options are presumed
   * to be falsey
   */
  options?: {
    /**
     * Whether the relationship is async
     *
     * If true, it is expected that the cache
     * data for this field will contain links
     * that can be used to fetch the related
     * resources when needed.
     *
     * When false, it is expected that all related
     * resources are loaded together with this resource,
     * and that the cache data for this field will
     * contain the full list of pointers.
     *
     * When true, it is expected that the relationship
     * is paginated. If the relationship is not paginated,
     * then the cache data for "page 1" would contain the
     * full list of pointers, and loading "page 1" would
     * load all related resources.
     */
    async?: boolean;

    /**
     * The name of the inverse field on the
     * related resource that points back to
     * this field on this resource to form a
     * bidirectional relationship.
     *
     * If null, the relationship is unidirectional.
     */
    inverse?: string | null;

    /**
     * If this field is satisfying a polymorphic
     * relationship on another resource, then this
     * should be set to the trait or abstract type
     * that this resource implements.
     */
    as?: string;

    /**
     * Whether this field is a polymorphic relationship,
     * meaning that it can point to multiple types of
     * resources so long as they implement the trait
     * or abstract type specified in `type`.
     */
    polymorphic?: boolean;
  };
};

/**
 * > [!CAUTION]
 * > This Field is LEGACY
 *
 * A generic "field" that can be used to define
 * primitive value fields.
 *
 * If the field points to an object or array,
 * it will not be deep-tracked.
 *
 * Transforms when defined are legacy transforms
 * that a serializer *might* use, but their usage
 * is not guaranteed.
 */
export type LegacyAttributeField = {
  kind: 'attribute';
  name: string;
  /** the name of the transform to use, if any */
  type?: string;
  /**
   * Options to pass to the transform, if any
   *
   * Must comply to the specific transform's options
   * schema.
   */
  options?: ObjectValue;
};

/**
 * > [!CAUTION]
 * > This Field is LEGACY
 *
 * Represents a field that is a reference to
 * another resource.
 *
 * This is the legacy version of the `ResourceField`.
 */
export type LegacyBelongsToField = {
  kind: 'belongsTo';
  name: string;

  /**
   * The name of the resource that this field
   * refers to. In the case of a polymorphic
   * relationship, this should be the trait
   * or abstract type.
   */
  type: string;

  /**
   * Options for belongsTo are mandatory.
   */
  options: {
    /**
     * Whether the relationship is async
     *
     * If true, it is expected that the cache
     * data for this field will contain a link
     * or a pointer that can be used to fetch
     * the related resource when needed.
     *
     * Pointers are highly discouraged.
     */
    async: boolean;

    /**
     * The name of the inverse field on the
     * related resource that points back to
     * this field on this resource to form a
     * bidirectional relationship.
     *
     * If null, the relationship is unidirectional.
     */
    inverse: string | null;

    /**
     * If this field is satisfying a polymorphic
     * relationship on another resource, then this
     * should be set to the trait or abstract type
     * that this resource implements.
     */
    as?: string;

    /**
     * Whether this field is a polymorphic relationship,
     * meaning that it can point to multiple types of
     * resources so long as they implement the trait
     * or abstract type specified in `type`.
     */
    polymorphic?: boolean;
  };
};

/**
 * > [!CAUTION]
 * > This Field is LEGACY
 * 
 * Represents a field that is a reference to
 * a collection of other resources.
 *
 * This is the legacy version of the `CollectionField`.
 */
export type LegacyHasManyField = {
  kind: 'hasMany';
  name: string;
  type: string;

  /**
   * Options for hasMany are mandatory.
   */
  options: {
    /**
     * Whether the relationship is async
     *
     * If true, it is expected that the cache
     * data for this field will contain links
     * or pointers that can be used to fetch
     * the related resources when needed.
     *
     * When false, it is expected that all related
     * resources are loaded together with this resource,
     * and that the cache data for this field will
     * contain the full list of pointers.
     *
     * hasMany relationships do not support pagination.
     */
    async: boolean;

    /**
     * The name of the inverse field on the
     * related resource that points back to
     * this field on this resource to form a
     * bidirectional relationship.
     *
     * If null, the relationship is unidirectional.
     */
    inverse: string | null;

    /**
     * If this field is satisfying a polymorphic
     * relationship on another resource, then this
     * should be set to the trait or abstract type
     * that this resource implements.
     */
    as?: string;

    /**
     * Whether this field is a polymorphic relationship,
     * meaning that it can point to multiple types of
     * resources so long as they implement the trait
     * or abstract type specified in `type`.
     */
    polymorphic?: boolean;

    /**
     * When omitted, the cache data for this field will
     * clear local state of all changes except for the
     * addition of records still in the "new" state any
     * time the remote data for this field is updated.
     *
     * When set to `false`, the cache data for this field
     * will instead intelligently commit any changes from
     * local state that are present in the remote data,
     * leaving any remaining changes in local state still.
     */
    resetOnRemoteUpdate?: false;
  };
};
```

### Transformations

Some fields have the ability to specify a transformation to serialize/deserialize the
data for the given field when the UI accesses the value from cache or updates the value.

Transformations are stateless objects that provide this ability to *hydrate* or *transform* a
serialized cache value into a richer form for use in your App. For instance, as an Enum or Luxon
Date.

Transformations ensure that the value in the cache is always in a raw serialized form even when
your App wants to conceptualize the state as something richer.

They are also how you can provide a default value for a field when no value is present yet in
the cache.

```ts
export type Transformation<T extends Value = string, PT = unknown> = {
  serialize(value: PT, options: ObjectValue | null, record: OpaqueRecordInstance): T;
  hydrate(value: T | undefined, options: ObjectValue | null, record: OpaqueRecordInstance): PT;
  defaultValue?(options: ObjectValue | null, identifier: StableRecordIdentifier): T;
  [Type]: string;
};
```

### Derivations

Derivations are functions which ingest the record their associated field is defined on,
the config for that field, and produce a value as a new field.

```ts
export type Derivation<R = unknown, T = unknown> = { [Type]: string } & ((
  record: R,
  options: ObjectValue | null,
  prop: string
) => T);
```

For example, a user's `fullName` field is often implemented as a derivation of `firstName` and `lastName`,
the fields for which might look like this:

```ts
[
  {
    name: 'firstName',
    kind: 'field',
  },
  {
    name: 'lastName',
    kind: 'field',
  },
  {
    name: 'fullName',
    type: 'concat',
    options: { fields: ['firstName', 'lastName'], separator: ' ' },
    kind: 'derived',
  },
]
```

To support `fullName`, we would register a derivation named `concat`.

```ts
function concat(record, options, prop) {
  if (!options) throw new Error(`options is required`);
  return options.fields.map((field) => record[field]).join(options.separator ?? '');
}
concat[Type] = 'concat';

store.schema.registerDerivation(concat);
```

Typically derivations will represent *highly reusable computations* that apply to lots of fields and resources,
we discourage using derivations for one-off scenarios: it's typically best to move those into components or
other layers of the program.

In most situations, derivations should be a calculation you want to conceptually share between the API and the UI,
such that a value derived from other state on the resource can be kept fresh in both locations.

> [!TIP]
> Derivations should rarely if ever access relationships as part of their calculation.
> Moreover, if using partial fields, you must be careful to send all fields a derivation
> needs to the client when it's part of the intended request result. This is somewhere
> where EmberData's branding strategy for Resource and Request types can be used to your
> app's benefit. If requesting partial data, only add the derived field to the type supplied
> to the request when all associated fields are also present.

### Hashing Functions

Hashing functions are functions which injest the raw cache data for a `schema-object`
and produce a string key that represents that object's identity for purposes of serializability
and comparison. The identity need only be unique-enough that two schema-objects of the same
type can be adequately distinguished.

```ts
export type HashFn<T extends object = object> = { [Type]: string } & ((
  data: T,
  options: ObjectValue | null,
  prop: string
) => string);
```

For example 

```ts
import { Type } from '@warp-drive/core-types/symbols';

function addressHash(data) {
  return data.street + data.unit + data.city + data.state + data.zip
}
addressHash[Type] = 'address';

store.schema.registerHashFn(addressHash);
```


### Locals

There is a hidden `kind` of field referred to as `locals`. We do not currently intend to expose these
for use by consuming apps outside of our own limited usage. Most usage is related to supporting the migration
from `@ember-data/model`, though there are a few fields that are likely to stick around such as `isDestroyed`.

The reason for this hidden class of fields is that `SchemaRecord` (the upcoming replacement for `@ember-data/model`)
implements absolutely *every* feature via schema. This keeps the implementation fairly simple to reason about and
debug, as we don't juggle lots of codepaths. This meant we needed a solution for state that doesn't belong in the
cache, nor ever persists to the API.

If we find that there are compelling cases for `@local` to become a public API, we will RFC making it public
at that time.

### Schema Defaults

Some packages may wish to provide utilities for enhancing ResourceSchemas with specialized fields and
derivations. Both the `@warp-drive/schema-record` package and `@ember-data/model` package are examples of this.

Since *every* behavior on a SchemaRecord is driven by schema, for a behavior to exist there needs to be
a schema field for it as well *and!* default behaviors can be optional (don't want the defaults? don't include them!).

#### For defaults with SchemaRecord:

```ts
import { withDefaults, registerDerivations } from '@warp-drive/schema-record/schema';

const upgradedResourceSchema = withDefaults(resourceSchema);

//...

// ensure derivations for use with the defaults are registered
registerDerivations(store.schema);
```

`withDefaults` adds defaults for the `constructor` property as well as for `$type`
and ensures the `ResourceSchema.identity` is set to the following IdentityField:
`{ name: 'id', kind: '@id' }`

`registerDerivations` adds derivations for the `constructor` property as well as an
`@identity` derivation that can be used to expose any information from the record's
`Identifier`, the implementation of which is shown below:

```ts
export function fromIdentity(record: SchemaRecord, options: null, key: string): asserts options;
export function fromIdentity(record: SchemaRecord, options: { key: 'lid' } | { key: 'type' }, key: string): string;
export function fromIdentity(record: SchemaRecord, options: { key: 'id' }, key: string): string | null;
export function fromIdentity(record: SchemaRecord, options: { key: '^' }, key: string): StableRecordIdentifier;
export function fromIdentity(
  record: SchemaRecord,
  options: { key: 'id' | 'lid' | 'type' | '^' } | null,
  key: string
): StableRecordIdentifier | string | null {
  const identifier = record[Identifier];
  assert(`Cannot compute @identity for a record without an identifier`, identifier);
  assert(
    `Expected to receive a key to compute @identity, but got ${String(options)}`,
    options?.key && ['lid', 'id', 'type', '^'].includes(options.key)
  );

  return options.key === '^' ? identifier : identifier[options.key];
}
fromIdentity[Type] = '@identity';
```

#### For defaults with Model:

```ts
import { withDefaults, registerDerivations } from '@ember-data/model/migration-support';

const upgradedResourceSchema = withDefaults(resourceSchema);

//...

// ensure derivations for use with the defaults are registered
registerDerivations(store.schema);
```

The defaults are primarily a mechanism to support legacy behaviors of Model while transitioning
a codebase. Most Model APIs are available via this mechanism (and, if you're curious just how advanced
derivations can get, most of these are implemented as derivations ... yes, even the functions)

-  id
-  _createSnapshot
-  adapterError
-  belongsTo
-  changedAttributes
-  constructor
-  currentState
-  deleteRecord
-  destroyRecord
-  dirtyType
-  errors
-  hasDirtyAttributes
-  hasMany
-  isDeleted
-  isEmpty
-  isError
-  isLoaded
-  isLoading
-  isNew
-  isSaving
-  isValid
-  reload
-  rollbackAttributes
-  save
-  serialize
-  unloadRecord
-  isReloading
-  isDestroying
-  isDestroyed

### ModelFragments

For users of ModelFragments, the following FieldSchemas, when used together with SchemaRecord,
are seen as the direct replacement.

- `FragmentArray` => `ArrayField` or  `SchemaArrayField` (depends on content)
  - the equivalent "key" strategy for `schema-array` is `@index`, though we believe the other
      options are likely better suited for this
  - for polymorphic arrays, the type can be specified by any field on the schema-object, but that
    field should be specified in the array's config, and should be a string value that matches a
    known `schema-object` resource-type. Note, the default is `"type"` where ModelFragments
    defaults to `"$type"`.
- `Fragment` => `ObjectField` or `SchemaObjectField` (depends on content)

## Deprecations

- `store.registerSchema` is deprecated in favor of the `createSchemaService` hook
- `store.registerSchemaDefinitionService` is deprecated in favor of the `createSchemaService` hook
- `store.getSchemaDefinitionService` is deprecated in favor of `store.schema` property
- `SchemaService.doesTypeExist` is deprecated in favor of `SchemaService.hasResource`
- `SchemaService.attributesDefinitionFor` is deprecated in favor of `SchemaService.fields`
- `SchemaService.relationshipsDefinitionFor` is deprecated in favor of `SchemaService.fields`

Since these APIs are relatively low-usage (power-user APIs mostly used by EmberData itself) and the migration
path is relatively simple, we do not foresee much churn occurring. Typical deprecation messages will print
and target `6.0`, a deprecation guide will be produced.

## How we teach this

The schema format requires its own documentation page as well as a guide for understanding
what each field type is and how they can be utilized and composed.

The schema service requires both developer docs and a usage guide with patterns for
loading schemas in a bundled, static json, or API-delivered pattern to show common
setups.

We will need to be clear in our language to avoid confusion, as schema (the word) is
bound to not only be overloaded, but confusing. For instance, a beginner may not
immediately grasp the distinction of a resource schema vs a field schema vs a
schema service. They may not even know what resources, fields, or service patterns are!

Visual aides and code examples that show the structure of data and how it maps to various
forms of schema or usage will be indispensable.

## Drawbacks

Without a way to elegantly compose schemas and types, or tools to generate them
from an existing source of truth, the barrier to getting started with schemas is
inherently higher than the barrier to getting started with Models.

However, it is not a requirement of this RFC to solve that problem. We're hard
at work on a tool for authoring schemas in a TypeScript based DSL that compiles
them into the JSON format as well as richer types than you'd get with a class or
a single TS interface alone. We expect *that* tool will be what keeps the barrier
to entry low.

However, we are also investigating creating a tool to convert OpenAPI specs into
these JSON schemas and types. OpenAPI has become a fairly widely adopted
standard with good tooling support throughout the software industry, and creating
a seamless integration with it seems like a no-brainer.

## Alternatives

There are an indefinite number of existing JSON schema representation formats
available, including many specifically for representing API resources.

However, we don't believe these adequately map to the characteristics we want
for performance, flexibility, and feature set in no small part because they 
generally are trying to communicate something different than what we need.

We've intentionally adopted a relatively simple interface approach that
plays well with TypeScript, is quick to iterate via switch, and arbitrarily
nests as deep as it needs to go.

## Unresolved questions

None


---

---
stage: released
start-date: 2024-05-20T00:00:00.000Z
release-date:
release-versions:
  ember-cli: 6.3.0
teams:
  - cli
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1029'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1044'
  released: 'https://github.com/emberjs/rfcs/pull/1072'
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate app-prefix, app-suffix, tests-prefix, and tests-suffix

## Summary

ember-cli addons can use their `contentFor` method to emit arbitrary Javascript into many places. This RFC proposes deprecating and removing several of them:

 - app-prefix
 - app-suffix
 - tests-prefix
 - tests-suffix
 - vendor-prefix
 - vendor-suffix

## Motivation

All of these assume there's going to be one "app" bundle, one "vendor" bundle, and one "tests" bundle. But those assumptions are now nonsense, given code-splitting and builds that can directly evaluate the module graph in the browser.

They are also seldom used based on code searches on emberobserver.com:

| Feature  | Usage Count   | Relevance |
| ---------| ------------- | -----------------------------------------------------------------------------------   |
| app-prefix  | 2 addons   | Last updated 6 and 8 years ago                                     |
| app-suffix | 1 addon     | Last updated 6 years ago |
| tests-prefix | 0 addons  | Never appears in emberobserver at all |
| tests-suffix | 0 addons  | Only some embroider testing infrastructure ever refers to this at all. |
| vendor-prefix | 3 addons | Last updated 6, 7, and 9 years ago | 
| vendor-suffix | 2 addons | Last updated 6 and 9 years ago |

## Transition Path

For all of these types of `contentFor` we will emit a deprecation if an addon returns content for the given `type` argument. An example of the deprecated behavior looks like:

```js
   contentFor(type, config, contents) {
     if (type === 'app-prefix') {
       return `console.log("LOL");`
     }
    }
```

## How We Teach This

The CLI docs [mention contentFor](https://ember-cli.com/api/classes/addon#method_contentFor) but they don't actually document any of the use cases we are deprecating. They describe using contentFor to target index.html instead. That is not being deprecated by this RFC.


### Deprecation Guide Content

#### app-prefix

Returning content from an addon's `contentFor()` hook for `type="app-prefix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. If you need to provide code that apps will run before booting, document that app authors should import and call your code at the start of their own `app.js` file.

#### app-suffix

Returning content from an addon's `contentFor()` hook for `type="app-suffix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. If you need to provide code that apps will run before booting, document that app authors should import and call your code at the start of their own `app.js` file.

If you were using app-suffix to overwrites modules provided by the app, that is intentionally not supported. Adjust your API to tell app authors to import your code and invoke it where appropriate.

#### tests-prefix

Returning content from an addon's `contentFor()` hook for `type="tests-prefix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. Provide utilities that users can import into their own test setup code instead.

#### tests-suffix

Returning content from an addon's `contentFor()` hook for `type="tests-suffix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. Provide utilities that users can import into their own test setup code instead.

#### vendor-prefix

Returning content from an addon's `contentFor()` hook for `type="vendor-prefix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. If you really need to run script (non-module) code, provides your own script via your addon's `/public` directory and either document that app authors should createa a `<script>` element in their HTML that includes it, or use `contentFor()` with one of the `type`s that appears in `index.html` to emit the scrip tag automatically. (`contentFor` targeting HTML is not deprecated, this deprecation only covers targeting javascript bundles.)

#### vendor-suffix

Returning content from an addon's `contentFor()` hook for `type="vendor-suffix"` is deprecated. Addons will no longer be allowed to inject arbitrary javascript here. If you really need to run script (non-module) code, provides your own script via your addon's `/public` directory and either document that app authors should createa a `<script>` element in their HTML that includes it, or use `contentFor()` with one of the `type`s that appears in `index.html` to emit the scrip tag automatically. (`contentFor` targeting HTML is not deprecated, this deprecation only covers targeting javascript bundles.)

## Drawbacks

This is a change to the v1 addon API. V2 addons already cannot use the contentFor hooks this RFC aims to deprecate. One could argue against bothering to change the v1 addon API.

## Alternatives

We could leave this API alone, on the assumption that it will get included in a wider "deprecate v1 addons" RFC. I'm not advocating that because I don't think it's practical to deprecate v1 addons any time soon.

We could include `app-boot` in this RFC. It certainly deserves to be deprecated, and has only a single use in the ecosystem (ember-cli-fastboot). But I think it's proper replacement should get designed in a "v2 app format" RFC instead, so that the booting of an app (or a test suite) is codified clearly as code the user controls. 


---

---
stage: released
start-date: 2024-10-04T00:00:00.000Z
release-date:
release-versions:
  ember-source: 6.3.0
teams:
  - framework
  - learning
  - typescript
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1046'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1053'
  released: 'https://github.com/emberjs/rfcs/pull/1069'
project-link:
suite:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Use Template Tag in Routes

## Summary

Allow `app/templates/*.hbs` to convert to `app/templates/*.gjs`.

## Motivation

We are rapidly approaching the point where Template Tag is the recommended way to author components. This means using `.gjs` (or `.gts`) files that combine your template and Javascript into one file. But you cannot currently use Template Tag to author the top-level templates invoked by the router (`app/templates/*.hbs`).

This inconsistency is especially apparent when working on teaching materials for new users. Making people learn both `.hbs` with global component resolution and `.gjs` with strict template resolution before they can even make their first component is unreasonable.

This RFC proposes allowing consistent use of `.gjs` everywhere. It doesn't remove any support for `.hbs`, but recommends that the guides default to all `.gjs`.

## Detailed design

The [implementation is small and already done](https://github.com/emberjs/ember.js/pull/20768).

### Illustration By Example

If you currently have this:

```hbs
{{! app/templates/example.hbs }}
<article>
  <MainContent @model={{@model}} @editorMode={{this.editorMode}} />
</article>
```

You can convert it to this:

```gjs
// app/templates/example.gjs
import MainContent from 'my-app/components/main-content';
<template>
  <article>
    <MainContent @model={{@model}} @editorModel={{@controller.editorMode}} />
  </article>
</template>
```

Key differences:

- this is [strict handlebars](https://github.com/emberjs/rfcs/blob/master/text/0496-handlebars-strict-mode.md), so components are imported explicitly
- the controller is no longer `this`, it is `@controller`.

Many things that you might have been forced to put on a controller can now be done directly. For example, if your controller has a `doSomething` event handler:

```hbs
{{! app/templates/example.hbs }}
<div {{on "click" this.doSomething}}></div>
```

You now have options to implement it in-place in the same file. If it's stateless it can just be a function:

```gjs
// app/templates/example.gjs

// This import will be unnecessary after https://github.com/emberjs/rfcs/pull/1033
import { on } from '@ember/modifier';

function doSomething() {
  alert("It worked");
}

<template>
  <div {{on "click" doSomething}}></div>
</template>
```

If it's stateful, you can upgrade from a template-only component to a Glimmer component:

```gjs
// app/templates/example.gjs
import { on } from '@ember/modifier';
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class extends Component {
  @tracked activated = false;

  doSomething = () => {
    this.activated = !this.activated;
  }

  <template>
    <div {{on "click" this.doSomething }}></div>
    {{#if this.activated}}
      It's activated!
    {{/if}}
  </template>
}
```

### Specification

When Ember resolves a route template (`owner.lookup("template:example")`:

1. Check whether the resulting value has a component manager.
   - If no, do exactly what happens today.
   - If yes, continue to step 2.
2. Synthesize a route template that invokes your component with these arguments:
   - @model: which means exactly the same as always.
   - @controller: makes the controller available.

Keen observers will notice that this says nothing about only supporting gjs files. Any component is eligible, no matter how it's authored or what Component Manager it uses. This is by design, because there's no reason for the router to violate the component abstraction and care about how that component was implemented.

However, in our learning materials we should present this as a feature designed for GJS files. Using it with components authored in .hbs would be needlessly confusing, because automatic template co-location **does not work in app/templates**, because it would collide with traditional route templates.

### ember-route-template addon

This RFC replaces the [ember-route-template](https://github.com/discourse/ember-route-template) addon. If you're already using it, it would continue to work without breaking, but you can simply delete all the calls to its `RouteTemplate` function and remove it. The popularity of that addon among teams who are already adopting Template Tag is an argument in favor of this RFC.

### Codemod

Because Embroider already generates imports for components, helpers, and modifiers in non-strict templates, there is [ongoing work](https://github.com/embroider-build/embroider/pull/2134) to offer Embroider's existing functionality as a Template Tag codemod.

For route templates, the only extra feature required would be replacing `this` with `@controller`.

In order to help people be successful with the codemod, we should also:

- deprecate passing dynamic component strings to the `{{component ...}}` helper, since that is the only non-strict-handlebars feature that Embroider cannot automatically concert to the equivalent strict-handlebars code.

- continue to emphasize v2 addons, because v1 addons that use the full weird panoply of old behaviors can make the codemod unreliable.

### TypeScript

No new typescript-specific features are required. If you're authoring route templates in GTS, Glint should treat them just like any other component. You will need to manually declare the signature for `@model` and `@controller`, but that is the same as now.

## How we teach this

This RFC was directly inspired by a first attempt at updating the Guides for Template Tag. It became immediately apparent that we can write _much_ clearer guides if we can teach all GJS, instead of a mix of GJS and HBS.

Starting at https://guides.emberjs.com/release/components/ when the first `application.hbs` file is introduced, we would use `.gjs` instead. In those opening examples that are emphasizing HTML, the only change to the content would be wrapping `<template></template>` around the HTML.

Progressing to https://guides.emberjs.com/release/components/introducing-components/, learners extract their first component. It now becomes possible to do that within the same file. This allows teaching fewer things in a single step. First, people can learn what a component is. Second, it can be refactored into a separate file. We can avoid teaching anything about "pascal case" and naming rules, because everything just follows javascript naming rules.

When starting to teach routing in https://guides.emberjs.com/release/routing/defining-your-routes/, the file extensions change and `<template></template>` wrappers are added, but nothing else on that page necessarily changes.

In https://guides.emberjs.com/release/routing/query-params/, it's appropriate to first introduce the `@controller` argument.

In https://guides.emberjs.com/release/routing/controllers/, the list of reasons to use a controller gets shortened to only queryParams, since now you can manage state directly in your route's component.

### How to teach: what to do when you encounter an HBS route template?

Guides will need one or more callout boxes in the routing area to point people toward a dedicated page about HBS files in app/templates.

The dedicated page will explain that this is the older pattern, the controller is available as `this` the model is still `@model`, and the instruction for dealing with them is to run the codemod to convert them to GJS.

## Drawbacks

There is appetite for a more ambitious RFC that changes more things about routing. Eliminating controllers, making routes play nice with the newer `@ember/destroyable` system, allowing parallel model hooks, etc, are all good goals. There is a risk that if we do those things soon, this would be seen as two steps of churn instead of one.

I think we can mitigate that risk because

- we won't deprecate `.hbs` routes yet, so no churn is forced immediately.
- we can ship the Template Tag codemod so that even big apps can adopt at low cost
- it's extremely unlikely that a future routing design would use anything other than `.gjs` to define route entrypoints. By converting now, you are already moving in the right direction by eliminating all the non-strict behaviors.

## Alternatives

### Bigger Router RFC

The main alternative here is to do a bigger change to the routing system. A "Route Manager" RFC would allow the creation of new Route implementations that could have their own opinions about how to route to GJS files. This RFC does not preclude that other work from also happening.

The main benefit of this RFC is that the [implementation is small and already done](https://github.com/emberjs/ember.js/pull/20768) so we could have it immediately.

### Eliminate Bare Templates Entirely

The existence of "bare templates" in the system alongside HBS components is a major source of incoherence and potential confusion. It's especially bad that the behavior is hard-coded to depend on particular filesystem paths (a standalone hbs file in `app/components` gets built to a component whereas anywhere else it remains a bare template).

To eliminate this source of incoherence, it would be desirable to introduce a feature flag that would make _all_ hbs files interpreted as components, regardless of filesystem path.

This is probably worth doing regardless of whether we also do the present RFC and deserves its own separate proposal. There is a practical question of whether this will be faster than eliminating all HBS via codemod and deprecation and removal.


---

---
stage: released
start-date: 2024-12-03T00:00:00.000Z
release-date:
release-versions:
  ember-cli: 6.3.0
teams:
  - cli
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1055'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1063'
  released: 'https://github.com/emberjs/rfcs/pull/1073'
project-link:
suite:
---

# Vanilla Prettier Setup in Blueprints

## Summary

This RFC proposes to migrate to a vanilla Prettier setup in the blueprints, instead of running Prettier via ESLint and Stylelint.

## Motivation

1. Because we run Prettier via ESLint and Stylelint, we only run the files these linters support through Prettier - Using a vanilla Prettier setup, would format all files Prettier supports, ensuring even more consistency in projects
2. Less dependencies in the blueprints - `eslint-plugin-prettier` and `stylelint-prettier` would not be needed anymore
3. The Prettier team recommends running Prettier directly, and not via linters:
   - Running Prettier directly is faster than running Prettier via ESLint and Stylelint
   - ESLint and Stylelint show red squiggly lines in editors (when using the corresponding extensions), while the idea behind Prettier is to make developers forget about formatting

`3.` is mostly taken from [Integrating with Linters > Notes](https://prettier.io/docs/en/integrating-with-linters.html#notes)

## Detailed Design

We would add the following scripts to the `package.json` file in the `app` blueprint:

```diff
+ "format": "prettier . --cache --write",
+ "lint:format": "prettier . --cache --check",
```

- `lint:format` would check the formatting of _all_ files Prettier supports
- `lint:format` would also run when running the `lint` script
- `format` would format _all_ files Prettier supports
- `format` would also run when running the `lint:fix` script

> NOTE: We use `format` instead of `lint:format:fix`, because we don't want to run Prettier parallel to ESLint and Stylelint when fixing lint errors. The `lint:fix` script will be updated to always run `format` last.

We would remove the following dependencies from the `package.json` file in the `app` blueprint:

```diff
- "eslint-plugin-prettier": "*",
- "stylelint-prettier": "*",
```

As these would not be needed anymore.

> NOTE: We will keep `eslint-config-prettier` installed, as we need this package to turn off the stylistic ESLint rules that might conflict with Prettier.

We would update the `.prettierignore` file in the `app` blueprint:

```diff
+ /pnpm-lock.yaml
```

To make sure Prettier does not format pnpm's lockfile.

We would also need to make sure that every file generated by the `app` blueprint is formatted correctly.

## How We Teach This

N/A

## Drawbacks

- Some developers or teams prefer running Prettier via ESLint and Stylelint

## Alternatives

N/A

## Unresolved Questions

N/A


---

---
stage: accepted
start-date: 2025-01-10T00:00:00.000Z
release-date:
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - data
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1065
project-link:
---

<!---
Directions for above:

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
-->

# Deprecate and Remove ember-fetch 

## Summary

This RFC proposes removing `ember-fetch` from the blueprint for new projects, and recommends alternative, more native, ways of having "managed fetch".

## Motivation

The package, `ember-fetch`, does a fair bit of deceptive and incorrect behavior that is incompatible with modern JavaScript tooling, such as _being_ `ember-fetch`, yet only importing from `fetch`.

## Transition Path

- Remove ember-fetch from all blueprints
- Deprecate the npm package and archive the github repo.
- Migrate to an alternative for "managed fetch" 

### What does `ember-fetch` do?

_Primarily_, it wraps the native `fetch` in `waitForPromise` from `@ember/test-waiters` (aka "settled state integration").


Secondarily, but not popularly used, are a series of utilities (e.g.: for checking kinds of errors). These could be copied into projects that use them and modified to fit each project's needs. 

### Using native `fetch`

If you only use `ember-fetch` in route model-hooks, then the settled-state integration isn't used (or rather, you rely on the routing's settled-state integration, and `ember-fetch`'s settled-state integration is extraneous) 


### Direct replacement


To replace `ember-fetch`'s core-functionality using the least amount of effort involves adding a new utility in `@ember/test-waiters`, `waitForFetch`:

```ts
// in @ember/test-waiters
import { waitForPromise } from './wait-for-promise';

export async function waitForFetch<Value>(fetchPromise: Promise<Value>) {
    waitForPromise(fetchPromise);

    let response = await fetchPromise;

    return new Proxy(response, {
        get(target, prop, receiver) {
            let original = Reflect.get(target, prop, receiver);

            if (['json', 'text', 'arrayBuffer', 'blob', 'formData'].includes(prop)) {
                return (...args) => {
                    let parsePromise = original.call(target, ...args);

                    return waitForPromise(parsePromise);
                }
            }

            return original;
        }
    });
}
```


To have a single import mirroring the behavior of `ember-fetch`, _in full_, folks can still provide a single export that does:

```ts
import { waitForFetch } from '@ember/test-waiters';

export function wrappedFetch(...args: Parameters<typeof fetch>) {
    return waitForFetch(fetch(...args));
}
```


And then throughout your project, you could find and replace all imports of `import fetch from 'fetch';` with `import { wrappedFetch } from 'app-name/utils/wrapped-fetch';`



### Using a service

Potentially an easier-to-manage implementation uses a service such as the following:

```ts
import Service from '@ember/service';
import { waitFor } from '@ember/test-waiters';

export default class Fetch extends Service {

    @waitFor
    @action
    requestJson(...args: Parameters<typeof fetch>) {
        return fetch(...args).then(response => response.json());
    }

    @waitFor
    @action
    requestText(...args: Parameters<typeof fetch>) {
        return fetch(...args).then(response => response.text());
    }
}
```

### Using warp-drive / ember-data

Docs available on https://github.com/emberjs/data/

## How We Teach This

- Add a deprecation notice to the ember-fetch README
- Archive the ember-fetch repo
- Remove ember-fetch from the blueprints
- Remove ember-fetch from the guides (only one reference per version)

## Drawbacks

- if we keep ember-fetch is not compatible with modern tooling and modern SSR approaches

## Alternatives

- n/a
- ask folks to wrap and proxy fetch themselves

## Unresolved questions

none


---

---
stage: accepted
start-date: 2025-01-12T00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - data
  - framework
  - learning
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1068 
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Built in tracking utilities for common collections 

## Summary

This RFC proposes making the set of collections from `tracked-built-ins` built in to the framework, in a byte-wise opt-in in a brand new package (`@ember/reactive`) and able to be used without `new`.

Additionally, these APIs can unblock the implementation of [RFC#1000: Make array built-in in strict mode](https://github.com/emberjs/rfcs/pull/1000) and [RFC#999: make hash built in in strict mode](https://github.com/emberjs/rfcs/pull/999) (but this is not the main focus of this RFC and only _could_ be an outcome).

## Motivation

tl;dr:

- performance 
- discoverability
- aiming towards better cohesion 

Because `tracked-built-ins` is built on top of public APIs, in particular, `ember-tracked-storage-polyfill`, we can expect to gain performance benefits by implementing the tracked collections directly into the framework, as we can eliminate ~2 layers of abstraction/wrapping.


Additionally, `tracked-built-ins` not being built in to the framework, or properly documented in the ember guides has had some negative consequences on folks apps.

For example, this often-inefficient pattern of re-assigning the whole reference. 
```js
@tracked value = [];
addItem = (x) => {
    this.value = [...this.value, x];
}
```

For large sets of data, rendered in a list (often tables), this pattern causes unneeded work in the reactivity-system.

We now know that `tracked-built-ins`' `TrackedArray` would be a good way to only _append_ an item to the array, and thus append DOM to our UI, without the reactive system doing anything to the data that hasn't changed.

Some may argue that it's our renderer's responsibility to detect this situation, and optimize best it can, and while there are opportunities we can find to optimize rendering, we also can't make an assumption that _either_ re-assigning or tracked collection usage is going to be the most performant. Developers can measure in their own app.


This is outside the scope of this RFC, but for some underlying motivation,
another motivation is along the lines of [reigning in our imports](https://github.com/emberjs/rfcs/pull/1060#issuecomment-2557737145) over time, potentially by eventually reclaiming the `'ember'` package, so that there is a simple package.json that can be _the framework_, which aligns with real imports (or re-exports) so that we don't _require_ build-system gymnastics in order to build ember apps.

<details><summary>examples</summary>

Old:
```js
import Route from '@ember/routing/route';
import Service, { service } from '@ember/service';
import Component from '@glimmer/component';
import { tracked, cached } from '@glimmer/tracking';
```

New:
```js
import Route from 'ember/routing/route';
import Service, { service } from 'ember/service';
import Component from 'ember/glimmer';
import { tracked, cached } 'ember/reactive';
```

The details of this are absolutely up for debate -- this is just demonstrating the concept -- by re-exporting everything from a single package, it gives folks an opportunity to use ember without embroider -- and without any build at all. 

</details>

## Detailed design

while _most of this_ already implemented, here is the behavior we expect when using any tracked wrapper:

- all property accesses should "entangle" with that property 
- all property sets should "dirty" that property
- changes to the length, or overall collection, is represented by an invisible-to-users "collection" internal tracked property, so that iteration can be dirtied
- changes to a collection (add, insert, delete, etc) should cause iteration (each, each-in) to only render what changed and not cause unneeded renders 
- changes to a collection copy the original passed in data -- keeping inline with the existing `tracked-built-ins` behavior
- deleting an entry in a collection should relieve memory pressure
- deleting an entry in a collection should dirty the "collection"
- prototype and `instanceof` checks should still work, e.g.: a `TrackedArray` should still return true from `Array.isArray`, and an instance of `TrackedSet` should be an `instanceof Set`.
- no `@dependentKeyCompat`, see: [`@ember-compat/tracked-built-ins`](https://www.npmjs.com/package/@ember-compat/tracked-built-ins)

How do we handle when the platform adds new APIs?

For example, Set has had new APIs added recently, and `tracked-built-ins` had to be updated to support those, so if possible, it would be ideal to rely on deferring to the underlying implementation as much as possible, rather than re-implementing a class-wrapper for all known methods -- proxies are particularly good at this -- and while folks have had complaints about proxies in the past, the user-facing API and underlying implementation of all these proxies would be the exact same, so the proxy isn't hiding anything.


Additionally, unlike in `tracked-built-ins`, we would not expose the _constructor APIs_; Mirroring the [Cell](https://github.com/emberjs/rfcs/pull/1071) proposal, also allowing customizable equality checking.


### The import

```js
import { 
    // able to be used in templates, no 'new'
    trackedObject, trackedArray, 
    trackedMap, trackedWeakMap,
    trackedSet, trackedWeakSet
} from '@ember/reactive';
```

### `trackedObject`, `trackedArray`, `trackedMap`, etc

These utilities wrap the call to their respective constructors. For example, for `trackedObject`, the implementation and type declaration may look like this:

```ts
export function trackedObject<Value>(
    data?: Value, 
    options?: { 
        equals?: (a, b) => boolean;
        description?: string;
    }
): NonNullable<Value> {
    return new TrackedObject(
        data, 
        { 
            equals: options.equals ?? Object.is,
            description: options.description,
        }
    );
}
```

Some examples assuming implementation of [RFC#998: Make fn built-in in strict-mode](https://github.com/emberjs/rfcs/pull/998) as well as [RFC#997: Make on built-in in strict-mode](https://github.com/emberjs/rfcs/pull/997):

#### Example `trackedArray`


```gjs
import { trackedArray } from '@ember/reactive';

const nonTrackedArray = [1, 2, 3];
const addTo = (arr) => arr.push(Math.random());

<template>
    {{#let (trackedArray nonTrackedArray) as |arr|}}
        {{#each arr as |datum|}}
            {{datum}}
        {{/each}}

        <button {{on 'click' (fn addTo arr)}}>Add Item</button> 
    {{/let}}
</template>
```

> [!NOTE]  
> Since [RFC#1000: Make Array built-in in strict mode](https://github.com/emberjs/rfcs/pull/1000) is stalled due to the original implementation of `(array)` being underspecified, the new implementation of the built in `(array)` could use this `trackdArray` implementation instead of re-defining the specification of how `(array)` works -- and this new implementation would probably more align with how folks expect `(array)` to work.

With RFC#1000, the above example would be behaviorally equivalent to:
```gjs
const nonTrackedArray = [1, 2, 3];
const addTo = (arr) => arr.push(Math.random());

<template>
    {{#let (array nonTrackedArray) as |arr|}}
        {{#each arr as |datum|}}
            {{datum}}
        {{/each}}

        <button {{on 'click' (fn addTo arr)}}>Add Item</button> 
    {{/let}}
</template>
```

#### Example `trackedObject`

```gjs
import { trackedObject } from '@ember/reactive';

const nonTrackedObject = { a: 1 };
const addTo = (obj) => obj[Math.random()] = Math.random();

<template>
    {{#let (trackedObject nonTrackedObject) as |obj|}}
        {{#each-in obj as |key value|}}
            {{key}} => {{value}}</br>
        {{/each-in}}

        <button {{on 'click' (fn addTo obj)}}>Add Pair</button>
    {{/let}}
</template>
```

> [!NOTE]  
> Since [RFC#999: Make hash built-in in strict mode](https://github.com/emberjs/rfcs/pull/999) is stalled due to the original implementation of `(hash)` being underspecified, the new implementation of the built in `(hash)` could use this `trackedObject` implementation instead of re-defining the specification of how `(hash)` works -- and this new implementation would probably more align with how folks expect `(hash)` to work.


With RFC#999, the above example would be behaviorally equivalent to:

```gjs
const nonTrackedObject = { a: 1 };
const addTo = (obj) => obj[Math.random()] = Math.random();

<template>
    {{#let (hash nonTrackedObject) as |obj|}}
        {{#each-in obj as |key value|}}
            {{key}} => {{value}}</br>
        {{/each-in}}

        <button {{on 'click' (fn addTo obj)}}>Add Pair</button>
    {{/let}}
</template>
```

### `@ember/reactive`

The process of making libraries support wide-ranges of `ember-source` is known. `ember-source` has recently been adapting its release process to use [release-plan][gh-release-plan], so that the [ember.js][gh-emberjs] repo can publish multiple packages seemslessly, rather than always bundle everything under one package.

With those new release capabilities within the [ember.js][gh-emberjs] repo, Instead of a polyfill for older versions of ember, `@ember/reactive`, the package (at the time of this RFC, does not exist, but would have the two exported utilities from it), would be published as its own `type=module` package _and_ included with ember-source, as to not add more dependencies to the package.json going forward.

[gh-release-plan]: https://github.com/embroider-build/release-plan
[gh-emberjs]: https://github.com/emberjs/ember.js/

Why `type=module`?

This is a requirement for some optimization features of packages (webpack / vite), such as _proper_ treeshaking -- without `type=module`, the best optimization we can get is "pay for only what you import". For large projects this isn't so much of a problem, but for small projects (or highly optimized projects), the impact to network transfer/parse/eval is measurable. This RFC is also proposing that `@ember/reactive` be _the_ place for all our ecosystem's reactivity utilities will end up once they've been proven out, tested, and desire for standardization is seen.

For example, other future exports from `@ember/reactive` (in future RFCs), may include:
- Resource
- AsyncResource
- TrackedPromise
- localCopy
- certain [window properties](https://svelte.dev/docs/svelte/svelte-reactivity-window)
- ...and more

without the static analysis guarantees of `type=module`, every consumer of `@ember/reactive` would always have all of these exports in their build.
For some utilities, we can place them under sub-path-exports, such as `@ember/reactive/window`, for window-specific reactive properties, but the exact specifics of each of these can be hashed out in their individual RFCs.


### Consumption

`@ember/reactive` would be another virtual package built in to ember-source, much like `@ember/service`, etc.

For polyfilling, a library could be created that uses `ember-addon.renamed-modules` to instruct our build tooling about a virtual package -- the same technique that `ember-source` uses. 

Once a project updates to a sufficiently new enough ember-source, the polyfilling library should be deleted.

## How we teach this

### API Docs

Most of the API docs are already written in `tracked-built-ins`, so we can re-use those. 

We would need to adapt all examples as well as the new template-oriented helpers to not use the `new`-able APIs, as those would not be exposed. 

#### `trackedArray`

A utility for creating tracked arrays, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedArray` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

```gjs
import { trackedArray } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedArray = [1, 2, 3];
const addTo = (arr) => arr.push(Math.random());

<template>
    {{#let (trackedArray nonTrackedArray) as |arr|}}
        {{#each arr as |datum|}}
            {{datum}}
        {{/each}}

        <button {{on 'click' (fn addTo arr)}}>Add Item</button> 
    {{/let}}
</template>
```

#### `trackedObject`

A utility for creating tracked objects, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedObject` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

```gjs
import { trackedObject } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedObject = { a: 1 };
const addTo = (obj) => obj[Math.random()] = Math.random();

<template>
    {{#let (trackedObject nonTrackedObject) as |obj|}}
        {{#each-in obj as |key value|}}
            {{key}} => {{value}}</br>
        {{/each-in}}

        <button {{on 'click' (fn addTo obj)}}>Add Pair</button>
    {{/let}}
</template>
```

#### `trackedMap`

A utility for creating tracked maps, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedMap` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)

```gjs
import { trackedMap } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedMap = new Map();
nonTrackedMap.set('a', 1);
const addTo = (map) => map.set(Math.random(), Math.random());

<template>
    {{#let (trackedMap nonTrackedMap) as |map|}}
        {{#each-in map as |key value|}}
          {{key}} => {{value}}</br>
        {{/each-in}}

        <button {{on 'click' (fn addTo map)}}>Add Pair</button>
    {{/let}}
</template>
```

#### `trackedWeakMap`

A utility for creating tracked weak maps, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedWeakMap` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)

```gjs
import { trackedWeakMap } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedWeakMap = new WeakMap();

<template>
    {{#let (trackedWeakMap nonTrackedWeakMap) as |weakMap|}}

        {{log weakMap}}

    {{/let}}
</template>
```

#### `trackedSet`

A utility for creating tracked maps, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedMap` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)

```gjs
import { trackedSet } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedSet = new Set();
nonTrackedSet.add(1);
const addTo = (set) => set.add(Math.random());

<template>
    {{#let (trackedMap nonTrackedMap) as |set|}}
        {{#each set as |value|}}
          {{value}}</br>
        {{/each}}

        <button {{on 'click' (fn addTo set)}}>Add</button>
    {{/let}}
</template>
```

#### `trackedWeakSet`

A utility for creating tracked weak sets, copying the original data so that mutations to the tracked data don't mutate the original untracked data. 

`trackedWeakSet` can be used in templates and in JavaScript via import

See [MDN for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)

```gjs
import { trackedWeakSet } from '@ember/reactive';
import { on } from '@ember/modifier';
import { fn } from '@ember/helper';

const nonTrackedWeakSet = new WeakSet();

<template>
    {{#let (trackedWeakSet nonTrackedWeakSet) as |weakSet|}}

        {{log weakSet}}

    {{/let}}
</template>
```

### Guides

Existing places that import from `tracked-built-ins` would update to the new imports -- no other changes would be needed.

- [This page](https://guides.emberjs.com/release/configuring-ember/disabling-prototype-extensions/#toc_tracking-of-changes-in-arrays) needs to be updated as `@glimmer/tracking` doesn't have `TrackedArray` today.

Something that could be used today, and definitely should be added is a page on how to handle referential integrity. Most of the "tracked" guides only touch on tracking _references_ (via `@tracked`). For example, each of `trackedArray`, `trackedMap`, `trackedSet`, etc can be used in these ways:

#### Static reference

```js
class Demo {
    collection = trackedMap();
}
```

Changes to `this.collection` can only happen via `Map` methods.

#### Double static reference

```js
class Demo {
    @tracked collection = trackedMap();
}
```
Changes to `this.collection` can happen via `Map` methods, as well as replacing the entirely collection can occur via re-assigning `this.collection` to a brand new `TrackedMap`. This also has a potential performance hazard, of re-assigning `this.collection` to a clone of the `TrackedMap`.

#### Based on Args

```js
class Demo extends Component {
    @cached
    get collection() {
        return trackedMap(this.args.otherData);
    }
}
```
Changes to the collection can happen via `Map` methods, as well as changes to `@otherData` will cause the entirety of `this.collection` to be re-created, with the previous instance being garbage collected. Usage of `@cached` is important here, because repeat-accesses to `this.collection` would otherwise create completely unrelated `trackedMap`s -- i.e.: Updating a `TrackedMap` would have no effect on a `TrackedMap` read elsewhere as they are different instances.  

### Migration

We should do a codemod to convert the newable constructors from tracked-built-ins to the direct-callable variants proposed in this RFC.

Using Vite or Webpack (Embroider 3+), we can alias `tracked-built-ins` to point at the new modules, using a shim -- for example:
```js 
// app/built-ins-shim.js
import { trackedArray } from '@ember/reactive';

export class TrackedArray {
    constructor(arr) {
        return trackedArray(arr);
    }
}

// etc
```


## Drawbacks

- A migration
  - however, the migration is completely optional as `tracked-built-ins` would still exist. The benefit to this RFC is for new projects, and apps that care more about performance.

## Alternatives

- reclaim the `ember` package and export under `ember/reactive`, add `ember` to the package.json.
  - doing this _would_ require a polyfill, as `ember` is already available in all versions of projects, but it does not have sub-path-exports that folks use.
- use `/reactivity` instead of `/reactive`
- re-use `@glimmer/tracking`
  - would require that `@glimmer/tracking` move in to the `ember-source` repo
  - would also require a polyfill, as prior versions of `@glimmer/tracking` would not have the new behaviors
  - there is an existing typo in the guides that hints at using this already for `TrackedArray`

## Unresolved questions

none (yet)


---

---
stage: released
start-date: 2025-01-18T00:00:00.000Z
release-date:
release-versions:
  babel-plugin-ember-template-compilation: 2.4.0 
teams:
  - cli
  - framework
  - learning
prs:
  accepted: 'https://github.com/emberjs/rfcs/pull/1070'
  ready-for-release: 'https://github.com/emberjs/rfcs/pull/1083'
  released: 'https://github.com/emberjs/rfcs/pull/1095'
project-link:
suite:
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

# Default globals for strict mode 

## Summary

This RFC aims to introduce platform-native globals as allowed defaults in strict-mode components, allowing for more intuitive usage, and less "know how the compiler works" 

This is an ergonomics-focused RFC. The proposed changes today can be polyfilled via `globalThis['...']` accesses.

## Motivation

Early on there was a bug in the build tools of strict-mode components that allowed _any_ global to be used components. This was dangerous, as strict-mode allows use of all in-scoped variables to be used in all valid syntax positions in the template, and while this is what folks would expect for languages with a scope-system, it means that if someone defined `window.div`, all `<div>`s in components would use that implementation instead.  This was fixed, but during that time, we realized that it's _very_ convenient to use platform-native globals as utilities, such as `Array`, `Boolean`, `String`, `Infinity`, `JSON`, and many more.

While we don't want to support _everything_ on `globalThis`, we can aim support a good list of utilities fitting some criteria. Committing to this list means that we promise to never create a keyword with the same name + casing as the platform-native API, likewise, having an allow-list of which platform-native APIs to support guides our decisions around what keywords to implement in templates, as the platform-native globals would take precedence over / be used instead of any same-named keywords. 

Without this RFC, all platform-native globals must be accessed via globalThis:

```gjs
<template>
  {{globalThis.JSON.stringify @data null 3}}
</template>
```
or
```gjs
const { JSON } = globalThis;

<template>
  {{JSON.stringify @data null 3}}
</template>
```

After this RFC is implemented, the following would work:
```gjs
<template>
  {{JSON.stringify @data null 3}}
</template>
```

## Detailed design

Allowing defaults means: when using `JSON` (for example) in a component, the compiled-to-plain-JS output results in the reference to JSON being added to the "scope bag", for example: :

```js
// Post-RFC 931
import { template } from '@ember/template-compiler'; 

const data = {};

export default template('{{JSON.stringify data}}', { scope: () => ({ JSON, data }) });
```

<details><summary>pre-RFC#931</summary>

```js
// Pre-RFC  931
import { precompileTemplate } from "@ember/template-compilation";
import { setComponentTemplate } from "@ember/component";
import templateOnly from "@ember/component/template-only";

const data = {};

export default setComponentTemplate(
    precompileTemplate('{{JSON.stringify data}}', { 
        strictMode: true, 
        scope: () => ({ JSON, data }) }
    ), templateOnly()
);
```

</details>

Criteria for a platform-native global to be accepted as default:

Any of
- begins with an uppercase letter 
- guaranteed to never be added to glimmer as a keyword (e.g.: `globalThis`)

And
- must not need `new` to invoke
- must not require lifetime management (e.g.: `setTimeout`)
- must not be a single-word lower-case API, because of potential collision with future [new HTML elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)
- if the API is a function, the return value should not be a promise
- must be one one of these lists:
  - https://tc39.es/ecma262/#sec-global-object
  - https://tc39.es/ecma262/#sec-function-properties-of-the-global-object
  - https://html.spec.whatwg.org/multipage/nav-history-apis.html#window
  - https://html.spec.whatwg.org/multipage/indices.html#all-interfaces    
  - https://html.spec.whatwg.org/multipage/webappapis.html


> [!IMPORTANT]  
> Because all function invocations are reactive by default, every function called from these APIs will be re-called when arguments change. 


Given the above criteria, the following should be added to default-available strict-mode scope:

### namespaces / objects

TC39:

- [`globalThis`](https://tc39.es/ecma262/#sec-globalthis) - Already available. 

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=MYewdgzgLgBAJgQygmBeGBvGBzATgU3ygEsxsAuGAcgAt8AbekGKOggQipgF8BuAKH4AeKPgC2AB3pJ8APn4xMGbEwBGCegBUaxCADoAUgGUA8gDk90XKWzEAZgE94SBN27CA9KMnTRsoA&format=gjs)
    ```gjs
    <template>
        {{JSON.stringify @data}}
    </template>
    ```

    </details>

- [`Atomics`](https://tc39.es/ecma262/#sec-atomics)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=MYewdgzgLgBARgVwGZIKYCcYF4ZlQdxgEF10BDATwCFk10AKARgDYBKAbgChRJYEBLMFAAc2XARgBVQSJLkK9RCgwdOAocIDaABgC6YgOxdOAehMwDMetsa3WMABoB5AEowATFe03t9nAFYvRhtWAB44dAA%2BTiIoEABbfmAIADoADxAGdREAGhhtPPdWTk5QqFR4gAcAGzJy6JgYAG8mgHNqkDgyaoAVAAt%2BVNiEpNSOsgATGGzhAF9Z0pNyqtr6oA&format=gjs)
    ```gjs
    const buffer = new ArrayBuffer(16);
    const uint8 = new Uint8Array(buffer);
    uint8[0] = 7;

    // 7 (0111) XOR 2 (0010) = 5 (0101)<br>
    Atomics.xor(uint8, 0, 2)

    <template>
      {{Atomics.load uint8}} === 5
    </template>
    ```

    </details>


- [`JSON`](https://tc39.es/ecma262/#sec-json)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=MYewdgzgLgBAJgQygmBeGBvGBzATgU3ygEsxsAuGAcgAt8AbekGKOggQipgF8BuAKH4AeKPgC2AB3pJ8APn4xMGbEwBGCegBUaxCADoAUgGUA8gDk90XKWzEAZgE94SBN27CA9KMnTRsoA&format=gjs)
    ```gjs
    <template>
        {{JSON.stringify @data}}
    </template>
    ```

    </details>

- [`Math`](https://tc39.es/ecma262/#sec-math)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOgFklzaoEAPNABjQCY0AWAL6DQAekixEKIA&format=gjs)
    ```gjs
    <template>
      {{Math.max 0 2 4}}
    </template>
    ```

    </details>

- [`Reflect`](https://tc39.es/ecma262/#sec-reflect)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=MYewdgzgLgBAJgQygmBeGBvGBzATgU3ygEsxsAuGAcgAt8AbekGKOgqmAXwG4AoXgDxR8AWwAO9JPgB8vGJgzYmAIwT0AKjWIQAdACV8AM3r5gUHdiLwkKKnkIkyVTp0EB6YeMnDpQA&format=gjs)
    ```gjs
    const data = { greeting: 'hello there' };

    <template>
      {{Reflect.get data 'greeting'}}
    </template>
    ```

    </details>

WHATWG:

- [`localStorage`](https://html.spec.whatwg.org/multipage/webstorage.html#the-localstorage-attribute)

    <details><summary>Example</summary>

    Example[^glimmer-call-bug]
    ```gjs
    <template>
      Current Theme: {{localStorage.getItem 'theme'}}

      <button {{on 'click' @toggleTheme}}>
        Toggle
      </button>
    </template>
    ```

    </details>

- [`sessionStorage`](https://html.spec.whatwg.org/multipage/webstorage.html#the-sessionstorage-attribute)

    <details><summary>Example</summary>

    Example[^glimmer-call-bug]
    ```gjs
    <template>
      Current Theme: {{sessionStorage.getItem 'theme'}}

      <button {{on 'click' @toggleTheme}}>
        Toggle
      </button>
    </template>
    ```

    </details>


### functions / utilities

TC39:

- [`isNaN`](https://tc39.es/ecma262/#sec-isnan-number)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wYgJYBmaAFAOZwD2ARgnACoAWeAzgHQsByCHaADAJQBfQegxoWaLh1HYIcZhGGiMEgrQUBPGZgD0hJSB2RYiFEA&format=gjs)
    ```gjs
    <template>
      {{#if (isNaN 0)}}
        is NaN
      {{else}}
        is falsey
      {{/if}}
    </template>
    ```

    </details>

- [`isFinite`](https://tc39.es/ecma262/#sec-isfinite-number)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wYgJYBmaAFAOZwD2ARgnACoAWeAzgHQsBieAdnpGuWq1GLVgEluBHnwCeASgC%2BC9BjQs0XXpBXYIcZhCUqM6grQMydmAPSEjIa5FiIUQA&format=gjs)
    ```gjs
    <template>
      {{#if (isFinite Infinity)}}
        is Finite
      {{else}}
        is falsey
      {{/if}}
    </template>
    ```

    </details>

- [`parseInt`](https://tc39.es/ecma262/#sec-parseint-string-radix)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOhgQCdqIBJAOzDQCZaBmAL4DQAekixEKIA&format=gjs)
    ```gjs
    <template>
      {{parseInt 2.3}} 
    </template>
    ```

    </details>

- [`parseFloat`](https://tc39.es/ecma262/#sec-parsefloat-string)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOhgQCdqIAxApNAJloGYBffqAD0kWIhRA&format=gjs)
    ```gjs
    <template>
      {{parseFloat 2.3}} 
    </template>
    ```

    </details>

- [`decodeURI`](https://tc39.es/ecma262/#sec-decodeuri-encodeduri)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOgBMIBjfRgVQCUBJNAIgFIArACEAHkIAivAL7S0oAPSRYiFEA&format=gjs)
    ```gjs
    <template>
      {{decodeURI "%5Bx%5D"}} 
    </template>
    ```

    </details>

- [`decodeURIComponent`](https://tc39.es/ecma262/#sec-decodeuricomponent-encodeduricomponent)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOgBMIBjfRgVQCUBJAYX1nwA7CILBoARAFIArACEAHjIAi4gL6q0oAPSRYiFEA&format=gjs)
    ```gjs
    <template>
      {{decodeURIComponent "%5Bx%5D"}} 
    </template>
    ```

    </details>

- [`encodeURI`](https://tc39.es/ecma262/#sec-encodeuri-uri)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOggDsBjfAEwgFUAlASTQCIA2gA8AuvwC%2BEtKAD0kWIhRA&format=gjs)
    ```gjs
    <template>
      {{encodeURI "[x]"}} 
    </template>
    ```

    </details>

- [`encodeURIComponent`](https://tc39.es/ecma262/#sec-encodeuricomponent-uricomponent)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOggDsBjfAEwgFUAlASQGF8sfA0Zg0AIgDaADwC64gL4K0oAPSRYiFEA&format=gjs)
    ```gjs
    <template>
      {{encodeURIComponent "[x]"}} 
    </template>
    ```

    </details>

WHATWG:

- [`postMessage`](https://html.spec.whatwg.org/multipage/web-messaging.html#dom-window-postmessage)

    <details><summary>Example</summary>

    ```gjs
    <template>
        <button {{on "click" (postMessage "Hello")>
            Greet
        </button>
    </template>
    ```

    </details>

- [`structuredClone`](https://html.spec.whatwg.org/multipage/structured-data.html#dom-structuredclone)

    <details><summary>Example</summary>

    ```gjs
    <template>
        <SomeComponent @data={{structuredClone @inputData}} />
    </template>
    ```


    </details>


### new-less constructors (still functions / utilities)

TC39:

- [`Array`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-array)

    <details><summary>Example</summary>

    See note[^reactive-array-note] about `(array)`, `@ember/helper`, and [RFC#1000](https://github.com/emberjs/rfcs/pull/1000)[^reactive-array-note]

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wYjHAYwAtUAKAcxgHsAjOGAFSIEsBnAOgEEAnbuAT1QBGVACZUAZgCUqOK1QAfZuAgKAvmrQZt2ZZA1b02APT5iB4MZWwEYFEA&format=gjs)
    
    ```gjs
    <template>
        {{#each (Array 1 2 3) as |item|}}
            {{item}}
        {{/each}}
    </template>
    ```

    [^reactive-array-note]: This is the same behavior as `(array)` in loose mode, and `import { array } from '@ember/helper';`, however, while the creation of the array is reactive (e.g.: if we had said `(Array @foo @bar)`, changes to `@foo` and `@bar` would cause the creation of a new array instance), the proposed _built-in_ `(array)` _keyword_ behavior _may_ have reactive items, as proposed by [RFC#1068](https://github.com/emberjs/rfcs/pull/1068) 

    </details>



- [`BigInt`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-bigint)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOgCFKcBJAOxFQCIAGADwEYAZsJGiRnAL4TkwAPTho8JMiA&format=gjs)
    ```gjs
    <template>
        {{BigInt "0x1fffffffffffff"}}
    </template>
    ```

    </details>

- [`Boolean`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-boolean)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wYgJYBmqAFAOYwD2ARnDACoAWeAzgHQBCFFMYcAdqgBEggJQBfMWgzoQAJwCuYKemxgYzMBOUYCtDduwB6QluCHw0eEmRA&format=gjs)
    ```gjs
    <template>
        {{#if (Boolean "")}}
          true
        {{else}}
          false
        {{/if}}
    </template>
    ```

    </details>

- [`Date`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-date)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOgBEExUBGAdgGY2AmAFg4AMAgKwBOPgF8JyYAHpw0eEmRA&format=gjs)
    ```gjs
    <template>
        {{Date 1737243005924}}
    </template>
    ```

    </details>

- [`Number`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-number)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOgDkBXCQsAJ1QCIAmbzgX37JgAenDR4SZEA&format=gjs)
    ```gjs
    <template>
        {{Number "22"}}
    </template>
    ```

    </details>

- [`Object`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-object)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wYjHAYwAsBaASwDtUAKAcxgHsAjOGAFSLIGcA6AeSYArMARCo4AXgCMqJhIBMASnFdUAHwDWYAJ6oAbqwCuYNQF9TaDOmxbt5gFxZMBmMfOXrmAPT5i5Cu7AXuDQ8EjIQA&format=gjs)
    ```gjs
    <template>
        {{#each-in (Object a=1 b=2) as |key value|}}
          {{key}}: {{value}}
        {{/each-in}}
    </template>
    ```

    </details>

- [`String`](https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object-string)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOgGUQAnSgOx1QCZOBfH5YAHpw0eEmRA&format=gjs)
    ```gjs
    <template>
        {{String 22}}
    </template>
    ```

    </details>

### Values

TC39:

- [`Infinity`](https://tc39.es/ecma262/#sec-value-properties-of-the-global-object-infinity)

    <details><summary>Example</summary>

    ```gjs
    <template>
        {{Infinity}}
    </template>
    ```

    </details>

- [`NaN`](https://tc39.es/ecma262/#sec-value-properties-of-the-global-object-nan)

    <details><summary>Example</summary>

    ```gjs
    <template>
        {{NaN}}
    </template>
    ```

    </details>

WHATWG:

- [`isSecureContext`](https://html.spec.whatwg.org/multipage/webappapis.html#dom-issecurecontext)

    <details><summary>Example</summary>

    ```gjs
    <template>
        {{#if isSecureContext}}
            is secure
        {{/if}}
    </template>
    ```

    </details>



### Potentially matching criteria, but not included

Existing keywords don't need to be included in the global scope allow-list

- [`undefined`](https://tc39.es/ecma262/#sec-undefined)

These do not exist in all supported environments:

- [`Encode`](https://tc39.es/ecma262/#sec-encode)
- [`Decode`](https://tc39.es/ecma262/#sec-decode)
- [`ParseHexOctet`](https://tc39.es/ecma262/#sec-parsehexoctet)

These are not common and / or may be actively dangerous to make easier to use:

- `eval`
- `PerformEval`
- `Function`

Uncommon entries from the "Constructor Properties" list: https://tc39.es/ecma262/#sec-constructor-properties-of-the-global-object
- `${...}Error`, e.g.: `AggregateError`
- `${...}Int${...}Array`, e.g.: `BigUint64Array`,
- anything that requires `new`, e.g.:  `DataView`, `Map`

APIs from WHATWG that are highly likely to collide with user-land code or are already ambiguous (and thus would be confusing to use):

- `stop()`, `close()`, `status()`, `focus()`, `blur()`, `open()`, `parent`, `confirm()`, `self`, etc


## How we teach this

Developers should primarily reference exising documentation on the web for the above-mentioned APIs, such as on MDN.

If we don't already, we should have an extensive guide on Polish Syntax, potentially similar to [https://cheatsheet.glimmer.nullvoxpopuli.com/docs/templates](https://cheatsheet.glimmer.nullvoxpopuli.com/docs/templates)

## Drawbacks

Takes a small amount of work to implement.


## Alternatives

- Do nothing, but this is worse, as folks intuitively expect these a lot of the above-mentioned APIs to "just work", without needing weird scope-tricks to convince our Scope-tracking tools in the build tools that certain APIs are in scope..

- Add some single-word globals, despite the potential future risk of HTML element being implemented with the same word / casing

WHATWG:

- [`atob`](https://html.spec.whatwg.org/multipage/webappapis.html#dom-btoa)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOgSNQCI4BxANWsNYA4BeJgF9ByYAHpw0eEmRA&format=gjs)

    ```gjs
    <template>
        {{atob "aGVsbG8="}}
    </template>
    ```

    </details>

- [`btoa`](https://html.spec.whatwg.org/multipage/webappapis.html#dom-atob)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=DwFwpgtgDgNghuAfAKAATtQb0wcxgewCM4YAVACwEsBnAOkJHzlQCJywYCWBfb5YAPTho8JMiA&format=gjs)

    ```gjs
    <template>
        {{btoa "hello"}}
    </template>
    ```

    </details>


- [`location`](https://html.spec.whatwg.org/multipage/nav-history-apis.html#dom-location)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOgIGMlL8A7W8gJwgDM0BffqAD0kWIhRA&format=gjs)
    ```gjs
    <template>
      {{location.href }}
    </template>
    ```

    </details>

- [`history`](https://html.spec.whatwg.org/multipage/nav-history-apis.html#dom-history)

    <details><summary>Example</summary>

    Example[^glimmer-call-bug]
    ```gjs
    import { on } from '@ember/modifier';

    <template>
      <button {{on 'click' history.back}}>Back</button>
    </template>
    ```
    [^glimmer-call-bug]: demo/example omitted because the glimmer-vm, at the time of the writing of this RFC has not fixed a bug that where this-binding is lost on method calls.

    </details>

- [`navigator`](https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator)

    <details><summary>Example</summary>

    [Link](https://limber.glimdown.com/edit?c=FAHgLgpgtgDgNgQ0gPmAAjQb0wczgewCME4AVACwEsBnAOgDsEA3SnJfAJ1oFdqIOAgjgj0wAXzGgA9JFiIUQA&format=gjs)
    ```gjs
    <template>
      {{navigator.userAgent}}

      <button {{on 'click' (fn navigator.clipboard.write @blob)}}>
        Copy to clipboard
      </button>
    </template>
    ```

    </details>

- [`window`](https://html.spec.whatwg.org/multipage/nav-history-apis.html#dom-window)

    Most APIs are also available on `window`

- [`document`](https://html.spec.whatwg.org/multipage/nav-history-apis.html#dom-document-2)

    <details><summary>Example</summary>

    Example[^glimmer-call-bug]
    ```gjs
    <template>
      <div id='foo'></div>
      
      {{#in-element (document.getElementById 'foo')}}
          rendered elsewhere
      {{/in-element}}
    </template>
    ```

    </details>




## Unresolved questions

none


---

---
stage: accepted
start-date: 2025-02-13T00:00:00.000Z # In format YYYY-MM-DDT00:00:00.000Z
release-date: # In format YYYY-MM-DDT00:00:00.000Z
release-versions:
teams: # delete teams that aren't relevant
  - cli
  - data
  - framework
  - learning
  - steering
  - typescript
prs:
  accepted: https://github.com/emberjs/rfcs/pull/1075
project-link:
suite: 
---

<!--- 
Directions for above: 

stage: Leave as is
start-date: Fill in with today's date, 2032-12-01T00:00:00.000Z
release-date: Leave as is
release-versions: Leave as is
teams: Include only the [team(s)](README.md#relevant-teams) for which this RFC applies
prs:
  accepted: Fill this in with the URL for the Proposal RFC PR
project-link: Leave as is
suite: Leave as is
-->

<-- Replace "RFC title" with the title of your RFC -->
# WarpDrive Package Unification

## Summary

Restructure the existing `@ember-data/*` and `@warp-drive/*` packages in order
to simplify the installation and configuration story while maintaining the benefits
of a multi-package architecture.

Required packages for a fully functional `ember.js` experience would be:

- `@warp-drive/core` (all the universal basics)
- `@warp-drive/ember` (reactivity and inspector integration, ember specific components)
- `@warp-drive/json-api` (cache implementation)

Additional packages that applications may choose to utilize would be:

- `@warp-drive/utilities`
- `@warp-drive/experiments`
- `@warp-drive/legacy`

A few packages would be deprecated, overall existing packages would remain and could still be individually installed and composed if desired.

## Motivation

WarpDrive is designed to be highly flexible and composable, with consuming applications able to
pick-and-choose combinations of packages alongside BYO/3rd-party implementations of interfaces.

WarpDrive packages generally try to follow a variation of the single-responsibility-principle:
while their surface area is larger than a single class or function, they tend to represent a
specific architectural boundary or concept and a group of tightly related primitives.

These are all good things, but it also makes the learning, onboarding and package.json maintenance
experience much harder once an application ejects from using the single `ember-data` package to
gain access to new features and abilities.

We want to rebalance the project, holding on to what has been great about small composable packages
while simplifying learning, onboarding and maintenance.

Now, as we rebrand to WarpDrive, seems an ideal opportunity to rebalance in this way as it gives us the opportunity to update names throughout.

## Detailed design

### The World Today

Currently, EmberData/WarpDrive publishes 18 primary source-code packages.

- `@ember-data/active-record`
- `@ember-data/adapter`
- `@ember-data/debug`
- `@ember-data/graph`
- `@ember-data/json-api`
- `@ember-data/legacy-compat`
- `@ember-data/model`
- `@ember-data/request`
- `@ember-data/request-utils`
- `@ember-data/rest`
- `@ember-data/serializer`
- `@ember-data/store`
- `@ember-data/tracking`
- `@warp-drive/build-config`
- `@warp-drive/core-types`
- `@warp-drive/ember`
- `@warp-drive/experiments`
- `@warp-drive/schema-record`

As well as the "meta" package which bundles together the needed dependencies and configures them for the "legacy" EmberData experience.

- `ember-data` 

We publish `mirror` and `types` packages for each of the primary 18 source-code repositories and the meta package (for a total of 57 published artifacts currently)

> [Info]
> Mirror packages allow for two-versions of the library to be used in a codebase
> simultaneously. Types packages allow older (pre 4.13/5.3) releases to consume
> the types from later releases as a way of getting a slightly better form of
> typescript support than what was offered by the DefinitelyTyped project.

We additionally publish a number of packages for tooling:

- `eslint-plugin-ember-data` (empty, reserved for security)
- `eslint-plugin-warp-drive`
- `warp-drive` (cli tool)

And as well we have multiple packages "under development", meaning they are currently unpublished but could become public in the future.

- `@warp-drive/holodeck`
- `@warp-drive/schema`
- `@warp-drive/diagnostic`

A final consideration: we plan to add packages for integrations with other ecosystems
as we expand the WarpDrive universe, these would be analogous to `@warp-drive/ember`

- `@warp-drive/{angular|vue|svelte|solidjs|etc}`

In short, lots of packages. So how do we clean this up and unify them?

### The World Tomorrow

We will introduce four new packages 🙈

- `@warp-drive/core`
- `@warp-drive/json-api`
- `@warp-drive/utilities`
- `@warp-drive/legacy`

Each of these four will also have a `mirror` (but not a `types`) equivalent. These four 
packages alongside the exising packages `@warp-drive/ember` and `@warp-drive/experiments`
for a total of **6** packages would become the **maximal** set of packages needing to be installed and configured by any Ember application.

For applications written with other frameworks, replace `@warp-drive/ember` with the ecosystem specific package and remove `@warp-drive/legacy` which can only be used with Ember for a maximum of 5 packages.

**None of the existing packages will cease to exist**

At least, not right away. A few of them will be restructured to support the the ideas outlined below describing what belongs in each of these 6, and two of them will be deprecated.

Retaining the actual package boundaries will allow us to continue to enforce strong boundaries between primitives, continue to offer applications looking to push boundaries the ability to compose an experience using a different combination of packages as desired, and give us the ability to bring new ideas into the library and move old ideas out of the library seamlessly.

But much like users of `ember-data` rarely had to consider where the source-code actually lived (it has not been in `ember-data` since 3.11), want future users to be able to get up and running with `warp-drive` with as few barriers as practical.

Lets look at what goes into each of the 6.

## @warp-drive/core

The primary package – what someone could install and use and need nothing else to achieve the most basic WarpDrive experience – is `@warp-drive/core`.

Unless otherwise specified, all packages moved into core are "clean" re-exports, meaning that the only thing necessary to change from the existing package to the new package is to change the package name and add the appropriate sub-path.

E.G.

```diff
-import { Type } from '@warp-drive/core-types/symbols';
+import { Type } from '@warp-drive/core/types/symbols';
-import { setConfig } from '@warp-drive/build-config';
+import { setConfig } from '@warp-drive/core/build-config';
```

This package is subject to the following constraints:

- it can contain and depend upon nothing framework specific
- it must contain everything required to setup and use a basic WarpDrive experience (managed requests)
- it should contain anything needed to go beyond the basic experience IF it would be usable by any framework and with any desired API. 

With this in mind: lets look at what packages move into core:

- `@warp-drive/core-types{/*}` => `@warp-drive/core/types{/*}`

This library which provides symbols and types that all (or most) other WarpDrive packages rely upon.

- `@warp-drive/build-config{/*}` => `@warp-drive/core/build-config{/*}`

This package provides our macros build-plugin configuration – allowing apps to utilize support for feature flags, deprecation removal, debug logging, and environment based debugging assistance. 

- `@ember-data/request` => `@warp-drive/core/request` (named exports only)

As the RequestManager is the heart of the basic experience, it will become a named import
from the root (see below). The remaining request utilities such as the promise cache and
request specific types will be available from the `/request` path.

We do not retain the `request/fetch` subpath (see next item).

- `@ember-data/request/fetch` => `@warp-drive/core`

The `Fetch` handler becomes a named import from the core path, this simplifies the imports when doing the most common configuration.

```diff
- import RequestManager from '@ember-data/request';
- import Fetch from '@ember-data/request/fetch';
+ import { RequestManager, Fetch } from '@warp-drive/core';
```

- `@ember-data/store{/*}` => `@warp-drive/core/store{/*}`

The lone exception in the store package is that the `Store` itself will become a named export in `@warp-drive/core`. We thinking giving `RequestManager` and `Store` the same level of precedence is important as the former is the heart of the basic experience and the latter the heart of the advanced experience.

- `@ember-data/graph{/*}` => `@warp-drive/core/graph{/*}`

Note: this package still does not have any public APIs, we believe we will be able to mark it public once schema-record reaches feature-complete status.

This package is in many ways a "utility" package for building a robust cache implementation offering ORM-like capabilities for use with the Store. As it is intended for use by any Cache implementation (not just the JSON:API cache) and because it is sufficiently advanced in ways Cache implementations are unlikely to want to attempt to replicate, we provide it from core and rely on tree-shaking to remove it if the cache implementation does not import and use it.

- `@ember-data/tracking` (gets deprecated)
- `@warp-drive/signals` (gets added)
- `@warp-drive/signals{/*}` => `@warp-drive/core/signals{/*}`

This move is the most chaotic one but we believe if we make it now it'll only affect the small number of apps that have manually configured all of the packages and their required peers, and we think we can do this move in a non-breaking way even for them.

Historically, `@ember-data/tracking` (and using TC39 terminology) this package has provided a `signal` and `computed` implementation as well as a batching mechanism for use by reactive primitives in other packages. By encapsulating our reactivity needs in this way, we've prepared ourselves to enable swaping out the underlying implementation as desired.

Today, this package uses `@tracked` and `@cached` as its implementations of signal and computed under the hood (handwave, its slightly more complicated than that), but we want to make the precise mechanism configurable.

We would keep the basic infrastructure, decorators and utils in a new `@warp-drive/signals` package which would then require being configured for a specific reactivity implementation (such as any of the many signals implementations available today).

We would move the ember-specific configuration code into the `@warp-drive/ember` package, and duplicate it in `@ember-data/tracking` with a deprecation to preserve existing behaviors.

- `@warp-drive/schema-record{/*}` => `@warp-drive/core/reactive`

This package enables applications to use deeply-reactive objects to access the data in the cache based upon a provided schema. It is the long-term replacement for `@ember-data/model`. We believe the SchemaRecord paradigm is flexible and powerful enough that even though we will retain the hook-based configuration for instantiating records we find it unlikely alternative record implementations will be built. By retaining the hook, should we (or someone else) decide to build an alternative, this code will be tree-shaken. That said, we believe this primitive is core to the WarpDrive experience.

## @warp-drive/json-api

This package will absorb the cache implementation from `@ember-data/json-api` (but not the request builders).

Every app that wants to go beyond the basic RequestManager experience and utilize a Store will need a Cache. We hope someday to see more cache implementations built, for now this is the only one officially available.

## @warp-drive/ember

This package stays the same but gains features from two other packages.

From `@ember-data/tracking` it will absorb the responsibility to configure the reactivity system to use ember's signals implementation (`@tracked`).

From `@ember-data/debug` it will absorb the repsonsibility of providing support for the ember-inspector, for as long as the library still integrates with ember-inspector. We may provide our own browser extension or "pluggable panel" in the future, at which point the proper home for extension support might get reconsidered. `@ember-data/debug` thus becomes deprecated.

Both of these changes mean that once deprecation cycles are complete, `@warp-drive/ember` becomes a required package for using EmberData/WarpDrive in an Ember application.

## @warp-drive/utilities

This package reconstitutes all or parts of four current packages:

- `@ember-data/rest/request{/*}` => `@warp-drive/utilities/rest{/*}`
- `@ember-data/active-record/request{/*}` => `@warp-drive/utilities/active-record{/*}`
- `@ember-data/json-api/request{/*}` => `@warp-drive/utilities/json-api{/*}`
- `@ember-data/request-utils{/*}` => `@warp-drive/utilities/request{/*}`

The primary exception is that the basic `CachePolicy` will move into core and be imported via

```ts
import { DefaultCachePolicy } from '@warp-drive/core/store';
```

We are making this move because we feel it is approaching the level of implementation that most apps will likely use it instead of authoring their own.

## @warp-drive/experiments

This package remains unchanged. It represents unstable experiments that we hope to eventually bring into the core experience.

## @warp-drive/legacy

This package exists somewhat-temporarily to make maintaining the legacy `ember-data` experience easier. It comprises of four packages:

- `@ember-data/adapter{/*}` => `@warp-drive/legacy/adapter{/*}`
- `@ember-data/serializer{/*}` => `@warp-drive/legacy/serializer{/*}`
- `@ember-data/model{/*}` => `@warp-drive/legacy/model{/*}`
- `@ember-data/legacy-compat{/*}` => `@warp-drive/legacy/legacy-compat{/*}`

## Configuring an Application

With all of the above changes in mind, here is what configuring an Ember application for
the recommended experience would look like:

**/app/services/store.ts**
```ts
import { RequestManager, Store, Fetch } from '@warp-drive/core';
import { CacheHandler, DefaultCachePolicy, SchemaService } from '@warp-drive/core/store';
import { JSONAPICache } from '@warp-drive/json-api';
import { instantiateRecord, teardownRecord, type SchemaRecord} from '@warp-drive/core/reactive';

import type { CacheCapabilitiesManager } from '@warp-drive/core/store/types';
import type { StableRecordIdentifier } from '@warp-drive/core/types';

export default class AppStore extends Store {
  requestManager = new RequestManager()
    .use([Fetch])
    .useCache(CacheHandler);

  cachePolicy = new DefaultCachePolicy({
    apiHardExpires: 5 * 60 * 1000 // 5min
    apiSoftExpires: 1 * 60 * 1000 // 1min
  });

  createSchemaService() {
    return new SchemaService();
  }

  createCache(capabilities: CacheCapabilitiesManager) {
    return new JSONAPICache(capabilities);
  }

  instantiateRecord(identifier: StableRecordIdentifier, createArgs?: Record<string, unknown>): SchemaRecord {
    return instantiateRecord(this, identifier, createArgs);
  }

  teardownRecord(record: SchemaRecord): void {
    return teardownRecord(record);
  }
}
```

**/ember-cli-build.js**
```ts
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const { maybeEmbroider } = require('@embroider/test-setup');

module.exports = async function (defaults) {
  let app = new EmberApp(defaults, {});

  const { setConfig } = await import('@warp-drive/build-config');
  setConfig(app, __dirname, {
    // the version of WarpDrive this file was generated with,
    // can be updated along with WarpDrive as long as deprecations
    // are resolved.
    compatWith: '5.4',
    debug: {
      // activate flags for logging here
    },
    deprecations: {
      // specify deprecated features to remove here
    }
  });

  return maybeEmbroider(app);
};

```

The below file would only be updated if `@warp-drive/utilities` was selected for use:

**/app/app.ts**
```diff
import Application from '@ember/application';
import compatModules from '@embroider/virtual/compat-modules';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
+import { setBuildURLConfig } from '@warp-drive/utilities';
import config from './config/environment';

+setBuildURLConfig({
+  host: '/',
+  namespace: 'api',
+});

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver.withModules(compatModules);
}

loadInitializers(App, config.modulePrefix, compatModules);
```

**/package.json**
```diff
{
  "dependencies": {
+    "@warp-drive/core": "5.4.0",
+    "@warp-drive/ember": "5.4.0",
+    "@warp-drive/json-api": "5.4.0"
  }
}
```

**/tsconfig.json**

No changes are required to tsconfig, as we will ship types as stable when installing WarpDrive
via this mechanism. If for some reason we are unable to:

```diff
 {
   "compilerOptions": {
+     "types": [
+       "ember-source/types",
+       "@warp-drive/core/preview-types",
+       "@warp-drive/ember/preview-types",
+       "@warp-drive/json-api/preview-types",
+    ]
   }
 }
```

## Codemod / Lint Rules for the Migration

This can become the recommended experience for new apps without any codemods or lint rules
provided documentation is updated.

In the interest of moving folks to this experience: we should consider a lint rule with an autofix
that changes paths similar to when we first split ember and ember-data into their multi-package
architecture.

We should also consider a lightweight codemod that uninstalls any WarpDrive/EmberData packages that
are present and installs the appropriate packages from the set of 6, updating import paths in the process.

Likely we can safely automate this for any app using 4.13 or 5.3+. 

## Polaris / V2 App Blueprint

We would remove `ember-data` from the default blueprint and add the file changes above as shown. This takes
the place of an automated installer script (which we still want to do). We can replace these changes with
a script that prompts the user for selections once we have the tooling for doing so.

## Guides & ApiDocs

The guides will need to be updated to reflect the WarpDrive terminology and
new import locations. They are already in need of a refresh to align with modern
best-practices as we push towards delivering the Polaris experience for WarpDrive,
and this can be done all at once.

We will need a solution for ApiDocs. While the ApiDocs have been able to handle
multiple packages, we would want to document these APIs via their locations in the
new packages instead, which means dropping quite a lot of packages from being
contained in the ApiDocs which has url concerns.

The intent is to have tooling that "re-exports" docs from the original packages at
from the new home as well to avoid things "Store" being imported from "@warp-drive/core"
but documented via "@ember-data/store".

We could have that tool produce an artifact that contains information about both
locations for use by the docs: e.g. something along the lines of:

```ts
const classDoc = {
  name: 'Store',
  export: 'Store',
  module: '@warp-drive/core',
  location: 'packages/core/src/index.ts',
  upstream: {
    name: 'Store',
    export: 'default',
    module: '@ember-data/store',
    location: 'packages/store/src/index.ts',
  },
  tags: [],
  description: [],
  // ... etc.
}
```

## Lockstep Versioning

We will continue to publish these packages in lockstep with each other. Specifically this means that
peers and dependencies are pinned to the version(s) published in the same release.

We will also continue to follow the general rule of thumb we've had with WarpDrive/EmberData packages
to this point: newer packages begin at 0.0.0, progress to 0.X.0 when mostly stable, and then jump to
match the overall project version once stable. This way even new packages come to have identical
versions once stability is reached, making version management easier.

## Future Deprecation cycles

This package configuration provides an avenue for cleaner deprecation cycles in the future for major
concepts.

When something at the package-level of scope is removed from the core experience, we can do a two-stage
deprecation.

In stage-1, the imports in `/core` are deprecated and instead users must install and import from `/legacy`.
In stage-2, the feature in `/legacy` is deprecated. This would spread this sort of "concept removal"
deprecation across two majors by design, enabling us to keep our preferred path of long-tail deprecation
support while still signifying in a clear way which patterns are the current happy path.

## Drawbacks

As far as I am aware, nearly everyone has expresed a desire to simplify the config in *some* way, though ideas on how have varied.

If there is a reason to *not* do this it is about future-unknowns.

We learned with `ember-data` just how hard it could be to remove bad concepts from the library and architecture - a pain which drove us to split into packages for easier isolation, iteration and replacement in the first place.

By recombining *at all* we risk having this happen again as these packages will be broader in focus than what we have arrived at today. However, we do not intend to drop the use of individual packages, but rather recombine their exports into an ideal place for consumers, so I suspect this risk is comparatively low.

## Alternatives

The impact of not doing this will be a cost payed by both maintainers and consumers. Maintainers will have to write extra tooling to help consumers maintain their projects, and spend more time debugging and answering questions around installation and configuration.

Consumers will feel frustrated with not being able to quickly get an updated version, or working installation.

An alternative is to return to a single package. In addition to `ember-data`, the team also owns the `warp-drive` npm package. This would enable us to do something along the lines of re-exporting every package under a sub-path. That would look something like this:

```ts
warp-drive
  /store
  /request
  /request-utils
  /tracking
  /adapter
  /serializer
  /schema-record
  /legacy-compat
  /model
  /ember
  /serializer
  /debug
  /build-config
  /core-types
  /json-api
  /rest
  /active-record
  /experiments
```

We feel this approach comes with several drawbacks.

First, it makes it harder to understand which packages are part of the recommended experience, vs which are being phased out.

Second, it means that code from all packages is available for import and intellisense, increasing the odds of developers making mistakes. Often those mistakes are easy to miss like importing the same token (`findRecord`) from legacy-compat or active-record instead of json-api.

Third: with the rise in AI assisted coding, having those packages and types present in a codebase also increases the risk of AI suggesting code utilizing them.

Lastly: we think we can use this opportunity to re-organize the mental model and reduce the number of concepts and terms developers need to be aware of when using WarpDrive.

In short, the original motivating factors for splitting into many-packages instead of one-package remain unchanged.

## Unresolved Questions

Are there more import paths that we should shift the locations of?

For instance, these two types will be imported by nearly every store configuration:

```ts
import type { CacheCapabilitiesManager } from '@warp-drive/core/store/types';
import type { StableRecordIdentifier } from '@warp-drive/core/types';
```

Many types in `core/store/types` are specific to the store and are store-specific
variations of signatures in `core/types`, but there are a few exceptions to this
and `CacheCapabilitiesManager` is one of them. Maybe it and a few others make the move.

Similarly, the types for `Document/RecordArray/Collection` etc come from the store today
(and are then repurposed for `HasMany` and similar), but these are types for reactive
objects, and as such it may be best to move them into `/reactive`.

Because types support is still canary for WarpDrive, we do not have to answer this question
via RFC and can answer it through iteration. But if we find other non-type imports that
make sense to move we should call them out here.

---

